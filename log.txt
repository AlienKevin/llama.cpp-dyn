
================
# Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =

LSP: Prelude: Recieved string: ### List ###

# Add an element to the front of a list. #
let cons: (Int, [Int]) -> [Int] = fun x, xs -> x::xs in

# Determine the length of a list. #
let length: [Int] -> Int =
  fun xs ->
    case xs
    | [] => 0
    | _::xs => 1 + length(xs) end in

# Extract the first element of a list. #
let hd: [Int] -> Option =
  fun l ->
    case l
    | [] => None
    | x::xs => Some(x) end in

# Extract the rest of the list. #
let tl: [Int] -> [Int] =
  fun l ->
    case l
    | [] => []
    | x::xs => xs end in

# Determine if a list is empty. #
let is_empty: [Int] -> Bool =
  fun xs ->
    case xs
    | [] => true
    | _::_ => false end in

# Return the element at the index. #
let nth: ([Int], Int) -> Option =
  fun xs, n ->
    case xs, n
    | x::_, 0 => Some(x)
    | _::xs, n => nth(xs, n - 1)
    | [], _ => None end in

# Reverse a List. #
let rev: [Int] -> [Int] =
fun l -> 
let go: ([Int], [Int]) -> [Int] =
  fun xs, acc -> 
    case xs 
    | [] => acc 
    | x::xs => go(xs, x::acc) end in
go(l, []) in

# Check if two lists are equal #
let equal: ([Int], [Int]) -> Bool =
    fun p, xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => x == y && equal(xs, ys)
    | _ => false end
in

# Initialize a list with a given length using an initializer function #
let init: (Int, Int -> Int) -> [Int] =
    fun len, f ->
        let go: (Int, [Int]) -> [Int] =
        fun idx, xs ->
            if idx < len 
            then go(idx + 1, xs @ [f(idx)])   
            else xs
        in
        go(0, [])
in

# Reduce a list from the left. #
let fold_left: ((Int, Int) -> Int, Int, [Int]) -> Int =
  fun f, acc, xs ->
    case xs 
    | [] => acc
    | hd::tl => fold_left(f, f(acc, hd), tl) end in

# Reduce a list from the right. #
let fold_right: ((Int, Int) -> Int, [Int], Int) -> Int =
  fun f, xs, acc ->
    case xs
    | [] => acc
    | hd::tl => f(hd, fold_right(f, tl, acc)) end in


666
LSP: Prelude: String parsed successfully
LSP: Prelude: Info map generated successfully
Debug: true, Constrain: Types
LSP: Init: Recieved string: # Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
LSP: Init: String parsed successfully
  LSP: Syntax: Leftward is Incomplete Tile: <let = in<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: (((Int -> Bool), [Int]) -> [Int])
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: in
  LSP: Info: ALL errors:
  LSP: Info: BidiCtx: Cls: Empty expression hole
  LSP: Info: BidiCtx: Expected type: (((Int -> Bool), [Int]) -> [Int])
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 (((Int -> Bool), [Int]) -> [Int])
  LSP: Convex: Target types: (((Int -> Bool), [Int]) -> [Int])
  LSP: Convex: Backpack: 
  LSP: Convex: Base: _ ( case  fun  if  let  type 
  LSP: Convex: Lookahead: ( _ case  fun  if  let  type 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new_tokens ::= whitespace | "(" | "_" | "case " | "fun " | "if " | "let " | "type "
root ::= new_tokens

Top 20 Logits:

:19.5932
 :18.8251
 fun:16.5032
  :14.5416
    :13.7367
                :12.1378
   :11.7684
     :11.7679
 {:11.5433
        :11.5115
      :11.1988
            :11.0185
 let:10.8055
       :10.6568
 //:10.6166
	:10.5715
 #:10.5713
 ?:10.5546
fun:10.5413
          :10.3993
         :10.378

================
# Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =


LSP: Prelude: Recieved string: ### List ###

# Add an element to the front of a list. #
let cons: (Int, [Int]) -> [Int] = fun x, xs -> x::xs in

# Determine the length of a list. #
let length: [Int] -> Int =
  fun xs ->
    case xs
    | [] => 0
    | _::xs => 1 + length(xs) end in

# Extract the first element of a list. #
let hd: [Int] -> Option =
  fun l ->
    case l
    | [] => None
    | x::xs => Some(x) end in

# Extract the rest of the list. #
let tl: [Int] -> [Int] =
  fun l ->
    case l
    | [] => []
    | x::xs => xs end in

# Determine if a list is empty. #
let is_empty: [Int] -> Bool =
  fun xs ->
    case xs
    | [] => true
    | _::_ => false end in

# Return the element at the index. #
let nth: ([Int], Int) -> Option =
  fun xs, n ->
    case xs, n
    | x::_, 0 => Some(x)
    | _::xs, n => nth(xs, n - 1)
    | [], _ => None end in

# Reverse a List. #
let rev: [Int] -> [Int] =
fun l -> 
let go: ([Int], [Int]) -> [Int] =
  fun xs, acc -> 
    case xs 
    | [] => acc 
    | x::xs => go(xs, x::acc) end in
go(l, []) in

# Check if two lists are equal #
let equal: ([Int], [Int]) -> Bool =
    fun p, xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => x == y && equal(xs, ys)
    | _ => false end
in

# Initialize a list with a given length using an initializer function #
let init: (Int, Int -> Int) -> [Int] =
    fun len, f ->
        let go: (Int, [Int]) -> [Int] =
        fun idx, xs ->
            if idx < len 
            then go(idx + 1, xs @ [f(idx)])   
            else xs
        in
        go(0, [])
in

# Reduce a list from the left. #
let fold_left: ((Int, Int) -> Int, Int, [Int]) -> Int =
  fun f, acc, xs ->
    case xs 
    | [] => acc
    | hd::tl => fold_left(f, f(acc, hd), tl) end in

# Reduce a list from the right. #
let fold_right: ((Int, Int) -> Int, [Int], Int) -> Int =
  fun f, xs, acc ->
    case xs
    | [] => acc
    | hd::tl => f(hd, fold_right(f, tl, acc)) end in


666
LSP: Prelude: String parsed successfully
LSP: Prelude: Info map generated successfully
Debug: true, Constrain: Types
LSP: Init: Recieved string: # Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =

LSP: Init: String parsed successfully
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Incomplete Tile: <let = in<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: (((Int -> Bool), [Int]) -> [Int])
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: in
  LSP: Info: ALL errors:
  LSP: Info: BidiCtx: Cls: Empty expression hole
  LSP: Info: BidiCtx: Expected type: (((Int -> Bool), [Int]) -> [Int])
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 (((Int -> Bool), [Int]) -> [Int])
  LSP: Convex: Target types: (((Int -> Bool), [Int]) -> [Int])
  LSP: Convex: Backpack: 
  LSP: Convex: Base: _ ( case  fun  if  let  type 
  LSP: Convex: Lookahead: ( _ case  fun  if  let  type 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new_tokens ::= whitespace | "(" | "_" | "case " | "fun " | "if " | "let " | "type "
root ::= new_tokens

Top 20 Logits:
 :21.7513
   :18.21
fun:17.5111
 fun:15.6754
  :15.3841
	:14.3851
     :14.1784
       :14.1636
let:13.9102
func:13.0767
    :12.9801
 let:12.8413

:12.1359
           :11.3969
function:11.026
         :10.9914
      :10.9777
 func:10.54
fn:10.5353
                :10.3635
//:10.2477

================
# Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
 

LSP: Prelude: Recieved string: ### List ###

# Add an element to the front of a list. #
let cons: (Int, [Int]) -> [Int] = fun x, xs -> x::xs in

# Determine the length of a list. #
let length: [Int] -> Int =
  fun xs ->
    case xs
    | [] => 0
    | _::xs => 1 + length(xs) end in

# Extract the first element of a list. #
let hd: [Int] -> Option =
  fun l ->
    case l
    | [] => None
    | x::xs => Some(x) end in

# Extract the rest of the list. #
let tl: [Int] -> [Int] =
  fun l ->
    case l
    | [] => []
    | x::xs => xs end in

# Determine if a list is empty. #
let is_empty: [Int] -> Bool =
  fun xs ->
    case xs
    | [] => true
    | _::_ => false end in

# Return the element at the index. #
let nth: ([Int], Int) -> Option =
  fun xs, n ->
    case xs, n
    | x::_, 0 => Some(x)
    | _::xs, n => nth(xs, n - 1)
    | [], _ => None end in

# Reverse a List. #
let rev: [Int] -> [Int] =
fun l -> 
let go: ([Int], [Int]) -> [Int] =
  fun xs, acc -> 
    case xs 
    | [] => acc 
    | x::xs => go(xs, x::acc) end in
go(l, []) in

# Check if two lists are equal #
let equal: ([Int], [Int]) -> Bool =
    fun p, xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => x == y && equal(xs, ys)
    | _ => false end
in

# Initialize a list with a given length using an initializer function #
let init: (Int, Int -> Int) -> [Int] =
    fun len, f ->
        let go: (Int, [Int]) -> [Int] =
        fun idx, xs ->
            if idx < len 
            then go(idx + 1, xs @ [f(idx)])   
            else xs
        in
        go(0, [])
in

# Reduce a list from the left. #
let fold_left: ((Int, Int) -> Int, Int, [Int]) -> Int =
  fun f, acc, xs ->
    case xs 
    | [] => acc
    | hd::tl => fold_left(f, f(acc, hd), tl) end in

# Reduce a list from the right. #
let fold_right: ((Int, Int) -> Int, [Int], Int) -> Int =
  fun f, xs, acc ->
    case xs
    | [] => acc
    | hd::tl => f(hd, fold_right(f, tl, acc)) end in


666
LSP: Prelude: String parsed successfully
LSP: Prelude: Info map generated successfully
Debug: true, Constrain: Types
LSP: Init: Recieved string: # Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
 
LSP: Init: String parsed successfully
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Incomplete Tile: <let = in<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: (((Int -> Bool), [Int]) -> [Int])
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: in
  LSP: Info: ALL errors:
  LSP: Info: BidiCtx: Cls: Empty expression hole
  LSP: Info: BidiCtx: Expected type: (((Int -> Bool), [Int]) -> [Int])
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 (((Int -> Bool), [Int]) -> [Int])
  LSP: Convex: Target types: (((Int -> Bool), [Int]) -> [Int])
  LSP: Convex: Backpack: 
  LSP: Convex: Base: _ ( case  fun  if  let  type 
  LSP: Convex: Lookahead: ( _ case  fun  if  let  type 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new_tokens ::= whitespace | "(" | "_" | "case " | "fun " | "if " | "let " | "type "
root ::= new_tokens

Top 20 Logits:
 fun:22.6545
 let:16.0184
 #:12.7141
 {:12.2172
 func:12.1631
 (:12.1005
 //:11.9584
 rec:11.6162
 lambda:11.2714
 (*:11.1199
 function:11.0961
 match:11.0917
 fol:10.9389
 f:10.5809
 if:10.465
 ##:10.2428
 /*:10.1604
 list:10.0544
 fn:10.0411
 fix:9.98905
 *:9.96788

================
# Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun

LSP: Prelude: Recieved string: ### List ###

# Add an element to the front of a list. #
let cons: (Int, [Int]) -> [Int] = fun x, xs -> x::xs in

# Determine the length of a list. #
let length: [Int] -> Int =
  fun xs ->
    case xs
    | [] => 0
    | _::xs => 1 + length(xs) end in

# Extract the first element of a list. #
let hd: [Int] -> Option =
  fun l ->
    case l
    | [] => None
    | x::xs => Some(x) end in

# Extract the rest of the list. #
let tl: [Int] -> [Int] =
  fun l ->
    case l
    | [] => []
    | x::xs => xs end in

# Determine if a list is empty. #
let is_empty: [Int] -> Bool =
  fun xs ->
    case xs
    | [] => true
    | _::_ => false end in

# Return the element at the index. #
let nth: ([Int], Int) -> Option =
  fun xs, n ->
    case xs, n
    | x::_, 0 => Some(x)
    | _::xs, n => nth(xs, n - 1)
    | [], _ => None end in

# Reverse a List. #
let rev: [Int] -> [Int] =
fun l -> 
let go: ([Int], [Int]) -> [Int] =
  fun xs, acc -> 
    case xs 
    | [] => acc 
    | x::xs => go(xs, x::acc) end in
go(l, []) in

# Check if two lists are equal #
let equal: ([Int], [Int]) -> Bool =
    fun p, xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => x == y && equal(xs, ys)
    | _ => false end
in

# Initialize a list with a given length using an initializer function #
let init: (Int, Int -> Int) -> [Int] =
    fun len, f ->
        let go: (Int, [Int]) -> [Int] =
        fun idx, xs ->
            if idx < len 
            then go(idx + 1, xs @ [f(idx)])   
            else xs
        in
        go(0, [])
in

# Reduce a list from the left. #
let fold_left: ((Int, Int) -> Int, Int, [Int]) -> Int =
  fun f, acc, xs ->
    case xs 
    | [] => acc
    | hd::tl => fold_left(f, f(acc, hd), tl) end in

# Reduce a list from the right. #
let fold_right: ((Int, Int) -> Int, [Int], Int) -> Int =
  fun f, xs, acc ->
    case xs
    | [] => acc
    | hd::tl => f(hd, fold_right(f, tl, acc)) end in


666
LSP: Prelude: String parsed successfully
LSP: Prelude: Info map generated successfully
Debug: true, Constrain: Types
LSP: Init: Recieved string: # Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun
LSP: Init: String parsed successfully
  LSP: Syntax: Leftward is Complete Tile: <fun>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: (((Int -> Bool), [Int]) -> [Int])
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Exp (FreeVariable "fun"))
  LSP: Info: Typing Context: {AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: in
  LSP: Info: ALL errors:Error in term:
  fun
Nature of error: Variable fun is not bound
  LSP: Info: BidiCtx: Cls: Variable reference
  LSP: Info: BidiCtx: Expected type: (((Int -> Bool), [Int]) -> [Int])
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-concave or complete: fun
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: 
  LSP: Concave: Infix: Lookahead types: (((Int -> Bool), [Int]) -> [Int])
  LSP: Concave: Infix: Lookahead: 
  LSP: Concave: Backpack: in
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: fun
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: 
  LSP: Concave: Infix: Lookahead types: (((Int -> Bool), [Int]) -> [Int])
  LSP: Concave: Infix: Lookahead: 
  LSP: Concave: Backpack: in
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
  LSP: Convex: Ty paths:
 (((Int -> Bool), [Int]) -> [Int])
  LSP: Convex: Target types: (((Int -> Bool), [Int]) -> [Int])
  LSP: Convex: Backpack: 
  LSP: Convex: Base: _ ( case  fun  if  let  type 
  LSP: Convex: Lookahead: ( _ case  fun  if  let  type 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= " "
new_tokens ::= whitespace | "(" | "in"
root ::= completions | new_tokens

Top 20 Logits:
 p:17.2058
 pred:16.2392
 f:16.1492
 predicate:14.5689
 test:13.5245
 fn:13.1081
 is:12.9327
 cond:12.153
 g:11.6595
 keep:11.4131
 func:11.2266
 check:10.7047
 pr:10.6897
 condition:10.6083
 ok:10.4941
 filter:10.252
 x:10.1861
 t:9.83942
 op:9.82883
 c:9.75233
 b:9.71816

================
# Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (

LSP: Prelude: Recieved string: ### List ###

# Add an element to the front of a list. #
let cons: (Int, [Int]) -> [Int] = fun x, xs -> x::xs in

# Determine the length of a list. #
let length: [Int] -> Int =
  fun xs ->
    case xs
    | [] => 0
    | _::xs => 1 + length(xs) end in

# Extract the first element of a list. #
let hd: [Int] -> Option =
  fun l ->
    case l
    | [] => None
    | x::xs => Some(x) end in

# Extract the rest of the list. #
let tl: [Int] -> [Int] =
  fun l ->
    case l
    | [] => []
    | x::xs => xs end in

# Determine if a list is empty. #
let is_empty: [Int] -> Bool =
  fun xs ->
    case xs
    | [] => true
    | _::_ => false end in

# Return the element at the index. #
let nth: ([Int], Int) -> Option =
  fun xs, n ->
    case xs, n
    | x::_, 0 => Some(x)
    | _::xs, n => nth(xs, n - 1)
    | [], _ => None end in

# Reverse a List. #
let rev: [Int] -> [Int] =
fun l -> 
let go: ([Int], [Int]) -> [Int] =
  fun xs, acc -> 
    case xs 
    | [] => acc 
    | x::xs => go(xs, x::acc) end in
go(l, []) in

# Check if two lists are equal #
let equal: ([Int], [Int]) -> Bool =
    fun p, xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => x == y && equal(xs, ys)
    | _ => false end
in

# Initialize a list with a given length using an initializer function #
let init: (Int, Int -> Int) -> [Int] =
    fun len, f ->
        let go: (Int, [Int]) -> [Int] =
        fun idx, xs ->
            if idx < len 
            then go(idx + 1, xs @ [f(idx)])   
            else xs
        in
        go(0, [])
in

# Reduce a list from the left. #
let fold_left: ((Int, Int) -> Int, Int, [Int]) -> Int =
  fun f, acc, xs ->
    case xs 
    | [] => acc
    | hd::tl => fold_left(f, f(acc, hd), tl) end in

# Reduce a list from the right. #
let fold_right: ((Int, Int) -> Int, [Int], Int) -> Int =
  fun f, xs, acc ->
    case xs
    | [] => acc
    | hd::tl => f(hd, fold_right(f, tl, acc)) end in


666
LSP: Prelude: String parsed successfully
LSP: Prelude: Info map generated successfully
Debug: true, Constrain: Types
LSP: Init: Recieved string: # Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (
LSP: Init: String parsed successfully
  LSP: Syntax: Leftward is Incomplete Tile: <( )<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty pattern hole
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: ((Int -> Bool), [Int])
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {filter: (((Int -> Bool), [Int]) -> [Int]), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) -> in
  LSP: Info: ALL errors:
  LSP: Info: BidiCtx: Cls: Empty pattern hole
  LSP: Info: BidiCtx: Expected type: ((Int -> Bool), [Int])
  LSP: Info: Bidi Parent Cls: Parenthesized pattern
  LSP: Info: Cls: Parenthesized pattern
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: ((Int -> Bool), [Int])
  LSP: Info: Seft type: ((Int -> Bool), [Int])
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {filter: (((Int -> Bool), [Int]) -> [Int]), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) -> in
  LSP: Info: ALL errors:
  LSP: Info: BidiCtx: Cls: Parenthesized pattern
  LSP: Info: BidiCtx: Expected type: ((Int -> Bool), [Int])
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Syntax: Can insert left-convex or complete: (
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: _ ~PATVAR~ (
  LSP: Convex: Lookahead: ( _ ~PATVAR~
LSP: Generating Completions for prefix: (
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: 
  LSP: Convex: Backpack: 
  LSP: Convex: Base: _ ~PATVAR~ (
  LSP: Convex: Lookahead: ( _ ~PATVAR~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new_tokens ::= whitespace | "(" | "_" | patvar
root ::= new_tokens

Top 20 Logits:
p:15.1165
f:13.9767
pred:13.5788
test:13.0735
is:11.5946
x:11.3618
fn:11.2217
_,:10.4478
g:10.2755
cond:10.0513
fun:10.0449
xs:10.0166
filter:9.95183
pf:9.75603
a:9.69232
pr:9.64725
t:9.5523
px:9.13375
P:9.10953
 p:9.02664
func:8.99279

================
# Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p

LSP: Prelude: Recieved string: ### List ###

# Add an element to the front of a list. #
let cons: (Int, [Int]) -> [Int] = fun x, xs -> x::xs in

# Determine the length of a list. #
let length: [Int] -> Int =
  fun xs ->
    case xs
    | [] => 0
    | _::xs => 1 + length(xs) end in

# Extract the first element of a list. #
let hd: [Int] -> Option =
  fun l ->
    case l
    | [] => None
    | x::xs => Some(x) end in

# Extract the rest of the list. #
let tl: [Int] -> [Int] =
  fun l ->
    case l
    | [] => []
    | x::xs => xs end in

# Determine if a list is empty. #
let is_empty: [Int] -> Bool =
  fun xs ->
    case xs
    | [] => true
    | _::_ => false end in

# Return the element at the index. #
let nth: ([Int], Int) -> Option =
  fun xs, n ->
    case xs, n
    | x::_, 0 => Some(x)
    | _::xs, n => nth(xs, n - 1)
    | [], _ => None end in

# Reverse a List. #
let rev: [Int] -> [Int] =
fun l -> 
let go: ([Int], [Int]) -> [Int] =
  fun xs, acc -> 
    case xs 
    | [] => acc 
    | x::xs => go(xs, x::acc) end in
go(l, []) in

# Check if two lists are equal #
let equal: ([Int], [Int]) -> Bool =
    fun p, xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => x == y && equal(xs, ys)
    | _ => false end
in

# Initialize a list with a given length using an initializer function #
let init: (Int, Int -> Int) -> [Int] =
    fun len, f ->
        let go: (Int, [Int]) -> [Int] =
        fun idx, xs ->
            if idx < len 
            then go(idx + 1, xs @ [f(idx)])   
            else xs
        in
        go(0, [])
in

# Reduce a list from the left. #
let fold_left: ((Int, Int) -> Int, Int, [Int]) -> Int =
  fun f, acc, xs ->
    case xs 
    | [] => acc
    | hd::tl => fold_left(f, f(acc, hd), tl) end in

# Reduce a list from the right. #
let fold_right: ((Int, Int) -> Int, [Int], Int) -> Int =
  fun f, xs, acc ->
    case xs
    | [] => acc
    | hd::tl => f(hd, fold_right(f, tl, acc)) end in


666
LSP: Prelude: String parsed successfully
LSP: Prelude: Info map generated successfully
Debug: true, Constrain: Types
LSP: Init: Recieved string: # Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p
LSP: Init: String parsed successfully
  LSP: Syntax: Leftward is Complete Tile: <p>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable binding
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: ((Int -> Bool), [Int])
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {p: ((Int -> Bool), [Int]), filter: (((Int -> Bool), [Int]) -> [Int]), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) -> in
  LSP: Info: ALL errors:
  LSP: Info: BidiCtx: Cls: Variable binding
  LSP: Info: BidiCtx: Expected type: ((Int -> Bool), [Int])
  LSP: Info: Bidi Parent Cls: Parenthesized pattern
  LSP: Syntax: Can insert left-concave or complete: p
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: p
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: _ ~PATVAR~ (
  LSP: Convex: Lookahead: ( _ ~PATVAR~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= extend-patvar
new_tokens ::= whitespace | "(" | ")"
root ::= completions | new_tokens

Top 20 Logits:
::14.7739
,:14.6056
),:13.7765
 ::13.1213
):12.0091
 as:11.5028
)::10.9169
 x:9.99923
?,:9.74339
(:9.64163
 ,:9.27491
 @:9.22443
?:9.03287
:(:8.76628
)(:8.62436
?::8.5429
ivot:8.31826
1:8.30864
:':8.24861
 (:8.14788
 ?:8.10061

================
# Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p)

LSP: Prelude: Recieved string: ### List ###

# Add an element to the front of a list. #
let cons: (Int, [Int]) -> [Int] = fun x, xs -> x::xs in

# Determine the length of a list. #
let length: [Int] -> Int =
  fun xs ->
    case xs
    | [] => 0
    | _::xs => 1 + length(xs) end in

# Extract the first element of a list. #
let hd: [Int] -> Option =
  fun l ->
    case l
    | [] => None
    | x::xs => Some(x) end in

# Extract the rest of the list. #
let tl: [Int] -> [Int] =
  fun l ->
    case l
    | [] => []
    | x::xs => xs end in

# Determine if a list is empty. #
let is_empty: [Int] -> Bool =
  fun xs ->
    case xs
    | [] => true
    | _::_ => false end in

# Return the element at the index. #
let nth: ([Int], Int) -> Option =
  fun xs, n ->
    case xs, n
    | x::_, 0 => Some(x)
    | _::xs, n => nth(xs, n - 1)
    | [], _ => None end in

# Reverse a List. #
let rev: [Int] -> [Int] =
fun l -> 
let go: ([Int], [Int]) -> [Int] =
  fun xs, acc -> 
    case xs 
    | [] => acc 
    | x::xs => go(xs, x::acc) end in
go(l, []) in

# Check if two lists are equal #
let equal: ([Int], [Int]) -> Bool =
    fun p, xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => x == y && equal(xs, ys)
    | _ => false end
in

# Initialize a list with a given length using an initializer function #
let init: (Int, Int -> Int) -> [Int] =
    fun len, f ->
        let go: (Int, [Int]) -> [Int] =
        fun idx, xs ->
            if idx < len 
            then go(idx + 1, xs @ [f(idx)])   
            else xs
        in
        go(0, [])
in

# Reduce a list from the left. #
let fold_left: ((Int, Int) -> Int, Int, [Int]) -> Int =
  fun f, acc, xs ->
    case xs 
    | [] => acc
    | hd::tl => fold_left(f, f(acc, hd), tl) end in

# Reduce a list from the right. #
let fold_right: ((Int, Int) -> Int, [Int], Int) -> Int =
  fun f, xs, acc ->
    case xs
    | [] => acc
    | hd::tl => f(hd, fold_right(f, tl, acc)) end in


666
LSP: Prelude: String parsed successfully
LSP: Prelude: Info map generated successfully
Debug: true, Constrain: Types
LSP: Init: Recieved string: # Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p)
LSP: Init: String parsed successfully
  LSP: Syntax: Leftward is Complete Tile: <( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Parenthesized pattern
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: ((Int -> Bool), [Int])
  LSP: Info: Seft type: ((Int -> Bool), [Int])
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {p: ((Int -> Bool), [Int]), filter: (((Int -> Bool), [Int]) -> [Int]), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: -> in
  LSP: Info: ALL errors:
  LSP: Info: BidiCtx: Cls: Parenthesized pattern
  LSP: Info: BidiCtx: Expected type: ((Int -> Bool), [Int])
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: ->
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new_tokens ::= whitespace | "->"
root ::= new_tokens

Top 20 Logits:
 xs:14.6807
 (:13.5378
 ->:13.3111
 l:13.0367
 as:12.852
 ,:12.1332
 in:11.8368
 =:11.7457
 {:11.5796
 x:11.2301
 and:11.1671
 =>:10.9672
 f:10.4408
 ::10.4204
xs:10.4097
 list:10.2546

:10.2205
 &&:10.2108
 ((:10.1679
 ([:9.87787
 acc:9.68106

================
# Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->

LSP: Prelude: Recieved string: ### List ###

# Add an element to the front of a list. #
let cons: (Int, [Int]) -> [Int] = fun x, xs -> x::xs in

# Determine the length of a list. #
let length: [Int] -> Int =
  fun xs ->
    case xs
    | [] => 0
    | _::xs => 1 + length(xs) end in

# Extract the first element of a list. #
let hd: [Int] -> Option =
  fun l ->
    case l
    | [] => None
    | x::xs => Some(x) end in

# Extract the rest of the list. #
let tl: [Int] -> [Int] =
  fun l ->
    case l
    | [] => []
    | x::xs => xs end in

# Determine if a list is empty. #
let is_empty: [Int] -> Bool =
  fun xs ->
    case xs
    | [] => true
    | _::_ => false end in

# Return the element at the index. #
let nth: ([Int], Int) -> Option =
  fun xs, n ->
    case xs, n
    | x::_, 0 => Some(x)
    | _::xs, n => nth(xs, n - 1)
    | [], _ => None end in

# Reverse a List. #
let rev: [Int] -> [Int] =
fun l -> 
let go: ([Int], [Int]) -> [Int] =
  fun xs, acc -> 
    case xs 
    | [] => acc 
    | x::xs => go(xs, x::acc) end in
go(l, []) in

# Check if two lists are equal #
let equal: ([Int], [Int]) -> Bool =
    fun p, xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => x == y && equal(xs, ys)
    | _ => false end
in

# Initialize a list with a given length using an initializer function #
let init: (Int, Int -> Int) -> [Int] =
    fun len, f ->
        let go: (Int, [Int]) -> [Int] =
        fun idx, xs ->
            if idx < len 
            then go(idx + 1, xs @ [f(idx)])   
            else xs
        in
        go(0, [])
in

# Reduce a list from the left. #
let fold_left: ((Int, Int) -> Int, Int, [Int]) -> Int =
  fun f, acc, xs ->
    case xs 
    | [] => acc
    | hd::tl => fold_left(f, f(acc, hd), tl) end in

# Reduce a list from the right. #
let fold_right: ((Int, Int) -> Int, [Int], Int) -> Int =
  fun f, xs, acc ->
    case xs
    | [] => acc
    | hd::tl => f(hd, fold_right(f, tl, acc)) end in


666
LSP: Prelude: String parsed successfully
LSP: Prelude: Info map generated successfully
Debug: true, Constrain: Types
LSP: Init: Recieved string: # Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
LSP: Init: String parsed successfully
  LSP: Syntax: Leftward is Complete Tile: <fun -><
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [Int]
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {p: ((Int -> Bool), [Int]), filter: (((Int -> Bool), [Int]) -> [Int]), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: in
  LSP: Info: ALL errors:
  LSP: Info: BidiCtx: Cls: Function literal
  LSP: Info: BidiCtx: Expected type: (((Int -> Bool), [Int]) -> [Int])
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 [Int]
Int <= [Int]
Int <= [Int]
  LSP: Convex: Target types: Int, [Int]
  LSP: Convex: Backpack: 
  LSP: Convex: Base: [] _ ( [ case  if  let  type 
  LSP: Convex: Lookahead: ( - [ [] _ abs case  filter if  int_of_float int_of_string let  max_int min_int mod string_compare string_length type  ~INTLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new_tokens ::= whitespace | "(" | "-" | "[" | "[]" | "_" | "abs" | "case " | "filter" | "if " | "int_of_float" | "int_of_string" | "let " | "max_int" | "min_int" | "mod" | "string_compare" | "string_length" | "type " | intlit
root ::= new_tokens

Top 20 Logits:

:16.3496
 :14.694
 fun:13.7423
 rev:12.9446
 List:12.7079
 fol:12.669
 let:12.5756
 go:12.0452
 (:11.8144
  :11.7084
 function:11.4453
 list:11.3302
 p:11.3214
 reverse:11.1174
 #:11.0659
 reduce:10.8814
    :10.7421
 map:10.6092
 rec:10.2957
 [:10.1909
                :10.0082

================
# Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->


LSP: Prelude: Recieved string: ### List ###

# Add an element to the front of a list. #
let cons: (Int, [Int]) -> [Int] = fun x, xs -> x::xs in

# Determine the length of a list. #
let length: [Int] -> Int =
  fun xs ->
    case xs
    | [] => 0
    | _::xs => 1 + length(xs) end in

# Extract the first element of a list. #
let hd: [Int] -> Option =
  fun l ->
    case l
    | [] => None
    | x::xs => Some(x) end in

# Extract the rest of the list. #
let tl: [Int] -> [Int] =
  fun l ->
    case l
    | [] => []
    | x::xs => xs end in

# Determine if a list is empty. #
let is_empty: [Int] -> Bool =
  fun xs ->
    case xs
    | [] => true
    | _::_ => false end in

# Return the element at the index. #
let nth: ([Int], Int) -> Option =
  fun xs, n ->
    case xs, n
    | x::_, 0 => Some(x)
    | _::xs, n => nth(xs, n - 1)
    | [], _ => None end in

# Reverse a List. #
let rev: [Int] -> [Int] =
fun l -> 
let go: ([Int], [Int]) -> [Int] =
  fun xs, acc -> 
    case xs 
    | [] => acc 
    | x::xs => go(xs, x::acc) end in
go(l, []) in

# Check if two lists are equal #
let equal: ([Int], [Int]) -> Bool =
    fun p, xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => x == y && equal(xs, ys)
    | _ => false end
in

# Initialize a list with a given length using an initializer function #
let init: (Int, Int -> Int) -> [Int] =
    fun len, f ->
        let go: (Int, [Int]) -> [Int] =
        fun idx, xs ->
            if idx < len 
            then go(idx + 1, xs @ [f(idx)])   
            else xs
        in
        go(0, [])
in

# Reduce a list from the left. #
let fold_left: ((Int, Int) -> Int, Int, [Int]) -> Int =
  fun f, acc, xs ->
    case xs 
    | [] => acc
    | hd::tl => fold_left(f, f(acc, hd), tl) end in

# Reduce a list from the right. #
let fold_right: ((Int, Int) -> Int, [Int], Int) -> Int =
  fun f, xs, acc ->
    case xs
    | [] => acc
    | hd::tl => f(hd, fold_right(f, tl, acc)) end in


666
LSP: Prelude: String parsed successfully
LSP: Prelude: Info map generated successfully
Debug: true, Constrain: Types
LSP: Init: Recieved string: # Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->

LSP: Init: String parsed successfully
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: <fun -><
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [Int]
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {p: ((Int -> Bool), [Int]), filter: (((Int -> Bool), [Int]) -> [Int]), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: in
  LSP: Info: ALL errors:
  LSP: Info: BidiCtx: Cls: Function literal
  LSP: Info: BidiCtx: Expected type: (((Int -> Bool), [Int]) -> [Int])
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 [Int]
Int <= [Int]
Int <= [Int]
  LSP: Convex: Target types: Int, [Int]
  LSP: Convex: Backpack: 
  LSP: Convex: Base: [] _ ( [ case  if  let  type 
  LSP: Convex: Lookahead: ( - [ [] _ abs case  filter if  int_of_float int_of_string let  max_int min_int mod string_compare string_length type  ~INTLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new_tokens ::= whitespace | "(" | "-" | "[" | "[]" | "_" | "abs" | "case " | "filter" | "if " | "int_of_float" | "int_of_string" | "let " | "max_int" | "min_int" | "mod" | "string_compare" | "string_length" | "type " | intlit
root ::= new_tokens

Top 20 Logits:
   :19.2618
 :17.643
     :16.7813
  :15.9902
    :15.4269
       :15.3953
fun:14.4884
let:14.1899
	:14.1251
      :13.2278

:13.221
         :13.1159
case:13.07
           :12.5096
        :12.0139
 let:11.7542
#:11.7478
match:11.5371
if:11.4098
func:11.2765
|:10.9881

================
# Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
   

LSP: Prelude: Recieved string: ### List ###

# Add an element to the front of a list. #
let cons: (Int, [Int]) -> [Int] = fun x, xs -> x::xs in

# Determine the length of a list. #
let length: [Int] -> Int =
  fun xs ->
    case xs
    | [] => 0
    | _::xs => 1 + length(xs) end in

# Extract the first element of a list. #
let hd: [Int] -> Option =
  fun l ->
    case l
    | [] => None
    | x::xs => Some(x) end in

# Extract the rest of the list. #
let tl: [Int] -> [Int] =
  fun l ->
    case l
    | [] => []
    | x::xs => xs end in

# Determine if a list is empty. #
let is_empty: [Int] -> Bool =
  fun xs ->
    case xs
    | [] => true
    | _::_ => false end in

# Return the element at the index. #
let nth: ([Int], Int) -> Option =
  fun xs, n ->
    case xs, n
    | x::_, 0 => Some(x)
    | _::xs, n => nth(xs, n - 1)
    | [], _ => None end in

# Reverse a List. #
let rev: [Int] -> [Int] =
fun l -> 
let go: ([Int], [Int]) -> [Int] =
  fun xs, acc -> 
    case xs 
    | [] => acc 
    | x::xs => go(xs, x::acc) end in
go(l, []) in

# Check if two lists are equal #
let equal: ([Int], [Int]) -> Bool =
    fun p, xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => x == y && equal(xs, ys)
    | _ => false end
in

# Initialize a list with a given length using an initializer function #
let init: (Int, Int -> Int) -> [Int] =
    fun len, f ->
        let go: (Int, [Int]) -> [Int] =
        fun idx, xs ->
            if idx < len 
            then go(idx + 1, xs @ [f(idx)])   
            else xs
        in
        go(0, [])
in

# Reduce a list from the left. #
let fold_left: ((Int, Int) -> Int, Int, [Int]) -> Int =
  fun f, acc, xs ->
    case xs 
    | [] => acc
    | hd::tl => fold_left(f, f(acc, hd), tl) end in

# Reduce a list from the right. #
let fold_right: ((Int, Int) -> Int, [Int], Int) -> Int =
  fun f, xs, acc ->
    case xs
    | [] => acc
    | hd::tl => f(hd, fold_right(f, tl, acc)) end in


666
LSP: Prelude: String parsed successfully
LSP: Prelude: Info map generated successfully
Debug: true, Constrain: Types
LSP: Init: Recieved string: # Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
   
LSP: Init: String parsed successfully
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: <fun -><
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [Int]
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {p: ((Int -> Bool), [Int]), filter: (((Int -> Bool), [Int]) -> [Int]), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: in
  LSP: Info: ALL errors:
  LSP: Info: BidiCtx: Cls: Function literal
  LSP: Info: BidiCtx: Expected type: (((Int -> Bool), [Int]) -> [Int])
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 [Int]
Int <= [Int]
Int <= [Int]
  LSP: Convex: Target types: Int, [Int]
  LSP: Convex: Backpack: 
  LSP: Convex: Base: [] _ ( [ case  if  let  type 
  LSP: Convex: Lookahead: ( - [ [] _ abs case  filter if  int_of_float int_of_string let  max_int min_int mod string_compare string_length type  ~INTLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new_tokens ::= whitespace | "(" | "-" | "[" | "[]" | "_" | "abs" | "case " | "filter" | "if " | "int_of_float" | "int_of_string" | "let " | "max_int" | "min_int" | "mod" | "string_compare" | "string_length" | "type " | intlit
root ::= new_tokens

Top 20 Logits:
 let:16.0293
 fun:14.7784
 case:13.1534
 fol:12.999
 List:12.3012
 rec:11.8061
 go:11.6383
 fix:11.5434
 list:11.4965
 rev:11.474
 if:11.2975
 reverse:11.2883
 (:11.1258
 #:11.0819
 function:10.9645
 filter:10.8115
 match:10.636
 map:10.5516
 cons:10.2349
 func:9.97233
 reduce:9.49355

================
# Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let

LSP: Prelude: Recieved string: ### List ###

# Add an element to the front of a list. #
let cons: (Int, [Int]) -> [Int] = fun x, xs -> x::xs in

# Determine the length of a list. #
let length: [Int] -> Int =
  fun xs ->
    case xs
    | [] => 0
    | _::xs => 1 + length(xs) end in

# Extract the first element of a list. #
let hd: [Int] -> Option =
  fun l ->
    case l
    | [] => None
    | x::xs => Some(x) end in

# Extract the rest of the list. #
let tl: [Int] -> [Int] =
  fun l ->
    case l
    | [] => []
    | x::xs => xs end in

# Determine if a list is empty. #
let is_empty: [Int] -> Bool =
  fun xs ->
    case xs
    | [] => true
    | _::_ => false end in

# Return the element at the index. #
let nth: ([Int], Int) -> Option =
  fun xs, n ->
    case xs, n
    | x::_, 0 => Some(x)
    | _::xs, n => nth(xs, n - 1)
    | [], _ => None end in

# Reverse a List. #
let rev: [Int] -> [Int] =
fun l -> 
let go: ([Int], [Int]) -> [Int] =
  fun xs, acc -> 
    case xs 
    | [] => acc 
    | x::xs => go(xs, x::acc) end in
go(l, []) in

# Check if two lists are equal #
let equal: ([Int], [Int]) -> Bool =
    fun p, xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => x == y && equal(xs, ys)
    | _ => false end
in

# Initialize a list with a given length using an initializer function #
let init: (Int, Int -> Int) -> [Int] =
    fun len, f ->
        let go: (Int, [Int]) -> [Int] =
        fun idx, xs ->
            if idx < len 
            then go(idx + 1, xs @ [f(idx)])   
            else xs
        in
        go(0, [])
in

# Reduce a list from the left. #
let fold_left: ((Int, Int) -> Int, Int, [Int]) -> Int =
  fun f, acc, xs ->
    case xs 
    | [] => acc
    | hd::tl => fold_left(f, f(acc, hd), tl) end in

# Reduce a list from the right. #
let fold_right: ((Int, Int) -> Int, [Int], Int) -> Int =
  fun f, xs, acc ->
    case xs
    | [] => acc
    | hd::tl => f(hd, fold_right(f, tl, acc)) end in


666
LSP: Prelude: String parsed successfully
LSP: Prelude: Info map generated successfully
Debug: true, Constrain: Types
LSP: Init: Recieved string: # Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let
LSP: Init: String parsed successfully
  LSP: Syntax: Leftward is Complete Tile: <let>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [Int]
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Exp (FreeVariable "let"))
  LSP: Info: Typing Context: {p: ((Int -> Bool), [Int]), filter: (((Int -> Bool), [Int]) -> [Int]), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: in
  LSP: Info: ALL errors:Error in term:
  let
Nature of error: Variable let is not bound
  LSP: Info: BidiCtx: Cls: Function literal
  LSP: Info: BidiCtx: Expected type: (((Int -> Bool), [Int]) -> [Int])
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-concave or complete: let
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: (((Int -> Bool), [Int]) -> [Int])
  LSP: Concave: Infix: Lookahead: 
  LSP: Concave: Backpack: in
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: let
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: (((Int -> Bool), [Int]) -> [Int])
  LSP: Concave: Infix: Lookahead: 
  LSP: Concave: Backpack: in
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: (
  LSP: Convex: Ty paths:
 [Int]
Int <= [Int]
Int <= [Int]
  LSP: Convex: Target types: Int, [Int]
  LSP: Convex: Backpack: 
  LSP: Convex: Base: [] _ ( [ case  if  let  type 
  LSP: Convex: Lookahead: ( - [ [] _ abs case  filter if  int_of_float int_of_string let  max_int min_int mod string_compare string_length type  ~INTLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= " "
new_tokens ::= whitespace | "(" | "::" | "@" | "in"
root ::= completions | new_tokens

Top 20 Logits:
 go:14.8719
 rec:14.305
 aux:9.71868
 cons:9.51933
 f:9.51241
 add:9.47872
rec:9.39383
 or:9.29598
 (:9.28514
 append:9.13208
 r:9.01552
 inner:8.98723
 is:8.94135
 accum:8.81294

:8.67893
 g:8.66905
 helper:8.65027
 filter:8.54836
 do:8.51077
 step:8.40671
 p:8.39157

================
# Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (

LSP: Prelude: Recieved string: ### List ###

# Add an element to the front of a list. #
let cons: (Int, [Int]) -> [Int] = fun x, xs -> x::xs in

# Determine the length of a list. #
let length: [Int] -> Int =
  fun xs ->
    case xs
    | [] => 0
    | _::xs => 1 + length(xs) end in

# Extract the first element of a list. #
let hd: [Int] -> Option =
  fun l ->
    case l
    | [] => None
    | x::xs => Some(x) end in

# Extract the rest of the list. #
let tl: [Int] -> [Int] =
  fun l ->
    case l
    | [] => []
    | x::xs => xs end in

# Determine if a list is empty. #
let is_empty: [Int] -> Bool =
  fun xs ->
    case xs
    | [] => true
    | _::_ => false end in

# Return the element at the index. #
let nth: ([Int], Int) -> Option =
  fun xs, n ->
    case xs, n
    | x::_, 0 => Some(x)
    | _::xs, n => nth(xs, n - 1)
    | [], _ => None end in

# Reverse a List. #
let rev: [Int] -> [Int] =
fun l -> 
let go: ([Int], [Int]) -> [Int] =
  fun xs, acc -> 
    case xs 
    | [] => acc 
    | x::xs => go(xs, x::acc) end in
go(l, []) in

# Check if two lists are equal #
let equal: ([Int], [Int]) -> Bool =
    fun p, xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => x == y && equal(xs, ys)
    | _ => false end
in

# Initialize a list with a given length using an initializer function #
let init: (Int, Int -> Int) -> [Int] =
    fun len, f ->
        let go: (Int, [Int]) -> [Int] =
        fun idx, xs ->
            if idx < len 
            then go(idx + 1, xs @ [f(idx)])   
            else xs
        in
        go(0, [])
in

# Reduce a list from the left. #
let fold_left: ((Int, Int) -> Int, Int, [Int]) -> Int =
  fun f, acc, xs ->
    case xs 
    | [] => acc
    | hd::tl => fold_left(f, f(acc, hd), tl) end in

# Reduce a list from the right. #
let fold_right: ((Int, Int) -> Int, [Int], Int) -> Int =
  fun f, xs, acc ->
    case xs
    | [] => acc
    | hd::tl => f(hd, fold_right(f, tl, acc)) end in


666
LSP: Prelude: String parsed successfully
LSP: Prelude: Info map generated successfully
Debug: true, Constrain: Types
LSP: Init: Recieved string: # Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (
LSP: Init: String parsed successfully
  LSP: Syntax: Leftward is Incomplete Tile: <( )<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty pattern hole
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {p: ((Int -> Bool), [Int]), filter: (((Int -> Bool), [Int]) -> [Int]), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) = in in
  LSP: Info: ALL errors:
  LSP: Info: BidiCtx: Cls: Empty pattern hole
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Parenthesized pattern
  LSP: Info: Cls: Parenthesized pattern
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {p: ((Int -> Bool), [Int]), filter: (((Int -> Bool), [Int]) -> [Int]), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) = in in
  LSP: Info: ALL errors:
  LSP: Info: BidiCtx: Cls: Parenthesized pattern
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-convex or complete: (
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position Width S () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: ( () AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position S Width [ [] _ false true ~FLOATLIT~ ~INTLIT~ ~PATVAR~ ~STRINGLIT~
LSP: Generating Completions for prefix: (
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: : ::
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position Width S () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: ( () AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position S Width [ [] _ false true ~FLOATLIT~ ~INTLIT~ ~PATVAR~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= ")"
new_tokens ::= whitespace | "(" | "()" | "AlignItems" | "BackgroundColor" | "Border" | "BorderRadius" | "BoxShadow" | "Color" | "Cursor" | "Display" | "FlexDirection" | "FontFamily" | "FontSize" | "FontStyle" | "Gap" | "Height" | "JustifyContent" | "Margin" | "Opacity" | "Outline" | "Overflow" | "Padding" | "Position" | "S" | "Width" | "[" | "[]" | "_" | "false" | "true" | floatlit | intlit | patvar | stringlit
root ::= completions | new_tokens

Top 20 Logits:
go:13.685
xs:12.7209
cons:12.2532
acc:12.0486
||:11.9262
f:11.5736
++):11.5174
|:11.496
x:11.43
rec:11.2872
p:11.2867
fold:11.1122
r:11.0234
&&:10.9111
a:10.8958
g:10.8184
q:10.782
rev:10.6437
filter:10.3535
or:10.2961
<:9.81838

================
# Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go

LSP: Prelude: Recieved string: ### List ###

# Add an element to the front of a list. #
let cons: (Int, [Int]) -> [Int] = fun x, xs -> x::xs in

# Determine the length of a list. #
let length: [Int] -> Int =
  fun xs ->
    case xs
    | [] => 0
    | _::xs => 1 + length(xs) end in

# Extract the first element of a list. #
let hd: [Int] -> Option =
  fun l ->
    case l
    | [] => None
    | x::xs => Some(x) end in

# Extract the rest of the list. #
let tl: [Int] -> [Int] =
  fun l ->
    case l
    | [] => []
    | x::xs => xs end in

# Determine if a list is empty. #
let is_empty: [Int] -> Bool =
  fun xs ->
    case xs
    | [] => true
    | _::_ => false end in

# Return the element at the index. #
let nth: ([Int], Int) -> Option =
  fun xs, n ->
    case xs, n
    | x::_, 0 => Some(x)
    | _::xs, n => nth(xs, n - 1)
    | [], _ => None end in

# Reverse a List. #
let rev: [Int] -> [Int] =
fun l -> 
let go: ([Int], [Int]) -> [Int] =
  fun xs, acc -> 
    case xs 
    | [] => acc 
    | x::xs => go(xs, x::acc) end in
go(l, []) in

# Check if two lists are equal #
let equal: ([Int], [Int]) -> Bool =
    fun p, xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => x == y && equal(xs, ys)
    | _ => false end
in

# Initialize a list with a given length using an initializer function #
let init: (Int, Int -> Int) -> [Int] =
    fun len, f ->
        let go: (Int, [Int]) -> [Int] =
        fun idx, xs ->
            if idx < len 
            then go(idx + 1, xs @ [f(idx)])   
            else xs
        in
        go(0, [])
in

# Reduce a list from the left. #
let fold_left: ((Int, Int) -> Int, Int, [Int]) -> Int =
  fun f, acc, xs ->
    case xs 
    | [] => acc
    | hd::tl => fold_left(f, f(acc, hd), tl) end in

# Reduce a list from the right. #
let fold_right: ((Int, Int) -> Int, [Int], Int) -> Int =
  fun f, xs, acc ->
    case xs
    | [] => acc
    | hd::tl => f(hd, fold_right(f, tl, acc)) end in


666
LSP: Prelude: String parsed successfully
LSP: Prelude: Info map generated successfully
Debug: true, Constrain: Types
LSP: Init: Recieved string: # Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go
LSP: Init: String parsed successfully
  LSP: Syntax: Leftward is Complete Tile: <go>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable binding
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {go: ?, p: ((Int -> Bool), [Int]), filter: (((Int -> Bool), [Int]) -> [Int]), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) = in in
  LSP: Info: ALL errors:
  LSP: Info: BidiCtx: Cls: Variable binding
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Parenthesized pattern
  LSP: Syntax: Can insert left-concave or complete: go
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: : ::
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: go
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: : ::
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position Width S () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: ( () AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position S Width [ [] _ false true ~FLOATLIT~ ~INTLIT~ ~PATVAR~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= extend-patvar
new_tokens ::= whitespace | "(" | ")" | ":" | "::"
root ::= completions | new_tokens

Top 20 Logits:
):14.8628
)::14.7812
,:13.1411
::12.5906
)(:11.5557
),:10.7485
 (:10.4098
_:10.1734
 ::9.92903
1:9.86005
(:9.77507
2:9.24372
 p:9.22968
:):9.10131
 xs:8.98055
0:8.77603
:(:8.69638
)=:8.67365
((:8.46422
?):8.37758
)?:8.25099

================
# Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go)

LSP: Prelude: Recieved string: ### List ###

# Add an element to the front of a list. #
let cons: (Int, [Int]) -> [Int] = fun x, xs -> x::xs in

# Determine the length of a list. #
let length: [Int] -> Int =
  fun xs ->
    case xs
    | [] => 0
    | _::xs => 1 + length(xs) end in

# Extract the first element of a list. #
let hd: [Int] -> Option =
  fun l ->
    case l
    | [] => None
    | x::xs => Some(x) end in

# Extract the rest of the list. #
let tl: [Int] -> [Int] =
  fun l ->
    case l
    | [] => []
    | x::xs => xs end in

# Determine if a list is empty. #
let is_empty: [Int] -> Bool =
  fun xs ->
    case xs
    | [] => true
    | _::_ => false end in

# Return the element at the index. #
let nth: ([Int], Int) -> Option =
  fun xs, n ->
    case xs, n
    | x::_, 0 => Some(x)
    | _::xs, n => nth(xs, n - 1)
    | [], _ => None end in

# Reverse a List. #
let rev: [Int] -> [Int] =
fun l -> 
let go: ([Int], [Int]) -> [Int] =
  fun xs, acc -> 
    case xs 
    | [] => acc 
    | x::xs => go(xs, x::acc) end in
go(l, []) in

# Check if two lists are equal #
let equal: ([Int], [Int]) -> Bool =
    fun p, xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => x == y && equal(xs, ys)
    | _ => false end
in

# Initialize a list with a given length using an initializer function #
let init: (Int, Int -> Int) -> [Int] =
    fun len, f ->
        let go: (Int, [Int]) -> [Int] =
        fun idx, xs ->
            if idx < len 
            then go(idx + 1, xs @ [f(idx)])   
            else xs
        in
        go(0, [])
in

# Reduce a list from the left. #
let fold_left: ((Int, Int) -> Int, Int, [Int]) -> Int =
  fun f, acc, xs ->
    case xs 
    | [] => acc
    | hd::tl => fold_left(f, f(acc, hd), tl) end in

# Reduce a list from the right. #
let fold_right: ((Int, Int) -> Int, [Int], Int) -> Int =
  fun f, xs, acc ->
    case xs
    | [] => acc
    | hd::tl => f(hd, fold_right(f, tl, acc)) end in


666
LSP: Prelude: String parsed successfully
LSP: Prelude: Info map generated successfully
Debug: true, Constrain: Types
LSP: Init: Recieved string: # Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go)
LSP: Init: String parsed successfully
  LSP: Syntax: Leftward is Complete Tile: <( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Parenthesized pattern
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {go: ?, p: ((Int -> Bool), [Int]), filter: (((Int -> Bool), [Int]) -> [Int]), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: = in in
  LSP: Info: ALL errors:
  LSP: Info: BidiCtx: Cls: Parenthesized pattern
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: =
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: : ::
  LSP: Concave: Postfix: (
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new_tokens ::= whitespace | "(" | ":" | "::" | "="
root ::= new_tokens

Top 20 Logits:
 =:16.0543
 ::14.3012
 (:14.2737
 xs:13.3081
 ((:13.1774
 p:12.3178
 x:11.94
 ([:11.8028
 l:11.5739
((:11.482
 ->:11.4334

:11.1606
 :::11.0877
 acc:10.8828
 :10.8234
 f:10.6806
 a:10.6382
 rec:10.584
 {:9.87259
 :=:9.69071
 :(:9.69068

================
# Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) =

LSP: Prelude: Recieved string: ### List ###

# Add an element to the front of a list. #
let cons: (Int, [Int]) -> [Int] = fun x, xs -> x::xs in

# Determine the length of a list. #
let length: [Int] -> Int =
  fun xs ->
    case xs
    | [] => 0
    | _::xs => 1 + length(xs) end in

# Extract the first element of a list. #
let hd: [Int] -> Option =
  fun l ->
    case l
    | [] => None
    | x::xs => Some(x) end in

# Extract the rest of the list. #
let tl: [Int] -> [Int] =
  fun l ->
    case l
    | [] => []
    | x::xs => xs end in

# Determine if a list is empty. #
let is_empty: [Int] -> Bool =
  fun xs ->
    case xs
    | [] => true
    | _::_ => false end in

# Return the element at the index. #
let nth: ([Int], Int) -> Option =
  fun xs, n ->
    case xs, n
    | x::_, 0 => Some(x)
    | _::xs, n => nth(xs, n - 1)
    | [], _ => None end in

# Reverse a List. #
let rev: [Int] -> [Int] =
fun l -> 
let go: ([Int], [Int]) -> [Int] =
  fun xs, acc -> 
    case xs 
    | [] => acc 
    | x::xs => go(xs, x::acc) end in
go(l, []) in

# Check if two lists are equal #
let equal: ([Int], [Int]) -> Bool =
    fun p, xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => x == y && equal(xs, ys)
    | _ => false end
in

# Initialize a list with a given length using an initializer function #
let init: (Int, Int -> Int) -> [Int] =
    fun len, f ->
        let go: (Int, [Int]) -> [Int] =
        fun idx, xs ->
            if idx < len 
            then go(idx + 1, xs @ [f(idx)])   
            else xs
        in
        go(0, [])
in

# Reduce a list from the left. #
let fold_left: ((Int, Int) -> Int, Int, [Int]) -> Int =
  fun f, acc, xs ->
    case xs 
    | [] => acc
    | hd::tl => fold_left(f, f(acc, hd), tl) end in

# Reduce a list from the right. #
let fold_right: ((Int, Int) -> Int, [Int], Int) -> Int =
  fun f, xs, acc ->
    case xs
    | [] => acc
    | hd::tl => f(hd, fold_right(f, tl, acc)) end in


666
LSP: Prelude: String parsed successfully
LSP: Prelude: Info map generated successfully
Debug: true, Constrain: Types
LSP: Init: Recieved string: # Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) =
LSP: Init: String parsed successfully
  LSP: Syntax: Leftward is Incomplete Tile: <let = in<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {p: ((Int -> Bool), [Int]), filter: (((Int -> Bool), [Int]) -> [Int]), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: in in
  LSP: Info: ALL errors:
  LSP: Info: BidiCtx: Cls: Empty expression hole
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 ?
  LSP: Convex: Target types: ?
  LSP: Convex: Backpack: 
  LSP: Convex: Base: p filter string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position Width S () [] _ false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: ! ( () - AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position S Width [ [] _ abs abs_float acos asin atan bool_of_string case  ceil cos epsilon_float exp false filter float_of_int float_of_string floor fun  if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod nan neg_infinity p pi sin sqrt string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan test  true type  ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new_tokens ::= whitespace | "!" | "(" | "()" | "-" | "AlignItems" | "BackgroundColor" | "Border" | "BorderRadius" | "BoxShadow" | "Color" | "Cursor" | "Display" | "FlexDirection" | "FontFamily" | "FontSize" | "FontStyle" | "Gap" | "Height" | "JustifyContent" | "Margin" | "Opacity" | "Outline" | "Overflow" | "Padding" | "Position" | "S" | "Width" | "[" | "[]" | "_" | "abs" | "abs_float" | "acos" | "asin" | "atan" | "bool_of_string" | "case " | "ceil" | "cos" | "epsilon_float" | "exp" | "false" | "filter" | "float_of_int" | "float_of_string" | "floor" | "fun " | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "nan" | "neg_infinity" | "p" | "pi" | "sin" | "sqrt" | "string_compare" | "string_concat" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "true" | "type " | floatlit | intlit | stringlit
root ::= new_tokens

Top 20 Logits:
 fun:15.9204

:15.2649
 :14.4646
 (:14.0103
 fix:11.825
 p:11.3192
 ((:11.2216
 {:10.7708
 ([:10.416
  :10.4018
 go:10.3542
 fn:10.1813
 list:10.0554
 rec:10.0424
 function:9.95537
 @:9.94412
    :9.93886
 fol:9.85767
 cons:9.81601
 let:9.61705
 [:9.54431

================
# Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun

LSP: Prelude: Recieved string: ### List ###

# Add an element to the front of a list. #
let cons: (Int, [Int]) -> [Int] = fun x, xs -> x::xs in

# Determine the length of a list. #
let length: [Int] -> Int =
  fun xs ->
    case xs
    | [] => 0
    | _::xs => 1 + length(xs) end in

# Extract the first element of a list. #
let hd: [Int] -> Option =
  fun l ->
    case l
    | [] => None
    | x::xs => Some(x) end in

# Extract the rest of the list. #
let tl: [Int] -> [Int] =
  fun l ->
    case l
    | [] => []
    | x::xs => xs end in

# Determine if a list is empty. #
let is_empty: [Int] -> Bool =
  fun xs ->
    case xs
    | [] => true
    | _::_ => false end in

# Return the element at the index. #
let nth: ([Int], Int) -> Option =
  fun xs, n ->
    case xs, n
    | x::_, 0 => Some(x)
    | _::xs, n => nth(xs, n - 1)
    | [], _ => None end in

# Reverse a List. #
let rev: [Int] -> [Int] =
fun l -> 
let go: ([Int], [Int]) -> [Int] =
  fun xs, acc -> 
    case xs 
    | [] => acc 
    | x::xs => go(xs, x::acc) end in
go(l, []) in

# Check if two lists are equal #
let equal: ([Int], [Int]) -> Bool =
    fun p, xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => x == y && equal(xs, ys)
    | _ => false end
in

# Initialize a list with a given length using an initializer function #
let init: (Int, Int -> Int) -> [Int] =
    fun len, f ->
        let go: (Int, [Int]) -> [Int] =
        fun idx, xs ->
            if idx < len 
            then go(idx + 1, xs @ [f(idx)])   
            else xs
        in
        go(0, [])
in

# Reduce a list from the left. #
let fold_left: ((Int, Int) -> Int, Int, [Int]) -> Int =
  fun f, acc, xs ->
    case xs 
    | [] => acc
    | hd::tl => fold_left(f, f(acc, hd), tl) end in

# Reduce a list from the right. #
let fold_right: ((Int, Int) -> Int, [Int], Int) -> Int =
  fun f, xs, acc ->
    case xs
    | [] => acc
    | hd::tl => f(hd, fold_right(f, tl, acc)) end in


666
LSP: Prelude: String parsed successfully
LSP: Prelude: Info map generated successfully
Debug: true, Constrain: Types
LSP: Init: Recieved string: # Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun
LSP: Init: String parsed successfully
  LSP: Syntax: Leftward is Complete Tile: <fun>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Exp (FreeVariable "fun"))
  LSP: Info: Typing Context: {p: ((Int -> Bool), [Int]), filter: (((Int -> Bool), [Int]) -> [Int]), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: in in
  LSP: Info: ALL errors:Error in term:
  fun
Nature of error: Variable fun is not bound
  LSP: Info: BidiCtx: Cls: Variable reference
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-concave or complete: fun
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: && \/ $== == != <= >= < > ==. !=. <=. >=. <. >. + - * / ** +. -. *. /. **. ++ :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Backpack: in
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: fun
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: && \/ $== == != <= >= < > ==. !=. <=. >=. <. >. + - * / ** +. -. *. /. **. ++ :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Backpack: in
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Ty paths:
 ?
  LSP: Convex: Target types: ?
  LSP: Convex: Backpack: 
  LSP: Convex: Base: p filter string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position Width S () [] _ false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: ! ( () - AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position S Width [ [] _ abs abs_float acos asin atan bool_of_string case  ceil cos epsilon_float exp false filter float_of_int float_of_string floor fun  if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod nan neg_infinity p pi sin sqrt string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan test  true type  ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= " "
new_tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/" | "in"
root ::= completions | new_tokens

Top 20 Logits:
 xs:15.4782
 (:14.705
 l:14.4564
 p:13.5425
 x:13.4225
 acc:12.5247

:11.8592
(:11.7691
 ([:11.5594
 y:11.2187
 :10.9871
 a:10.9367
 ((:10.8404
 n:10.7186
 s:10.5748
 ls:10.5312
 i:10.5053
 el:10.495
 list:10.4226
 v:10.3676
 e:10.3338

================
# Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (

LSP: Prelude: Recieved string: ### List ###

# Add an element to the front of a list. #
let cons: (Int, [Int]) -> [Int] = fun x, xs -> x::xs in

# Determine the length of a list. #
let length: [Int] -> Int =
  fun xs ->
    case xs
    | [] => 0
    | _::xs => 1 + length(xs) end in

# Extract the first element of a list. #
let hd: [Int] -> Option =
  fun l ->
    case l
    | [] => None
    | x::xs => Some(x) end in

# Extract the rest of the list. #
let tl: [Int] -> [Int] =
  fun l ->
    case l
    | [] => []
    | x::xs => xs end in

# Determine if a list is empty. #
let is_empty: [Int] -> Bool =
  fun xs ->
    case xs
    | [] => true
    | _::_ => false end in

# Return the element at the index. #
let nth: ([Int], Int) -> Option =
  fun xs, n ->
    case xs, n
    | x::_, 0 => Some(x)
    | _::xs, n => nth(xs, n - 1)
    | [], _ => None end in

# Reverse a List. #
let rev: [Int] -> [Int] =
fun l -> 
let go: ([Int], [Int]) -> [Int] =
  fun xs, acc -> 
    case xs 
    | [] => acc 
    | x::xs => go(xs, x::acc) end in
go(l, []) in

# Check if two lists are equal #
let equal: ([Int], [Int]) -> Bool =
    fun p, xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => x == y && equal(xs, ys)
    | _ => false end
in

# Initialize a list with a given length using an initializer function #
let init: (Int, Int -> Int) -> [Int] =
    fun len, f ->
        let go: (Int, [Int]) -> [Int] =
        fun idx, xs ->
            if idx < len 
            then go(idx + 1, xs @ [f(idx)])   
            else xs
        in
        go(0, [])
in

# Reduce a list from the left. #
let fold_left: ((Int, Int) -> Int, Int, [Int]) -> Int =
  fun f, acc, xs ->
    case xs 
    | [] => acc
    | hd::tl => fold_left(f, f(acc, hd), tl) end in

# Reduce a list from the right. #
let fold_right: ((Int, Int) -> Int, [Int], Int) -> Int =
  fun f, xs, acc ->
    case xs
    | [] => acc
    | hd::tl => f(hd, fold_right(f, tl, acc)) end in


666
LSP: Prelude: String parsed successfully
LSP: Prelude: Info map generated successfully
Debug: true, Constrain: Types
LSP: Init: Recieved string: # Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (
LSP: Init: String parsed successfully
  LSP: Syntax: Leftward is Incomplete Tile: <( )<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty pattern hole
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {p: ((Int -> Bool), [Int]), filter: (((Int -> Bool), [Int]) -> [Int]), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) -> in in
  LSP: Info: ALL errors:
  LSP: Info: BidiCtx: Cls: Empty pattern hole
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Parenthesized pattern
  LSP: Info: Cls: Parenthesized pattern
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {p: ((Int -> Bool), [Int]), filter: (((Int -> Bool), [Int]) -> [Int]), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) -> in in
  LSP: Info: ALL errors:
  LSP: Info: BidiCtx: Cls: Parenthesized pattern
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Syntax: Can insert left-convex or complete: (
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position Width S () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: ( () AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position S Width [ [] _ false true ~FLOATLIT~ ~INTLIT~ ~PATVAR~ ~STRINGLIT~
LSP: Generating Completions for prefix: (
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: : ::
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position Width S () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: ( () AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position S Width [ [] _ false true ~FLOATLIT~ ~INTLIT~ ~PATVAR~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= ")"
new_tokens ::= whitespace | "(" | "()" | "AlignItems" | "BackgroundColor" | "Border" | "BorderRadius" | "BoxShadow" | "Color" | "Cursor" | "Display" | "FlexDirection" | "FontFamily" | "FontSize" | "FontStyle" | "Gap" | "Height" | "JustifyContent" | "Margin" | "Opacity" | "Outline" | "Overflow" | "Padding" | "Position" | "S" | "Width" | "[" | "[]" | "_" | "false" | "true" | floatlit | intlit | patvar | stringlit
root ::= completions | new_tokens

Top 20 Logits:
xs:16.2329
acc:15.2686
x:13.8688
p:13.1643
l:12.9282
a:12.0242
i:11.1953
ls:11.1843
ys:11.0419
f:10.9822
res:10.9059
lst:10.8561
n:10.7816
e:10.6722
test:10.6701
r:10.6054
y:10.5442
s:10.4851
k:10.3817
v:10.3799
list:10.3758

================
# Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs

LSP: Prelude: Recieved string: ### List ###

# Add an element to the front of a list. #
let cons: (Int, [Int]) -> [Int] = fun x, xs -> x::xs in

# Determine the length of a list. #
let length: [Int] -> Int =
  fun xs ->
    case xs
    | [] => 0
    | _::xs => 1 + length(xs) end in

# Extract the first element of a list. #
let hd: [Int] -> Option =
  fun l ->
    case l
    | [] => None
    | x::xs => Some(x) end in

# Extract the rest of the list. #
let tl: [Int] -> [Int] =
  fun l ->
    case l
    | [] => []
    | x::xs => xs end in

# Determine if a list is empty. #
let is_empty: [Int] -> Bool =
  fun xs ->
    case xs
    | [] => true
    | _::_ => false end in

# Return the element at the index. #
let nth: ([Int], Int) -> Option =
  fun xs, n ->
    case xs, n
    | x::_, 0 => Some(x)
    | _::xs, n => nth(xs, n - 1)
    | [], _ => None end in

# Reverse a List. #
let rev: [Int] -> [Int] =
fun l -> 
let go: ([Int], [Int]) -> [Int] =
  fun xs, acc -> 
    case xs 
    | [] => acc 
    | x::xs => go(xs, x::acc) end in
go(l, []) in

# Check if two lists are equal #
let equal: ([Int], [Int]) -> Bool =
    fun p, xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => x == y && equal(xs, ys)
    | _ => false end
in

# Initialize a list with a given length using an initializer function #
let init: (Int, Int -> Int) -> [Int] =
    fun len, f ->
        let go: (Int, [Int]) -> [Int] =
        fun idx, xs ->
            if idx < len 
            then go(idx + 1, xs @ [f(idx)])   
            else xs
        in
        go(0, [])
in

# Reduce a list from the left. #
let fold_left: ((Int, Int) -> Int, Int, [Int]) -> Int =
  fun f, acc, xs ->
    case xs 
    | [] => acc
    | hd::tl => fold_left(f, f(acc, hd), tl) end in

# Reduce a list from the right. #
let fold_right: ((Int, Int) -> Int, [Int], Int) -> Int =
  fun f, xs, acc ->
    case xs
    | [] => acc
    | hd::tl => f(hd, fold_right(f, tl, acc)) end in


666
LSP: Prelude: String parsed successfully
LSP: Prelude: Info map generated successfully
Debug: true, Constrain: Types
LSP: Init: Recieved string: # Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs
LSP: Init: String parsed successfully
  LSP: Syntax: Leftward is Complete Tile: <xs>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable binding
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {xs: ?, p: ((Int -> Bool), [Int]), filter: (((Int -> Bool), [Int]) -> [Int]), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) -> in in
  LSP: Info: ALL errors:
  LSP: Info: BidiCtx: Cls: Variable binding
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Parenthesized pattern
  LSP: Syntax: Can insert left-concave or complete: xs
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: : ::
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: xs
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: : ::
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position Width S () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: ( () AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position S Width [ [] _ false true ~FLOATLIT~ ~INTLIT~ ~PATVAR~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= extend-patvar
new_tokens ::= whitespace | "(" | ")" | "," | ":" | "::"
root ::= completions | new_tokens

Top 20 Logits:
,:17.02
):16.0108
)::15.1511
::14.1412
),:12.6365
 ::12.5298
)->:12.5144
 ,:11.8366
',:11.2842
1:11.2189
 as:11.0781
 ->:10.8524
 =:10.8011
 acc:10.496
0:10.4737
_:10.4082
_,:10.3113
:[:10.2385
)(:10.0161
 y:9.85574
'):9.84413

================
# Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs,

LSP: Prelude: Recieved string: ### List ###

# Add an element to the front of a list. #
let cons: (Int, [Int]) -> [Int] = fun x, xs -> x::xs in

# Determine the length of a list. #
let length: [Int] -> Int =
  fun xs ->
    case xs
    | [] => 0
    | _::xs => 1 + length(xs) end in

# Extract the first element of a list. #
let hd: [Int] -> Option =
  fun l ->
    case l
    | [] => None
    | x::xs => Some(x) end in

# Extract the rest of the list. #
let tl: [Int] -> [Int] =
  fun l ->
    case l
    | [] => []
    | x::xs => xs end in

# Determine if a list is empty. #
let is_empty: [Int] -> Bool =
  fun xs ->
    case xs
    | [] => true
    | _::_ => false end in

# Return the element at the index. #
let nth: ([Int], Int) -> Option =
  fun xs, n ->
    case xs, n
    | x::_, 0 => Some(x)
    | _::xs, n => nth(xs, n - 1)
    | [], _ => None end in

# Reverse a List. #
let rev: [Int] -> [Int] =
fun l -> 
let go: ([Int], [Int]) -> [Int] =
  fun xs, acc -> 
    case xs 
    | [] => acc 
    | x::xs => go(xs, x::acc) end in
go(l, []) in

# Check if two lists are equal #
let equal: ([Int], [Int]) -> Bool =
    fun p, xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => x == y && equal(xs, ys)
    | _ => false end
in

# Initialize a list with a given length using an initializer function #
let init: (Int, Int -> Int) -> [Int] =
    fun len, f ->
        let go: (Int, [Int]) -> [Int] =
        fun idx, xs ->
            if idx < len 
            then go(idx + 1, xs @ [f(idx)])   
            else xs
        in
        go(0, [])
in

# Reduce a list from the left. #
let fold_left: ((Int, Int) -> Int, Int, [Int]) -> Int =
  fun f, acc, xs ->
    case xs 
    | [] => acc
    | hd::tl => fold_left(f, f(acc, hd), tl) end in

# Reduce a list from the right. #
let fold_right: ((Int, Int) -> Int, [Int], Int) -> Int =
  fun f, xs, acc ->
    case xs
    | [] => acc
    | hd::tl => f(hd, fold_right(f, tl, acc)) end in


666
LSP: Prelude: String parsed successfully
LSP: Prelude: Info map generated successfully
Debug: true, Constrain: Types
LSP: Init: Recieved string: # Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs,
LSP: Init: String parsed successfully
  LSP: Syntax: Leftward is Complete Tile: >,<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty pattern hole
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {xs: ?, p: ((Int -> Bool), [Int]), filter: (((Int -> Bool), [Int]) -> [Int]), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) -> in in
  LSP: Info: ALL errors:
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Parenthesized pattern
  LSP: Info: Cls: Tuple
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: (?, ?)
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {xs: ?, p: ((Int -> Bool), [Int]), filter: (((Int -> Bool), [Int]) -> [Int]), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) -> in in
  LSP: Info: ALL errors:
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Parenthesized pattern
  LSP: Syntax: Can insert left-convex or complete: ,
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position Width S () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: ( () AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position S Width [ [] _ false true ~FLOATLIT~ ~INTLIT~ ~PATVAR~ ~STRINGLIT~
LSP: Generating Completions for prefix: ,
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: : ::
  LSP: Concave: Postfix: 
  LSP: Convex: Backpack: 
  LSP: Convex: Base: AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position Width S () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: ( () AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position S Width [ [] _ false true ~FLOATLIT~ ~INTLIT~ ~PATVAR~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new_tokens ::= whitespace | "(" | "()" | "AlignItems" | "BackgroundColor" | "Border" | "BorderRadius" | "BoxShadow" | "Color" | "Cursor" | "Display" | "FlexDirection" | "FontFamily" | "FontSize" | "FontStyle" | "Gap" | "Height" | "JustifyContent" | "Margin" | "Opacity" | "Outline" | "Overflow" | "Padding" | "Position" | "S" | "Width" | "[" | "[]" | "_" | "false" | "true" | floatlit | intlit | patvar | stringlit
root ::= new_tokens

Top 20 Logits:
 acc:14.8972
 y:13.905
 res:11.6342
 p:11.1378
 r:10.9879
 rs:10.8199
 xs:10.6715
 accum:10.5654
 l:10.5013
 (:10.4824
 result:10.4375
 z:10.3648
acc:10.275
 out:10.2699
 rest:9.94893
 x:9.90614
 a:9.76019
 vs:9.64195
 ret:9.59113
 ac:9.49234
 n:9.211

================
# Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc

LSP: Prelude: Recieved string: ### List ###

# Add an element to the front of a list. #
let cons: (Int, [Int]) -> [Int] = fun x, xs -> x::xs in

# Determine the length of a list. #
let length: [Int] -> Int =
  fun xs ->
    case xs
    | [] => 0
    | _::xs => 1 + length(xs) end in

# Extract the first element of a list. #
let hd: [Int] -> Option =
  fun l ->
    case l
    | [] => None
    | x::xs => Some(x) end in

# Extract the rest of the list. #
let tl: [Int] -> [Int] =
  fun l ->
    case l
    | [] => []
    | x::xs => xs end in

# Determine if a list is empty. #
let is_empty: [Int] -> Bool =
  fun xs ->
    case xs
    | [] => true
    | _::_ => false end in

# Return the element at the index. #
let nth: ([Int], Int) -> Option =
  fun xs, n ->
    case xs, n
    | x::_, 0 => Some(x)
    | _::xs, n => nth(xs, n - 1)
    | [], _ => None end in

# Reverse a List. #
let rev: [Int] -> [Int] =
fun l -> 
let go: ([Int], [Int]) -> [Int] =
  fun xs, acc -> 
    case xs 
    | [] => acc 
    | x::xs => go(xs, x::acc) end in
go(l, []) in

# Check if two lists are equal #
let equal: ([Int], [Int]) -> Bool =
    fun p, xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => x == y && equal(xs, ys)
    | _ => false end
in

# Initialize a list with a given length using an initializer function #
let init: (Int, Int -> Int) -> [Int] =
    fun len, f ->
        let go: (Int, [Int]) -> [Int] =
        fun idx, xs ->
            if idx < len 
            then go(idx + 1, xs @ [f(idx)])   
            else xs
        in
        go(0, [])
in

# Reduce a list from the left. #
let fold_left: ((Int, Int) -> Int, Int, [Int]) -> Int =
  fun f, acc, xs ->
    case xs 
    | [] => acc
    | hd::tl => fold_left(f, f(acc, hd), tl) end in

# Reduce a list from the right. #
let fold_right: ((Int, Int) -> Int, [Int], Int) -> Int =
  fun f, xs, acc ->
    case xs
    | [] => acc
    | hd::tl => f(hd, fold_right(f, tl, acc)) end in


666
LSP: Prelude: String parsed successfully
LSP: Prelude: Info map generated successfully
Debug: true, Constrain: Types
LSP: Init: Recieved string: # Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc
LSP: Init: String parsed successfully
  LSP: Syntax: Leftward is Complete Tile: <acc>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable binding
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {acc: ?, xs: ?, p: ((Int -> Bool), [Int]), filter: (((Int -> Bool), [Int]) -> [Int]), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) -> in in
  LSP: Info: ALL errors:
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Parenthesized pattern
  LSP: Syntax: Can insert left-concave or complete: acc
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: : ::
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: acc
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: : ::
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position Width S () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: ( () AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position S Width [ [] _ false true ~FLOATLIT~ ~INTLIT~ ~PATVAR~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= extend-patvar
new_tokens ::= whitespace | "(" | ")" | "," | ":" | "::"
root ::= completions | new_tokens

Top 20 Logits:
):17.6281
)::16.551
)->:14.5366
u:13.2952
,:13.1455
 ->:12.6137
::12.4101
 =:12.2389
),:11.7324
1:11.5331
0:11.3177
_:11.1569
 ):11.1008
 ::11.0928
m:10.8354
=:10.4977
_):10.4561
 as:10.3006
2:10.1751
)=:10.1597
->:9.65454

================
# Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc)

LSP: Prelude: Recieved string: ### List ###

# Add an element to the front of a list. #
let cons: (Int, [Int]) -> [Int] = fun x, xs -> x::xs in

# Determine the length of a list. #
let length: [Int] -> Int =
  fun xs ->
    case xs
    | [] => 0
    | _::xs => 1 + length(xs) end in

# Extract the first element of a list. #
let hd: [Int] -> Option =
  fun l ->
    case l
    | [] => None
    | x::xs => Some(x) end in

# Extract the rest of the list. #
let tl: [Int] -> [Int] =
  fun l ->
    case l
    | [] => []
    | x::xs => xs end in

# Determine if a list is empty. #
let is_empty: [Int] -> Bool =
  fun xs ->
    case xs
    | [] => true
    | _::_ => false end in

# Return the element at the index. #
let nth: ([Int], Int) -> Option =
  fun xs, n ->
    case xs, n
    | x::_, 0 => Some(x)
    | _::xs, n => nth(xs, n - 1)
    | [], _ => None end in

# Reverse a List. #
let rev: [Int] -> [Int] =
fun l -> 
let go: ([Int], [Int]) -> [Int] =
  fun xs, acc -> 
    case xs 
    | [] => acc 
    | x::xs => go(xs, x::acc) end in
go(l, []) in

# Check if two lists are equal #
let equal: ([Int], [Int]) -> Bool =
    fun p, xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => x == y && equal(xs, ys)
    | _ => false end
in

# Initialize a list with a given length using an initializer function #
let init: (Int, Int -> Int) -> [Int] =
    fun len, f ->
        let go: (Int, [Int]) -> [Int] =
        fun idx, xs ->
            if idx < len 
            then go(idx + 1, xs @ [f(idx)])   
            else xs
        in
        go(0, [])
in

# Reduce a list from the left. #
let fold_left: ((Int, Int) -> Int, Int, [Int]) -> Int =
  fun f, acc, xs ->
    case xs 
    | [] => acc
    | hd::tl => fold_left(f, f(acc, hd), tl) end in

# Reduce a list from the right. #
let fold_right: ((Int, Int) -> Int, [Int], Int) -> Int =
  fun f, xs, acc ->
    case xs
    | [] => acc
    | hd::tl => f(hd, fold_right(f, tl, acc)) end in


666
LSP: Prelude: String parsed successfully
LSP: Prelude: Info map generated successfully
Debug: true, Constrain: Types
LSP: Init: Recieved string: # Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc)
LSP: Init: String parsed successfully
  LSP: Syntax: Leftward is Complete Tile: <( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Parenthesized pattern
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: (?, ?)
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {acc: ?, xs: ?, p: ((Int -> Bool), [Int]), filter: (((Int -> Bool), [Int]) -> [Int]), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: -> in in
  LSP: Info: ALL errors:
  LSP: Info: BidiCtx: Cls: Parenthesized pattern
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: ->
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: : ::
  LSP: Concave: Postfix: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new_tokens ::= whitespace | "," | "->" | ":" | "::"
root ::= new_tokens

Top 20 Logits:
 ->:16.7608
 =>:12.744

:12.1886
 :11.9568
 xs:11.2107
 {:10.9485
 ::10.9079
 (:10.6302
 p:10.5562
 =:10.5213
 match:10.0594
 x:9.78153
 acc:9.50659
 -:9.30083
 :9.22444
 in:8.7267
 ~:8.57686
 case:8.47437
 |:8.47372
 -->:8.45016
 :::8.34628

================
# Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->

LSP: Prelude: Recieved string: ### List ###

# Add an element to the front of a list. #
let cons: (Int, [Int]) -> [Int] = fun x, xs -> x::xs in

# Determine the length of a list. #
let length: [Int] -> Int =
  fun xs ->
    case xs
    | [] => 0
    | _::xs => 1 + length(xs) end in

# Extract the first element of a list. #
let hd: [Int] -> Option =
  fun l ->
    case l
    | [] => None
    | x::xs => Some(x) end in

# Extract the rest of the list. #
let tl: [Int] -> [Int] =
  fun l ->
    case l
    | [] => []
    | x::xs => xs end in

# Determine if a list is empty. #
let is_empty: [Int] -> Bool =
  fun xs ->
    case xs
    | [] => true
    | _::_ => false end in

# Return the element at the index. #
let nth: ([Int], Int) -> Option =
  fun xs, n ->
    case xs, n
    | x::_, 0 => Some(x)
    | _::xs, n => nth(xs, n - 1)
    | [], _ => None end in

# Reverse a List. #
let rev: [Int] -> [Int] =
fun l -> 
let go: ([Int], [Int]) -> [Int] =
  fun xs, acc -> 
    case xs 
    | [] => acc 
    | x::xs => go(xs, x::acc) end in
go(l, []) in

# Check if two lists are equal #
let equal: ([Int], [Int]) -> Bool =
    fun p, xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => x == y && equal(xs, ys)
    | _ => false end
in

# Initialize a list with a given length using an initializer function #
let init: (Int, Int -> Int) -> [Int] =
    fun len, f ->
        let go: (Int, [Int]) -> [Int] =
        fun idx, xs ->
            if idx < len 
            then go(idx + 1, xs @ [f(idx)])   
            else xs
        in
        go(0, [])
in

# Reduce a list from the left. #
let fold_left: ((Int, Int) -> Int, Int, [Int]) -> Int =
  fun f, acc, xs ->
    case xs 
    | [] => acc
    | hd::tl => fold_left(f, f(acc, hd), tl) end in

# Reduce a list from the right. #
let fold_right: ((Int, Int) -> Int, [Int], Int) -> Int =
  fun f, xs, acc ->
    case xs
    | [] => acc
    | hd::tl => f(hd, fold_right(f, tl, acc)) end in


666
LSP: Prelude: String parsed successfully
LSP: Prelude: Info map generated successfully
Debug: true, Constrain: Types
LSP: Init: Recieved string: # Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
LSP: Init: String parsed successfully
  LSP: Syntax: Leftward is Complete Tile: <fun -><
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {acc: ?, xs: ?, p: ((Int -> Bool), [Int]), filter: (((Int -> Bool), [Int]) -> [Int]), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: in in
  LSP: Info: ALL errors:
  LSP: Info: BidiCtx: Cls: Function literal
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 ?
  LSP: Convex: Target types: ?
  LSP: Convex: Backpack: 
  LSP: Convex: Base: acc xs p filter string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position Width S () [] _ false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: ! ( () - AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position S Width [ [] _ abs abs_float acc acos asin atan bool_of_string case  ceil cos epsilon_float exp false filter float_of_int float_of_string floor fun  if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod nan neg_infinity p pi sin sqrt string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan test  true type  xs ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new_tokens ::= whitespace | "!" | "(" | "()" | "-" | "AlignItems" | "BackgroundColor" | "Border" | "BorderRadius" | "BoxShadow" | "Color" | "Cursor" | "Display" | "FlexDirection" | "FontFamily" | "FontSize" | "FontStyle" | "Gap" | "Height" | "JustifyContent" | "Margin" | "Opacity" | "Outline" | "Overflow" | "Padding" | "Position" | "S" | "Width" | "[" | "[]" | "_" | "abs" | "abs_float" | "acc" | "acos" | "asin" | "atan" | "bool_of_string" | "case " | "ceil" | "cos" | "epsilon_float" | "exp" | "false" | "filter" | "float_of_int" | "float_of_string" | "floor" | "fun " | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "nan" | "neg_infinity" | "p" | "pi" | "sin" | "sqrt" | "string_compare" | "string_concat" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "true" | "type " | "xs" | floatlit | intlit | stringlit
root ::= new_tokens

Top 20 Logits:

:19.0414
 :16.8953
 case:16.1888
 match:15.0903
  :14.661
    :13.4326
 xs:12.9897
 if:12.5313
                :12.425
        :12.3251
      :12.2634
     :12.2328
 p:12.0765
 (:11.8761
   :11.8346
       :11.7326
 //:11.7318
 {:11.6859
 #:11.6852
         :11.5683
            :11.4919

================
# Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->


LSP: Prelude: Recieved string: ### List ###

# Add an element to the front of a list. #
let cons: (Int, [Int]) -> [Int] = fun x, xs -> x::xs in

# Determine the length of a list. #
let length: [Int] -> Int =
  fun xs ->
    case xs
    | [] => 0
    | _::xs => 1 + length(xs) end in

# Extract the first element of a list. #
let hd: [Int] -> Option =
  fun l ->
    case l
    | [] => None
    | x::xs => Some(x) end in

# Extract the rest of the list. #
let tl: [Int] -> [Int] =
  fun l ->
    case l
    | [] => []
    | x::xs => xs end in

# Determine if a list is empty. #
let is_empty: [Int] -> Bool =
  fun xs ->
    case xs
    | [] => true
    | _::_ => false end in

# Return the element at the index. #
let nth: ([Int], Int) -> Option =
  fun xs, n ->
    case xs, n
    | x::_, 0 => Some(x)
    | _::xs, n => nth(xs, n - 1)
    | [], _ => None end in

# Reverse a List. #
let rev: [Int] -> [Int] =
fun l -> 
let go: ([Int], [Int]) -> [Int] =
  fun xs, acc -> 
    case xs 
    | [] => acc 
    | x::xs => go(xs, x::acc) end in
go(l, []) in

# Check if two lists are equal #
let equal: ([Int], [Int]) -> Bool =
    fun p, xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => x == y && equal(xs, ys)
    | _ => false end
in

# Initialize a list with a given length using an initializer function #
let init: (Int, Int -> Int) -> [Int] =
    fun len, f ->
        let go: (Int, [Int]) -> [Int] =
        fun idx, xs ->
            if idx < len 
            then go(idx + 1, xs @ [f(idx)])   
            else xs
        in
        go(0, [])
in

# Reduce a list from the left. #
let fold_left: ((Int, Int) -> Int, Int, [Int]) -> Int =
  fun f, acc, xs ->
    case xs 
    | [] => acc
    | hd::tl => fold_left(f, f(acc, hd), tl) end in

# Reduce a list from the right. #
let fold_right: ((Int, Int) -> Int, [Int], Int) -> Int =
  fun f, xs, acc ->
    case xs
    | [] => acc
    | hd::tl => f(hd, fold_right(f, tl, acc)) end in


666
LSP: Prelude: String parsed successfully
LSP: Prelude: Info map generated successfully
Debug: true, Constrain: Types
LSP: Init: Recieved string: # Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->

LSP: Init: String parsed successfully
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: <fun -><
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {acc: ?, xs: ?, p: ((Int -> Bool), [Int]), filter: (((Int -> Bool), [Int]) -> [Int]), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: in in
  LSP: Info: ALL errors:
  LSP: Info: BidiCtx: Cls: Function literal
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 ?
  LSP: Convex: Target types: ?
  LSP: Convex: Backpack: 
  LSP: Convex: Base: acc xs p filter string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position Width S () [] _ false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: ! ( () - AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position S Width [ [] _ abs abs_float acc acos asin atan bool_of_string case  ceil cos epsilon_float exp false filter float_of_int float_of_string floor fun  if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod nan neg_infinity p pi sin sqrt string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan test  true type  xs ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new_tokens ::= whitespace | "!" | "(" | "()" | "-" | "AlignItems" | "BackgroundColor" | "Border" | "BorderRadius" | "BoxShadow" | "Color" | "Cursor" | "Display" | "FlexDirection" | "FontFamily" | "FontSize" | "FontStyle" | "Gap" | "Height" | "JustifyContent" | "Margin" | "Opacity" | "Outline" | "Overflow" | "Padding" | "Position" | "S" | "Width" | "[" | "[]" | "_" | "abs" | "abs_float" | "acc" | "acos" | "asin" | "atan" | "bool_of_string" | "case " | "ceil" | "cos" | "epsilon_float" | "exp" | "false" | "filter" | "float_of_int" | "float_of_string" | "floor" | "fun " | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "nan" | "neg_infinity" | "p" | "pi" | "sin" | "sqrt" | "string_compare" | "string_concat" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "true" | "type " | "xs" | floatlit | intlit | stringlit
root ::= new_tokens

Top 20 Logits:
     :19.5699
       :18.1877
               :15.8105
   :15.6506
                :15.4175
           :15.139
         :14.8566
      :14.2369
    :13.7144
             :13.653
              :12.9731
	:12.9166
          :12.4685
        :12.4364
            :12.1624
 :10.8654

:10.7933
  :10.6014
//:8.56089
if:8.48904
case:7.69647

================
# Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
     

LSP: Prelude: Recieved string: ### List ###

# Add an element to the front of a list. #
let cons: (Int, [Int]) -> [Int] = fun x, xs -> x::xs in

# Determine the length of a list. #
let length: [Int] -> Int =
  fun xs ->
    case xs
    | [] => 0
    | _::xs => 1 + length(xs) end in

# Extract the first element of a list. #
let hd: [Int] -> Option =
  fun l ->
    case l
    | [] => None
    | x::xs => Some(x) end in

# Extract the rest of the list. #
let tl: [Int] -> [Int] =
  fun l ->
    case l
    | [] => []
    | x::xs => xs end in

# Determine if a list is empty. #
let is_empty: [Int] -> Bool =
  fun xs ->
    case xs
    | [] => true
    | _::_ => false end in

# Return the element at the index. #
let nth: ([Int], Int) -> Option =
  fun xs, n ->
    case xs, n
    | x::_, 0 => Some(x)
    | _::xs, n => nth(xs, n - 1)
    | [], _ => None end in

# Reverse a List. #
let rev: [Int] -> [Int] =
fun l -> 
let go: ([Int], [Int]) -> [Int] =
  fun xs, acc -> 
    case xs 
    | [] => acc 
    | x::xs => go(xs, x::acc) end in
go(l, []) in

# Check if two lists are equal #
let equal: ([Int], [Int]) -> Bool =
    fun p, xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => x == y && equal(xs, ys)
    | _ => false end
in

# Initialize a list with a given length using an initializer function #
let init: (Int, Int -> Int) -> [Int] =
    fun len, f ->
        let go: (Int, [Int]) -> [Int] =
        fun idx, xs ->
            if idx < len 
            then go(idx + 1, xs @ [f(idx)])   
            else xs
        in
        go(0, [])
in

# Reduce a list from the left. #
let fold_left: ((Int, Int) -> Int, Int, [Int]) -> Int =
  fun f, acc, xs ->
    case xs 
    | [] => acc
    | hd::tl => fold_left(f, f(acc, hd), tl) end in

# Reduce a list from the right. #
let fold_right: ((Int, Int) -> Int, [Int], Int) -> Int =
  fun f, xs, acc ->
    case xs
    | [] => acc
    | hd::tl => f(hd, fold_right(f, tl, acc)) end in


666
LSP: Prelude: String parsed successfully
LSP: Prelude: Info map generated successfully
Debug: true, Constrain: Types
LSP: Init: Recieved string: # Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
     
LSP: Init: String parsed successfully
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: <fun -><
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {acc: ?, xs: ?, p: ((Int -> Bool), [Int]), filter: (((Int -> Bool), [Int]) -> [Int]), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: in in
  LSP: Info: ALL errors:
  LSP: Info: BidiCtx: Cls: Function literal
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 ?
  LSP: Convex: Target types: ?
  LSP: Convex: Backpack: 
  LSP: Convex: Base: acc xs p filter string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position Width S () [] _ false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: ! ( () - AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position S Width [ [] _ abs abs_float acc acos asin atan bool_of_string case  ceil cos epsilon_float exp false filter float_of_int float_of_string floor fun  if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod nan neg_infinity p pi sin sqrt string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan test  true type  xs ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new_tokens ::= whitespace | "!" | "(" | "()" | "-" | "AlignItems" | "BackgroundColor" | "Border" | "BorderRadius" | "BoxShadow" | "Color" | "Cursor" | "Display" | "FlexDirection" | "FontFamily" | "FontSize" | "FontStyle" | "Gap" | "Height" | "JustifyContent" | "Margin" | "Opacity" | "Outline" | "Overflow" | "Padding" | "Position" | "S" | "Width" | "[" | "[]" | "_" | "abs" | "abs_float" | "acc" | "acos" | "asin" | "atan" | "bool_of_string" | "case " | "ceil" | "cos" | "epsilon_float" | "exp" | "false" | "filter" | "float_of_int" | "float_of_string" | "floor" | "fun " | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "nan" | "neg_infinity" | "p" | "pi" | "sin" | "sqrt" | "string_compare" | "string_concat" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "true" | "type " | "xs" | floatlit | intlit | stringlit
root ::= new_tokens

Top 20 Logits:
 case:21.5976
 match:18.5656
 if:16.5954
 let:14.4611
 (:13.3322
 xs:12.6722
 fol:12.451
 switch:12.2606
 p:12.1885
 print:12.1252
 fun:12.0627
 |:11.5693
 #:11.5299
 go:11.4468
 begin:11.4434
 //:11.3443
 (*:10.9364
 in:10.914
 is:10.9105
 var:10.8115
 cases:10.7913

================
# Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case

LSP: Prelude: Recieved string: ### List ###

# Add an element to the front of a list. #
let cons: (Int, [Int]) -> [Int] = fun x, xs -> x::xs in

# Determine the length of a list. #
let length: [Int] -> Int =
  fun xs ->
    case xs
    | [] => 0
    | _::xs => 1 + length(xs) end in

# Extract the first element of a list. #
let hd: [Int] -> Option =
  fun l ->
    case l
    | [] => None
    | x::xs => Some(x) end in

# Extract the rest of the list. #
let tl: [Int] -> [Int] =
  fun l ->
    case l
    | [] => []
    | x::xs => xs end in

# Determine if a list is empty. #
let is_empty: [Int] -> Bool =
  fun xs ->
    case xs
    | [] => true
    | _::_ => false end in

# Return the element at the index. #
let nth: ([Int], Int) -> Option =
  fun xs, n ->
    case xs, n
    | x::_, 0 => Some(x)
    | _::xs, n => nth(xs, n - 1)
    | [], _ => None end in

# Reverse a List. #
let rev: [Int] -> [Int] =
fun l -> 
let go: ([Int], [Int]) -> [Int] =
  fun xs, acc -> 
    case xs 
    | [] => acc 
    | x::xs => go(xs, x::acc) end in
go(l, []) in

# Check if two lists are equal #
let equal: ([Int], [Int]) -> Bool =
    fun p, xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => x == y && equal(xs, ys)
    | _ => false end
in

# Initialize a list with a given length using an initializer function #
let init: (Int, Int -> Int) -> [Int] =
    fun len, f ->
        let go: (Int, [Int]) -> [Int] =
        fun idx, xs ->
            if idx < len 
            then go(idx + 1, xs @ [f(idx)])   
            else xs
        in
        go(0, [])
in

# Reduce a list from the left. #
let fold_left: ((Int, Int) -> Int, Int, [Int]) -> Int =
  fun f, acc, xs ->
    case xs 
    | [] => acc
    | hd::tl => fold_left(f, f(acc, hd), tl) end in

# Reduce a list from the right. #
let fold_right: ((Int, Int) -> Int, [Int], Int) -> Int =
  fun f, xs, acc ->
    case xs
    | [] => acc
    | hd::tl => f(hd, fold_right(f, tl, acc)) end in


666
LSP: Prelude: String parsed successfully
LSP: Prelude: Info map generated successfully
Debug: true, Constrain: Types
LSP: Init: Recieved string: # Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case
LSP: Init: String parsed successfully
  LSP: Syntax: Leftward is Complete Tile: <case>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Exp (FreeVariable "case"))
  LSP: Info: Typing Context: {acc: ?, xs: ?, p: ((Int -> Bool), [Int]), filter: (((Int -> Bool), [Int]) -> [Int]), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: in in
  LSP: Info: ALL errors:Error in term:
  case
Nature of error: Variable case is not bound
  LSP: Info: BidiCtx: Cls: Function literal
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-concave or complete: case
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: && \/ $== == != <= >= < > ==. !=. <=. >=. <. >. + - * / ** +. -. *. /. **. ++ :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Backpack: in
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: case
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: && \/ $== == != <= >= < > ==. !=. <=. >=. <. >. + - * / ** +. -. *. /. **. ++ :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Backpack: in
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Ty paths:
 ?
  LSP: Convex: Target types: ?
  LSP: Convex: Backpack: 
  LSP: Convex: Base: acc xs p filter string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position Width S () [] _ false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: ! ( () - AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position S Width [ [] _ abs abs_float acc acos asin atan bool_of_string case  ceil cos epsilon_float exp false filter float_of_int float_of_string floor fun  if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod nan neg_infinity p pi sin sqrt string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan test  true type  xs ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= " "
new_tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/" | "in"
root ::= completions | new_tokens

Top 20 Logits:
 xs:20.7605
 p:14.5688
 (:14.3429
 h:12.7254
 x:12.3408
 l:12.0063
 go:11.9761
 :11.803
 list:11.6439

:11.5282
(:11.3967
 acc:11.2267
 match:11.1571
 t:10.9919
 !:10.9786
 n:10.9776
 is:10.905
 [:10.3957
 length:10.2825
 in:10.172
 ():9.99298

================
# Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (

LSP: Prelude: Recieved string: ### List ###

# Add an element to the front of a list. #
let cons: (Int, [Int]) -> [Int] = fun x, xs -> x::xs in

# Determine the length of a list. #
let length: [Int] -> Int =
  fun xs ->
    case xs
    | [] => 0
    | _::xs => 1 + length(xs) end in

# Extract the first element of a list. #
let hd: [Int] -> Option =
  fun l ->
    case l
    | [] => None
    | x::xs => Some(x) end in

# Extract the rest of the list. #
let tl: [Int] -> [Int] =
  fun l ->
    case l
    | [] => []
    | x::xs => xs end in

# Determine if a list is empty. #
let is_empty: [Int] -> Bool =
  fun xs ->
    case xs
    | [] => true
    | _::_ => false end in

# Return the element at the index. #
let nth: ([Int], Int) -> Option =
  fun xs, n ->
    case xs, n
    | x::_, 0 => Some(x)
    | _::xs, n => nth(xs, n - 1)
    | [], _ => None end in

# Reverse a List. #
let rev: [Int] -> [Int] =
fun l -> 
let go: ([Int], [Int]) -> [Int] =
  fun xs, acc -> 
    case xs 
    | [] => acc 
    | x::xs => go(xs, x::acc) end in
go(l, []) in

# Check if two lists are equal #
let equal: ([Int], [Int]) -> Bool =
    fun p, xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => x == y && equal(xs, ys)
    | _ => false end
in

# Initialize a list with a given length using an initializer function #
let init: (Int, Int -> Int) -> [Int] =
    fun len, f ->
        let go: (Int, [Int]) -> [Int] =
        fun idx, xs ->
            if idx < len 
            then go(idx + 1, xs @ [f(idx)])   
            else xs
        in
        go(0, [])
in

# Reduce a list from the left. #
let fold_left: ((Int, Int) -> Int, Int, [Int]) -> Int =
  fun f, acc, xs ->
    case xs 
    | [] => acc
    | hd::tl => fold_left(f, f(acc, hd), tl) end in

# Reduce a list from the right. #
let fold_right: ((Int, Int) -> Int, [Int], Int) -> Int =
  fun f, xs, acc ->
    case xs
    | [] => acc
    | hd::tl => f(hd, fold_right(f, tl, acc)) end in


666
LSP: Prelude: String parsed successfully
LSP: Prelude: Info map generated successfully
Debug: true, Constrain: Types
LSP: Init: Recieved string: # Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (
LSP: Init: String parsed successfully
  LSP: Syntax: Leftward is Incomplete Tile: <( )<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {acc: ?, xs: ?, p: ((Int -> Bool), [Int]), filter: (((Int -> Bool), [Int]) -> [Int]), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in in
  LSP: Info: ALL errors:
  LSP: Info: BidiCtx: Cls: Empty expression hole
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Info: Cls: Parenthesized expression
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {acc: ?, xs: ?, p: ((Int -> Bool), [Int]), filter: (((Int -> Bool), [Int]) -> [Int]), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in in
  LSP: Info: ALL errors:
  LSP: Info: BidiCtx: Cls: Parenthesized expression
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Syntax: Can insert left-convex or complete: (
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 ?
  LSP: Convex: Target types: ?
  LSP: Convex: Backpack: 
  LSP: Convex: Base: acc xs p filter string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position Width S () [] _ false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: ! ( () - AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position S Width [ [] _ abs abs_float acc acos asin atan bool_of_string case  ceil cos epsilon_float exp false filter float_of_int float_of_string floor fun  if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod nan neg_infinity p pi sin sqrt string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan test  true type  xs ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Generating Completions for prefix: (
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: && \/ $== == != <= >= < > ==. !=. <=. >=. <. >. + - * / ** +. -. *. /. **. ++ :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: ( |
  LSP: Convex: Ty paths:
 ?
  LSP: Convex: Target types: ?
  LSP: Convex: Backpack: 
  LSP: Convex: Base: acc xs p filter string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position Width S () [] _ false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: ! ( () - AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position S Width [ [] _ abs abs_float acc acos asin atan bool_of_string case  ceil cos epsilon_float exp false filter float_of_int float_of_string floor fun  if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod nan neg_infinity p pi sin sqrt string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan test  true type  xs ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= ")"
new_tokens ::= whitespace | "!" | "(" | "()" | "-" | "AlignItems" | "BackgroundColor" | "Border" | "BorderRadius" | "BoxShadow" | "Color" | "Cursor" | "Display" | "FlexDirection" | "FontFamily" | "FontSize" | "FontStyle" | "Gap" | "Height" | "JustifyContent" | "Margin" | "Opacity" | "Outline" | "Overflow" | "Padding" | "Position" | "S" | "Width" | "[" | "[]" | "_" | "abs" | "abs_float" | "acc" | "acos" | "asin" | "atan" | "bool_of_string" | "case " | "ceil" | "cos" | "epsilon_float" | "exp" | "false" | "filter" | "float_of_int" | "float_of_string" | "floor" | "fun " | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "nan" | "neg_infinity" | "p" | "pi" | "sin" | "sqrt" | "string_compare" | "string_concat" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "true" | "type " | "xs" | floatlit | intlit | stringlit
root ::= completions | new_tokens

Top 20 Logits:
xs:17.5668
p:13.803
acc:12.6712
 xs:12.0554
x:11.9078
hd:11.8641
is:11.4799
match:11.4262
case:10.9186
hs:10.8349
cons:10.7607
filter:10.5138
tl:10.3663

:10.0118
length:9.93095
if:9.87964
go:9.85066
fun:9.84474
list:9.8298
List:9.81182
not:9.69757

================
# Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs

LSP: Prelude: Recieved string: ### List ###

# Add an element to the front of a list. #
let cons: (Int, [Int]) -> [Int] = fun x, xs -> x::xs in

# Determine the length of a list. #
let length: [Int] -> Int =
  fun xs ->
    case xs
    | [] => 0
    | _::xs => 1 + length(xs) end in

# Extract the first element of a list. #
let hd: [Int] -> Option =
  fun l ->
    case l
    | [] => None
    | x::xs => Some(x) end in

# Extract the rest of the list. #
let tl: [Int] -> [Int] =
  fun l ->
    case l
    | [] => []
    | x::xs => xs end in

# Determine if a list is empty. #
let is_empty: [Int] -> Bool =
  fun xs ->
    case xs
    | [] => true
    | _::_ => false end in

# Return the element at the index. #
let nth: ([Int], Int) -> Option =
  fun xs, n ->
    case xs, n
    | x::_, 0 => Some(x)
    | _::xs, n => nth(xs, n - 1)
    | [], _ => None end in

# Reverse a List. #
let rev: [Int] -> [Int] =
fun l -> 
let go: ([Int], [Int]) -> [Int] =
  fun xs, acc -> 
    case xs 
    | [] => acc 
    | x::xs => go(xs, x::acc) end in
go(l, []) in

# Check if two lists are equal #
let equal: ([Int], [Int]) -> Bool =
    fun p, xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => x == y && equal(xs, ys)
    | _ => false end
in

# Initialize a list with a given length using an initializer function #
let init: (Int, Int -> Int) -> [Int] =
    fun len, f ->
        let go: (Int, [Int]) -> [Int] =
        fun idx, xs ->
            if idx < len 
            then go(idx + 1, xs @ [f(idx)])   
            else xs
        in
        go(0, [])
in

# Reduce a list from the left. #
let fold_left: ((Int, Int) -> Int, Int, [Int]) -> Int =
  fun f, acc, xs ->
    case xs 
    | [] => acc
    | hd::tl => fold_left(f, f(acc, hd), tl) end in

# Reduce a list from the right. #
let fold_right: ((Int, Int) -> Int, [Int], Int) -> Int =
  fun f, xs, acc ->
    case xs
    | [] => acc
    | hd::tl => f(hd, fold_right(f, tl, acc)) end in


666
LSP: Prelude: String parsed successfully
LSP: Prelude: Info map generated successfully
Debug: true, Constrain: Types
LSP: Init: Recieved string: # Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs
LSP: Init: String parsed successfully
  LSP: Syntax: Leftward is Complete Tile: <xs>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {acc: ?, xs: ?, p: ((Int -> Bool), [Int]), filter: (((Int -> Bool), [Int]) -> [Int]), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in in
  LSP: Info: ALL errors:
  LSP: Info: BidiCtx: Cls: Variable reference
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Can insert left-concave or complete: xs
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: && \/ $== == != <= >= < > ==. !=. <=. >=. <. >. + - * / ** +. -. *. /. **. ++ :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: xs
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: && \/ $== == != <= >= < > ==. !=. <=. >=. <. >. + - * / ** +. -. *. /. **. ++ :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Ty paths:
 ?
  LSP: Convex: Target types: ?
  LSP: Convex: Backpack: 
  LSP: Convex: Base: acc xs p filter string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position Width S () [] _ false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: ! ( () - AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position S Width [ [] _ abs abs_float acc acos asin atan bool_of_string case  ceil cos epsilon_float exp false filter float_of_int float_of_string floor fun  if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod nan neg_infinity p pi sin sqrt string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan test  true type  xs ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new_tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | ")" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/"
root ::= new_tokens

Top 20 Logits:
):19.2588
,:17.0232
)::16.6926
),:14.7585
::13.9346
 ::12.9559
 =:12.4121
 as:12.2963
 ==:12.0994
 ):11.9599
[:11.8702
 ,:11.8058
)[:11.6994
)?:11.6686
 p:11.6641
);:11.5525
;:11.5492
 |:11.2647
){:11.2039
)(:10.9916
 !=:10.837

================
# Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)

LSP: Prelude: Recieved string: ### List ###

# Add an element to the front of a list. #
let cons: (Int, [Int]) -> [Int] = fun x, xs -> x::xs in

# Determine the length of a list. #
let length: [Int] -> Int =
  fun xs ->
    case xs
    | [] => 0
    | _::xs => 1 + length(xs) end in

# Extract the first element of a list. #
let hd: [Int] -> Option =
  fun l ->
    case l
    | [] => None
    | x::xs => Some(x) end in

# Extract the rest of the list. #
let tl: [Int] -> [Int] =
  fun l ->
    case l
    | [] => []
    | x::xs => xs end in

# Determine if a list is empty. #
let is_empty: [Int] -> Bool =
  fun xs ->
    case xs
    | [] => true
    | _::_ => false end in

# Return the element at the index. #
let nth: ([Int], Int) -> Option =
  fun xs, n ->
    case xs, n
    | x::_, 0 => Some(x)
    | _::xs, n => nth(xs, n - 1)
    | [], _ => None end in

# Reverse a List. #
let rev: [Int] -> [Int] =
fun l -> 
let go: ([Int], [Int]) -> [Int] =
  fun xs, acc -> 
    case xs 
    | [] => acc 
    | x::xs => go(xs, x::acc) end in
go(l, []) in

# Check if two lists are equal #
let equal: ([Int], [Int]) -> Bool =
    fun p, xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => x == y && equal(xs, ys)
    | _ => false end
in

# Initialize a list with a given length using an initializer function #
let init: (Int, Int -> Int) -> [Int] =
    fun len, f ->
        let go: (Int, [Int]) -> [Int] =
        fun idx, xs ->
            if idx < len 
            then go(idx + 1, xs @ [f(idx)])   
            else xs
        in
        go(0, [])
in

# Reduce a list from the left. #
let fold_left: ((Int, Int) -> Int, Int, [Int]) -> Int =
  fun f, acc, xs ->
    case xs 
    | [] => acc
    | hd::tl => fold_left(f, f(acc, hd), tl) end in

# Reduce a list from the right. #
let fold_right: ((Int, Int) -> Int, [Int], Int) -> Int =
  fun f, xs, acc ->
    case xs
    | [] => acc
    | hd::tl => f(hd, fold_right(f, tl, acc)) end in


666
LSP: Prelude: String parsed successfully
LSP: Prelude: Info map generated successfully
Debug: true, Constrain: Types
LSP: Init: Recieved string: # Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
LSP: Init: String parsed successfully
  LSP: Syntax: Leftward is Complete Tile: <( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Parenthesized expression
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {acc: ?, xs: ?, p: ((Int -> Bool), [Int]), filter: (((Int -> Bool), [Int]) -> [Int]), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end in in
  LSP: Info: ALL errors:
  LSP: Info: BidiCtx: Cls: Parenthesized expression
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: && \/ $== == != <= >= < > ==. !=. <=. >=. <. >. + - * / ** +. -. *. /. **. ++ :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Backpack: end
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: ( |
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new_tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/" | "end" | "|"
root ::= new_tokens

Top 20 Logits:

:18.772
 :17.04
 of:16.0805
 |:14.7775
 as:14.3984
 {:14.3691
  :13.7903
 ->:13.709
 =>:13.6396
 in:13.4945
 match:12.8832
 (:12.6297
 with:12.5002
 ::12.4069
 :::12.3851
    :12.1236
 =:11.9692
 end:11.9044
 #:11.5297
 when:11.2032
                :11.0618

================
# Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)


LSP: Prelude: Recieved string: ### List ###

# Add an element to the front of a list. #
let cons: (Int, [Int]) -> [Int] = fun x, xs -> x::xs in

# Determine the length of a list. #
let length: [Int] -> Int =
  fun xs ->
    case xs
    | [] => 0
    | _::xs => 1 + length(xs) end in

# Extract the first element of a list. #
let hd: [Int] -> Option =
  fun l ->
    case l
    | [] => None
    | x::xs => Some(x) end in

# Extract the rest of the list. #
let tl: [Int] -> [Int] =
  fun l ->
    case l
    | [] => []
    | x::xs => xs end in

# Determine if a list is empty. #
let is_empty: [Int] -> Bool =
  fun xs ->
    case xs
    | [] => true
    | _::_ => false end in

# Return the element at the index. #
let nth: ([Int], Int) -> Option =
  fun xs, n ->
    case xs, n
    | x::_, 0 => Some(x)
    | _::xs, n => nth(xs, n - 1)
    | [], _ => None end in

# Reverse a List. #
let rev: [Int] -> [Int] =
fun l -> 
let go: ([Int], [Int]) -> [Int] =
  fun xs, acc -> 
    case xs 
    | [] => acc 
    | x::xs => go(xs, x::acc) end in
go(l, []) in

# Check if two lists are equal #
let equal: ([Int], [Int]) -> Bool =
    fun p, xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => x == y && equal(xs, ys)
    | _ => false end
in

# Initialize a list with a given length using an initializer function #
let init: (Int, Int -> Int) -> [Int] =
    fun len, f ->
        let go: (Int, [Int]) -> [Int] =
        fun idx, xs ->
            if idx < len 
            then go(idx + 1, xs @ [f(idx)])   
            else xs
        in
        go(0, [])
in

# Reduce a list from the left. #
let fold_left: ((Int, Int) -> Int, Int, [Int]) -> Int =
  fun f, acc, xs ->
    case xs 
    | [] => acc
    | hd::tl => fold_left(f, f(acc, hd), tl) end in

# Reduce a list from the right. #
let fold_right: ((Int, Int) -> Int, [Int], Int) -> Int =
  fun f, xs, acc ->
    case xs
    | [] => acc
    | hd::tl => f(hd, fold_right(f, tl, acc)) end in


666
LSP: Prelude: String parsed successfully
LSP: Prelude: Info map generated successfully
Debug: true, Constrain: Types
LSP: Init: Recieved string: # Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)

LSP: Init: String parsed successfully
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: <( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Parenthesized expression
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {acc: ?, xs: ?, p: ((Int -> Bool), [Int]), filter: (((Int -> Bool), [Int]) -> [Int]), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end in in
  LSP: Info: ALL errors:
  LSP: Info: BidiCtx: Cls: Parenthesized expression
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: && \/ $== == != <= >= < > ==. !=. <=. >=. <. >. + - * / ** +. -. *. /. **. ++ :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Backpack: end
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: ( |
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new_tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/" | "end" | "|"
root ::= new_tokens

Top 20 Logits:
     :22.5298
       :22.352
      :19.2793
         :18.9637
        :17.8929
	:17.876
    :17.5087
           :16.9448
   :16.738
          :16.4481

:15.2837
             :15.1066
               :15.0199
                :15.0057
            :14.9325
  :14.7844
|:14.0356
 :14.0174
              :13.7814
#:13.3761
 |:12.9463

================
# Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
     

LSP: Prelude: Recieved string: ### List ###

# Add an element to the front of a list. #
let cons: (Int, [Int]) -> [Int] = fun x, xs -> x::xs in

# Determine the length of a list. #
let length: [Int] -> Int =
  fun xs ->
    case xs
    | [] => 0
    | _::xs => 1 + length(xs) end in

# Extract the first element of a list. #
let hd: [Int] -> Option =
  fun l ->
    case l
    | [] => None
    | x::xs => Some(x) end in

# Extract the rest of the list. #
let tl: [Int] -> [Int] =
  fun l ->
    case l
    | [] => []
    | x::xs => xs end in

# Determine if a list is empty. #
let is_empty: [Int] -> Bool =
  fun xs ->
    case xs
    | [] => true
    | _::_ => false end in

# Return the element at the index. #
let nth: ([Int], Int) -> Option =
  fun xs, n ->
    case xs, n
    | x::_, 0 => Some(x)
    | _::xs, n => nth(xs, n - 1)
    | [], _ => None end in

# Reverse a List. #
let rev: [Int] -> [Int] =
fun l -> 
let go: ([Int], [Int]) -> [Int] =
  fun xs, acc -> 
    case xs 
    | [] => acc 
    | x::xs => go(xs, x::acc) end in
go(l, []) in

# Check if two lists are equal #
let equal: ([Int], [Int]) -> Bool =
    fun p, xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => x == y && equal(xs, ys)
    | _ => false end
in

# Initialize a list with a given length using an initializer function #
let init: (Int, Int -> Int) -> [Int] =
    fun len, f ->
        let go: (Int, [Int]) -> [Int] =
        fun idx, xs ->
            if idx < len 
            then go(idx + 1, xs @ [f(idx)])   
            else xs
        in
        go(0, [])
in

# Reduce a list from the left. #
let fold_left: ((Int, Int) -> Int, Int, [Int]) -> Int =
  fun f, acc, xs ->
    case xs 
    | [] => acc
    | hd::tl => fold_left(f, f(acc, hd), tl) end in

# Reduce a list from the right. #
let fold_right: ((Int, Int) -> Int, [Int], Int) -> Int =
  fun f, xs, acc ->
    case xs
    | [] => acc
    | hd::tl => f(hd, fold_right(f, tl, acc)) end in


666
LSP: Prelude: String parsed successfully
LSP: Prelude: Info map generated successfully
Debug: true, Constrain: Types
LSP: Init: Recieved string: # Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
     
LSP: Init: String parsed successfully
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: <( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Parenthesized expression
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {acc: ?, xs: ?, p: ((Int -> Bool), [Int]), filter: (((Int -> Bool), [Int]) -> [Int]), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end in in
  LSP: Info: ALL errors:
  LSP: Info: BidiCtx: Cls: Parenthesized expression
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: && \/ $== == != <= >= < > ==. !=. <=. >=. <. >. + - * / ** +. -. *. /. **. ++ :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Backpack: end
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: ( |
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new_tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/" | "end" | "|"
root ::= new_tokens

Top 20 Logits:
 |:23.2603
 #:14.3671
 ||:13.9028
 (*:13.7302
 if:12.7393
 //:12.706
 of:12.5756
 when:12.4182
 (:12.2955
 p:12.1436
 match:12.0754
 /*:11.7741
 {:11.3458
 *:11.1992
 end:11.1501
 []:11.1383
 -:11.0718
 .:10.803
 ##:10.7108
 [:10.6954
 ::10.6811

================
# Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      |

LSP: Prelude: Recieved string: ### List ###

# Add an element to the front of a list. #
let cons: (Int, [Int]) -> [Int] = fun x, xs -> x::xs in

# Determine the length of a list. #
let length: [Int] -> Int =
  fun xs ->
    case xs
    | [] => 0
    | _::xs => 1 + length(xs) end in

# Extract the first element of a list. #
let hd: [Int] -> Option =
  fun l ->
    case l
    | [] => None
    | x::xs => Some(x) end in

# Extract the rest of the list. #
let tl: [Int] -> [Int] =
  fun l ->
    case l
    | [] => []
    | x::xs => xs end in

# Determine if a list is empty. #
let is_empty: [Int] -> Bool =
  fun xs ->
    case xs
    | [] => true
    | _::_ => false end in

# Return the element at the index. #
let nth: ([Int], Int) -> Option =
  fun xs, n ->
    case xs, n
    | x::_, 0 => Some(x)
    | _::xs, n => nth(xs, n - 1)
    | [], _ => None end in

# Reverse a List. #
let rev: [Int] -> [Int] =
fun l -> 
let go: ([Int], [Int]) -> [Int] =
  fun xs, acc -> 
    case xs 
    | [] => acc 
    | x::xs => go(xs, x::acc) end in
go(l, []) in

# Check if two lists are equal #
let equal: ([Int], [Int]) -> Bool =
    fun p, xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => x == y && equal(xs, ys)
    | _ => false end
in

# Initialize a list with a given length using an initializer function #
let init: (Int, Int -> Int) -> [Int] =
    fun len, f ->
        let go: (Int, [Int]) -> [Int] =
        fun idx, xs ->
            if idx < len 
            then go(idx + 1, xs @ [f(idx)])   
            else xs
        in
        go(0, [])
in

# Reduce a list from the left. #
let fold_left: ((Int, Int) -> Int, Int, [Int]) -> Int =
  fun f, acc, xs ->
    case xs 
    | [] => acc
    | hd::tl => fold_left(f, f(acc, hd), tl) end in

# Reduce a list from the right. #
let fold_right: ((Int, Int) -> Int, [Int], Int) -> Int =
  fun f, xs, acc ->
    case xs
    | [] => acc
    | hd::tl => f(hd, fold_right(f, tl, acc)) end in


666
LSP: Prelude: String parsed successfully
LSP: Prelude: Info map generated successfully
Debug: true, Constrain: Types
LSP: Init: Recieved string: # Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      |
LSP: Init: String parsed successfully
  LSP: Syntax: Leftward is Incomplete Tile: >| =><
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty pattern hole
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {acc: ?, xs: ?, p: ((Int -> Bool), [Int]), filter: (((Int -> Bool), [Int]) -> [Int]), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: => end in in
  LSP: Info: ALL errors:
  LSP: Info: BidiCtx: Cls: Empty pattern hole
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position Width S () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: ( () AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position S Width [ [] _ false true ~FLOATLIT~ ~INTLIT~ ~PATVAR~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new_tokens ::= whitespace | "(" | "()" | "AlignItems" | "BackgroundColor" | "Border" | "BorderRadius" | "BoxShadow" | "Color" | "Cursor" | "Display" | "FlexDirection" | "FontFamily" | "FontSize" | "FontStyle" | "Gap" | "Height" | "JustifyContent" | "Margin" | "Opacity" | "Outline" | "Overflow" | "Padding" | "Position" | "S" | "Width" | "[" | "[]" | "_" | "false" | "true" | floatlit | intlit | patvar | stringlit
root ::= new_tokens

Top 20 Logits:
 []:20.4732
 x:16.6509
 h:15.9245
 (:15.2741
[]:14.6571
 y:13.5902
 ([:13.366
 [:13.2101
 ((:13.0069
 [],:12.9035
 _:12.6865
 [(:12.0695
 xs:11.9343
 :11.9296
 a:11.8206
 (_:11.7002
 ():11.327
  :11.2273
 e:11.0855
 l:11.0436
 z:10.975

================
# Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | []

LSP: Prelude: Recieved string: ### List ###

# Add an element to the front of a list. #
let cons: (Int, [Int]) -> [Int] = fun x, xs -> x::xs in

# Determine the length of a list. #
let length: [Int] -> Int =
  fun xs ->
    case xs
    | [] => 0
    | _::xs => 1 + length(xs) end in

# Extract the first element of a list. #
let hd: [Int] -> Option =
  fun l ->
    case l
    | [] => None
    | x::xs => Some(x) end in

# Extract the rest of the list. #
let tl: [Int] -> [Int] =
  fun l ->
    case l
    | [] => []
    | x::xs => xs end in

# Determine if a list is empty. #
let is_empty: [Int] -> Bool =
  fun xs ->
    case xs
    | [] => true
    | _::_ => false end in

# Return the element at the index. #
let nth: ([Int], Int) -> Option =
  fun xs, n ->
    case xs, n
    | x::_, 0 => Some(x)
    | _::xs, n => nth(xs, n - 1)
    | [], _ => None end in

# Reverse a List. #
let rev: [Int] -> [Int] =
fun l -> 
let go: ([Int], [Int]) -> [Int] =
  fun xs, acc -> 
    case xs 
    | [] => acc 
    | x::xs => go(xs, x::acc) end in
go(l, []) in

# Check if two lists are equal #
let equal: ([Int], [Int]) -> Bool =
    fun p, xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => x == y && equal(xs, ys)
    | _ => false end
in

# Initialize a list with a given length using an initializer function #
let init: (Int, Int -> Int) -> [Int] =
    fun len, f ->
        let go: (Int, [Int]) -> [Int] =
        fun idx, xs ->
            if idx < len 
            then go(idx + 1, xs @ [f(idx)])   
            else xs
        in
        go(0, [])
in

# Reduce a list from the left. #
let fold_left: ((Int, Int) -> Int, Int, [Int]) -> Int =
  fun f, acc, xs ->
    case xs 
    | [] => acc
    | hd::tl => fold_left(f, f(acc, hd), tl) end in

# Reduce a list from the right. #
let fold_right: ((Int, Int) -> Int, [Int], Int) -> Int =
  fun f, xs, acc ->
    case xs
    | [] => acc
    | hd::tl => f(hd, fold_right(f, tl, acc)) end in


666
LSP: Prelude: String parsed successfully
LSP: Prelude: Info map generated successfully
Debug: true, Constrain: Types
LSP: Init: Recieved string: # Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | []
LSP: Init: String parsed successfully
  LSP: Syntax: Leftward is Complete Tile: <[]>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: List literal
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {acc: ?, xs: ?, p: ((Int -> Bool), [Int]), filter: (((Int -> Bool), [Int]) -> [Int]), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: => end in in
  LSP: Info: ALL errors:
  LSP: Info: BidiCtx: Cls: List literal
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Syntax: Can insert left-concave or complete: []
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: =>
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: : ::
  LSP: Concave: Postfix: 
LSP: Generating Completions for prefix: []
  LSP: Concave: Backpack: =>
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: : ::
  LSP: Concave: Postfix: 
  LSP: Convex: Backpack: 
  LSP: Convex: Base: AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position Width S () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: ( () AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position S Width [ [] _ false true ~FLOATLIT~ ~INTLIT~ ~PATVAR~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new_tokens ::= whitespace | ":" | "::" | "=>"
root ::= new_tokens

Top 20 Logits:
 =>:20.4216
 ->:15.0449
=>:13.2093
    :13.2065
       :13.2054
      :13.0909
  :13.0409
         :12.8068
 :12.7042
   :12.5267
 :=:12.4707
        :12.3925
           :12.1859
 :::12.1549
     :12.0862
          :12.0843
                :12.0725
             :11.8627
            :11.8571
              :11.0274
               :10.9189

================
# Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] =>

LSP: Prelude: Recieved string: ### List ###

# Add an element to the front of a list. #
let cons: (Int, [Int]) -> [Int] = fun x, xs -> x::xs in

# Determine the length of a list. #
let length: [Int] -> Int =
  fun xs ->
    case xs
    | [] => 0
    | _::xs => 1 + length(xs) end in

# Extract the first element of a list. #
let hd: [Int] -> Option =
  fun l ->
    case l
    | [] => None
    | x::xs => Some(x) end in

# Extract the rest of the list. #
let tl: [Int] -> [Int] =
  fun l ->
    case l
    | [] => []
    | x::xs => xs end in

# Determine if a list is empty. #
let is_empty: [Int] -> Bool =
  fun xs ->
    case xs
    | [] => true
    | _::_ => false end in

# Return the element at the index. #
let nth: ([Int], Int) -> Option =
  fun xs, n ->
    case xs, n
    | x::_, 0 => Some(x)
    | _::xs, n => nth(xs, n - 1)
    | [], _ => None end in

# Reverse a List. #
let rev: [Int] -> [Int] =
fun l -> 
let go: ([Int], [Int]) -> [Int] =
  fun xs, acc -> 
    case xs 
    | [] => acc 
    | x::xs => go(xs, x::acc) end in
go(l, []) in

# Check if two lists are equal #
let equal: ([Int], [Int]) -> Bool =
    fun p, xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => x == y && equal(xs, ys)
    | _ => false end
in

# Initialize a list with a given length using an initializer function #
let init: (Int, Int -> Int) -> [Int] =
    fun len, f ->
        let go: (Int, [Int]) -> [Int] =
        fun idx, xs ->
            if idx < len 
            then go(idx + 1, xs @ [f(idx)])   
            else xs
        in
        go(0, [])
in

# Reduce a list from the left. #
let fold_left: ((Int, Int) -> Int, Int, [Int]) -> Int =
  fun f, acc, xs ->
    case xs 
    | [] => acc
    | hd::tl => fold_left(f, f(acc, hd), tl) end in

# Reduce a list from the right. #
let fold_right: ((Int, Int) -> Int, [Int], Int) -> Int =
  fun f, xs, acc ->
    case xs
    | [] => acc
    | hd::tl => f(hd, fold_right(f, tl, acc)) end in


666
LSP: Prelude: String parsed successfully
LSP: Prelude: Info map generated successfully
Debug: true, Constrain: Types
LSP: Init: Recieved string: # Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] =>
LSP: Init: String parsed successfully
  LSP: Syntax: Leftward is Complete Tile: >| =><
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {acc: ?, xs: ?, p: ((Int -> Bool), [Int]), filter: (((Int -> Bool), [Int]) -> [Int]), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end in in
  LSP: Info: ALL errors:
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 ?
  LSP: Convex: Target types: ?
  LSP: Convex: Backpack: 
  LSP: Convex: Base: acc xs p filter string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position Width S () [] _ false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: ! ( () - AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position S Width [ [] _ abs abs_float acc acos asin atan bool_of_string case  ceil cos epsilon_float exp false filter float_of_int float_of_string floor fun  if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod nan neg_infinity p pi sin sqrt string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan test  true type  xs ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new_tokens ::= whitespace | "!" | "(" | "()" | "-" | "AlignItems" | "BackgroundColor" | "Border" | "BorderRadius" | "BoxShadow" | "Color" | "Cursor" | "Display" | "FlexDirection" | "FontFamily" | "FontSize" | "FontStyle" | "Gap" | "Height" | "JustifyContent" | "Margin" | "Opacity" | "Outline" | "Overflow" | "Padding" | "Position" | "S" | "Width" | "[" | "[]" | "_" | "abs" | "abs_float" | "acc" | "acos" | "asin" | "atan" | "bool_of_string" | "case " | "ceil" | "cos" | "epsilon_float" | "exp" | "false" | "filter" | "float_of_int" | "float_of_string" | "floor" | "fun " | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "nan" | "neg_infinity" | "p" | "pi" | "sin" | "sqrt" | "string_compare" | "string_concat" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "true" | "type " | "xs" | floatlit | intlit | stringlit
root ::= new_tokens

Top 20 Logits:
 rev:16.5052
 acc:15.7298
 reverse:14.3907
 []:12.1333
 List:11.7778
 (:11.5302
 Some:11.2724
 xs:10.9399
 :10.7592
 fol:10.7281
 list:10.5936

:10.4179
 None:10.3147
 t:10.079
rev:9.7854
 revers:9.73382
 ():9.43605
 accum:9.38329
 [:9.30687
 cons:9.16487
 res:9.03964

================
# Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc

LSP: Prelude: Recieved string: ### List ###

# Add an element to the front of a list. #
let cons: (Int, [Int]) -> [Int] = fun x, xs -> x::xs in

# Determine the length of a list. #
let length: [Int] -> Int =
  fun xs ->
    case xs
    | [] => 0
    | _::xs => 1 + length(xs) end in

# Extract the first element of a list. #
let hd: [Int] -> Option =
  fun l ->
    case l
    | [] => None
    | x::xs => Some(x) end in

# Extract the rest of the list. #
let tl: [Int] -> [Int] =
  fun l ->
    case l
    | [] => []
    | x::xs => xs end in

# Determine if a list is empty. #
let is_empty: [Int] -> Bool =
  fun xs ->
    case xs
    | [] => true
    | _::_ => false end in

# Return the element at the index. #
let nth: ([Int], Int) -> Option =
  fun xs, n ->
    case xs, n
    | x::_, 0 => Some(x)
    | _::xs, n => nth(xs, n - 1)
    | [], _ => None end in

# Reverse a List. #
let rev: [Int] -> [Int] =
fun l -> 
let go: ([Int], [Int]) -> [Int] =
  fun xs, acc -> 
    case xs 
    | [] => acc 
    | x::xs => go(xs, x::acc) end in
go(l, []) in

# Check if two lists are equal #
let equal: ([Int], [Int]) -> Bool =
    fun p, xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => x == y && equal(xs, ys)
    | _ => false end
in

# Initialize a list with a given length using an initializer function #
let init: (Int, Int -> Int) -> [Int] =
    fun len, f ->
        let go: (Int, [Int]) -> [Int] =
        fun idx, xs ->
            if idx < len 
            then go(idx + 1, xs @ [f(idx)])   
            else xs
        in
        go(0, [])
in

# Reduce a list from the left. #
let fold_left: ((Int, Int) -> Int, Int, [Int]) -> Int =
  fun f, acc, xs ->
    case xs 
    | [] => acc
    | hd::tl => fold_left(f, f(acc, hd), tl) end in

# Reduce a list from the right. #
let fold_right: ((Int, Int) -> Int, [Int], Int) -> Int =
  fun f, xs, acc ->
    case xs
    | [] => acc
    | hd::tl => f(hd, fold_right(f, tl, acc)) end in


666
LSP: Prelude: String parsed successfully
LSP: Prelude: Info map generated successfully
Debug: true, Constrain: Types
LSP: Init: Recieved string: # Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
LSP: Init: String parsed successfully
  LSP: Syntax: Leftward is Complete Tile: <acc>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {acc: ?, xs: ?, p: ((Int -> Bool), [Int]), filter: (((Int -> Bool), [Int]) -> [Int]), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end in in
  LSP: Info: ALL errors:
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Syntax: Can insert left-concave or complete: acc
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: && \/ $== == != <= >= < > ==. !=. <=. >=. <. >. + - * / ** +. -. *. /. **. ++ :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Backpack: end
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: ( |
LSP: Generating Completions for prefix: acc
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: && \/ $== == != <= >= < > ==. !=. <=. >=. <. >. + - * / ** +. -. *. /. **. ++ :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Backpack: end
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: ( |
  LSP: Convex: Ty paths:
 ?
  LSP: Convex: Target types: ?
  LSP: Convex: Backpack: 
  LSP: Convex: Base: acc xs p filter string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position Width S () [] _ false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: ! ( () - AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position S Width [ [] _ abs abs_float acc acos asin atan bool_of_string case  ceil cos epsilon_float exp false filter float_of_int float_of_string floor fun  if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod nan neg_infinity p pi sin sqrt string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan test  true type  xs ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new_tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/" | "end" | "|"
root ::= new_tokens

Top 20 Logits:

:18.4788
 :14.9531
 |:13.7874
 @:13.6982
:::13.1273
  :12.9879
;:12.7206
    :12.0413
                :11.9724
 //:11.6724
 :::11.5774
      :11.4863
 #:11.2968
@:11.1931
,:11.1408
.:11.0244
        :10.8561
 reverse:10.8422
 in:10.835
 ::10.7345
   :10.5204

================
# Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc


LSP: Prelude: Recieved string: ### List ###

# Add an element to the front of a list. #
let cons: (Int, [Int]) -> [Int] = fun x, xs -> x::xs in

# Determine the length of a list. #
let length: [Int] -> Int =
  fun xs ->
    case xs
    | [] => 0
    | _::xs => 1 + length(xs) end in

# Extract the first element of a list. #
let hd: [Int] -> Option =
  fun l ->
    case l
    | [] => None
    | x::xs => Some(x) end in

# Extract the rest of the list. #
let tl: [Int] -> [Int] =
  fun l ->
    case l
    | [] => []
    | x::xs => xs end in

# Determine if a list is empty. #
let is_empty: [Int] -> Bool =
  fun xs ->
    case xs
    | [] => true
    | _::_ => false end in

# Return the element at the index. #
let nth: ([Int], Int) -> Option =
  fun xs, n ->
    case xs, n
    | x::_, 0 => Some(x)
    | _::xs, n => nth(xs, n - 1)
    | [], _ => None end in

# Reverse a List. #
let rev: [Int] -> [Int] =
fun l -> 
let go: ([Int], [Int]) -> [Int] =
  fun xs, acc -> 
    case xs 
    | [] => acc 
    | x::xs => go(xs, x::acc) end in
go(l, []) in

# Check if two lists are equal #
let equal: ([Int], [Int]) -> Bool =
    fun p, xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => x == y && equal(xs, ys)
    | _ => false end
in

# Initialize a list with a given length using an initializer function #
let init: (Int, Int -> Int) -> [Int] =
    fun len, f ->
        let go: (Int, [Int]) -> [Int] =
        fun idx, xs ->
            if idx < len 
            then go(idx + 1, xs @ [f(idx)])   
            else xs
        in
        go(0, [])
in

# Reduce a list from the left. #
let fold_left: ((Int, Int) -> Int, Int, [Int]) -> Int =
  fun f, acc, xs ->
    case xs 
    | [] => acc
    | hd::tl => fold_left(f, f(acc, hd), tl) end in

# Reduce a list from the right. #
let fold_right: ((Int, Int) -> Int, [Int], Int) -> Int =
  fun f, xs, acc ->
    case xs
    | [] => acc
    | hd::tl => f(hd, fold_right(f, tl, acc)) end in


666
LSP: Prelude: String parsed successfully
LSP: Prelude: Info map generated successfully
Debug: true, Constrain: Types
LSP: Init: Recieved string: # Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc

LSP: Init: String parsed successfully
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: <acc>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {acc: ?, xs: ?, p: ((Int -> Bool), [Int]), filter: (((Int -> Bool), [Int]) -> [Int]), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end in in
  LSP: Info: ALL errors:
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: && \/ $== == != <= >= < > ==. !=. <=. >=. <. >. + - * / ** +. -. *. /. **. ++ :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Backpack: end
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: ( |
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new_tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/" | "end" | "|"
root ::= new_tokens

Top 20 Logits:
     :22.3308
       :16.6121
      :16.5576
	:15.9148
    :15.6534
   :14.8027

:14.7766
         :14.4176
        :14.1926
           :14.0367
  :13.724
          :13.7225
                :13.1851
|:13.1122
            :12.9563
#:12.9476
 :12.4809
             :12.0167
              :11.5835
               :11.5447
:11.3628

================
# Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
     

LSP: Prelude: Recieved string: ### List ###

# Add an element to the front of a list. #
let cons: (Int, [Int]) -> [Int] = fun x, xs -> x::xs in

# Determine the length of a list. #
let length: [Int] -> Int =
  fun xs ->
    case xs
    | [] => 0
    | _::xs => 1 + length(xs) end in

# Extract the first element of a list. #
let hd: [Int] -> Option =
  fun l ->
    case l
    | [] => None
    | x::xs => Some(x) end in

# Extract the rest of the list. #
let tl: [Int] -> [Int] =
  fun l ->
    case l
    | [] => []
    | x::xs => xs end in

# Determine if a list is empty. #
let is_empty: [Int] -> Bool =
  fun xs ->
    case xs
    | [] => true
    | _::_ => false end in

# Return the element at the index. #
let nth: ([Int], Int) -> Option =
  fun xs, n ->
    case xs, n
    | x::_, 0 => Some(x)
    | _::xs, n => nth(xs, n - 1)
    | [], _ => None end in

# Reverse a List. #
let rev: [Int] -> [Int] =
fun l -> 
let go: ([Int], [Int]) -> [Int] =
  fun xs, acc -> 
    case xs 
    | [] => acc 
    | x::xs => go(xs, x::acc) end in
go(l, []) in

# Check if two lists are equal #
let equal: ([Int], [Int]) -> Bool =
    fun p, xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => x == y && equal(xs, ys)
    | _ => false end
in

# Initialize a list with a given length using an initializer function #
let init: (Int, Int -> Int) -> [Int] =
    fun len, f ->
        let go: (Int, [Int]) -> [Int] =
        fun idx, xs ->
            if idx < len 
            then go(idx + 1, xs @ [f(idx)])   
            else xs
        in
        go(0, [])
in

# Reduce a list from the left. #
let fold_left: ((Int, Int) -> Int, Int, [Int]) -> Int =
  fun f, acc, xs ->
    case xs 
    | [] => acc
    | hd::tl => fold_left(f, f(acc, hd), tl) end in

# Reduce a list from the right. #
let fold_right: ((Int, Int) -> Int, [Int], Int) -> Int =
  fun f, xs, acc ->
    case xs
    | [] => acc
    | hd::tl => f(hd, fold_right(f, tl, acc)) end in


666
LSP: Prelude: String parsed successfully
LSP: Prelude: Info map generated successfully
Debug: true, Constrain: Types
LSP: Init: Recieved string: # Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
     
LSP: Init: String parsed successfully
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: <acc>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {acc: ?, xs: ?, p: ((Int -> Bool), [Int]), filter: (((Int -> Bool), [Int]) -> [Int]), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end in in
  LSP: Info: ALL errors:
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: && \/ $== == != <= >= < > ==. !=. <=. >=. <. >. + - * / ** +. -. *. /. **. ++ :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Backpack: end
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: ( |
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new_tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/" | "end" | "|"
root ::= new_tokens

Top 20 Logits:
 |:22.1826
 #:14.6271
 end:13.6285
 (*:13.6052
 //:13.4448
 if:13.1978
 x:12.9585
 h:12.3809
 (:12.3042
 when:12.1554
 /*:12.1337
 ||:11.372
 else:11.2987
 ##:11.1041
 case:11.0815
 (**:11.0035
 --:10.9027
 #(:10.8314
 ((:10.6943
 @:10.5211
 |\:10.4811

================
# Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      |

LSP: Prelude: Recieved string: ### List ###

# Add an element to the front of a list. #
let cons: (Int, [Int]) -> [Int] = fun x, xs -> x::xs in

# Determine the length of a list. #
let length: [Int] -> Int =
  fun xs ->
    case xs
    | [] => 0
    | _::xs => 1 + length(xs) end in

# Extract the first element of a list. #
let hd: [Int] -> Option =
  fun l ->
    case l
    | [] => None
    | x::xs => Some(x) end in

# Extract the rest of the list. #
let tl: [Int] -> [Int] =
  fun l ->
    case l
    | [] => []
    | x::xs => xs end in

# Determine if a list is empty. #
let is_empty: [Int] -> Bool =
  fun xs ->
    case xs
    | [] => true
    | _::_ => false end in

# Return the element at the index. #
let nth: ([Int], Int) -> Option =
  fun xs, n ->
    case xs, n
    | x::_, 0 => Some(x)
    | _::xs, n => nth(xs, n - 1)
    | [], _ => None end in

# Reverse a List. #
let rev: [Int] -> [Int] =
fun l -> 
let go: ([Int], [Int]) -> [Int] =
  fun xs, acc -> 
    case xs 
    | [] => acc 
    | x::xs => go(xs, x::acc) end in
go(l, []) in

# Check if two lists are equal #
let equal: ([Int], [Int]) -> Bool =
    fun p, xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => x == y && equal(xs, ys)
    | _ => false end
in

# Initialize a list with a given length using an initializer function #
let init: (Int, Int -> Int) -> [Int] =
    fun len, f ->
        let go: (Int, [Int]) -> [Int] =
        fun idx, xs ->
            if idx < len 
            then go(idx + 1, xs @ [f(idx)])   
            else xs
        in
        go(0, [])
in

# Reduce a list from the left. #
let fold_left: ((Int, Int) -> Int, Int, [Int]) -> Int =
  fun f, acc, xs ->
    case xs 
    | [] => acc
    | hd::tl => fold_left(f, f(acc, hd), tl) end in

# Reduce a list from the right. #
let fold_right: ((Int, Int) -> Int, [Int], Int) -> Int =
  fun f, xs, acc ->
    case xs
    | [] => acc
    | hd::tl => f(hd, fold_right(f, tl, acc)) end in


666
LSP: Prelude: String parsed successfully
LSP: Prelude: Info map generated successfully
Debug: true, Constrain: Types
LSP: Init: Recieved string: # Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      |
LSP: Init: String parsed successfully
  LSP: Syntax: Leftward is Incomplete Tile: >| =><
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty pattern hole
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {acc: ?, xs: ?, p: ((Int -> Bool), [Int]), filter: (((Int -> Bool), [Int]) -> [Int]), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: => end in in
  LSP: Info: ALL errors:
  LSP: Info: BidiCtx: Cls: Empty pattern hole
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position Width S () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: ( () AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position S Width [ [] _ false true ~FLOATLIT~ ~INTLIT~ ~PATVAR~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new_tokens ::= whitespace | "(" | "()" | "AlignItems" | "BackgroundColor" | "Border" | "BorderRadius" | "BoxShadow" | "Color" | "Cursor" | "Display" | "FlexDirection" | "FontFamily" | "FontSize" | "FontStyle" | "Gap" | "Height" | "JustifyContent" | "Margin" | "Opacity" | "Outline" | "Overflow" | "Padding" | "Position" | "S" | "Width" | "[" | "[]" | "_" | "false" | "true" | floatlit | intlit | patvar | stringlit
root ::= new_tokens

Top 20 Logits:
 h:18.7491
 x:17.66
 y:14.5143
 (:13.9522
 head:13.8685
 a:13.6219
 [:13.4349
 e:12.6364
 _:12.4685
 f:12.3472
hd:12.1931
 p:12.107
 l:11.79
 v:11.7502
 z:11.73
 xs:11.7283
 ((:11.4887
 t:11.4218
 i:11.3907
 first:11.3037
 el:11.166

================
# Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | h

LSP: Prelude: Recieved string: ### List ###

# Add an element to the front of a list. #
let cons: (Int, [Int]) -> [Int] = fun x, xs -> x::xs in

# Determine the length of a list. #
let length: [Int] -> Int =
  fun xs ->
    case xs
    | [] => 0
    | _::xs => 1 + length(xs) end in

# Extract the first element of a list. #
let hd: [Int] -> Option =
  fun l ->
    case l
    | [] => None
    | x::xs => Some(x) end in

# Extract the rest of the list. #
let tl: [Int] -> [Int] =
  fun l ->
    case l
    | [] => []
    | x::xs => xs end in

# Determine if a list is empty. #
let is_empty: [Int] -> Bool =
  fun xs ->
    case xs
    | [] => true
    | _::_ => false end in

# Return the element at the index. #
let nth: ([Int], Int) -> Option =
  fun xs, n ->
    case xs, n
    | x::_, 0 => Some(x)
    | _::xs, n => nth(xs, n - 1)
    | [], _ => None end in

# Reverse a List. #
let rev: [Int] -> [Int] =
fun l -> 
let go: ([Int], [Int]) -> [Int] =
  fun xs, acc -> 
    case xs 
    | [] => acc 
    | x::xs => go(xs, x::acc) end in
go(l, []) in

# Check if two lists are equal #
let equal: ([Int], [Int]) -> Bool =
    fun p, xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => x == y && equal(xs, ys)
    | _ => false end
in

# Initialize a list with a given length using an initializer function #
let init: (Int, Int -> Int) -> [Int] =
    fun len, f ->
        let go: (Int, [Int]) -> [Int] =
        fun idx, xs ->
            if idx < len 
            then go(idx + 1, xs @ [f(idx)])   
            else xs
        in
        go(0, [])
in

# Reduce a list from the left. #
let fold_left: ((Int, Int) -> Int, Int, [Int]) -> Int =
  fun f, acc, xs ->
    case xs 
    | [] => acc
    | hd::tl => fold_left(f, f(acc, hd), tl) end in

# Reduce a list from the right. #
let fold_right: ((Int, Int) -> Int, [Int], Int) -> Int =
  fun f, xs, acc ->
    case xs
    | [] => acc
    | hd::tl => f(hd, fold_right(f, tl, acc)) end in


666
LSP: Prelude: String parsed successfully
LSP: Prelude: Info map generated successfully
Debug: true, Constrain: Types
LSP: Init: Recieved string: # Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | h
LSP: Init: String parsed successfully
  LSP: Syntax: Leftward is Complete Tile: <h>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable binding
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {h: ?, acc: ?, xs: ?, p: ((Int -> Bool), [Int]), filter: (((Int -> Bool), [Int]) -> [Int]), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: => end in in
  LSP: Info: ALL errors:
  LSP: Info: BidiCtx: Cls: Variable binding
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Syntax: Can insert left-concave or complete: h
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: =>
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: : ::
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: h
  LSP: Concave: Backpack: =>
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: : ::
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position Width S () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: ( () AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position S Width [ [] _ false true ~FLOATLIT~ ~INTLIT~ ~PATVAR~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= extend-patvar
new_tokens ::= whitespace | "(" | ":" | "::" | "=>"
root ::= completions | new_tokens

Top 20 Logits:
d:21.3508
:::17.8435
 :::14.9965
dx:12.7493
dr:12.0625
x:11.6779
1:10.8963
@:10.6607
dd:10.3611
dl:10.3186
_:10.1774
ds:10.1697
::10.1378
s:10.1123
,:10.0122
t:9.92191
ed:9.87421
hd:9.85135
l:9.68462
n:9.59589
dc:9.53264

================
# Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd

LSP: Prelude: Recieved string: ### List ###

# Add an element to the front of a list. #
let cons: (Int, [Int]) -> [Int] = fun x, xs -> x::xs in

# Determine the length of a list. #
let length: [Int] -> Int =
  fun xs ->
    case xs
    | [] => 0
    | _::xs => 1 + length(xs) end in

# Extract the first element of a list. #
let hd: [Int] -> Option =
  fun l ->
    case l
    | [] => None
    | x::xs => Some(x) end in

# Extract the rest of the list. #
let tl: [Int] -> [Int] =
  fun l ->
    case l
    | [] => []
    | x::xs => xs end in

# Determine if a list is empty. #
let is_empty: [Int] -> Bool =
  fun xs ->
    case xs
    | [] => true
    | _::_ => false end in

# Return the element at the index. #
let nth: ([Int], Int) -> Option =
  fun xs, n ->
    case xs, n
    | x::_, 0 => Some(x)
    | _::xs, n => nth(xs, n - 1)
    | [], _ => None end in

# Reverse a List. #
let rev: [Int] -> [Int] =
fun l -> 
let go: ([Int], [Int]) -> [Int] =
  fun xs, acc -> 
    case xs 
    | [] => acc 
    | x::xs => go(xs, x::acc) end in
go(l, []) in

# Check if two lists are equal #
let equal: ([Int], [Int]) -> Bool =
    fun p, xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => x == y && equal(xs, ys)
    | _ => false end
in

# Initialize a list with a given length using an initializer function #
let init: (Int, Int -> Int) -> [Int] =
    fun len, f ->
        let go: (Int, [Int]) -> [Int] =
        fun idx, xs ->
            if idx < len 
            then go(idx + 1, xs @ [f(idx)])   
            else xs
        in
        go(0, [])
in

# Reduce a list from the left. #
let fold_left: ((Int, Int) -> Int, Int, [Int]) -> Int =
  fun f, acc, xs ->
    case xs 
    | [] => acc
    | hd::tl => fold_left(f, f(acc, hd), tl) end in

# Reduce a list from the right. #
let fold_right: ((Int, Int) -> Int, [Int], Int) -> Int =
  fun f, xs, acc ->
    case xs
    | [] => acc
    | hd::tl => f(hd, fold_right(f, tl, acc)) end in


666
LSP: Prelude: String parsed successfully
LSP: Prelude: Info map generated successfully
Debug: true, Constrain: Types
LSP: Init: Recieved string: # Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd
LSP: Init: String parsed successfully
  LSP: Syntax: Leftward is Complete Tile: <hd>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable binding
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {hd: ?, acc: ?, xs: ?, p: ((Int -> Bool), [Int]), filter: (((Int -> Bool), [Int]) -> [Int]), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: => end in in
  LSP: Info: ALL errors:
  LSP: Info: BidiCtx: Cls: Variable binding
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Syntax: Can insert left-concave or complete: hd
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: =>
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: : ::
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: hd
  LSP: Concave: Backpack: =>
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: : ::
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position Width S () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: ( () AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position S Width [ [] _ false true ~FLOATLIT~ ~INTLIT~ ~PATVAR~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= extend-patvar
new_tokens ::= whitespace | "(" | ":" | "::" | "=>"
root ::= completions | new_tokens

Top 20 Logits:
:::21.9846
 :::17.9705
::12.9215
_:12.2906
@:12.2307
 +:12.212
1:12.1106
,:11.6665
 ::11.3532
|:10.7663
 &:10.5942
 as:10.4817
 @:10.2877
':10.0493
 ->:9.89055
 |:9.808
+:9.76638
X:9.62688
 =>:9.56494
 =:9.47231
0:9.40593

================
# Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::

LSP: Prelude: Recieved string: ### List ###

# Add an element to the front of a list. #
let cons: (Int, [Int]) -> [Int] = fun x, xs -> x::xs in

# Determine the length of a list. #
let length: [Int] -> Int =
  fun xs ->
    case xs
    | [] => 0
    | _::xs => 1 + length(xs) end in

# Extract the first element of a list. #
let hd: [Int] -> Option =
  fun l ->
    case l
    | [] => None
    | x::xs => Some(x) end in

# Extract the rest of the list. #
let tl: [Int] -> [Int] =
  fun l ->
    case l
    | [] => []
    | x::xs => xs end in

# Determine if a list is empty. #
let is_empty: [Int] -> Bool =
  fun xs ->
    case xs
    | [] => true
    | _::_ => false end in

# Return the element at the index. #
let nth: ([Int], Int) -> Option =
  fun xs, n ->
    case xs, n
    | x::_, 0 => Some(x)
    | _::xs, n => nth(xs, n - 1)
    | [], _ => None end in

# Reverse a List. #
let rev: [Int] -> [Int] =
fun l -> 
let go: ([Int], [Int]) -> [Int] =
  fun xs, acc -> 
    case xs 
    | [] => acc 
    | x::xs => go(xs, x::acc) end in
go(l, []) in

# Check if two lists are equal #
let equal: ([Int], [Int]) -> Bool =
    fun p, xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => x == y && equal(xs, ys)
    | _ => false end
in

# Initialize a list with a given length using an initializer function #
let init: (Int, Int -> Int) -> [Int] =
    fun len, f ->
        let go: (Int, [Int]) -> [Int] =
        fun idx, xs ->
            if idx < len 
            then go(idx + 1, xs @ [f(idx)])   
            else xs
        in
        go(0, [])
in

# Reduce a list from the left. #
let fold_left: ((Int, Int) -> Int, Int, [Int]) -> Int =
  fun f, acc, xs ->
    case xs 
    | [] => acc
    | hd::tl => fold_left(f, f(acc, hd), tl) end in

# Reduce a list from the right. #
let fold_right: ((Int, Int) -> Int, [Int], Int) -> Int =
  fun f, xs, acc ->
    case xs
    | [] => acc
    | hd::tl => f(hd, fold_right(f, tl, acc)) end in


666
LSP: Prelude: String parsed successfully
LSP: Prelude: Info map generated successfully
Debug: true, Constrain: Types
LSP: Init: Recieved string: # Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::
LSP: Init: String parsed successfully
  LSP: Syntax: Leftward is Complete Tile: >::<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty pattern hole
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: [?]
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {hd: ?, acc: ?, xs: ?, p: ((Int -> Bool), [Int]), filter: (((Int -> Bool), [Int]) -> [Int]), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: => end in in
  LSP: Info: ALL errors:
  LSP: Info: BidiCtx: Cls: Cons
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Info: Cls: Cons
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {hd: ?, acc: ?, xs: ?, p: ((Int -> Bool), [Int]), filter: (((Int -> Bool), [Int]) -> [Int]), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: => end in in
  LSP: Info: ALL errors:
  LSP: Info: BidiCtx: Cls: Cons
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Syntax: Can insert left-convex or complete: ::
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: [] _ ~PATVAR~ ( [
  LSP: Convex: Lookahead: ( () AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position S Width [ [] _ false true ~FLOATLIT~ ~INTLIT~ ~PATVAR~ ~STRINGLIT~
LSP: Generating Completions for prefix: ::
  LSP: Concave: Backpack: =>
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: : ::
  LSP: Concave: Postfix: 
  LSP: Convex: Backpack: 
  LSP: Convex: Base: AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position Width S () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: ( () AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position S Width [ [] _ false true ~FLOATLIT~ ~INTLIT~ ~PATVAR~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new_tokens ::= whitespace | "(" | "()" | "AlignItems" | "BackgroundColor" | "Border" | "BorderRadius" | "BoxShadow" | "Color" | "Cursor" | "Display" | "FlexDirection" | "FontFamily" | "FontSize" | "FontStyle" | "Gap" | "Height" | "JustifyContent" | "Margin" | "Opacity" | "Outline" | "Overflow" | "Padding" | "Position" | "S" | "Width" | "[" | "[]" | "_" | "false" | "true" | floatlit | intlit | patvar | stringlit
root ::= new_tokens

Top 20 Logits:
tl:18.9881
tail:13.3922
xs:13.3857
 t:12.8065
rest:11.85
[]:11.7435
_:11.5748
(:11.3527
ts:10.6286
t:10.2281
tt:9.82175
xl:9.67641
td:9.51747
x:9.48653
ys:9.45085
 xs:9.42644
[:9.32742
lst:9.15567
tp:9.15098
tn:9.0406
next:8.9427

================
# Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl

LSP: Prelude: Recieved string: ### List ###

# Add an element to the front of a list. #
let cons: (Int, [Int]) -> [Int] = fun x, xs -> x::xs in

# Determine the length of a list. #
let length: [Int] -> Int =
  fun xs ->
    case xs
    | [] => 0
    | _::xs => 1 + length(xs) end in

# Extract the first element of a list. #
let hd: [Int] -> Option =
  fun l ->
    case l
    | [] => None
    | x::xs => Some(x) end in

# Extract the rest of the list. #
let tl: [Int] -> [Int] =
  fun l ->
    case l
    | [] => []
    | x::xs => xs end in

# Determine if a list is empty. #
let is_empty: [Int] -> Bool =
  fun xs ->
    case xs
    | [] => true
    | _::_ => false end in

# Return the element at the index. #
let nth: ([Int], Int) -> Option =
  fun xs, n ->
    case xs, n
    | x::_, 0 => Some(x)
    | _::xs, n => nth(xs, n - 1)
    | [], _ => None end in

# Reverse a List. #
let rev: [Int] -> [Int] =
fun l -> 
let go: ([Int], [Int]) -> [Int] =
  fun xs, acc -> 
    case xs 
    | [] => acc 
    | x::xs => go(xs, x::acc) end in
go(l, []) in

# Check if two lists are equal #
let equal: ([Int], [Int]) -> Bool =
    fun p, xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => x == y && equal(xs, ys)
    | _ => false end
in

# Initialize a list with a given length using an initializer function #
let init: (Int, Int -> Int) -> [Int] =
    fun len, f ->
        let go: (Int, [Int]) -> [Int] =
        fun idx, xs ->
            if idx < len 
            then go(idx + 1, xs @ [f(idx)])   
            else xs
        in
        go(0, [])
in

# Reduce a list from the left. #
let fold_left: ((Int, Int) -> Int, Int, [Int]) -> Int =
  fun f, acc, xs ->
    case xs 
    | [] => acc
    | hd::tl => fold_left(f, f(acc, hd), tl) end in

# Reduce a list from the right. #
let fold_right: ((Int, Int) -> Int, [Int], Int) -> Int =
  fun f, xs, acc ->
    case xs
    | [] => acc
    | hd::tl => f(hd, fold_right(f, tl, acc)) end in


666
LSP: Prelude: String parsed successfully
LSP: Prelude: Info map generated successfully
Debug: true, Constrain: Types
LSP: Init: Recieved string: # Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl
LSP: Init: String parsed successfully
  LSP: Syntax: Leftward is Complete Tile: <tl>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable binding
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: [?]
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {tl: [?], hd: ?, acc: ?, xs: ?, p: ((Int -> Bool), [Int]), filter: (((Int -> Bool), [Int]) -> [Int]), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: => end in in
  LSP: Info: ALL errors:
  LSP: Info: BidiCtx: Cls: Cons
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Syntax: Can insert left-concave or complete: tl
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: =>
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: : ::
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: tl
  LSP: Concave: Backpack: =>
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: : ::
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: [] _ ~PATVAR~ ( [
  LSP: Convex: Lookahead: ( () AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position S Width [ [] _ false true ~FLOATLIT~ ~INTLIT~ ~PATVAR~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= extend-patvar
new_tokens ::= whitespace | "(" | ":" | "::" | "=>"
root ::= completions | new_tokens

Top 20 Logits:
 =>:17.9507
 when:17.3092
 ->:16.6887
 if:14.4821
 :12.9739

:12.9731
 as:12.6709
,:12.0974
=>:12.056
 =:11.6316
->:11.5122
 :::11.12
 where:10.2245
 :9.8099
 <-:9.78366
  :9.77591
 :=:9.73956
 |:9.70099
1:9.66138
_:9.61291
 ::9.54333

================
# Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl =>

LSP: Prelude: Recieved string: ### List ###

# Add an element to the front of a list. #
let cons: (Int, [Int]) -> [Int] = fun x, xs -> x::xs in

# Determine the length of a list. #
let length: [Int] -> Int =
  fun xs ->
    case xs
    | [] => 0
    | _::xs => 1 + length(xs) end in

# Extract the first element of a list. #
let hd: [Int] -> Option =
  fun l ->
    case l
    | [] => None
    | x::xs => Some(x) end in

# Extract the rest of the list. #
let tl: [Int] -> [Int] =
  fun l ->
    case l
    | [] => []
    | x::xs => xs end in

# Determine if a list is empty. #
let is_empty: [Int] -> Bool =
  fun xs ->
    case xs
    | [] => true
    | _::_ => false end in

# Return the element at the index. #
let nth: ([Int], Int) -> Option =
  fun xs, n ->
    case xs, n
    | x::_, 0 => Some(x)
    | _::xs, n => nth(xs, n - 1)
    | [], _ => None end in

# Reverse a List. #
let rev: [Int] -> [Int] =
fun l -> 
let go: ([Int], [Int]) -> [Int] =
  fun xs, acc -> 
    case xs 
    | [] => acc 
    | x::xs => go(xs, x::acc) end in
go(l, []) in

# Check if two lists are equal #
let equal: ([Int], [Int]) -> Bool =
    fun p, xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => x == y && equal(xs, ys)
    | _ => false end
in

# Initialize a list with a given length using an initializer function #
let init: (Int, Int -> Int) -> [Int] =
    fun len, f ->
        let go: (Int, [Int]) -> [Int] =
        fun idx, xs ->
            if idx < len 
            then go(idx + 1, xs @ [f(idx)])   
            else xs
        in
        go(0, [])
in

# Reduce a list from the left. #
let fold_left: ((Int, Int) -> Int, Int, [Int]) -> Int =
  fun f, acc, xs ->
    case xs 
    | [] => acc
    | hd::tl => fold_left(f, f(acc, hd), tl) end in

# Reduce a list from the right. #
let fold_right: ((Int, Int) -> Int, [Int], Int) -> Int =
  fun f, xs, acc ->
    case xs
    | [] => acc
    | hd::tl => f(hd, fold_right(f, tl, acc)) end in


666
LSP: Prelude: String parsed successfully
LSP: Prelude: Info map generated successfully
Debug: true, Constrain: Types
LSP: Init: Recieved string: # Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl =>
LSP: Init: String parsed successfully
  LSP: Syntax: Leftward is Complete Tile: >| =><
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {tl: [?], hd: ?, acc: ?, xs: ?, p: ((Int -> Bool), [Int]), filter: (((Int -> Bool), [Int]) -> [Int]), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end in in
  LSP: Info: ALL errors:
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 ?
  LSP: Convex: Target types: ?
  LSP: Convex: Backpack: 
  LSP: Convex: Base: tl hd acc xs p filter string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position Width S () [] _ false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: ! ( () - AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position S Width [ [] _ abs abs_float acc acos asin atan bool_of_string case  ceil cos epsilon_float exp false filter float_of_int float_of_string floor fun  hd if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod nan neg_infinity p pi sin sqrt string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan test  tl true type  xs ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new_tokens ::= whitespace | "!" | "(" | "()" | "-" | "AlignItems" | "BackgroundColor" | "Border" | "BorderRadius" | "BoxShadow" | "Color" | "Cursor" | "Display" | "FlexDirection" | "FontFamily" | "FontSize" | "FontStyle" | "Gap" | "Height" | "JustifyContent" | "Margin" | "Opacity" | "Outline" | "Overflow" | "Padding" | "Position" | "S" | "Width" | "[" | "[]" | "_" | "abs" | "abs_float" | "acc" | "acos" | "asin" | "atan" | "bool_of_string" | "case " | "ceil" | "cos" | "epsilon_float" | "exp" | "false" | "filter" | "float_of_int" | "float_of_string" | "floor" | "fun " | "hd" | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "nan" | "neg_infinity" | "p" | "pi" | "sin" | "sqrt" | "string_compare" | "string_concat" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "tl" | "true" | "type " | "xs" | floatlit | intlit | stringlit
root ::= new_tokens

Top 20 Logits:
 if:18.9015

:17.2433
 go:17.06
 :16.4465
 let:14.1724
 p:13.7449
 match:13.5817
 (:13.5554
  :13.4356
 case:12.1611
    :11.5077
if:11.4168
 begin:11.1749
 {:11.0772
 fun:11.0036
 If:10.816
 h:10.6581
   :10.496
 filter:10.4716
      :10.3225
 ((:10.1129

================
# Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if

LSP: Prelude: Recieved string: ### List ###

# Add an element to the front of a list. #
let cons: (Int, [Int]) -> [Int] = fun x, xs -> x::xs in

# Determine the length of a list. #
let length: [Int] -> Int =
  fun xs ->
    case xs
    | [] => 0
    | _::xs => 1 + length(xs) end in

# Extract the first element of a list. #
let hd: [Int] -> Option =
  fun l ->
    case l
    | [] => None
    | x::xs => Some(x) end in

# Extract the rest of the list. #
let tl: [Int] -> [Int] =
  fun l ->
    case l
    | [] => []
    | x::xs => xs end in

# Determine if a list is empty. #
let is_empty: [Int] -> Bool =
  fun xs ->
    case xs
    | [] => true
    | _::_ => false end in

# Return the element at the index. #
let nth: ([Int], Int) -> Option =
  fun xs, n ->
    case xs, n
    | x::_, 0 => Some(x)
    | _::xs, n => nth(xs, n - 1)
    | [], _ => None end in

# Reverse a List. #
let rev: [Int] -> [Int] =
fun l -> 
let go: ([Int], [Int]) -> [Int] =
  fun xs, acc -> 
    case xs 
    | [] => acc 
    | x::xs => go(xs, x::acc) end in
go(l, []) in

# Check if two lists are equal #
let equal: ([Int], [Int]) -> Bool =
    fun p, xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => x == y && equal(xs, ys)
    | _ => false end
in

# Initialize a list with a given length using an initializer function #
let init: (Int, Int -> Int) -> [Int] =
    fun len, f ->
        let go: (Int, [Int]) -> [Int] =
        fun idx, xs ->
            if idx < len 
            then go(idx + 1, xs @ [f(idx)])   
            else xs
        in
        go(0, [])
in

# Reduce a list from the left. #
let fold_left: ((Int, Int) -> Int, Int, [Int]) -> Int =
  fun f, acc, xs ->
    case xs 
    | [] => acc
    | hd::tl => fold_left(f, f(acc, hd), tl) end in

# Reduce a list from the right. #
let fold_right: ((Int, Int) -> Int, [Int], Int) -> Int =
  fun f, xs, acc ->
    case xs
    | [] => acc
    | hd::tl => f(hd, fold_right(f, tl, acc)) end in


666
LSP: Prelude: String parsed successfully
LSP: Prelude: Info map generated successfully
Debug: true, Constrain: Types
LSP: Init: Recieved string: # Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if
LSP: Init: String parsed successfully
  LSP: Syntax: Leftward is Complete Tile: <if>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Exp (FreeVariable "if"))
  LSP: Info: Typing Context: {tl: [?], hd: ?, acc: ?, xs: ?, p: ((Int -> Bool), [Int]), filter: (((Int -> Bool), [Int]) -> [Int]), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end in in
  LSP: Info: ALL errors:Error in term:
  if
Nature of error: Variable if is not bound
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Syntax: Can insert left-concave or complete: if
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: && \/ $== == != <= >= < > ==. !=. <=. >=. <. >. + - * / ** +. -. *. /. **. ++ :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Backpack: end
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: ( |
LSP: Generating Completions for prefix: if
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: && \/ $== == != <= >= < > ==. !=. <=. >=. <. >. + - * / ** +. -. *. /. **. ++ :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Backpack: end
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: ( |
  LSP: Convex: Ty paths:
 ?
  LSP: Convex: Target types: ?
  LSP: Convex: Backpack: 
  LSP: Convex: Base: tl hd acc xs p filter string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position Width S () [] _ false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: ! ( () - AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position S Width [ [] _ abs abs_float acc acos asin atan bool_of_string case  ceil cos epsilon_float exp false filter float_of_int float_of_string floor fun  hd if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod nan neg_infinity p pi sin sqrt string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan test  tl true type  xs ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= " "
new_tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/" | "end" | "|"
root ::= completions | new_tokens

Top 20 Logits:
 p:19.5094
 (:16.7778
(:15.1476
 !:13.3196
 not:13.3014
 ((:12.8012
 (!:12.5544
 h:12.0953
 is:12.0906
 go:11.9914
 true:11.6675
 @:11.6448
 :11.4356
_:11.0836
 (@:10.8281
 test:10.7666
 apply:10.7011
 xs:10.6613
 call:10.4464
  :10.4043
 (*:10.3787

================
# Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (

LSP: Prelude: Recieved string: ### List ###

# Add an element to the front of a list. #
let cons: (Int, [Int]) -> [Int] = fun x, xs -> x::xs in

# Determine the length of a list. #
let length: [Int] -> Int =
  fun xs ->
    case xs
    | [] => 0
    | _::xs => 1 + length(xs) end in

# Extract the first element of a list. #
let hd: [Int] -> Option =
  fun l ->
    case l
    | [] => None
    | x::xs => Some(x) end in

# Extract the rest of the list. #
let tl: [Int] -> [Int] =
  fun l ->
    case l
    | [] => []
    | x::xs => xs end in

# Determine if a list is empty. #
let is_empty: [Int] -> Bool =
  fun xs ->
    case xs
    | [] => true
    | _::_ => false end in

# Return the element at the index. #
let nth: ([Int], Int) -> Option =
  fun xs, n ->
    case xs, n
    | x::_, 0 => Some(x)
    | _::xs, n => nth(xs, n - 1)
    | [], _ => None end in

# Reverse a List. #
let rev: [Int] -> [Int] =
fun l -> 
let go: ([Int], [Int]) -> [Int] =
  fun xs, acc -> 
    case xs 
    | [] => acc 
    | x::xs => go(xs, x::acc) end in
go(l, []) in

# Check if two lists are equal #
let equal: ([Int], [Int]) -> Bool =
    fun p, xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => x == y && equal(xs, ys)
    | _ => false end
in

# Initialize a list with a given length using an initializer function #
let init: (Int, Int -> Int) -> [Int] =
    fun len, f ->
        let go: (Int, [Int]) -> [Int] =
        fun idx, xs ->
            if idx < len 
            then go(idx + 1, xs @ [f(idx)])   
            else xs
        in
        go(0, [])
in

# Reduce a list from the left. #
let fold_left: ((Int, Int) -> Int, Int, [Int]) -> Int =
  fun f, acc, xs ->
    case xs 
    | [] => acc
    | hd::tl => fold_left(f, f(acc, hd), tl) end in

# Reduce a list from the right. #
let fold_right: ((Int, Int) -> Int, [Int], Int) -> Int =
  fun f, xs, acc ->
    case xs
    | [] => acc
    | hd::tl => f(hd, fold_right(f, tl, acc)) end in


666
LSP: Prelude: String parsed successfully
LSP: Prelude: Info map generated successfully
Debug: true, Constrain: Types
LSP: Init: Recieved string: # Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (
LSP: Init: String parsed successfully
  LSP: Syntax: Leftward is Incomplete Tile: <( )<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Bool
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {tl: [?], hd: ?, acc: ?, xs: ?, p: ((Int -> Bool), [Int]), filter: (((Int -> Bool), [Int]) -> [Int]), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) then else end in in
  LSP: Info: ALL errors:
  LSP: Info: BidiCtx: Cls: Empty expression hole
  LSP: Info: BidiCtx: Expected type: Bool
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Info: Cls: Parenthesized expression
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Bool
  LSP: Info: Seft type: Bool
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {tl: [?], hd: ?, acc: ?, xs: ?, p: ((Int -> Bool), [Int]), filter: (((Int -> Bool), [Int]) -> [Int]), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) then else end in in
  LSP: Info: ALL errors:
  LSP: Info: BidiCtx: Cls: Parenthesized expression
  LSP: Info: BidiCtx: Expected type: Bool
  LSP: Info: Bidi Parent Cls: If expression
  LSP: Syntax: Can insert left-convex or complete: (
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 Bool
Int <= Bool
Float <= Bool
String <= Bool
  LSP: Convex: Target types: Int, Float, Bool, String
  LSP: Convex: Backpack: 
  LSP: Convex: Base: hd acc xs _ false true ! ( case  if  let  type 
  LSP: Convex: Lookahead: ! ( - _ abs abs_float acc acos asin atan bool_of_string case  ceil cos epsilon_float exp false float_of_int float_of_string floor hd if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod nan neg_infinity pi sin sqrt string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan true type  xs ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Generating Completions for prefix: (
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: && \/ $== == != <= >= < > ==. !=. <=. >=. <. >.
  LSP: Concave: Infix: Lookahead types: Int, Float, Bool, String
  LSP: Concave: Infix: Lookahead: != !=. $== && * ** **. *. + ++ +. - -. / /. < <. <= <=. == ==. > >. >= >=. \/
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. < <. <= <=. == ==. > >. >= >=. \/
  LSP: Concave: Postfix: 
  LSP: Convex: Ty paths:
 Bool
Int <= Bool
Float <= Bool
String <= Bool
  LSP: Convex: Target types: Int, Float, Bool, String
  LSP: Convex: Backpack: 
  LSP: Convex: Base: hd acc xs _ false true ! ( case  if  let  type 
  LSP: Convex: Lookahead: ! ( - _ abs abs_float acc acos asin atan bool_of_string case  ceil cos epsilon_float exp false float_of_int float_of_string floor hd if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod nan neg_infinity pi sin sqrt string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan true type  xs ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new_tokens ::= whitespace | "!" | "(" | "-" | "_" | "abs" | "abs_float" | "acc" | "acos" | "asin" | "atan" | "bool_of_string" | "case " | "ceil" | "cos" | "epsilon_float" | "exp" | "false" | "float_of_int" | "float_of_string" | "floor" | "hd" | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "nan" | "neg_infinity" | "pi" | "sin" | "sqrt" | "string_compare" | "string_concat" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "true" | "type " | "xs" | floatlit | intlit | stringlit
root ::= new_tokens

Top 20 Logits:
p:17.576
hd:13.2296
not:13.1283
 p:12.8146
true:11.4282
call:11.4122
go:11.3275
Bool:11.1632
acc:10.9562
is:10.8123
test:10.7776
apply:10.4348
x:10.1602
((:10.1301
xs:9.97014
fun:9.88893
eq:9.73588
#:9.67281
filter:9.66981
eval:9.65592
match:9.62988

================
# Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p

LSP: Prelude: Recieved string: ### List ###

# Add an element to the front of a list. #
let cons: (Int, [Int]) -> [Int] = fun x, xs -> x::xs in

# Determine the length of a list. #
let length: [Int] -> Int =
  fun xs ->
    case xs
    | [] => 0
    | _::xs => 1 + length(xs) end in

# Extract the first element of a list. #
let hd: [Int] -> Option =
  fun l ->
    case l
    | [] => None
    | x::xs => Some(x) end in

# Extract the rest of the list. #
let tl: [Int] -> [Int] =
  fun l ->
    case l
    | [] => []
    | x::xs => xs end in

# Determine if a list is empty. #
let is_empty: [Int] -> Bool =
  fun xs ->
    case xs
    | [] => true
    | _::_ => false end in

# Return the element at the index. #
let nth: ([Int], Int) -> Option =
  fun xs, n ->
    case xs, n
    | x::_, 0 => Some(x)
    | _::xs, n => nth(xs, n - 1)
    | [], _ => None end in

# Reverse a List. #
let rev: [Int] -> [Int] =
fun l -> 
let go: ([Int], [Int]) -> [Int] =
  fun xs, acc -> 
    case xs 
    | [] => acc 
    | x::xs => go(xs, x::acc) end in
go(l, []) in

# Check if two lists are equal #
let equal: ([Int], [Int]) -> Bool =
    fun p, xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => x == y && equal(xs, ys)
    | _ => false end
in

# Initialize a list with a given length using an initializer function #
let init: (Int, Int -> Int) -> [Int] =
    fun len, f ->
        let go: (Int, [Int]) -> [Int] =
        fun idx, xs ->
            if idx < len 
            then go(idx + 1, xs @ [f(idx)])   
            else xs
        in
        go(0, [])
in

# Reduce a list from the left. #
let fold_left: ((Int, Int) -> Int, Int, [Int]) -> Int =
  fun f, acc, xs ->
    case xs 
    | [] => acc
    | hd::tl => fold_left(f, f(acc, hd), tl) end in

# Reduce a list from the right. #
let fold_right: ((Int, Int) -> Int, [Int], Int) -> Int =
  fun f, xs, acc ->
    case xs
    | [] => acc
    | hd::tl => f(hd, fold_right(f, tl, acc)) end in


666
LSP: Prelude: String parsed successfully
LSP: Prelude: Info map generated successfully
Debug: true, Constrain: Types
LSP: Init: Recieved string: # Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p
LSP: Init: String parsed successfully
  LSP: Syntax: Leftward is Complete Tile: <p>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Bool
  LSP: Info: Seft type: ((Int -> Bool), [Int])
  LSP: Info: Error Status: (Exp
   (Common
      (Inconsistent
         Expectation {ana = Bool;
           syn = (Prod [(Arrow (Int, Bool)); (List Int)])})))
  LSP: Info: Typing Context: {tl: [?], hd: ?, acc: ?, xs: ?, p: ((Int -> Bool), [Int]), filter: (((Int -> Bool), [Int]) -> [Int]), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) then else end in in
  LSP: Info: ALL errors:Error in term:
  p
Nature of error: Expecting type Bool but got inconsistent type ((Int -> Bool), [Int])
  LSP: Info: BidiCtx: Cls: Variable reference
  LSP: Info: BidiCtx: Expected type: Bool
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Can insert left-concave or complete: p
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: ((Int -> Bool), [Int])
  LSP: Concave: Infix: Base: 
  LSP: Concave: Infix: Lookahead types: Int, Float, Bool, String
  LSP: Concave: Infix: Lookahead: 
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: 
LSP: Generating Completions for prefix: p
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: && \/ $== == != <= >= < > ==. !=. <=. >=. <. >.
  LSP: Concave: Infix: Lookahead types: Int, Float, Bool, String
  LSP: Concave: Infix: Lookahead: != !=. $== && * ** **. *. + ++ +. - -. / /. < <. <= <=. == ==. > >. >= >=. \/
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. < <. <= <=. == ==. > >. >= >=. \/
  LSP: Concave: Postfix: 
  LSP: Convex: Ty paths:
 Bool
Int <= Bool
Float <= Bool
String <= Bool
  LSP: Convex: Target types: Int, Float, Bool, String
  LSP: Convex: Backpack: 
  LSP: Convex: Base: hd acc xs _ false true ! ( case  if  let  type 
  LSP: Convex: Lookahead: ! ( - _ abs abs_float acc acos asin atan bool_of_string case  ceil cos epsilon_float exp false float_of_int float_of_string floor hd if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod nan neg_infinity pi sin sqrt string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan true type  xs ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "i"
new_tokens ::= whitespace | ")"
root ::= completions | new_tokens

Top 20 Logits:
(:20.3044
 h:16.1144
 (:14.6607
)(:13.8831
):13.4608
,:12.6697
((:12.001
::11.7264
.(:11.512
 ::11.2168
.:11.1021
 ==:10.5454
 x:10.4672
:(:10.4346
[:10.3477
()):10.1774
?(:10.1739
!(:10.1449
 t:10.1116
 @:10.0885
(@:10.0176

================
# Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p)

LSP: Prelude: Recieved string: ### List ###

# Add an element to the front of a list. #
let cons: (Int, [Int]) -> [Int] = fun x, xs -> x::xs in

# Determine the length of a list. #
let length: [Int] -> Int =
  fun xs ->
    case xs
    | [] => 0
    | _::xs => 1 + length(xs) end in

# Extract the first element of a list. #
let hd: [Int] -> Option =
  fun l ->
    case l
    | [] => None
    | x::xs => Some(x) end in

# Extract the rest of the list. #
let tl: [Int] -> [Int] =
  fun l ->
    case l
    | [] => []
    | x::xs => xs end in

# Determine if a list is empty. #
let is_empty: [Int] -> Bool =
  fun xs ->
    case xs
    | [] => true
    | _::_ => false end in

# Return the element at the index. #
let nth: ([Int], Int) -> Option =
  fun xs, n ->
    case xs, n
    | x::_, 0 => Some(x)
    | _::xs, n => nth(xs, n - 1)
    | [], _ => None end in

# Reverse a List. #
let rev: [Int] -> [Int] =
fun l -> 
let go: ([Int], [Int]) -> [Int] =
  fun xs, acc -> 
    case xs 
    | [] => acc 
    | x::xs => go(xs, x::acc) end in
go(l, []) in

# Check if two lists are equal #
let equal: ([Int], [Int]) -> Bool =
    fun p, xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => x == y && equal(xs, ys)
    | _ => false end
in

# Initialize a list with a given length using an initializer function #
let init: (Int, Int -> Int) -> [Int] =
    fun len, f ->
        let go: (Int, [Int]) -> [Int] =
        fun idx, xs ->
            if idx < len 
            then go(idx + 1, xs @ [f(idx)])   
            else xs
        in
        go(0, [])
in

# Reduce a list from the left. #
let fold_left: ((Int, Int) -> Int, Int, [Int]) -> Int =
  fun f, acc, xs ->
    case xs 
    | [] => acc
    | hd::tl => fold_left(f, f(acc, hd), tl) end in

# Reduce a list from the right. #
let fold_right: ((Int, Int) -> Int, [Int], Int) -> Int =
  fun f, xs, acc ->
    case xs
    | [] => acc
    | hd::tl => f(hd, fold_right(f, tl, acc)) end in


666
LSP: Prelude: String parsed successfully
LSP: Prelude: Info map generated successfully
Debug: true, Constrain: Types
LSP: Init: Recieved string: # Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p)
LSP: Init: String parsed successfully
  LSP: Syntax: Leftward is Complete Tile: <( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Parenthesized expression
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Bool
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {tl: [?], hd: ?, acc: ?, xs: ?, p: ((Int -> Bool), [Int]), filter: (((Int -> Bool), [Int]) -> [Int]), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: then else end in in
  LSP: Info: ALL errors:Error in term:
  p
Nature of error: Expecting type Bool but got inconsistent type ((Int -> Bool), [Int])
  LSP: Info: BidiCtx: Cls: Parenthesized expression
  LSP: Info: BidiCtx: Expected type: Bool
  LSP: Info: Bidi Parent Cls: If expression
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: && \/ $== == != <= >= < > ==. !=. <=. >=. <. >.
  LSP: Concave: Infix: Lookahead types: Int, Float, Bool, String
  LSP: Concave: Infix: Lookahead: != !=. $== && * ** **. *. + ++ +. - -. / /. < <. <= <=. == ==. > >. >= >=. \/
  LSP: Concave: Backpack: then
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. < <. <= <=. == ==. > >. >= >=. \/
  LSP: Concave: Postfix: (
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new_tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "-" | "-." | "/" | "/." | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "\\/" | "then"
root ::= new_tokens

Top 20 Logits:
 h:15.4094
 (:14.8072
 then:14.7261
hd:13.1853

:13.0137
 in:12.2499
 ==:12.2285
 {:12.0186
 ->:11.9978
 :11.6361
 @:11.5066
 ~:11.3205
 ?:11.1715
 =:11.0659
 ::10.7778
 =>:10.7528
 x:10.6588
 else:10.5571
 t:10.2646
 :::10.191
 &&:10.0978

================
# Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (

LSP: Prelude: Recieved string: ### List ###

# Add an element to the front of a list. #
let cons: (Int, [Int]) -> [Int] = fun x, xs -> x::xs in

# Determine the length of a list. #
let length: [Int] -> Int =
  fun xs ->
    case xs
    | [] => 0
    | _::xs => 1 + length(xs) end in

# Extract the first element of a list. #
let hd: [Int] -> Option =
  fun l ->
    case l
    | [] => None
    | x::xs => Some(x) end in

# Extract the rest of the list. #
let tl: [Int] -> [Int] =
  fun l ->
    case l
    | [] => []
    | x::xs => xs end in

# Determine if a list is empty. #
let is_empty: [Int] -> Bool =
  fun xs ->
    case xs
    | [] => true
    | _::_ => false end in

# Return the element at the index. #
let nth: ([Int], Int) -> Option =
  fun xs, n ->
    case xs, n
    | x::_, 0 => Some(x)
    | _::xs, n => nth(xs, n - 1)
    | [], _ => None end in

# Reverse a List. #
let rev: [Int] -> [Int] =
fun l -> 
let go: ([Int], [Int]) -> [Int] =
  fun xs, acc -> 
    case xs 
    | [] => acc 
    | x::xs => go(xs, x::acc) end in
go(l, []) in

# Check if two lists are equal #
let equal: ([Int], [Int]) -> Bool =
    fun p, xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => x == y && equal(xs, ys)
    | _ => false end
in

# Initialize a list with a given length using an initializer function #
let init: (Int, Int -> Int) -> [Int] =
    fun len, f ->
        let go: (Int, [Int]) -> [Int] =
        fun idx, xs ->
            if idx < len 
            then go(idx + 1, xs @ [f(idx)])   
            else xs
        in
        go(0, [])
in

# Reduce a list from the left. #
let fold_left: ((Int, Int) -> Int, Int, [Int]) -> Int =
  fun f, acc, xs ->
    case xs 
    | [] => acc
    | hd::tl => fold_left(f, f(acc, hd), tl) end in

# Reduce a list from the right. #
let fold_right: ((Int, Int) -> Int, [Int], Int) -> Int =
  fun f, xs, acc ->
    case xs
    | [] => acc
    | hd::tl => f(hd, fold_right(f, tl, acc)) end in


666
LSP: Prelude: String parsed successfully
LSP: Prelude: Info map generated successfully
Debug: true, Constrain: Types
LSP: Init: Recieved string: # Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (
LSP: Init: String parsed successfully
  LSP: Syntax: Leftward is Incomplete Tile: >( )<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {tl: [?], hd: ?, acc: ?, xs: ?, p: ((Int -> Bool), [Int]), filter: (((Int -> Bool), [Int]) -> [Int]), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) then else end in in
  LSP: Info: ALL errors:Error in term:
  p
Nature of error: type ((Int -> Bool), [Int]) is not consistent with arrow type
  LSP: Info: BidiCtx: Cls: Empty expression hole
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Application
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Bool
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {tl: [?], hd: ?, acc: ?, xs: ?, p: ((Int -> Bool), [Int]), filter: (((Int -> Bool), [Int]) -> [Int]), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) then else end in in
  LSP: Info: ALL errors:Error in term:
  p
Nature of error: type ((Int -> Bool), [Int]) is not consistent with arrow type
  LSP: Info: BidiCtx: Cls: Application
  LSP: Info: BidiCtx: Expected type: Bool
  LSP: Info: Bidi Parent Cls: If expression
  LSP: Syntax: Can insert left-convex or complete: (
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 ?
  LSP: Convex: Target types: ?
  LSP: Convex: Backpack: 
  LSP: Convex: Base: tl hd acc xs p filter string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position Width S () [] _ false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: ! ( () - AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position S Width [ [] _ abs abs_float acc acos asin atan bool_of_string case  ceil cos epsilon_float exp false filter float_of_int float_of_string floor fun  hd if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod nan neg_infinity p pi sin sqrt string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan test  tl true type  xs ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Generating Completions for prefix: (
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: && \/ $== == != <= >= < > ==. !=. <=. >=. <. >.
  LSP: Concave: Infix: Lookahead types: Int, Float, Bool, String
  LSP: Concave: Infix: Lookahead: != !=. $== && * ** **. *. + ++ +. - -. / /. < <. <= <=. == ==. > >. >= >=. \/
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. < <. <= <=. == ==. > >. >= >=. \/
  LSP: Concave: Postfix: (
  LSP: Convex: Ty paths:
 Bool
Int <= Bool
Float <= Bool
String <= Bool
  LSP: Convex: Target types: Int, Float, Bool, String
  LSP: Convex: Backpack: 
  LSP: Convex: Base: hd acc xs _ false true ! ( case  if  let  type 
  LSP: Convex: Lookahead: ! ( - _ abs abs_float acc acos asin atan bool_of_string case  ceil cos epsilon_float exp false float_of_int float_of_string floor hd if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod nan neg_infinity pi sin sqrt string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan true type  xs ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new_tokens ::= whitespace | "!" | "(" | "()" | "-" | "AlignItems" | "BackgroundColor" | "Border" | "BorderRadius" | "BoxShadow" | "Color" | "Cursor" | "Display" | "FlexDirection" | "FontFamily" | "FontSize" | "FontStyle" | "Gap" | "Height" | "JustifyContent" | "Margin" | "Opacity" | "Outline" | "Overflow" | "Padding" | "Position" | "S" | "Width" | "[" | "[]" | "_" | "abs" | "abs_float" | "acc" | "acos" | "asin" | "atan" | "bool_of_string" | "case " | "ceil" | "cos" | "epsilon_float" | "exp" | "false" | "filter" | "float_of_int" | "float_of_string" | "floor" | "fun " | "hd" | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "nan" | "neg_infinity" | "p" | "pi" | "sin" | "sqrt" | "string_compare" | "string_concat" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "tl" | "true" | "type " | "xs" | floatlit | intlit | stringlit
root ::= new_tokens

Top 20 Logits:
hd:20.7705
head:12.2919
go:12.1612
x:12.0168
 h:11.7792
acc:11.7189
fun:11.3472
h:11.0404
hs:10.2767
val:10.271
xs:10.1633
eq:10.125
fold:9.89512
hl:9.80306
f:9.73506
in:9.7209
eval:9.58933
==:9.39765
cons:9.38308
td:9.21702
Some:9.21352

================
# Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd

LSP: Prelude: Recieved string: ### List ###

# Add an element to the front of a list. #
let cons: (Int, [Int]) -> [Int] = fun x, xs -> x::xs in

# Determine the length of a list. #
let length: [Int] -> Int =
  fun xs ->
    case xs
    | [] => 0
    | _::xs => 1 + length(xs) end in

# Extract the first element of a list. #
let hd: [Int] -> Option =
  fun l ->
    case l
    | [] => None
    | x::xs => Some(x) end in

# Extract the rest of the list. #
let tl: [Int] -> [Int] =
  fun l ->
    case l
    | [] => []
    | x::xs => xs end in

# Determine if a list is empty. #
let is_empty: [Int] -> Bool =
  fun xs ->
    case xs
    | [] => true
    | _::_ => false end in

# Return the element at the index. #
let nth: ([Int], Int) -> Option =
  fun xs, n ->
    case xs, n
    | x::_, 0 => Some(x)
    | _::xs, n => nth(xs, n - 1)
    | [], _ => None end in

# Reverse a List. #
let rev: [Int] -> [Int] =
fun l -> 
let go: ([Int], [Int]) -> [Int] =
  fun xs, acc -> 
    case xs 
    | [] => acc 
    | x::xs => go(xs, x::acc) end in
go(l, []) in

# Check if two lists are equal #
let equal: ([Int], [Int]) -> Bool =
    fun p, xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => x == y && equal(xs, ys)
    | _ => false end
in

# Initialize a list with a given length using an initializer function #
let init: (Int, Int -> Int) -> [Int] =
    fun len, f ->
        let go: (Int, [Int]) -> [Int] =
        fun idx, xs ->
            if idx < len 
            then go(idx + 1, xs @ [f(idx)])   
            else xs
        in
        go(0, [])
in

# Reduce a list from the left. #
let fold_left: ((Int, Int) -> Int, Int, [Int]) -> Int =
  fun f, acc, xs ->
    case xs 
    | [] => acc
    | hd::tl => fold_left(f, f(acc, hd), tl) end in

# Reduce a list from the right. #
let fold_right: ((Int, Int) -> Int, [Int], Int) -> Int =
  fun f, xs, acc ->
    case xs
    | [] => acc
    | hd::tl => f(hd, fold_right(f, tl, acc)) end in


666
LSP: Prelude: String parsed successfully
LSP: Prelude: Info map generated successfully
Debug: true, Constrain: Types
LSP: Init: Recieved string: # Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd
LSP: Init: String parsed successfully
  LSP: Syntax: Leftward is Complete Tile: <hd>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {tl: [?], hd: ?, acc: ?, xs: ?, p: ((Int -> Bool), [Int]), filter: (((Int -> Bool), [Int]) -> [Int]), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) then else end in in
  LSP: Info: ALL errors:Error in term:
  p
Nature of error: type ((Int -> Bool), [Int]) is not consistent with arrow type
  LSP: Info: BidiCtx: Cls: Variable reference
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Can insert left-concave or complete: hd
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: && \/ $== == != <= >= < > ==. !=. <=. >=. <. >. + - * / ** +. -. *. /. **. ++ :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: hd
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: && \/ $== == != <= >= < > ==. !=. <=. >=. <. >. + - * / ** +. -. *. /. **. ++ :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Ty paths:
 ?
  LSP: Convex: Target types: ?
  LSP: Convex: Backpack: 
  LSP: Convex: Base: tl hd acc xs p filter string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position Width S () [] _ false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: ! ( () - AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position S Width [ [] _ abs abs_float acc acos asin atan bool_of_string case  ceil cos epsilon_float exp false filter float_of_int float_of_string floor fun  hd if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod nan neg_infinity p pi sin sqrt string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan test  tl true type  xs ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new_tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | ")" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/"
root ::= new_tokens

Top 20 Logits:
):20.3997
),:14.6487
);:14.1718
)(:13.6756
,:13.5231
){:13.3847
)::13.3265
)=:13.188
 ==:12.5113
 as:12.3076
 ):12.2781
=:12.1031
 =:11.8848
).:11.8038
)?:11.7463
)->:11.3772
)[:10.8722
.:10.7572
::10.6647
)):10.551
 then:10.1946

================
# Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd)

LSP: Prelude: Recieved string: ### List ###

# Add an element to the front of a list. #
let cons: (Int, [Int]) -> [Int] = fun x, xs -> x::xs in

# Determine the length of a list. #
let length: [Int] -> Int =
  fun xs ->
    case xs
    | [] => 0
    | _::xs => 1 + length(xs) end in

# Extract the first element of a list. #
let hd: [Int] -> Option =
  fun l ->
    case l
    | [] => None
    | x::xs => Some(x) end in

# Extract the rest of the list. #
let tl: [Int] -> [Int] =
  fun l ->
    case l
    | [] => []
    | x::xs => xs end in

# Determine if a list is empty. #
let is_empty: [Int] -> Bool =
  fun xs ->
    case xs
    | [] => true
    | _::_ => false end in

# Return the element at the index. #
let nth: ([Int], Int) -> Option =
  fun xs, n ->
    case xs, n
    | x::_, 0 => Some(x)
    | _::xs, n => nth(xs, n - 1)
    | [], _ => None end in

# Reverse a List. #
let rev: [Int] -> [Int] =
fun l -> 
let go: ([Int], [Int]) -> [Int] =
  fun xs, acc -> 
    case xs 
    | [] => acc 
    | x::xs => go(xs, x::acc) end in
go(l, []) in

# Check if two lists are equal #
let equal: ([Int], [Int]) -> Bool =
    fun p, xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => x == y && equal(xs, ys)
    | _ => false end
in

# Initialize a list with a given length using an initializer function #
let init: (Int, Int -> Int) -> [Int] =
    fun len, f ->
        let go: (Int, [Int]) -> [Int] =
        fun idx, xs ->
            if idx < len 
            then go(idx + 1, xs @ [f(idx)])   
            else xs
        in
        go(0, [])
in

# Reduce a list from the left. #
let fold_left: ((Int, Int) -> Int, Int, [Int]) -> Int =
  fun f, acc, xs ->
    case xs 
    | [] => acc
    | hd::tl => fold_left(f, f(acc, hd), tl) end in

# Reduce a list from the right. #
let fold_right: ((Int, Int) -> Int, [Int], Int) -> Int =
  fun f, xs, acc ->
    case xs
    | [] => acc
    | hd::tl => f(hd, fold_right(f, tl, acc)) end in


666
LSP: Prelude: String parsed successfully
LSP: Prelude: Info map generated successfully
Debug: true, Constrain: Types
LSP: Init: Recieved string: # Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd)
LSP: Init: String parsed successfully
  LSP: Syntax: Leftward is Complete Tile: >( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Bool
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {tl: [?], hd: ?, acc: ?, xs: ?, p: ((Int -> Bool), [Int]), filter: (((Int -> Bool), [Int]) -> [Int]), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: then else end in in
  LSP: Info: ALL errors:Error in term:
  p
Nature of error: type ((Int -> Bool), [Int]) is not consistent with arrow type
  LSP: Info: BidiCtx: Cls: Application
  LSP: Info: BidiCtx: Expected type: Bool
  LSP: Info: Bidi Parent Cls: If expression
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: && \/ $== == != <= >= < > ==. !=. <=. >=. <. >.
  LSP: Concave: Infix: Lookahead types: Int, Float, Bool, String
  LSP: Concave: Infix: Lookahead: != !=. $== && * ** **. *. + ++ +. - -. / /. < <. <= <=. == ==. > >. >= >=. \/
  LSP: Concave: Backpack: then
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. < <. <= <=. == ==. > >. >= >=. \/
  LSP: Concave: Postfix: (
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new_tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "-" | "-." | "/" | "/." | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "\\/" | "then"
root ::= new_tokens

Top 20 Logits:
 then:17.1167

:14.6662
 :14.3333
 (:13.788
 {:13.6363
 go:13.2986
 ==:12.9833
 =:11.8251
 h:10.8632
 ():10.7688
 ((:10.702
 fol:10.6724
 ?:10.4497
  :10.4438
 is:10.2977
 acc:10.2679
 [:10.1763
 Then:10.1568
 true:10.0984
 t:10.0293
 ->:9.97487

================
# Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then

LSP: Prelude: Recieved string: ### List ###

# Add an element to the front of a list. #
let cons: (Int, [Int]) -> [Int] = fun x, xs -> x::xs in

# Determine the length of a list. #
let length: [Int] -> Int =
  fun xs ->
    case xs
    | [] => 0
    | _::xs => 1 + length(xs) end in

# Extract the first element of a list. #
let hd: [Int] -> Option =
  fun l ->
    case l
    | [] => None
    | x::xs => Some(x) end in

# Extract the rest of the list. #
let tl: [Int] -> [Int] =
  fun l ->
    case l
    | [] => []
    | x::xs => xs end in

# Determine if a list is empty. #
let is_empty: [Int] -> Bool =
  fun xs ->
    case xs
    | [] => true
    | _::_ => false end in

# Return the element at the index. #
let nth: ([Int], Int) -> Option =
  fun xs, n ->
    case xs, n
    | x::_, 0 => Some(x)
    | _::xs, n => nth(xs, n - 1)
    | [], _ => None end in

# Reverse a List. #
let rev: [Int] -> [Int] =
fun l -> 
let go: ([Int], [Int]) -> [Int] =
  fun xs, acc -> 
    case xs 
    | [] => acc 
    | x::xs => go(xs, x::acc) end in
go(l, []) in

# Check if two lists are equal #
let equal: ([Int], [Int]) -> Bool =
    fun p, xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => x == y && equal(xs, ys)
    | _ => false end
in

# Initialize a list with a given length using an initializer function #
let init: (Int, Int -> Int) -> [Int] =
    fun len, f ->
        let go: (Int, [Int]) -> [Int] =
        fun idx, xs ->
            if idx < len 
            then go(idx + 1, xs @ [f(idx)])   
            else xs
        in
        go(0, [])
in

# Reduce a list from the left. #
let fold_left: ((Int, Int) -> Int, Int, [Int]) -> Int =
  fun f, acc, xs ->
    case xs 
    | [] => acc
    | hd::tl => fold_left(f, f(acc, hd), tl) end in

# Reduce a list from the right. #
let fold_right: ((Int, Int) -> Int, [Int], Int) -> Int =
  fun f, xs, acc ->
    case xs
    | [] => acc
    | hd::tl => f(hd, fold_right(f, tl, acc)) end in


666
LSP: Prelude: String parsed successfully
LSP: Prelude: Info map generated successfully
Debug: true, Constrain: Types
LSP: Init: Recieved string: # Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then
LSP: Init: String parsed successfully
  LSP: Syntax: Leftward is Incomplete Tile: <if then else<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {tl: [?], hd: ?, acc: ?, xs: ?, p: ((Int -> Bool), [Int]), filter: (((Int -> Bool), [Int]) -> [Int]), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: else end in in
  LSP: Info: ALL errors:Error in term:
  p
Nature of error: type ((Int -> Bool), [Int]) is not consistent with arrow type
  LSP: Info: BidiCtx: Cls: Empty expression hole
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: If expression
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 ?
  LSP: Convex: Target types: ?
  LSP: Convex: Backpack: 
  LSP: Convex: Base: tl hd acc xs p filter string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position Width S () [] _ false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: ! ( () - AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position S Width [ [] _ abs abs_float acc acos asin atan bool_of_string case  ceil cos epsilon_float exp false filter float_of_int float_of_string floor fun  hd if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod nan neg_infinity p pi sin sqrt string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan test  tl true type  xs ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new_tokens ::= whitespace | "!" | "(" | "()" | "-" | "AlignItems" | "BackgroundColor" | "Border" | "BorderRadius" | "BoxShadow" | "Color" | "Cursor" | "Display" | "FlexDirection" | "FontFamily" | "FontSize" | "FontStyle" | "Gap" | "Height" | "JustifyContent" | "Margin" | "Opacity" | "Outline" | "Overflow" | "Padding" | "Position" | "S" | "Width" | "[" | "[]" | "_" | "abs" | "abs_float" | "acc" | "acos" | "asin" | "atan" | "bool_of_string" | "case " | "ceil" | "cos" | "epsilon_float" | "exp" | "false" | "filter" | "float_of_int" | "float_of_string" | "floor" | "fun " | "hd" | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "nan" | "neg_infinity" | "p" | "pi" | "sin" | "sqrt" | "string_compare" | "string_concat" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "tl" | "true" | "type " | "xs" | floatlit | intlit | stringlit
root ::= new_tokens

Top 20 Logits:
 go:18.4483
 (:15.5515

:13.2868
 :13.0321
 t:11.6831
 acc:11.4182
 h:11.3783
 ((:11.2615
 [:11.2512
 xs:10.8675
 {:10.8132
(:10.7046
 filter:10.6034
 let:10.1858
 fol:10.1014
 ([:9.84712
 @:9.23154
 ():9.20621
 cons:9.07715
 [(:9.06469
  :9.05502

================
# Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (

LSP: Prelude: Recieved string: ### List ###

# Add an element to the front of a list. #
let cons: (Int, [Int]) -> [Int] = fun x, xs -> x::xs in

# Determine the length of a list. #
let length: [Int] -> Int =
  fun xs ->
    case xs
    | [] => 0
    | _::xs => 1 + length(xs) end in

# Extract the first element of a list. #
let hd: [Int] -> Option =
  fun l ->
    case l
    | [] => None
    | x::xs => Some(x) end in

# Extract the rest of the list. #
let tl: [Int] -> [Int] =
  fun l ->
    case l
    | [] => []
    | x::xs => xs end in

# Determine if a list is empty. #
let is_empty: [Int] -> Bool =
  fun xs ->
    case xs
    | [] => true
    | _::_ => false end in

# Return the element at the index. #
let nth: ([Int], Int) -> Option =
  fun xs, n ->
    case xs, n
    | x::_, 0 => Some(x)
    | _::xs, n => nth(xs, n - 1)
    | [], _ => None end in

# Reverse a List. #
let rev: [Int] -> [Int] =
fun l -> 
let go: ([Int], [Int]) -> [Int] =
  fun xs, acc -> 
    case xs 
    | [] => acc 
    | x::xs => go(xs, x::acc) end in
go(l, []) in

# Check if two lists are equal #
let equal: ([Int], [Int]) -> Bool =
    fun p, xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => x == y && equal(xs, ys)
    | _ => false end
in

# Initialize a list with a given length using an initializer function #
let init: (Int, Int -> Int) -> [Int] =
    fun len, f ->
        let go: (Int, [Int]) -> [Int] =
        fun idx, xs ->
            if idx < len 
            then go(idx + 1, xs @ [f(idx)])   
            else xs
        in
        go(0, [])
in

# Reduce a list from the left. #
let fold_left: ((Int, Int) -> Int, Int, [Int]) -> Int =
  fun f, acc, xs ->
    case xs 
    | [] => acc
    | hd::tl => fold_left(f, f(acc, hd), tl) end in

# Reduce a list from the right. #
let fold_right: ((Int, Int) -> Int, [Int], Int) -> Int =
  fun f, xs, acc ->
    case xs
    | [] => acc
    | hd::tl => f(hd, fold_right(f, tl, acc)) end in


666
LSP: Prelude: String parsed successfully
LSP: Prelude: Info map generated successfully
Debug: true, Constrain: Types
LSP: Init: Recieved string: # Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (
LSP: Init: String parsed successfully
  LSP: Syntax: Leftward is Incomplete Tile: <( )<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {tl: [?], hd: ?, acc: ?, xs: ?, p: ((Int -> Bool), [Int]), filter: (((Int -> Bool), [Int]) -> [Int]), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) else end in in
  LSP: Info: ALL errors:Error in term:
  p
Nature of error: type ((Int -> Bool), [Int]) is not consistent with arrow type
  LSP: Info: BidiCtx: Cls: Empty expression hole
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Info: Cls: Parenthesized expression
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {tl: [?], hd: ?, acc: ?, xs: ?, p: ((Int -> Bool), [Int]), filter: (((Int -> Bool), [Int]) -> [Int]), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) else end in in
  LSP: Info: ALL errors:Error in term:
  p
Nature of error: type ((Int -> Bool), [Int]) is not consistent with arrow type
  LSP: Info: BidiCtx: Cls: Parenthesized expression
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: If expression
  LSP: Syntax: Can insert left-convex or complete: (
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 ?
  LSP: Convex: Target types: ?
  LSP: Convex: Backpack: 
  LSP: Convex: Base: tl hd acc xs p filter string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position Width S () [] _ false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: ! ( () - AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position S Width [ [] _ abs abs_float acc acos asin atan bool_of_string case  ceil cos epsilon_float exp false filter float_of_int float_of_string floor fun  hd if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod nan neg_infinity p pi sin sqrt string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan test  tl true type  xs ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Generating Completions for prefix: (
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: && \/ $== == != <= >= < > ==. !=. <=. >=. <. >. + - * / ** +. -. *. /. **. ++ :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Ty paths:
 ?
  LSP: Convex: Target types: ?
  LSP: Convex: Backpack: 
  LSP: Convex: Base: tl hd acc xs p filter string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position Width S () [] _ false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: ! ( () - AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position S Width [ [] _ abs abs_float acc acos asin atan bool_of_string case  ceil cos epsilon_float exp false filter float_of_int float_of_string floor fun  hd if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod nan neg_infinity p pi sin sqrt string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan test  tl true type  xs ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= ")"
new_tokens ::= whitespace | "!" | "(" | "()" | "-" | "AlignItems" | "BackgroundColor" | "Border" | "BorderRadius" | "BoxShadow" | "Color" | "Cursor" | "Display" | "FlexDirection" | "FontFamily" | "FontSize" | "FontStyle" | "Gap" | "Height" | "JustifyContent" | "Margin" | "Opacity" | "Outline" | "Overflow" | "Padding" | "Position" | "S" | "Width" | "[" | "[]" | "_" | "abs" | "abs_float" | "acc" | "acos" | "asin" | "atan" | "bool_of_string" | "case " | "ceil" | "cos" | "epsilon_float" | "exp" | "false" | "filter" | "float_of_int" | "float_of_string" | "floor" | "fun " | "hd" | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "nan" | "neg_infinity" | "p" | "pi" | "sin" | "sqrt" | "string_compare" | "string_concat" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "tl" | "true" | "type " | "xs" | floatlit | intlit | stringlit
root ::= completions | new_tokens

Top 20 Logits:
go:16.8753
acc:13.1526
filter:12.6142
 go:12.3791
cons:11.8552

:11.7803
xs:11.5166
hd:11.3239
x:10.7468
tl:10.6865
let:10.5395
fun:9.79257
p:9.74205
rev:9.67426
h:9.67394
fold:9.59126
t:9.44407
push:9.10352
List:9.07849
reverse:9.06047
((:8.96351

================
# Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc

LSP: Prelude: Recieved string: ### List ###

# Add an element to the front of a list. #
let cons: (Int, [Int]) -> [Int] = fun x, xs -> x::xs in

# Determine the length of a list. #
let length: [Int] -> Int =
  fun xs ->
    case xs
    | [] => 0
    | _::xs => 1 + length(xs) end in

# Extract the first element of a list. #
let hd: [Int] -> Option =
  fun l ->
    case l
    | [] => None
    | x::xs => Some(x) end in

# Extract the rest of the list. #
let tl: [Int] -> [Int] =
  fun l ->
    case l
    | [] => []
    | x::xs => xs end in

# Determine if a list is empty. #
let is_empty: [Int] -> Bool =
  fun xs ->
    case xs
    | [] => true
    | _::_ => false end in

# Return the element at the index. #
let nth: ([Int], Int) -> Option =
  fun xs, n ->
    case xs, n
    | x::_, 0 => Some(x)
    | _::xs, n => nth(xs, n - 1)
    | [], _ => None end in

# Reverse a List. #
let rev: [Int] -> [Int] =
fun l -> 
let go: ([Int], [Int]) -> [Int] =
  fun xs, acc -> 
    case xs 
    | [] => acc 
    | x::xs => go(xs, x::acc) end in
go(l, []) in

# Check if two lists are equal #
let equal: ([Int], [Int]) -> Bool =
    fun p, xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => x == y && equal(xs, ys)
    | _ => false end
in

# Initialize a list with a given length using an initializer function #
let init: (Int, Int -> Int) -> [Int] =
    fun len, f ->
        let go: (Int, [Int]) -> [Int] =
        fun idx, xs ->
            if idx < len 
            then go(idx + 1, xs @ [f(idx)])   
            else xs
        in
        go(0, [])
in

# Reduce a list from the left. #
let fold_left: ((Int, Int) -> Int, Int, [Int]) -> Int =
  fun f, acc, xs ->
    case xs 
    | [] => acc
    | hd::tl => fold_left(f, f(acc, hd), tl) end in

# Reduce a list from the right. #
let fold_right: ((Int, Int) -> Int, [Int], Int) -> Int =
  fun f, xs, acc ->
    case xs
    | [] => acc
    | hd::tl => f(hd, fold_right(f, tl, acc)) end in


666
LSP: Prelude: String parsed successfully
LSP: Prelude: Info map generated successfully
Debug: true, Constrain: Types
LSP: Init: Recieved string: # Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc
LSP: Init: String parsed successfully
  LSP: Syntax: Leftward is Complete Tile: <acc>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {tl: [?], hd: ?, acc: ?, xs: ?, p: ((Int -> Bool), [Int]), filter: (((Int -> Bool), [Int]) -> [Int]), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) else end in in
  LSP: Info: ALL errors:Error in term:
  p
Nature of error: type ((Int -> Bool), [Int]) is not consistent with arrow type
  LSP: Info: BidiCtx: Cls: Variable reference
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Can insert left-concave or complete: acc
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: && \/ $== == != <= >= < > ==. !=. <=. >=. <. >. + - * / ** +. -. *. /. **. ++ :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: acc
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: && \/ $== == != <= >= < > ==. !=. <=. >=. <. >. + - * / ** +. -. *. /. **. ++ :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Ty paths:
 ?
  LSP: Convex: Target types: ?
  LSP: Convex: Backpack: 
  LSP: Convex: Base: tl hd acc xs p filter string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position Width S () [] _ false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: ! ( () - AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position S Width [ [] _ abs abs_float acc acos asin atan bool_of_string case  ceil cos epsilon_float exp false filter float_of_int float_of_string floor fun  hd if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod nan neg_infinity p pi sin sqrt string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan test  tl true type  xs ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new_tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | ")" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/"
root ::= new_tokens

Top 20 Logits:
 @:17.4026
@:14.4836
):12.9892
 +:11.9222
 ++:11.528
.:11.1741
 :::11.0802
 =:11.0372
:::10.9313
 <>:10.6617
 ::10.5873
 :=:10.2906
::10.2443
 |:9.98237
 &:9.80299
,:9.76478
 <:9.52157
 ^:9.42692
@@:9.01478
)(:8.83591
 .:8.81128

================
# Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @

LSP: Prelude: Recieved string: ### List ###

# Add an element to the front of a list. #
let cons: (Int, [Int]) -> [Int] = fun x, xs -> x::xs in

# Determine the length of a list. #
let length: [Int] -> Int =
  fun xs ->
    case xs
    | [] => 0
    | _::xs => 1 + length(xs) end in

# Extract the first element of a list. #
let hd: [Int] -> Option =
  fun l ->
    case l
    | [] => None
    | x::xs => Some(x) end in

# Extract the rest of the list. #
let tl: [Int] -> [Int] =
  fun l ->
    case l
    | [] => []
    | x::xs => xs end in

# Determine if a list is empty. #
let is_empty: [Int] -> Bool =
  fun xs ->
    case xs
    | [] => true
    | _::_ => false end in

# Return the element at the index. #
let nth: ([Int], Int) -> Option =
  fun xs, n ->
    case xs, n
    | x::_, 0 => Some(x)
    | _::xs, n => nth(xs, n - 1)
    | [], _ => None end in

# Reverse a List. #
let rev: [Int] -> [Int] =
fun l -> 
let go: ([Int], [Int]) -> [Int] =
  fun xs, acc -> 
    case xs 
    | [] => acc 
    | x::xs => go(xs, x::acc) end in
go(l, []) in

# Check if two lists are equal #
let equal: ([Int], [Int]) -> Bool =
    fun p, xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => x == y && equal(xs, ys)
    | _ => false end
in

# Initialize a list with a given length using an initializer function #
let init: (Int, Int -> Int) -> [Int] =
    fun len, f ->
        let go: (Int, [Int]) -> [Int] =
        fun idx, xs ->
            if idx < len 
            then go(idx + 1, xs @ [f(idx)])   
            else xs
        in
        go(0, [])
in

# Reduce a list from the left. #
let fold_left: ((Int, Int) -> Int, Int, [Int]) -> Int =
  fun f, acc, xs ->
    case xs 
    | [] => acc
    | hd::tl => fold_left(f, f(acc, hd), tl) end in

# Reduce a list from the right. #
let fold_right: ((Int, Int) -> Int, [Int], Int) -> Int =
  fun f, xs, acc ->
    case xs
    | [] => acc
    | hd::tl => f(hd, fold_right(f, tl, acc)) end in


666
LSP: Prelude: String parsed successfully
LSP: Prelude: Info map generated successfully
Debug: true, Constrain: Types
LSP: Init: Recieved string: # Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @
LSP: Init: String parsed successfully
  LSP: Syntax: Leftward is Complete Tile: >@<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [?]
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {tl: [?], hd: ?, acc: ?, xs: ?, p: ((Int -> Bool), [Int]), filter: (((Int -> Bool), [Int]) -> [Int]), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) else end in in
  LSP: Info: ALL errors:Error in term:
  p
Nature of error: type ((Int -> Bool), [Int]) is not consistent with arrow type
  LSP: Info: BidiCtx: Cls: List Concatenation
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Info: Cls: List Concatenation
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {tl: [?], hd: ?, acc: ?, xs: ?, p: ((Int -> Bool), [Int]), filter: (((Int -> Bool), [Int]) -> [Int]), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) else end in in
  LSP: Info: ALL errors:Error in term:
  p
Nature of error: type ((Int -> Bool), [Int]) is not consistent with arrow type
  LSP: Info: BidiCtx: Cls: List Concatenation
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Can insert left-convex or complete: @
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 [?]
? <= [?]
? <= [?]
  LSP: Convex: Target types: ?, [?]
  LSP: Convex: Backpack: 
  LSP: Convex: Base: tl hd acc xs [] _ ( [ case  if  let  type 
  LSP: Convex: Lookahead: ! ( () - AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position S Width [ [] _ abs abs_float acc acos asin atan bool_of_string case  ceil cos epsilon_float exp false filter float_of_int float_of_string floor fun  hd if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod nan neg_infinity p pi sin sqrt string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan test  tl true type  xs ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Generating Completions for prefix: @
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: && \/ $== == != <= >= < > ==. !=. <=. >=. <. >. + - * / ** +. -. *. /. **. ++ :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: 
  LSP: Convex: Ty paths:
 ?
  LSP: Convex: Target types: ?
  LSP: Convex: Backpack: 
  LSP: Convex: Base: tl hd acc xs p filter string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position Width S () [] _ false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: ! ( () - AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position S Width [ [] _ abs abs_float acc acos asin atan bool_of_string case  ceil cos epsilon_float exp false filter float_of_int float_of_string floor fun  hd if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod nan neg_infinity p pi sin sqrt string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan test  tl true type  xs ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new_tokens ::= whitespace | "!" | "(" | "()" | "-" | "AlignItems" | "BackgroundColor" | "Border" | "BorderRadius" | "BoxShadow" | "Color" | "Cursor" | "Display" | "FlexDirection" | "FontFamily" | "FontSize" | "FontStyle" | "Gap" | "Height" | "JustifyContent" | "Margin" | "Opacity" | "Outline" | "Overflow" | "Padding" | "Position" | "S" | "Width" | "[" | "[]" | "_" | "abs" | "abs_float" | "acc" | "acos" | "asin" | "atan" | "bool_of_string" | "case " | "ceil" | "cos" | "epsilon_float" | "exp" | "false" | "filter" | "float_of_int" | "float_of_string" | "floor" | "fun " | "hd" | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "nan" | "neg_infinity" | "p" | "pi" | "sin" | "sqrt" | "string_compare" | "string_concat" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "tl" | "true" | "type " | "xs" | floatlit | intlit | stringlit
root ::= new_tokens

Top 20 Logits:
 [:18.2295
 [(:14.674
 go:14.3458
 (:14.0234
 h:13.8907
[:13.8889
 t:13.7832
 ([:13.7542
 xs:12.5691
 [[:12.2484
 cons:11.4973
 :11.3413
 ((:11.168
 p:11.1611
@:11.0741
 @:10.6505
 x:10.4702
:10.4585
 <:10.3456
 {:10.3363
 List:10.3148

================
# Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [

LSP: Prelude: Recieved string: ### List ###

# Add an element to the front of a list. #
let cons: (Int, [Int]) -> [Int] = fun x, xs -> x::xs in

# Determine the length of a list. #
let length: [Int] -> Int =
  fun xs ->
    case xs
    | [] => 0
    | _::xs => 1 + length(xs) end in

# Extract the first element of a list. #
let hd: [Int] -> Option =
  fun l ->
    case l
    | [] => None
    | x::xs => Some(x) end in

# Extract the rest of the list. #
let tl: [Int] -> [Int] =
  fun l ->
    case l
    | [] => []
    | x::xs => xs end in

# Determine if a list is empty. #
let is_empty: [Int] -> Bool =
  fun xs ->
    case xs
    | [] => true
    | _::_ => false end in

# Return the element at the index. #
let nth: ([Int], Int) -> Option =
  fun xs, n ->
    case xs, n
    | x::_, 0 => Some(x)
    | _::xs, n => nth(xs, n - 1)
    | [], _ => None end in

# Reverse a List. #
let rev: [Int] -> [Int] =
fun l -> 
let go: ([Int], [Int]) -> [Int] =
  fun xs, acc -> 
    case xs 
    | [] => acc 
    | x::xs => go(xs, x::acc) end in
go(l, []) in

# Check if two lists are equal #
let equal: ([Int], [Int]) -> Bool =
    fun p, xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => x == y && equal(xs, ys)
    | _ => false end
in

# Initialize a list with a given length using an initializer function #
let init: (Int, Int -> Int) -> [Int] =
    fun len, f ->
        let go: (Int, [Int]) -> [Int] =
        fun idx, xs ->
            if idx < len 
            then go(idx + 1, xs @ [f(idx)])   
            else xs
        in
        go(0, [])
in

# Reduce a list from the left. #
let fold_left: ((Int, Int) -> Int, Int, [Int]) -> Int =
  fun f, acc, xs ->
    case xs 
    | [] => acc
    | hd::tl => fold_left(f, f(acc, hd), tl) end in

# Reduce a list from the right. #
let fold_right: ((Int, Int) -> Int, [Int], Int) -> Int =
  fun f, xs, acc ->
    case xs
    | [] => acc
    | hd::tl => f(hd, fold_right(f, tl, acc)) end in


666
LSP: Prelude: String parsed successfully
LSP: Prelude: Info map generated successfully
Debug: true, Constrain: Types
LSP: Init: Recieved string: # Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [
LSP: Init: String parsed successfully
  LSP: Syntax: Leftward is Incomplete Tile: <[ ]<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {tl: [?], hd: ?, acc: ?, xs: ?, p: ((Int -> Bool), [Int]), filter: (((Int -> Bool), [Int]) -> [Int]), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ] ) else end in in
  LSP: Info: ALL errors:Error in term:
  p
Nature of error: type ((Int -> Bool), [Int]) is not consistent with arrow type
  LSP: Info: BidiCtx: Cls: Empty expression hole
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: List literal
  LSP: Info: Cls: List literal
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [?]
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {tl: [?], hd: ?, acc: ?, xs: ?, p: ((Int -> Bool), [Int]), filter: (((Int -> Bool), [Int]) -> [Int]), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ] ) else end in in
  LSP: Info: ALL errors:Error in term:
  p
Nature of error: type ((Int -> Bool), [Int]) is not consistent with arrow type
  LSP: Info: BidiCtx: Cls: List Concatenation
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Can insert left-convex or complete: [
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 ?
  LSP: Convex: Target types: ?
  LSP: Convex: Backpack: 
  LSP: Convex: Base: tl hd acc xs p filter string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position Width S () [] _ false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: ! ( () - AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position S Width [ [] _ abs abs_float acc acos asin atan bool_of_string case  ceil cos epsilon_float exp false filter float_of_int float_of_string floor fun  hd if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod nan neg_infinity p pi sin sqrt string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan test  tl true type  xs ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Generating Completions for prefix: [
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Backpack: ]
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: 
  LSP: Convex: Ty paths:
 [?]
? <= [?]
? <= [?]
  LSP: Convex: Target types: ?, [?]
  LSP: Convex: Backpack: 
  LSP: Convex: Base: tl hd acc xs [] _ ( [ case  if  let  type 
  LSP: Convex: Lookahead: ! ( () - AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position S Width [ [] _ abs abs_float acc acos asin atan bool_of_string case  ceil cos epsilon_float exp false filter float_of_int float_of_string floor fun  hd if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod nan neg_infinity p pi sin sqrt string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan test  tl true type  xs ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "]"
new_tokens ::= whitespace | "!" | "(" | "()" | "-" | "AlignItems" | "BackgroundColor" | "Border" | "BorderRadius" | "BoxShadow" | "Color" | "Cursor" | "Display" | "FlexDirection" | "FontFamily" | "FontSize" | "FontStyle" | "Gap" | "Height" | "JustifyContent" | "Margin" | "Opacity" | "Outline" | "Overflow" | "Padding" | "Position" | "S" | "Width" | "[" | "[]" | "_" | "abs" | "abs_float" | "acc" | "acos" | "asin" | "atan" | "bool_of_string" | "case " | "ceil" | "cos" | "epsilon_float" | "exp" | "false" | "filter" | "float_of_int" | "float_of_string" | "floor" | "fun " | "hd" | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "nan" | "neg_infinity" | "p" | "pi" | "sin" | "sqrt" | "string_compare" | "string_concat" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "tl" | "true" | "type " | "xs" | floatlit | intlit | stringlit
root ::= completions | new_tokens

Top 20 Logits:
hd:17.6014
 h:13.3521
go:11.8598
h:11.0334
x:11.0198
p:10.7589
head:10.6699
f:10.5818
]):9.97803
((:9.94807
hl:9.90483
cons:9.81696
 p:9.79634
 go:9.72312
fd:9.70537
fold:9.68262
td:9.47939
ht:9.30567
 (:9.24079
 f:9.12798
@:9.12188

================
# Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd

LSP: Prelude: Recieved string: ### List ###

# Add an element to the front of a list. #
let cons: (Int, [Int]) -> [Int] = fun x, xs -> x::xs in

# Determine the length of a list. #
let length: [Int] -> Int =
  fun xs ->
    case xs
    | [] => 0
    | _::xs => 1 + length(xs) end in

# Extract the first element of a list. #
let hd: [Int] -> Option =
  fun l ->
    case l
    | [] => None
    | x::xs => Some(x) end in

# Extract the rest of the list. #
let tl: [Int] -> [Int] =
  fun l ->
    case l
    | [] => []
    | x::xs => xs end in

# Determine if a list is empty. #
let is_empty: [Int] -> Bool =
  fun xs ->
    case xs
    | [] => true
    | _::_ => false end in

# Return the element at the index. #
let nth: ([Int], Int) -> Option =
  fun xs, n ->
    case xs, n
    | x::_, 0 => Some(x)
    | _::xs, n => nth(xs, n - 1)
    | [], _ => None end in

# Reverse a List. #
let rev: [Int] -> [Int] =
fun l -> 
let go: ([Int], [Int]) -> [Int] =
  fun xs, acc -> 
    case xs 
    | [] => acc 
    | x::xs => go(xs, x::acc) end in
go(l, []) in

# Check if two lists are equal #
let equal: ([Int], [Int]) -> Bool =
    fun p, xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => x == y && equal(xs, ys)
    | _ => false end
in

# Initialize a list with a given length using an initializer function #
let init: (Int, Int -> Int) -> [Int] =
    fun len, f ->
        let go: (Int, [Int]) -> [Int] =
        fun idx, xs ->
            if idx < len 
            then go(idx + 1, xs @ [f(idx)])   
            else xs
        in
        go(0, [])
in

# Reduce a list from the left. #
let fold_left: ((Int, Int) -> Int, Int, [Int]) -> Int =
  fun f, acc, xs ->
    case xs 
    | [] => acc
    | hd::tl => fold_left(f, f(acc, hd), tl) end in

# Reduce a list from the right. #
let fold_right: ((Int, Int) -> Int, [Int], Int) -> Int =
  fun f, xs, acc ->
    case xs
    | [] => acc
    | hd::tl => f(hd, fold_right(f, tl, acc)) end in


666
LSP: Prelude: String parsed successfully
LSP: Prelude: Info map generated successfully
Debug: true, Constrain: Types
LSP: Init: Recieved string: # Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd
LSP: Init: String parsed successfully
  LSP: Syntax: Leftward is Complete Tile: <hd>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {tl: [?], hd: ?, acc: ?, xs: ?, p: ((Int -> Bool), [Int]), filter: (((Int -> Bool), [Int]) -> [Int]), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ] ) else end in in
  LSP: Info: ALL errors:Error in term:
  p
Nature of error: type ((Int -> Bool), [Int]) is not consistent with arrow type
  LSP: Info: BidiCtx: Cls: Variable reference
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: List literal
  LSP: Syntax: Can insert left-concave or complete: hd
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: && \/ $== == != <= >= < > ==. !=. <=. >=. <. >. + - * / ** +. -. *. /. **. ++ :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Backpack: ]
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: hd
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: && \/ $== == != <= >= < > ==. !=. <=. >=. <. >. + - * / ** +. -. *. /. **. ++ :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Backpack: ]
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Ty paths:
 ?
  LSP: Convex: Target types: ?
  LSP: Convex: Backpack: 
  LSP: Convex: Base: tl hd acc xs p filter string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position Width S () [] _ false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: ! ( () - AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position S Width [ [] _ abs abs_float acc acos asin atan bool_of_string case  ceil cos epsilon_float exp false filter float_of_int float_of_string floor fun  hd if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod nan neg_infinity p pi sin sqrt string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan test  tl true type  xs ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new_tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/" | "]"
root ::= new_tokens

Top 20 Logits:
]):18.6897
]:15.4729
],:14.2208
]),:12.5684
,:12.1277
 @:11.8266
]).:11.7062
 :::11.3781
:::11.2415
@:11.0228
])):10.9843
 +:10.9643
]);:10.5105
];:9.87766
::9.72352
 :9.68079
]::9.54969
 ]:9.39362
](:9.38076
 -:9.33595
 ::9.1066

================
# Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd]

LSP: Prelude: Recieved string: ### List ###

# Add an element to the front of a list. #
let cons: (Int, [Int]) -> [Int] = fun x, xs -> x::xs in

# Determine the length of a list. #
let length: [Int] -> Int =
  fun xs ->
    case xs
    | [] => 0
    | _::xs => 1 + length(xs) end in

# Extract the first element of a list. #
let hd: [Int] -> Option =
  fun l ->
    case l
    | [] => None
    | x::xs => Some(x) end in

# Extract the rest of the list. #
let tl: [Int] -> [Int] =
  fun l ->
    case l
    | [] => []
    | x::xs => xs end in

# Determine if a list is empty. #
let is_empty: [Int] -> Bool =
  fun xs ->
    case xs
    | [] => true
    | _::_ => false end in

# Return the element at the index. #
let nth: ([Int], Int) -> Option =
  fun xs, n ->
    case xs, n
    | x::_, 0 => Some(x)
    | _::xs, n => nth(xs, n - 1)
    | [], _ => None end in

# Reverse a List. #
let rev: [Int] -> [Int] =
fun l -> 
let go: ([Int], [Int]) -> [Int] =
  fun xs, acc -> 
    case xs 
    | [] => acc 
    | x::xs => go(xs, x::acc) end in
go(l, []) in

# Check if two lists are equal #
let equal: ([Int], [Int]) -> Bool =
    fun p, xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => x == y && equal(xs, ys)
    | _ => false end
in

# Initialize a list with a given length using an initializer function #
let init: (Int, Int -> Int) -> [Int] =
    fun len, f ->
        let go: (Int, [Int]) -> [Int] =
        fun idx, xs ->
            if idx < len 
            then go(idx + 1, xs @ [f(idx)])   
            else xs
        in
        go(0, [])
in

# Reduce a list from the left. #
let fold_left: ((Int, Int) -> Int, Int, [Int]) -> Int =
  fun f, acc, xs ->
    case xs 
    | [] => acc
    | hd::tl => fold_left(f, f(acc, hd), tl) end in

# Reduce a list from the right. #
let fold_right: ((Int, Int) -> Int, [Int], Int) -> Int =
  fun f, xs, acc ->
    case xs
    | [] => acc
    | hd::tl => f(hd, fold_right(f, tl, acc)) end in


666
LSP: Prelude: String parsed successfully
LSP: Prelude: Info map generated successfully
Debug: true, Constrain: Types
LSP: Init: Recieved string: # Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd]
LSP: Init: String parsed successfully
  LSP: Syntax: Leftward is Complete Tile: <[ ]>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: List literal
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [?]
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {tl: [?], hd: ?, acc: ?, xs: ?, p: ((Int -> Bool), [Int]), filter: (((Int -> Bool), [Int]) -> [Int]), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) else end in in
  LSP: Info: ALL errors:Error in term:
  p
Nature of error: type ((Int -> Bool), [Int]) is not consistent with arrow type
  LSP: Info: BidiCtx: Cls: List Concatenation
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: [?]
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: :: @
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new_tokens ::= whitespace | ")" | "," | "::" | "@"
root ::= new_tokens

Top 20 Logits:
 @:15.5304
 ):14.9344
 &&:13.8847
 ||:13.6151
)::13.1216
 else:13.0424
 &:12.7094
 |:12.7065
@:12.6208
 ::12.6114
 ,:12.4939
 :::12.4456
 and:11.3947
 +:11.3722

:11.3495
:::11.3137
 /:10.9266
)\:10.8395
 <>:10.7675
 :10.7496
 as:10.5073

================
# Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @

LSP: Prelude: Recieved string: ### List ###

# Add an element to the front of a list. #
let cons: (Int, [Int]) -> [Int] = fun x, xs -> x::xs in

# Determine the length of a list. #
let length: [Int] -> Int =
  fun xs ->
    case xs
    | [] => 0
    | _::xs => 1 + length(xs) end in

# Extract the first element of a list. #
let hd: [Int] -> Option =
  fun l ->
    case l
    | [] => None
    | x::xs => Some(x) end in

# Extract the rest of the list. #
let tl: [Int] -> [Int] =
  fun l ->
    case l
    | [] => []
    | x::xs => xs end in

# Determine if a list is empty. #
let is_empty: [Int] -> Bool =
  fun xs ->
    case xs
    | [] => true
    | _::_ => false end in

# Return the element at the index. #
let nth: ([Int], Int) -> Option =
  fun xs, n ->
    case xs, n
    | x::_, 0 => Some(x)
    | _::xs, n => nth(xs, n - 1)
    | [], _ => None end in

# Reverse a List. #
let rev: [Int] -> [Int] =
fun l -> 
let go: ([Int], [Int]) -> [Int] =
  fun xs, acc -> 
    case xs 
    | [] => acc 
    | x::xs => go(xs, x::acc) end in
go(l, []) in

# Check if two lists are equal #
let equal: ([Int], [Int]) -> Bool =
    fun p, xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => x == y && equal(xs, ys)
    | _ => false end
in

# Initialize a list with a given length using an initializer function #
let init: (Int, Int -> Int) -> [Int] =
    fun len, f ->
        let go: (Int, [Int]) -> [Int] =
        fun idx, xs ->
            if idx < len 
            then go(idx + 1, xs @ [f(idx)])   
            else xs
        in
        go(0, [])
in

# Reduce a list from the left. #
let fold_left: ((Int, Int) -> Int, Int, [Int]) -> Int =
  fun f, acc, xs ->
    case xs 
    | [] => acc
    | hd::tl => fold_left(f, f(acc, hd), tl) end in

# Reduce a list from the right. #
let fold_right: ((Int, Int) -> Int, [Int], Int) -> Int =
  fun f, xs, acc ->
    case xs
    | [] => acc
    | hd::tl => f(hd, fold_right(f, tl, acc)) end in


666
LSP: Prelude: String parsed successfully
LSP: Prelude: Info map generated successfully
Debug: true, Constrain: Types
LSP: Init: Recieved string: # Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @
LSP: Init: String parsed successfully
  LSP: Syntax: Leftward is Complete Tile: >@<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [?]
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {tl: [?], hd: ?, acc: ?, xs: ?, p: ((Int -> Bool), [Int]), filter: (((Int -> Bool), [Int]) -> [Int]), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) else end in in
  LSP: Info: ALL errors:Error in term:
  p
Nature of error: type ((Int -> Bool), [Int]) is not consistent with arrow type
  LSP: Info: BidiCtx: Cls: List Concatenation
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Info: Cls: List Concatenation
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {tl: [?], hd: ?, acc: ?, xs: ?, p: ((Int -> Bool), [Int]), filter: (((Int -> Bool), [Int]) -> [Int]), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) else end in in
  LSP: Info: ALL errors:Error in term:
  p
Nature of error: type ((Int -> Bool), [Int]) is not consistent with arrow type
  LSP: Info: BidiCtx: Cls: List Concatenation
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Can insert left-convex or complete: @
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 [?]
? <= [?]
? <= [?]
  LSP: Convex: Target types: ?, [?]
  LSP: Convex: Backpack: 
  LSP: Convex: Base: tl hd acc xs [] _ ( [ case  if  let  type 
  LSP: Convex: Lookahead: ! ( () - AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position S Width [ [] _ abs abs_float acc acos asin atan bool_of_string case  ceil cos epsilon_float exp false filter float_of_int float_of_string floor fun  hd if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod nan neg_infinity p pi sin sqrt string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan test  tl true type  xs ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Generating Completions for prefix: @
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: && \/ $== == != <= >= < > ==. !=. <=. >=. <. >. + - * / ** +. -. *. /. **. ++ :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: 
  LSP: Convex: Ty paths:
 ?
  LSP: Convex: Target types: ?
  LSP: Convex: Backpack: 
  LSP: Convex: Base: tl hd acc xs p filter string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position Width S () [] _ false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: ! ( () - AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position S Width [ [] _ abs abs_float acc acos asin atan bool_of_string case  ceil cos epsilon_float exp false filter float_of_int float_of_string floor fun  hd if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod nan neg_infinity p pi sin sqrt string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan test  tl true type  xs ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new_tokens ::= whitespace | "!" | "(" | "()" | "-" | "AlignItems" | "BackgroundColor" | "Border" | "BorderRadius" | "BoxShadow" | "Color" | "Cursor" | "Display" | "FlexDirection" | "FontFamily" | "FontSize" | "FontStyle" | "Gap" | "Height" | "JustifyContent" | "Margin" | "Opacity" | "Outline" | "Overflow" | "Padding" | "Position" | "S" | "Width" | "[" | "[]" | "_" | "abs" | "abs_float" | "acc" | "acos" | "asin" | "atan" | "bool_of_string" | "case " | "ceil" | "cos" | "epsilon_float" | "exp" | "false" | "filter" | "float_of_int" | "float_of_string" | "floor" | "fun " | "hd" | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "nan" | "neg_infinity" | "p" | "pi" | "sin" | "sqrt" | "string_compare" | "string_concat" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "tl" | "true" | "type " | "xs" | floatlit | intlit | stringlit
root ::= new_tokens

Top 20 Logits:
 go:16.5904
 t:15.4572
 (:15.4498
 filter:15.0723
 [:13.1134
 fol:12.4622
 [(:12.0201
 ((:11.5234
 xs:11.1501
 ([:10.8367
 []:10.6531
 :10.6004
 tail:10.405
(:10.3919
 @:10.1674
 [],:9.98307
[]):9.96634
 h:9.90466
 acc:9.81168

:9.74889
 fl:9.68512

================
# Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ t

LSP: Prelude: Recieved string: ### List ###

# Add an element to the front of a list. #
let cons: (Int, [Int]) -> [Int] = fun x, xs -> x::xs in

# Determine the length of a list. #
let length: [Int] -> Int =
  fun xs ->
    case xs
    | [] => 0
    | _::xs => 1 + length(xs) end in

# Extract the first element of a list. #
let hd: [Int] -> Option =
  fun l ->
    case l
    | [] => None
    | x::xs => Some(x) end in

# Extract the rest of the list. #
let tl: [Int] -> [Int] =
  fun l ->
    case l
    | [] => []
    | x::xs => xs end in

# Determine if a list is empty. #
let is_empty: [Int] -> Bool =
  fun xs ->
    case xs
    | [] => true
    | _::_ => false end in

# Return the element at the index. #
let nth: ([Int], Int) -> Option =
  fun xs, n ->
    case xs, n
    | x::_, 0 => Some(x)
    | _::xs, n => nth(xs, n - 1)
    | [], _ => None end in

# Reverse a List. #
let rev: [Int] -> [Int] =
fun l -> 
let go: ([Int], [Int]) -> [Int] =
  fun xs, acc -> 
    case xs 
    | [] => acc 
    | x::xs => go(xs, x::acc) end in
go(l, []) in

# Check if two lists are equal #
let equal: ([Int], [Int]) -> Bool =
    fun p, xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => x == y && equal(xs, ys)
    | _ => false end
in

# Initialize a list with a given length using an initializer function #
let init: (Int, Int -> Int) -> [Int] =
    fun len, f ->
        let go: (Int, [Int]) -> [Int] =
        fun idx, xs ->
            if idx < len 
            then go(idx + 1, xs @ [f(idx)])   
            else xs
        in
        go(0, [])
in

# Reduce a list from the left. #
let fold_left: ((Int, Int) -> Int, Int, [Int]) -> Int =
  fun f, acc, xs ->
    case xs 
    | [] => acc
    | hd::tl => fold_left(f, f(acc, hd), tl) end in

# Reduce a list from the right. #
let fold_right: ((Int, Int) -> Int, [Int], Int) -> Int =
  fun f, xs, acc ->
    case xs
    | [] => acc
    | hd::tl => f(hd, fold_right(f, tl, acc)) end in


666
LSP: Prelude: String parsed successfully
LSP: Prelude: Info map generated successfully
Debug: true, Constrain: Types
LSP: Init: Recieved string: # Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ t
LSP: Init: String parsed successfully
  LSP: Syntax: Leftward is Complete Tile: <t>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [?]
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Exp (FreeVariable "t"))
  LSP: Info: Typing Context: {tl: [?], hd: ?, acc: ?, xs: ?, p: ((Int -> Bool), [Int]), filter: (((Int -> Bool), [Int]) -> [Int]), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) else end in in
  LSP: Info: ALL errors:Error in term:
  p
Nature of error: type ((Int -> Bool), [Int]) is not consistent with arrow type    
Error in term:
  t
Nature of error: Variable t is not bound
  LSP: Info: BidiCtx: Cls: List Concatenation
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Can insert left-concave or complete: t
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: t
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Ty paths:
 [?]
? <= [?]
? <= [?]
  LSP: Convex: Target types: ?, [?]
  LSP: Convex: Backpack: 
  LSP: Convex: Base: tl hd acc xs [] _ ( [ case  if  let  type 
  LSP: Convex: Lookahead: ! ( () - AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position S Width [ [] _ abs abs_float acc acos asin atan bool_of_string case  ceil cos epsilon_float exp false filter float_of_int float_of_string floor fun  hd if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod nan neg_infinity p pi sin sqrt string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan test  tl true type  xs ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "an" | "est " | "l" | "rue" | "ype "
new_tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | ")" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/"
root ::= completions | new_tokens

Top 20 Logits:
l:21.1166
ls:10.9069
la:10.7459
):10.3801
(:10.3129
L:10.0103
ln:10.0046
_:9.89514
lv:9.74922
1:9.70304
li:9.5349
tl:9.36527
ails:9.24398
n:9.16665
filter:8.80352
[:8.70893
 l:8.64521
ail:8.64397
b:8.63052
2:8.55992
lr:8.49807

================
# Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl

LSP: Prelude: Recieved string: ### List ###

# Add an element to the front of a list. #
let cons: (Int, [Int]) -> [Int] = fun x, xs -> x::xs in

# Determine the length of a list. #
let length: [Int] -> Int =
  fun xs ->
    case xs
    | [] => 0
    | _::xs => 1 + length(xs) end in

# Extract the first element of a list. #
let hd: [Int] -> Option =
  fun l ->
    case l
    | [] => None
    | x::xs => Some(x) end in

# Extract the rest of the list. #
let tl: [Int] -> [Int] =
  fun l ->
    case l
    | [] => []
    | x::xs => xs end in

# Determine if a list is empty. #
let is_empty: [Int] -> Bool =
  fun xs ->
    case xs
    | [] => true
    | _::_ => false end in

# Return the element at the index. #
let nth: ([Int], Int) -> Option =
  fun xs, n ->
    case xs, n
    | x::_, 0 => Some(x)
    | _::xs, n => nth(xs, n - 1)
    | [], _ => None end in

# Reverse a List. #
let rev: [Int] -> [Int] =
fun l -> 
let go: ([Int], [Int]) -> [Int] =
  fun xs, acc -> 
    case xs 
    | [] => acc 
    | x::xs => go(xs, x::acc) end in
go(l, []) in

# Check if two lists are equal #
let equal: ([Int], [Int]) -> Bool =
    fun p, xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => x == y && equal(xs, ys)
    | _ => false end
in

# Initialize a list with a given length using an initializer function #
let init: (Int, Int -> Int) -> [Int] =
    fun len, f ->
        let go: (Int, [Int]) -> [Int] =
        fun idx, xs ->
            if idx < len 
            then go(idx + 1, xs @ [f(idx)])   
            else xs
        in
        go(0, [])
in

# Reduce a list from the left. #
let fold_left: ((Int, Int) -> Int, Int, [Int]) -> Int =
  fun f, acc, xs ->
    case xs 
    | [] => acc
    | hd::tl => fold_left(f, f(acc, hd), tl) end in

# Reduce a list from the right. #
let fold_right: ((Int, Int) -> Int, [Int], Int) -> Int =
  fun f, xs, acc ->
    case xs
    | [] => acc
    | hd::tl => f(hd, fold_right(f, tl, acc)) end in


666
LSP: Prelude: String parsed successfully
LSP: Prelude: Info map generated successfully
Debug: true, Constrain: Types
LSP: Init: Recieved string: # Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl
LSP: Init: String parsed successfully
  LSP: Syntax: Leftward is Complete Tile: <tl>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [?]
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {tl: [?], hd: ?, acc: ?, xs: ?, p: ((Int -> Bool), [Int]), filter: (((Int -> Bool), [Int]) -> [Int]), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) else end in in
  LSP: Info: ALL errors:Error in term:
  p
Nature of error: type ((Int -> Bool), [Int]) is not consistent with arrow type
  LSP: Info: BidiCtx: Cls: List Concatenation
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Can insert left-concave or complete: tl
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: [?]
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: :: @
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: 
LSP: Generating Completions for prefix: tl
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: 
  LSP: Convex: Ty paths:
 [?]
? <= [?]
? <= [?]
  LSP: Convex: Target types: ?, [?]
  LSP: Convex: Backpack: 
  LSP: Convex: Base: tl hd acc xs [] _ ( [ case  if  let  type 
  LSP: Convex: Lookahead: ! ( () - AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position S Width [ [] _ abs abs_float acc acos asin atan bool_of_string case  ceil cos epsilon_float exp false filter float_of_int float_of_string floor fun  hd if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod nan neg_infinity p pi sin sqrt string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan test  tl true type  xs ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new_tokens ::= whitespace | ")" | "," | "::" | "@"
root ::= new_tokens

Top 20 Logits:
):15.3463
 else:12.0418
 ):11.4894
)):11.3213
,:10.6913
(:10.4052
 @:10.3215
 |:10.258
),:10.0002
);:9.67969
 end:9.54644
.:9.53365
:::9.52229
;:9.4738
 go:9.42594
 =:9.07298
 (:9.03163
::8.94981
2:8.89022
@:8.78978
_:8.74906

================
# Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl)

LSP: Prelude: Recieved string: ### List ###

# Add an element to the front of a list. #
let cons: (Int, [Int]) -> [Int] = fun x, xs -> x::xs in

# Determine the length of a list. #
let length: [Int] -> Int =
  fun xs ->
    case xs
    | [] => 0
    | _::xs => 1 + length(xs) end in

# Extract the first element of a list. #
let hd: [Int] -> Option =
  fun l ->
    case l
    | [] => None
    | x::xs => Some(x) end in

# Extract the rest of the list. #
let tl: [Int] -> [Int] =
  fun l ->
    case l
    | [] => []
    | x::xs => xs end in

# Determine if a list is empty. #
let is_empty: [Int] -> Bool =
  fun xs ->
    case xs
    | [] => true
    | _::_ => false end in

# Return the element at the index. #
let nth: ([Int], Int) -> Option =
  fun xs, n ->
    case xs, n
    | x::_, 0 => Some(x)
    | _::xs, n => nth(xs, n - 1)
    | [], _ => None end in

# Reverse a List. #
let rev: [Int] -> [Int] =
fun l -> 
let go: ([Int], [Int]) -> [Int] =
  fun xs, acc -> 
    case xs 
    | [] => acc 
    | x::xs => go(xs, x::acc) end in
go(l, []) in

# Check if two lists are equal #
let equal: ([Int], [Int]) -> Bool =
    fun p, xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => x == y && equal(xs, ys)
    | _ => false end
in

# Initialize a list with a given length using an initializer function #
let init: (Int, Int -> Int) -> [Int] =
    fun len, f ->
        let go: (Int, [Int]) -> [Int] =
        fun idx, xs ->
            if idx < len 
            then go(idx + 1, xs @ [f(idx)])   
            else xs
        in
        go(0, [])
in

# Reduce a list from the left. #
let fold_left: ((Int, Int) -> Int, Int, [Int]) -> Int =
  fun f, acc, xs ->
    case xs 
    | [] => acc
    | hd::tl => fold_left(f, f(acc, hd), tl) end in

# Reduce a list from the right. #
let fold_right: ((Int, Int) -> Int, [Int], Int) -> Int =
  fun f, xs, acc ->
    case xs
    | [] => acc
    | hd::tl => f(hd, fold_right(f, tl, acc)) end in


666
LSP: Prelude: String parsed successfully
LSP: Prelude: Info map generated successfully
Debug: true, Constrain: Types
LSP: Init: Recieved string: # Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl)
LSP: Init: String parsed successfully
  LSP: Syntax: Leftward is Complete Tile: <( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Parenthesized expression
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {tl: [?], hd: ?, acc: ?, xs: ?, p: ((Int -> Bool), [Int]), filter: (((Int -> Bool), [Int]) -> [Int]), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: else end in in
  LSP: Info: ALL errors:Error in term:
  p
Nature of error: type ((Int -> Bool), [Int]) is not consistent with arrow type
  LSP: Info: BidiCtx: Cls: Parenthesized expression
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: If expression
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: [?]
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: :: @
  LSP: Concave: Backpack: else
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new_tokens ::= whitespace | "," | "::" | "@" | "else"
root ::= new_tokens

Top 20 Logits:
 else:17.7526

:14.059
 :13.0284
 @:12.611
 end:12.1442
 go:11.7538
 ::11.52
 |:11.0845
 =:10.5236
  :10.5038
 ||:10.4526
 :::10.388
 (:10.345
 acc:10.3405
 in:10.1913
@:10.1454
 &&:10.1283
 t:9.96366
 (@:9.86389
 :=:9.86338
 elif:9.8394

================
# Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else

LSP: Prelude: Recieved string: ### List ###

# Add an element to the front of a list. #
let cons: (Int, [Int]) -> [Int] = fun x, xs -> x::xs in

# Determine the length of a list. #
let length: [Int] -> Int =
  fun xs ->
    case xs
    | [] => 0
    | _::xs => 1 + length(xs) end in

# Extract the first element of a list. #
let hd: [Int] -> Option =
  fun l ->
    case l
    | [] => None
    | x::xs => Some(x) end in

# Extract the rest of the list. #
let tl: [Int] -> [Int] =
  fun l ->
    case l
    | [] => []
    | x::xs => xs end in

# Determine if a list is empty. #
let is_empty: [Int] -> Bool =
  fun xs ->
    case xs
    | [] => true
    | _::_ => false end in

# Return the element at the index. #
let nth: ([Int], Int) -> Option =
  fun xs, n ->
    case xs, n
    | x::_, 0 => Some(x)
    | _::xs, n => nth(xs, n - 1)
    | [], _ => None end in

# Reverse a List. #
let rev: [Int] -> [Int] =
fun l -> 
let go: ([Int], [Int]) -> [Int] =
  fun xs, acc -> 
    case xs 
    | [] => acc 
    | x::xs => go(xs, x::acc) end in
go(l, []) in

# Check if two lists are equal #
let equal: ([Int], [Int]) -> Bool =
    fun p, xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => x == y && equal(xs, ys)
    | _ => false end
in

# Initialize a list with a given length using an initializer function #
let init: (Int, Int -> Int) -> [Int] =
    fun len, f ->
        let go: (Int, [Int]) -> [Int] =
        fun idx, xs ->
            if idx < len 
            then go(idx + 1, xs @ [f(idx)])   
            else xs
        in
        go(0, [])
in

# Reduce a list from the left. #
let fold_left: ((Int, Int) -> Int, Int, [Int]) -> Int =
  fun f, acc, xs ->
    case xs 
    | [] => acc
    | hd::tl => fold_left(f, f(acc, hd), tl) end in

# Reduce a list from the right. #
let fold_right: ((Int, Int) -> Int, [Int], Int) -> Int =
  fun f, xs, acc ->
    case xs
    | [] => acc
    | hd::tl => f(hd, fold_right(f, tl, acc)) end in


666
LSP: Prelude: String parsed successfully
LSP: Prelude: Info map generated successfully
Debug: true, Constrain: Types
LSP: Init: Recieved string: # Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else
LSP: Init: String parsed successfully
  LSP: Syntax: Leftward is Complete Tile: <if then else<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {tl: [?], hd: ?, acc: ?, xs: ?, p: ((Int -> Bool), [Int]), filter: (((Int -> Bool), [Int]) -> [Int]), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end in in
  LSP: Info: ALL errors:Error in term:
  p
Nature of error: type ((Int -> Bool), [Int]) is not consistent with arrow type
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 ?
  LSP: Convex: Target types: ?
  LSP: Convex: Backpack: 
  LSP: Convex: Base: tl hd acc xs p filter string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position Width S () [] _ false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: ! ( () - AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position S Width [ [] _ abs abs_float acc acos asin atan bool_of_string case  ceil cos epsilon_float exp false filter float_of_int float_of_string floor fun  hd if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod nan neg_infinity p pi sin sqrt string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan test  tl true type  xs ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new_tokens ::= whitespace | "!" | "(" | "()" | "-" | "AlignItems" | "BackgroundColor" | "Border" | "BorderRadius" | "BoxShadow" | "Color" | "Cursor" | "Display" | "FlexDirection" | "FontFamily" | "FontSize" | "FontStyle" | "Gap" | "Height" | "JustifyContent" | "Margin" | "Opacity" | "Outline" | "Overflow" | "Padding" | "Position" | "S" | "Width" | "[" | "[]" | "_" | "abs" | "abs_float" | "acc" | "acos" | "asin" | "atan" | "bool_of_string" | "case " | "ceil" | "cos" | "epsilon_float" | "exp" | "false" | "filter" | "float_of_int" | "float_of_string" | "floor" | "fun " | "hd" | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "nan" | "neg_infinity" | "p" | "pi" | "sin" | "sqrt" | "string_compare" | "string_concat" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "tl" | "true" | "type " | "xs" | floatlit | intlit | stringlit
root ::= new_tokens

Top 20 Logits:
 go:16.9686
 (:16.0611
 acc:14.0318
 t:13.2122
 filter:12.8677
 ([:12.6041
 :12.1397
 h:11.8028
 [:11.7783

:11.7199
(:11.6377
 ((:11.6266
 xs:11.5516
 []:11.4271
 ():11.1417
 fol:11.0564
 [(:10.07
 if:9.81348
 p:9.71185
 (_:9.26157
 _:9.02782

================
# Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (

LSP: Prelude: Recieved string: ### List ###

# Add an element to the front of a list. #
let cons: (Int, [Int]) -> [Int] = fun x, xs -> x::xs in

# Determine the length of a list. #
let length: [Int] -> Int =
  fun xs ->
    case xs
    | [] => 0
    | _::xs => 1 + length(xs) end in

# Extract the first element of a list. #
let hd: [Int] -> Option =
  fun l ->
    case l
    | [] => None
    | x::xs => Some(x) end in

# Extract the rest of the list. #
let tl: [Int] -> [Int] =
  fun l ->
    case l
    | [] => []
    | x::xs => xs end in

# Determine if a list is empty. #
let is_empty: [Int] -> Bool =
  fun xs ->
    case xs
    | [] => true
    | _::_ => false end in

# Return the element at the index. #
let nth: ([Int], Int) -> Option =
  fun xs, n ->
    case xs, n
    | x::_, 0 => Some(x)
    | _::xs, n => nth(xs, n - 1)
    | [], _ => None end in

# Reverse a List. #
let rev: [Int] -> [Int] =
fun l -> 
let go: ([Int], [Int]) -> [Int] =
  fun xs, acc -> 
    case xs 
    | [] => acc 
    | x::xs => go(xs, x::acc) end in
go(l, []) in

# Check if two lists are equal #
let equal: ([Int], [Int]) -> Bool =
    fun p, xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => x == y && equal(xs, ys)
    | _ => false end
in

# Initialize a list with a given length using an initializer function #
let init: (Int, Int -> Int) -> [Int] =
    fun len, f ->
        let go: (Int, [Int]) -> [Int] =
        fun idx, xs ->
            if idx < len 
            then go(idx + 1, xs @ [f(idx)])   
            else xs
        in
        go(0, [])
in

# Reduce a list from the left. #
let fold_left: ((Int, Int) -> Int, Int, [Int]) -> Int =
  fun f, acc, xs ->
    case xs 
    | [] => acc
    | hd::tl => fold_left(f, f(acc, hd), tl) end in

# Reduce a list from the right. #
let fold_right: ((Int, Int) -> Int, [Int], Int) -> Int =
  fun f, xs, acc ->
    case xs
    | [] => acc
    | hd::tl => f(hd, fold_right(f, tl, acc)) end in


666
LSP: Prelude: String parsed successfully
LSP: Prelude: Info map generated successfully
Debug: true, Constrain: Types
LSP: Init: Recieved string: # Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (
LSP: Init: String parsed successfully
  LSP: Syntax: Leftward is Incomplete Tile: <( )<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {tl: [?], hd: ?, acc: ?, xs: ?, p: ((Int -> Bool), [Int]), filter: (((Int -> Bool), [Int]) -> [Int]), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in in
  LSP: Info: ALL errors:Error in term:
  p
Nature of error: type ((Int -> Bool), [Int]) is not consistent with arrow type
  LSP: Info: BidiCtx: Cls: Empty expression hole
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Info: Cls: Parenthesized expression
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {tl: [?], hd: ?, acc: ?, xs: ?, p: ((Int -> Bool), [Int]), filter: (((Int -> Bool), [Int]) -> [Int]), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in in
  LSP: Info: ALL errors:Error in term:
  p
Nature of error: type ((Int -> Bool), [Int]) is not consistent with arrow type
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Syntax: Can insert left-convex or complete: (
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 ?
  LSP: Convex: Target types: ?
  LSP: Convex: Backpack: 
  LSP: Convex: Base: tl hd acc xs p filter string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position Width S () [] _ false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: ! ( () - AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position S Width [ [] _ abs abs_float acc acos asin atan bool_of_string case  ceil cos epsilon_float exp false filter float_of_int float_of_string floor fun  hd if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod nan neg_infinity p pi sin sqrt string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan test  tl true type  xs ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Generating Completions for prefix: (
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: && \/ $== == != <= >= < > ==. !=. <=. >=. <. >. + - * / ** +. -. *. /. **. ++ :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: ( |
  LSP: Convex: Ty paths:
 ?
  LSP: Convex: Target types: ?
  LSP: Convex: Backpack: 
  LSP: Convex: Base: tl hd acc xs p filter string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position Width S () [] _ false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: ! ( () - AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position S Width [ [] _ abs abs_float acc acos asin atan bool_of_string case  ceil cos epsilon_float exp false filter float_of_int float_of_string floor fun  hd if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod nan neg_infinity p pi sin sqrt string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan test  tl true type  xs ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= ")"
new_tokens ::= whitespace | "!" | "(" | "()" | "-" | "AlignItems" | "BackgroundColor" | "Border" | "BorderRadius" | "BoxShadow" | "Color" | "Cursor" | "Display" | "FlexDirection" | "FontFamily" | "FontSize" | "FontStyle" | "Gap" | "Height" | "JustifyContent" | "Margin" | "Opacity" | "Outline" | "Overflow" | "Padding" | "Position" | "S" | "Width" | "[" | "[]" | "_" | "abs" | "abs_float" | "acc" | "acos" | "asin" | "atan" | "bool_of_string" | "case " | "ceil" | "cos" | "epsilon_float" | "exp" | "false" | "filter" | "float_of_int" | "float_of_string" | "floor" | "fun " | "hd" | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "nan" | "neg_infinity" | "p" | "pi" | "sin" | "sqrt" | "string_compare" | "string_concat" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "tl" | "true" | "type " | "xs" | floatlit | intlit | stringlit
root ::= completions | new_tokens

Top 20 Logits:
go:15.284
acc:15.1455
filter:14.041
tl:11.7169
ac:11.6326
xs:11.2878
hd:10.9631
[]:10.9169
fold:10.776
 go:10.7495
td:10.0435
t:9.62875
x:9.54373
tail:9.51621
tc:9.41096
 acc:9.30085
cons:9.27072

:9.21951
p:8.91864
hs:8.6833
fil:8.3759

================
# Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc

LSP: Prelude: Recieved string: ### List ###

# Add an element to the front of a list. #
let cons: (Int, [Int]) -> [Int] = fun x, xs -> x::xs in

# Determine the length of a list. #
let length: [Int] -> Int =
  fun xs ->
    case xs
    | [] => 0
    | _::xs => 1 + length(xs) end in

# Extract the first element of a list. #
let hd: [Int] -> Option =
  fun l ->
    case l
    | [] => None
    | x::xs => Some(x) end in

# Extract the rest of the list. #
let tl: [Int] -> [Int] =
  fun l ->
    case l
    | [] => []
    | x::xs => xs end in

# Determine if a list is empty. #
let is_empty: [Int] -> Bool =
  fun xs ->
    case xs
    | [] => true
    | _::_ => false end in

# Return the element at the index. #
let nth: ([Int], Int) -> Option =
  fun xs, n ->
    case xs, n
    | x::_, 0 => Some(x)
    | _::xs, n => nth(xs, n - 1)
    | [], _ => None end in

# Reverse a List. #
let rev: [Int] -> [Int] =
fun l -> 
let go: ([Int], [Int]) -> [Int] =
  fun xs, acc -> 
    case xs 
    | [] => acc 
    | x::xs => go(xs, x::acc) end in
go(l, []) in

# Check if two lists are equal #
let equal: ([Int], [Int]) -> Bool =
    fun p, xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => x == y && equal(xs, ys)
    | _ => false end
in

# Initialize a list with a given length using an initializer function #
let init: (Int, Int -> Int) -> [Int] =
    fun len, f ->
        let go: (Int, [Int]) -> [Int] =
        fun idx, xs ->
            if idx < len 
            then go(idx + 1, xs @ [f(idx)])   
            else xs
        in
        go(0, [])
in

# Reduce a list from the left. #
let fold_left: ((Int, Int) -> Int, Int, [Int]) -> Int =
  fun f, acc, xs ->
    case xs 
    | [] => acc
    | hd::tl => fold_left(f, f(acc, hd), tl) end in

# Reduce a list from the right. #
let fold_right: ((Int, Int) -> Int, [Int], Int) -> Int =
  fun f, xs, acc ->
    case xs
    | [] => acc
    | hd::tl => f(hd, fold_right(f, tl, acc)) end in


666
LSP: Prelude: String parsed successfully
LSP: Prelude: Info map generated successfully
Debug: true, Constrain: Types
LSP: Init: Recieved string: # Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc
LSP: Init: String parsed successfully
  LSP: Syntax: Leftward is Complete Tile: <acc>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {tl: [?], hd: ?, acc: ?, xs: ?, p: ((Int -> Bool), [Int]), filter: (((Int -> Bool), [Int]) -> [Int]), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in in
  LSP: Info: ALL errors:Error in term:
  p
Nature of error: type ((Int -> Bool), [Int]) is not consistent with arrow type
  LSP: Info: BidiCtx: Cls: Variable reference
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Can insert left-concave or complete: acc
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: && \/ $== == != <= >= < > ==. !=. <=. >=. <. >. + - * / ** +. -. *. /. **. ++ :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: acc
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: && \/ $== == != <= >= < > ==. !=. <=. >=. <. >. + - * / ** +. -. *. /. **. ++ :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Ty paths:
 ?
  LSP: Convex: Target types: ?
  LSP: Convex: Backpack: 
  LSP: Convex: Base: tl hd acc xs p filter string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position Width S () [] _ false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: ! ( () - AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position S Width [ [] _ abs abs_float acc acos asin atan bool_of_string case  ceil cos epsilon_float exp false filter float_of_int float_of_string floor fun  hd if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod nan neg_infinity p pi sin sqrt string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan test  tl true type  xs ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new_tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | ")" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/"
root ::= new_tokens

Top 20 Logits:
 @:17.1477
):14.7465
@:12.6472
 :::11.5651
 t:11.2138
:::10.9292
),:10.8163
 :10.7784
,:10.6842
 +:10.6252
 &:10.526
 ):10.0126
)):9.92041
 *:9.90454
 ::9.74988
 end:9.62102
 &&:9.60258
::9.40425
 <>:9.37909
);:9.34022
 |:9.29057

================
# Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @

LSP: Prelude: Recieved string: ### List ###

# Add an element to the front of a list. #
let cons: (Int, [Int]) -> [Int] = fun x, xs -> x::xs in

# Determine the length of a list. #
let length: [Int] -> Int =
  fun xs ->
    case xs
    | [] => 0
    | _::xs => 1 + length(xs) end in

# Extract the first element of a list. #
let hd: [Int] -> Option =
  fun l ->
    case l
    | [] => None
    | x::xs => Some(x) end in

# Extract the rest of the list. #
let tl: [Int] -> [Int] =
  fun l ->
    case l
    | [] => []
    | x::xs => xs end in

# Determine if a list is empty. #
let is_empty: [Int] -> Bool =
  fun xs ->
    case xs
    | [] => true
    | _::_ => false end in

# Return the element at the index. #
let nth: ([Int], Int) -> Option =
  fun xs, n ->
    case xs, n
    | x::_, 0 => Some(x)
    | _::xs, n => nth(xs, n - 1)
    | [], _ => None end in

# Reverse a List. #
let rev: [Int] -> [Int] =
fun l -> 
let go: ([Int], [Int]) -> [Int] =
  fun xs, acc -> 
    case xs 
    | [] => acc 
    | x::xs => go(xs, x::acc) end in
go(l, []) in

# Check if two lists are equal #
let equal: ([Int], [Int]) -> Bool =
    fun p, xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => x == y && equal(xs, ys)
    | _ => false end
in

# Initialize a list with a given length using an initializer function #
let init: (Int, Int -> Int) -> [Int] =
    fun len, f ->
        let go: (Int, [Int]) -> [Int] =
        fun idx, xs ->
            if idx < len 
            then go(idx + 1, xs @ [f(idx)])   
            else xs
        in
        go(0, [])
in

# Reduce a list from the left. #
let fold_left: ((Int, Int) -> Int, Int, [Int]) -> Int =
  fun f, acc, xs ->
    case xs 
    | [] => acc
    | hd::tl => fold_left(f, f(acc, hd), tl) end in

# Reduce a list from the right. #
let fold_right: ((Int, Int) -> Int, [Int], Int) -> Int =
  fun f, xs, acc ->
    case xs
    | [] => acc
    | hd::tl => f(hd, fold_right(f, tl, acc)) end in


666
LSP: Prelude: String parsed successfully
LSP: Prelude: Info map generated successfully
Debug: true, Constrain: Types
LSP: Init: Recieved string: # Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @
LSP: Init: String parsed successfully
  LSP: Syntax: Leftward is Complete Tile: >@<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [?]
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {tl: [?], hd: ?, acc: ?, xs: ?, p: ((Int -> Bool), [Int]), filter: (((Int -> Bool), [Int]) -> [Int]), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in in
  LSP: Info: ALL errors:Error in term:
  p
Nature of error: type ((Int -> Bool), [Int]) is not consistent with arrow type
  LSP: Info: BidiCtx: Cls: List Concatenation
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Info: Cls: List Concatenation
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {tl: [?], hd: ?, acc: ?, xs: ?, p: ((Int -> Bool), [Int]), filter: (((Int -> Bool), [Int]) -> [Int]), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in in
  LSP: Info: ALL errors:Error in term:
  p
Nature of error: type ((Int -> Bool), [Int]) is not consistent with arrow type
  LSP: Info: BidiCtx: Cls: List Concatenation
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Can insert left-convex or complete: @
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 [?]
? <= [?]
? <= [?]
  LSP: Convex: Target types: ?, [?]
  LSP: Convex: Backpack: 
  LSP: Convex: Base: tl hd acc xs [] _ ( [ case  if  let  type 
  LSP: Convex: Lookahead: ! ( () - AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position S Width [ [] _ abs abs_float acc acos asin atan bool_of_string case  ceil cos epsilon_float exp false filter float_of_int float_of_string floor fun  hd if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod nan neg_infinity p pi sin sqrt string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan test  tl true type  xs ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Generating Completions for prefix: @
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: && \/ $== == != <= >= < > ==. !=. <=. >=. <. >. + - * / ** +. -. *. /. **. ++ :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: 
  LSP: Convex: Ty paths:
 ?
  LSP: Convex: Target types: ?
  LSP: Convex: Backpack: 
  LSP: Convex: Base: tl hd acc xs p filter string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position Width S () [] _ false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: ! ( () - AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position S Width [ [] _ abs abs_float acc acos asin atan bool_of_string case  ceil cos epsilon_float exp false filter float_of_int float_of_string floor fun  hd if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod nan neg_infinity p pi sin sqrt string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan test  tl true type  xs ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new_tokens ::= whitespace | "!" | "(" | "()" | "-" | "AlignItems" | "BackgroundColor" | "Border" | "BorderRadius" | "BoxShadow" | "Color" | "Cursor" | "Display" | "FlexDirection" | "FontFamily" | "FontSize" | "FontStyle" | "Gap" | "Height" | "JustifyContent" | "Margin" | "Opacity" | "Outline" | "Overflow" | "Padding" | "Position" | "S" | "Width" | "[" | "[]" | "_" | "abs" | "abs_float" | "acc" | "acos" | "asin" | "atan" | "bool_of_string" | "case " | "ceil" | "cos" | "epsilon_float" | "exp" | "false" | "filter" | "float_of_int" | "float_of_string" | "floor" | "fun " | "hd" | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "nan" | "neg_infinity" | "p" | "pi" | "sin" | "sqrt" | "string_compare" | "string_concat" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "tl" | "true" | "type " | "xs" | floatlit | intlit | stringlit
root ::= new_tokens

Top 20 Logits:
 t:16.4288
 go:16.216
 [:15.1879
 filter:14.9532
 (:13.6676
 xs:12.9237
 h:12.6917
 fol:12.6466
 acc:12.6154
 p:12.0945
[:11.8989
 []:11.7219
 [(:11.3929
 ([:11.1704
 ((:10.8773
 :10.8342
 tail:10.3488
 g:9.99775
 f:9.98087
 [[:9.886
 x:9.88248

================
# Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ t

LSP: Prelude: Recieved string: ### List ###

# Add an element to the front of a list. #
let cons: (Int, [Int]) -> [Int] = fun x, xs -> x::xs in

# Determine the length of a list. #
let length: [Int] -> Int =
  fun xs ->
    case xs
    | [] => 0
    | _::xs => 1 + length(xs) end in

# Extract the first element of a list. #
let hd: [Int] -> Option =
  fun l ->
    case l
    | [] => None
    | x::xs => Some(x) end in

# Extract the rest of the list. #
let tl: [Int] -> [Int] =
  fun l ->
    case l
    | [] => []
    | x::xs => xs end in

# Determine if a list is empty. #
let is_empty: [Int] -> Bool =
  fun xs ->
    case xs
    | [] => true
    | _::_ => false end in

# Return the element at the index. #
let nth: ([Int], Int) -> Option =
  fun xs, n ->
    case xs, n
    | x::_, 0 => Some(x)
    | _::xs, n => nth(xs, n - 1)
    | [], _ => None end in

# Reverse a List. #
let rev: [Int] -> [Int] =
fun l -> 
let go: ([Int], [Int]) -> [Int] =
  fun xs, acc -> 
    case xs 
    | [] => acc 
    | x::xs => go(xs, x::acc) end in
go(l, []) in

# Check if two lists are equal #
let equal: ([Int], [Int]) -> Bool =
    fun p, xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => x == y && equal(xs, ys)
    | _ => false end
in

# Initialize a list with a given length using an initializer function #
let init: (Int, Int -> Int) -> [Int] =
    fun len, f ->
        let go: (Int, [Int]) -> [Int] =
        fun idx, xs ->
            if idx < len 
            then go(idx + 1, xs @ [f(idx)])   
            else xs
        in
        go(0, [])
in

# Reduce a list from the left. #
let fold_left: ((Int, Int) -> Int, Int, [Int]) -> Int =
  fun f, acc, xs ->
    case xs 
    | [] => acc
    | hd::tl => fold_left(f, f(acc, hd), tl) end in

# Reduce a list from the right. #
let fold_right: ((Int, Int) -> Int, [Int], Int) -> Int =
  fun f, xs, acc ->
    case xs
    | [] => acc
    | hd::tl => f(hd, fold_right(f, tl, acc)) end in


666
LSP: Prelude: String parsed successfully
LSP: Prelude: Info map generated successfully
Debug: true, Constrain: Types
LSP: Init: Recieved string: # Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ t
LSP: Init: String parsed successfully
  LSP: Syntax: Leftward is Complete Tile: <t>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [?]
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Exp (FreeVariable "t"))
  LSP: Info: Typing Context: {tl: [?], hd: ?, acc: ?, xs: ?, p: ((Int -> Bool), [Int]), filter: (((Int -> Bool), [Int]) -> [Int]), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in in
  LSP: Info: ALL errors:Error in term:
  p
Nature of error: type ((Int -> Bool), [Int]) is not consistent with arrow type    
Error in term:
  t
Nature of error: Variable t is not bound
  LSP: Info: BidiCtx: Cls: List Concatenation
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Can insert left-concave or complete: t
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: t
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Ty paths:
 [?]
? <= [?]
? <= [?]
  LSP: Convex: Target types: ?, [?]
  LSP: Convex: Backpack: 
  LSP: Convex: Base: tl hd acc xs [] _ ( [ case  if  let  type 
  LSP: Convex: Lookahead: ! ( () - AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position S Width [ [] _ abs abs_float acc acos asin atan bool_of_string case  ceil cos epsilon_float exp false filter float_of_int float_of_string floor fun  hd if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod nan neg_infinity p pi sin sqrt string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan test  tl true type  xs ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "an" | "est " | "l" | "rue" | "ype "
new_tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | ")" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/"
root ::= completions | new_tokens

Top 20 Logits:
l:20.6983
tl:12.0517
ls:11.7426
ld:10.6896
lv:10.5708
la:10.3102
sl:10.2954
1:10.2622
ln:9.94077
 l:9.86099
L:9.84875
ail:9.7849
):9.67194
n:9.67154
ails:9.23465
t:9.2045
(:9.09485
dl:9.03722
nl:8.7824
ai:8.71407
li:8.53218

================
# Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl

LSP: Prelude: Recieved string: ### List ###

# Add an element to the front of a list. #
let cons: (Int, [Int]) -> [Int] = fun x, xs -> x::xs in

# Determine the length of a list. #
let length: [Int] -> Int =
  fun xs ->
    case xs
    | [] => 0
    | _::xs => 1 + length(xs) end in

# Extract the first element of a list. #
let hd: [Int] -> Option =
  fun l ->
    case l
    | [] => None
    | x::xs => Some(x) end in

# Extract the rest of the list. #
let tl: [Int] -> [Int] =
  fun l ->
    case l
    | [] => []
    | x::xs => xs end in

# Determine if a list is empty. #
let is_empty: [Int] -> Bool =
  fun xs ->
    case xs
    | [] => true
    | _::_ => false end in

# Return the element at the index. #
let nth: ([Int], Int) -> Option =
  fun xs, n ->
    case xs, n
    | x::_, 0 => Some(x)
    | _::xs, n => nth(xs, n - 1)
    | [], _ => None end in

# Reverse a List. #
let rev: [Int] -> [Int] =
fun l -> 
let go: ([Int], [Int]) -> [Int] =
  fun xs, acc -> 
    case xs 
    | [] => acc 
    | x::xs => go(xs, x::acc) end in
go(l, []) in

# Check if two lists are equal #
let equal: ([Int], [Int]) -> Bool =
    fun p, xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => x == y && equal(xs, ys)
    | _ => false end
in

# Initialize a list with a given length using an initializer function #
let init: (Int, Int -> Int) -> [Int] =
    fun len, f ->
        let go: (Int, [Int]) -> [Int] =
        fun idx, xs ->
            if idx < len 
            then go(idx + 1, xs @ [f(idx)])   
            else xs
        in
        go(0, [])
in

# Reduce a list from the left. #
let fold_left: ((Int, Int) -> Int, Int, [Int]) -> Int =
  fun f, acc, xs ->
    case xs 
    | [] => acc
    | hd::tl => fold_left(f, f(acc, hd), tl) end in

# Reduce a list from the right. #
let fold_right: ((Int, Int) -> Int, [Int], Int) -> Int =
  fun f, xs, acc ->
    case xs
    | [] => acc
    | hd::tl => f(hd, fold_right(f, tl, acc)) end in


666
LSP: Prelude: String parsed successfully
LSP: Prelude: Info map generated successfully
Debug: true, Constrain: Types
LSP: Init: Recieved string: # Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl
LSP: Init: String parsed successfully
  LSP: Syntax: Leftward is Complete Tile: <tl>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [?]
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {tl: [?], hd: ?, acc: ?, xs: ?, p: ((Int -> Bool), [Int]), filter: (((Int -> Bool), [Int]) -> [Int]), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in in
  LSP: Info: ALL errors:Error in term:
  p
Nature of error: type ((Int -> Bool), [Int]) is not consistent with arrow type
  LSP: Info: BidiCtx: Cls: List Concatenation
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Can insert left-concave or complete: tl
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: [?]
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: :: @
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: 
LSP: Generating Completions for prefix: tl
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: 
  LSP: Convex: Ty paths:
 [?]
? <= [?]
? <= [?]
  LSP: Convex: Target types: ?, [?]
  LSP: Convex: Backpack: 
  LSP: Convex: Base: tl hd acc xs [] _ ( [ case  if  let  type 
  LSP: Convex: Lookahead: ! ( () - AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position S Width [ [] _ abs abs_float acc acos asin atan bool_of_string case  ceil cos epsilon_float exp false filter float_of_int float_of_string floor fun  hd if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod nan neg_infinity p pi sin sqrt string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan test  tl true type  xs ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new_tokens ::= whitespace | ")" | "," | "::" | "@"
root ::= new_tokens

Top 20 Logits:
):18.0804
 end:15.0332
)):14.6944
);:14.454
 ):13.6267
),:12.9943
)]:12.3482
 @:11.6804
@:10.9177
));:10.737
))):10.6637
(:10.6438
)::10.5952
[:10.4765
)}:10.1734
;:10.1629
)(:9.95436
)":9.85884
).:9.74514
))]:9.70479
 t:9.67478

================
# Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl)

LSP: Prelude: Recieved string: ### List ###

# Add an element to the front of a list. #
let cons: (Int, [Int]) -> [Int] = fun x, xs -> x::xs in

# Determine the length of a list. #
let length: [Int] -> Int =
  fun xs ->
    case xs
    | [] => 0
    | _::xs => 1 + length(xs) end in

# Extract the first element of a list. #
let hd: [Int] -> Option =
  fun l ->
    case l
    | [] => None
    | x::xs => Some(x) end in

# Extract the rest of the list. #
let tl: [Int] -> [Int] =
  fun l ->
    case l
    | [] => []
    | x::xs => xs end in

# Determine if a list is empty. #
let is_empty: [Int] -> Bool =
  fun xs ->
    case xs
    | [] => true
    | _::_ => false end in

# Return the element at the index. #
let nth: ([Int], Int) -> Option =
  fun xs, n ->
    case xs, n
    | x::_, 0 => Some(x)
    | _::xs, n => nth(xs, n - 1)
    | [], _ => None end in

# Reverse a List. #
let rev: [Int] -> [Int] =
fun l -> 
let go: ([Int], [Int]) -> [Int] =
  fun xs, acc -> 
    case xs 
    | [] => acc 
    | x::xs => go(xs, x::acc) end in
go(l, []) in

# Check if two lists are equal #
let equal: ([Int], [Int]) -> Bool =
    fun p, xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => x == y && equal(xs, ys)
    | _ => false end
in

# Initialize a list with a given length using an initializer function #
let init: (Int, Int -> Int) -> [Int] =
    fun len, f ->
        let go: (Int, [Int]) -> [Int] =
        fun idx, xs ->
            if idx < len 
            then go(idx + 1, xs @ [f(idx)])   
            else xs
        in
        go(0, [])
in

# Reduce a list from the left. #
let fold_left: ((Int, Int) -> Int, Int, [Int]) -> Int =
  fun f, acc, xs ->
    case xs 
    | [] => acc
    | hd::tl => fold_left(f, f(acc, hd), tl) end in

# Reduce a list from the right. #
let fold_right: ((Int, Int) -> Int, [Int], Int) -> Int =
  fun f, xs, acc ->
    case xs
    | [] => acc
    | hd::tl => f(hd, fold_right(f, tl, acc)) end in


666
LSP: Prelude: String parsed successfully
LSP: Prelude: Info map generated successfully
Debug: true, Constrain: Types
LSP: Init: Recieved string: # Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl)
LSP: Init: String parsed successfully
  LSP: Syntax: Leftward is Complete Tile: <( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Parenthesized expression
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {tl: [?], hd: ?, acc: ?, xs: ?, p: ((Int -> Bool), [Int]), filter: (((Int -> Bool), [Int]) -> [Int]), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end in in
  LSP: Info: ALL errors:Error in term:
  p
Nature of error: type ((Int -> Bool), [Int]) is not consistent with arrow type
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: [?]
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: :: @
  LSP: Concave: Backpack: end
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: |
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new_tokens ::= whitespace | "," | "::" | "@" | "end" | "|"
root ::= new_tokens

Top 20 Logits:
 end:16.4291

:14.2595
 in:13.5936
 :13.4255
  :10.59
 go:9.8096
end:9.51747
 |:9.47358
 ::9.46197
    :9.33081
 else:9.15095
 #:8.9265
   :8.79971
      :8.74033
 @:8.64869
        :8.40936
                :8.16842
 (*:8.14928
 //:8.11494
 ():8.08061
 ;:8.079

================
# Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end

LSP: Prelude: Recieved string: ### List ###

# Add an element to the front of a list. #
let cons: (Int, [Int]) -> [Int] = fun x, xs -> x::xs in

# Determine the length of a list. #
let length: [Int] -> Int =
  fun xs ->
    case xs
    | [] => 0
    | _::xs => 1 + length(xs) end in

# Extract the first element of a list. #
let hd: [Int] -> Option =
  fun l ->
    case l
    | [] => None
    | x::xs => Some(x) end in

# Extract the rest of the list. #
let tl: [Int] -> [Int] =
  fun l ->
    case l
    | [] => []
    | x::xs => xs end in

# Determine if a list is empty. #
let is_empty: [Int] -> Bool =
  fun xs ->
    case xs
    | [] => true
    | _::_ => false end in

# Return the element at the index. #
let nth: ([Int], Int) -> Option =
  fun xs, n ->
    case xs, n
    | x::_, 0 => Some(x)
    | _::xs, n => nth(xs, n - 1)
    | [], _ => None end in

# Reverse a List. #
let rev: [Int] -> [Int] =
fun l -> 
let go: ([Int], [Int]) -> [Int] =
  fun xs, acc -> 
    case xs 
    | [] => acc 
    | x::xs => go(xs, x::acc) end in
go(l, []) in

# Check if two lists are equal #
let equal: ([Int], [Int]) -> Bool =
    fun p, xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => x == y && equal(xs, ys)
    | _ => false end
in

# Initialize a list with a given length using an initializer function #
let init: (Int, Int -> Int) -> [Int] =
    fun len, f ->
        let go: (Int, [Int]) -> [Int] =
        fun idx, xs ->
            if idx < len 
            then go(idx + 1, xs @ [f(idx)])   
            else xs
        in
        go(0, [])
in

# Reduce a list from the left. #
let fold_left: ((Int, Int) -> Int, Int, [Int]) -> Int =
  fun f, acc, xs ->
    case xs 
    | [] => acc
    | hd::tl => fold_left(f, f(acc, hd), tl) end in

# Reduce a list from the right. #
let fold_right: ((Int, Int) -> Int, [Int], Int) -> Int =
  fun f, xs, acc ->
    case xs
    | [] => acc
    | hd::tl => f(hd, fold_right(f, tl, acc)) end in


666
LSP: Prelude: String parsed successfully
LSP: Prelude: Info map generated successfully
Debug: true, Constrain: Types
LSP: Init: Recieved string: # Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end
LSP: Init: String parsed successfully
  LSP: Syntax: Leftward is Complete Tile: <case end>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Case expression
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {acc: ?, xs: ?, p: ((Int -> Bool), [Int]), filter: (((Int -> Bool), [Int]) -> [Int]), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: in in
  LSP: Info: ALL errors:Error in term:
  p
Nature of error: type ((Int -> Bool), [Int]) is not consistent with arrow type
  LSP: Info: BidiCtx: Cls: Function literal
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: [?]
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: :: @
  LSP: Concave: Backpack: in
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new_tokens ::= whitespace | "," | "::" | "@" | "in"
root ::= new_tokens

Top 20 Logits:
 in:18.2226

:16.2781
 :15.6435
 end:12.9349
;:12.3975
  :12.2492
):11.9958
 if:11.9232
.:10.7957
    :10.7511
 else:10.6882
 (:10.4793
 fun:10.4778
 ):10.4686
,:10.2283
 go:9.99972
 ():9.8909
   :9.88391
in:9.87614
 and:9.84734
 &&:9.75617

================
# Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in

LSP: Prelude: Recieved string: ### List ###

# Add an element to the front of a list. #
let cons: (Int, [Int]) -> [Int] = fun x, xs -> x::xs in

# Determine the length of a list. #
let length: [Int] -> Int =
  fun xs ->
    case xs
    | [] => 0
    | _::xs => 1 + length(xs) end in

# Extract the first element of a list. #
let hd: [Int] -> Option =
  fun l ->
    case l
    | [] => None
    | x::xs => Some(x) end in

# Extract the rest of the list. #
let tl: [Int] -> [Int] =
  fun l ->
    case l
    | [] => []
    | x::xs => xs end in

# Determine if a list is empty. #
let is_empty: [Int] -> Bool =
  fun xs ->
    case xs
    | [] => true
    | _::_ => false end in

# Return the element at the index. #
let nth: ([Int], Int) -> Option =
  fun xs, n ->
    case xs, n
    | x::_, 0 => Some(x)
    | _::xs, n => nth(xs, n - 1)
    | [], _ => None end in

# Reverse a List. #
let rev: [Int] -> [Int] =
fun l -> 
let go: ([Int], [Int]) -> [Int] =
  fun xs, acc -> 
    case xs 
    | [] => acc 
    | x::xs => go(xs, x::acc) end in
go(l, []) in

# Check if two lists are equal #
let equal: ([Int], [Int]) -> Bool =
    fun p, xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => x == y && equal(xs, ys)
    | _ => false end
in

# Initialize a list with a given length using an initializer function #
let init: (Int, Int -> Int) -> [Int] =
    fun len, f ->
        let go: (Int, [Int]) -> [Int] =
        fun idx, xs ->
            if idx < len 
            then go(idx + 1, xs @ [f(idx)])   
            else xs
        in
        go(0, [])
in

# Reduce a list from the left. #
let fold_left: ((Int, Int) -> Int, Int, [Int]) -> Int =
  fun f, acc, xs ->
    case xs 
    | [] => acc
    | hd::tl => fold_left(f, f(acc, hd), tl) end in

# Reduce a list from the right. #
let fold_right: ((Int, Int) -> Int, [Int], Int) -> Int =
  fun f, xs, acc ->
    case xs
    | [] => acc
    | hd::tl => f(hd, fold_right(f, tl, acc)) end in


666
LSP: Prelude: String parsed successfully
LSP: Prelude: Info map generated successfully
Debug: true, Constrain: Types
LSP: Init: Recieved string: # Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
LSP: Init: String parsed successfully
  LSP: Syntax: Leftward is Complete Tile: <let = in<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [Int]
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {go: ((?, ?) -> [?]), p: ((Int -> Bool), [Int]), filter: (((Int -> Bool), [Int]) -> [Int]), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: in
  LSP: Info: ALL errors:Error in term:
  p
Nature of error: type ((Int -> Bool), [Int]) is not consistent with arrow type
  LSP: Info: BidiCtx: Cls: Function literal
  LSP: Info: BidiCtx: Expected type: (((Int -> Bool), [Int]) -> [Int])
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 [Int]
Int <= [Int]
Int <= [Int]
  LSP: Convex: Target types: Int, [Int]
  LSP: Convex: Backpack: 
  LSP: Convex: Base: [] _ ( [ case  if  let  type 
  LSP: Convex: Lookahead: ( - [ [] _ abs case  filter go if  int_of_float int_of_string let  max_int min_int mod string_compare string_length type  ~INTLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new_tokens ::= whitespace | "(" | "-" | "[" | "[]" | "_" | "abs" | "case " | "filter" | "go" | "if " | "int_of_float" | "int_of_string" | "let " | "max_int" | "min_int" | "mod" | "string_compare" | "string_length" | "type " | intlit
root ::= new_tokens

Top 20 Logits:

:18.7425
 :17.2852
 go:15.8125
  :14.13
 (:13.8107
    :13.6721
      :12.3416
        :11.9657
   :11.4581
            :11.3964
                :11.2981
 fol:11.2147
       :10.9361
          :10.862
     :10.7845
	:10.4396
 fun:10.3163
         :10.3117
 acc:10.1584
 //:10.1567
 #:10.1059

================
# Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in


LSP: Prelude: Recieved string: ### List ###

# Add an element to the front of a list. #
let cons: (Int, [Int]) -> [Int] = fun x, xs -> x::xs in

# Determine the length of a list. #
let length: [Int] -> Int =
  fun xs ->
    case xs
    | [] => 0
    | _::xs => 1 + length(xs) end in

# Extract the first element of a list. #
let hd: [Int] -> Option =
  fun l ->
    case l
    | [] => None
    | x::xs => Some(x) end in

# Extract the rest of the list. #
let tl: [Int] -> [Int] =
  fun l ->
    case l
    | [] => []
    | x::xs => xs end in

# Determine if a list is empty. #
let is_empty: [Int] -> Bool =
  fun xs ->
    case xs
    | [] => true
    | _::_ => false end in

# Return the element at the index. #
let nth: ([Int], Int) -> Option =
  fun xs, n ->
    case xs, n
    | x::_, 0 => Some(x)
    | _::xs, n => nth(xs, n - 1)
    | [], _ => None end in

# Reverse a List. #
let rev: [Int] -> [Int] =
fun l -> 
let go: ([Int], [Int]) -> [Int] =
  fun xs, acc -> 
    case xs 
    | [] => acc 
    | x::xs => go(xs, x::acc) end in
go(l, []) in

# Check if two lists are equal #
let equal: ([Int], [Int]) -> Bool =
    fun p, xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => x == y && equal(xs, ys)
    | _ => false end
in

# Initialize a list with a given length using an initializer function #
let init: (Int, Int -> Int) -> [Int] =
    fun len, f ->
        let go: (Int, [Int]) -> [Int] =
        fun idx, xs ->
            if idx < len 
            then go(idx + 1, xs @ [f(idx)])   
            else xs
        in
        go(0, [])
in

# Reduce a list from the left. #
let fold_left: ((Int, Int) -> Int, Int, [Int]) -> Int =
  fun f, acc, xs ->
    case xs 
    | [] => acc
    | hd::tl => fold_left(f, f(acc, hd), tl) end in

# Reduce a list from the right. #
let fold_right: ((Int, Int) -> Int, [Int], Int) -> Int =
  fun f, xs, acc ->
    case xs
    | [] => acc
    | hd::tl => f(hd, fold_right(f, tl, acc)) end in


666
LSP: Prelude: String parsed successfully
LSP: Prelude: Info map generated successfully
Debug: true, Constrain: Types
LSP: Init: Recieved string: # Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in

LSP: Init: String parsed successfully
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: <let = in<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [Int]
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {go: ((?, ?) -> [?]), p: ((Int -> Bool), [Int]), filter: (((Int -> Bool), [Int]) -> [Int]), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: in
  LSP: Info: ALL errors:Error in term:
  p
Nature of error: type ((Int -> Bool), [Int]) is not consistent with arrow type
  LSP: Info: BidiCtx: Cls: Function literal
  LSP: Info: BidiCtx: Expected type: (((Int -> Bool), [Int]) -> [Int])
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 [Int]
Int <= [Int]
Int <= [Int]
  LSP: Convex: Target types: Int, [Int]
  LSP: Convex: Backpack: 
  LSP: Convex: Base: [] _ ( [ case  if  let  type 
  LSP: Convex: Lookahead: ( - [ [] _ abs case  filter go if  int_of_float int_of_string let  max_int min_int mod string_compare string_length type  ~INTLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new_tokens ::= whitespace | "(" | "-" | "[" | "[]" | "_" | "abs" | "case " | "filter" | "go" | "if " | "int_of_float" | "int_of_string" | "let " | "max_int" | "min_int" | "mod" | "string_compare" | "string_length" | "type " | intlit
root ::= new_tokens

Top 20 Logits:
   :17.6026
 :16.1688
       :15.5689
     :15.4952
    :14.2184
  :13.6972
go:13.5524

:13.5349
      :12.7605
         :12.5608
           :11.9508
        :11.851
(:11.7364
let:11.3339
 go:11.185
	:11.1327
                :11.0832
fun:10.8543
in:10.6751
               :10.5111
          :10.487

================
# Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
   

LSP: Prelude: Recieved string: ### List ###

# Add an element to the front of a list. #
let cons: (Int, [Int]) -> [Int] = fun x, xs -> x::xs in

# Determine the length of a list. #
let length: [Int] -> Int =
  fun xs ->
    case xs
    | [] => 0
    | _::xs => 1 + length(xs) end in

# Extract the first element of a list. #
let hd: [Int] -> Option =
  fun l ->
    case l
    | [] => None
    | x::xs => Some(x) end in

# Extract the rest of the list. #
let tl: [Int] -> [Int] =
  fun l ->
    case l
    | [] => []
    | x::xs => xs end in

# Determine if a list is empty. #
let is_empty: [Int] -> Bool =
  fun xs ->
    case xs
    | [] => true
    | _::_ => false end in

# Return the element at the index. #
let nth: ([Int], Int) -> Option =
  fun xs, n ->
    case xs, n
    | x::_, 0 => Some(x)
    | _::xs, n => nth(xs, n - 1)
    | [], _ => None end in

# Reverse a List. #
let rev: [Int] -> [Int] =
fun l -> 
let go: ([Int], [Int]) -> [Int] =
  fun xs, acc -> 
    case xs 
    | [] => acc 
    | x::xs => go(xs, x::acc) end in
go(l, []) in

# Check if two lists are equal #
let equal: ([Int], [Int]) -> Bool =
    fun p, xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => x == y && equal(xs, ys)
    | _ => false end
in

# Initialize a list with a given length using an initializer function #
let init: (Int, Int -> Int) -> [Int] =
    fun len, f ->
        let go: (Int, [Int]) -> [Int] =
        fun idx, xs ->
            if idx < len 
            then go(idx + 1, xs @ [f(idx)])   
            else xs
        in
        go(0, [])
in

# Reduce a list from the left. #
let fold_left: ((Int, Int) -> Int, Int, [Int]) -> Int =
  fun f, acc, xs ->
    case xs 
    | [] => acc
    | hd::tl => fold_left(f, f(acc, hd), tl) end in

# Reduce a list from the right. #
let fold_right: ((Int, Int) -> Int, [Int], Int) -> Int =
  fun f, xs, acc ->
    case xs
    | [] => acc
    | hd::tl => f(hd, fold_right(f, tl, acc)) end in


666
LSP: Prelude: String parsed successfully
LSP: Prelude: Info map generated successfully
Debug: true, Constrain: Types
LSP: Init: Recieved string: # Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
   
LSP: Init: String parsed successfully
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: <let = in<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [Int]
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {go: ((?, ?) -> [?]), p: ((Int -> Bool), [Int]), filter: (((Int -> Bool), [Int]) -> [Int]), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: in
  LSP: Info: ALL errors:Error in term:
  p
Nature of error: type ((Int -> Bool), [Int]) is not consistent with arrow type
  LSP: Info: BidiCtx: Cls: Function literal
  LSP: Info: BidiCtx: Expected type: (((Int -> Bool), [Int]) -> [Int])
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 [Int]
Int <= [Int]
Int <= [Int]
  LSP: Convex: Target types: Int, [Int]
  LSP: Convex: Backpack: 
  LSP: Convex: Base: [] _ ( [ case  if  let  type 
  LSP: Convex: Lookahead: ( - [ [] _ abs case  filter go if  int_of_float int_of_string let  max_int min_int mod string_compare string_length type  ~INTLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new_tokens ::= whitespace | "(" | "-" | "[" | "[]" | "_" | "abs" | "case " | "filter" | "go" | "if " | "int_of_float" | "int_of_string" | "let " | "max_int" | "min_int" | "mod" | "string_compare" | "string_length" | "type " | intlit
root ::= new_tokens

Top 20 Logits:
 go:16.9972
 fun:15.2365
 (:15.0057
 let:12.5731
 xs:11.8177
 lambda:11.6077
 {:11.3826
 fol:11.0697
 list:11.0641
 ((:10.9556
 p:10.4585
 rev:10.4559
 acc:10.2355
 function:10.0983
 in:10.0743
 reverse:10.0481
 #:10.0185
 List:10.0087
 cur:9.96565
 func:9.92054
 fn:9.60783

================
# Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go

LSP: Prelude: Recieved string: ### List ###

# Add an element to the front of a list. #
let cons: (Int, [Int]) -> [Int] = fun x, xs -> x::xs in

# Determine the length of a list. #
let length: [Int] -> Int =
  fun xs ->
    case xs
    | [] => 0
    | _::xs => 1 + length(xs) end in

# Extract the first element of a list. #
let hd: [Int] -> Option =
  fun l ->
    case l
    | [] => None
    | x::xs => Some(x) end in

# Extract the rest of the list. #
let tl: [Int] -> [Int] =
  fun l ->
    case l
    | [] => []
    | x::xs => xs end in

# Determine if a list is empty. #
let is_empty: [Int] -> Bool =
  fun xs ->
    case xs
    | [] => true
    | _::_ => false end in

# Return the element at the index. #
let nth: ([Int], Int) -> Option =
  fun xs, n ->
    case xs, n
    | x::_, 0 => Some(x)
    | _::xs, n => nth(xs, n - 1)
    | [], _ => None end in

# Reverse a List. #
let rev: [Int] -> [Int] =
fun l -> 
let go: ([Int], [Int]) -> [Int] =
  fun xs, acc -> 
    case xs 
    | [] => acc 
    | x::xs => go(xs, x::acc) end in
go(l, []) in

# Check if two lists are equal #
let equal: ([Int], [Int]) -> Bool =
    fun p, xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => x == y && equal(xs, ys)
    | _ => false end
in

# Initialize a list with a given length using an initializer function #
let init: (Int, Int -> Int) -> [Int] =
    fun len, f ->
        let go: (Int, [Int]) -> [Int] =
        fun idx, xs ->
            if idx < len 
            then go(idx + 1, xs @ [f(idx)])   
            else xs
        in
        go(0, [])
in

# Reduce a list from the left. #
let fold_left: ((Int, Int) -> Int, Int, [Int]) -> Int =
  fun f, acc, xs ->
    case xs 
    | [] => acc
    | hd::tl => fold_left(f, f(acc, hd), tl) end in

# Reduce a list from the right. #
let fold_right: ((Int, Int) -> Int, [Int], Int) -> Int =
  fun f, xs, acc ->
    case xs
    | [] => acc
    | hd::tl => f(hd, fold_right(f, tl, acc)) end in


666
LSP: Prelude: String parsed successfully
LSP: Prelude: Info map generated successfully
Debug: true, Constrain: Types
LSP: Init: Recieved string: # Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go
LSP: Init: String parsed successfully
  LSP: Syntax: Leftward is Complete Tile: <go>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [Int]
  LSP: Info: Seft type: ((?, ?) -> [?])
  LSP: Info: Error Status: (Exp
   (Common
      (Inconsistent
         Expectation {ana = (List Int);
           syn =
           (Arrow ((Prod [(Unknown Internal); (Unknown Internal)]),
              (List (Unknown SynSwitch))))})))
  LSP: Info: Typing Context: {go: ((?, ?) -> [?]), p: ((Int -> Bool), [Int]), filter: (((Int -> Bool), [Int]) -> [Int]), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: in
  LSP: Info: ALL errors:Error in term:
  go
Nature of error: Expecting type [Int] but got inconsistent type ((?, ?) -> [?])    
Error in term:
  p
Nature of error: type ((Int -> Bool), [Int]) is not consistent with arrow type
  LSP: Info: BidiCtx: Cls: Function literal
  LSP: Info: BidiCtx: Expected type: (((Int -> Bool), [Int]) -> [Int])
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-concave or complete: go
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: ((?, ?) -> [?])
  LSP: Concave: Infix: Base: 
  LSP: Concave: Infix: Lookahead types: (((Int -> Bool), [Int]) -> [Int])
  LSP: Concave: Infix: Lookahead: 
  LSP: Concave: Backpack: in
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: go
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: (((Int -> Bool), [Int]) -> [Int])
  LSP: Concave: Infix: Lookahead: 
  LSP: Concave: Backpack: in
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: (
  LSP: Convex: Ty paths:
 [Int]
Int <= [Int]
Int <= [Int]
  LSP: Convex: Target types: Int, [Int]
  LSP: Convex: Backpack: 
  LSP: Convex: Base: [] _ ( [ case  if  let  type 
  LSP: Convex: Lookahead: ( - [ [] _ abs case  filter go if  int_of_float int_of_string let  max_int min_int mod string_compare string_length type  ~INTLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new_tokens ::= whitespace | "(" | "in"
root ::= new_tokens

Top 20 Logits:
(:16.19
 in:15.0685

:14.7868
 end:13.8264
([:13.6335
 :13.6242
((:13.416
 (:13.2531
():12.2066
 ((:12.0921
 ([:11.9898
 xs:11.649
(_:11.4203
 >>:11.0256
 ():10.7849
.:10.7232
 ->:10.5821
;:10.5097
 _:10.2627
.(:9.97539
 (*:9.72371

================
# Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(

LSP: Prelude: Recieved string: ### List ###

# Add an element to the front of a list. #
let cons: (Int, [Int]) -> [Int] = fun x, xs -> x::xs in

# Determine the length of a list. #
let length: [Int] -> Int =
  fun xs ->
    case xs
    | [] => 0
    | _::xs => 1 + length(xs) end in

# Extract the first element of a list. #
let hd: [Int] -> Option =
  fun l ->
    case l
    | [] => None
    | x::xs => Some(x) end in

# Extract the rest of the list. #
let tl: [Int] -> [Int] =
  fun l ->
    case l
    | [] => []
    | x::xs => xs end in

# Determine if a list is empty. #
let is_empty: [Int] -> Bool =
  fun xs ->
    case xs
    | [] => true
    | _::_ => false end in

# Return the element at the index. #
let nth: ([Int], Int) -> Option =
  fun xs, n ->
    case xs, n
    | x::_, 0 => Some(x)
    | _::xs, n => nth(xs, n - 1)
    | [], _ => None end in

# Reverse a List. #
let rev: [Int] -> [Int] =
fun l -> 
let go: ([Int], [Int]) -> [Int] =
  fun xs, acc -> 
    case xs 
    | [] => acc 
    | x::xs => go(xs, x::acc) end in
go(l, []) in

# Check if two lists are equal #
let equal: ([Int], [Int]) -> Bool =
    fun p, xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => x == y && equal(xs, ys)
    | _ => false end
in

# Initialize a list with a given length using an initializer function #
let init: (Int, Int -> Int) -> [Int] =
    fun len, f ->
        let go: (Int, [Int]) -> [Int] =
        fun idx, xs ->
            if idx < len 
            then go(idx + 1, xs @ [f(idx)])   
            else xs
        in
        go(0, [])
in

# Reduce a list from the left. #
let fold_left: ((Int, Int) -> Int, Int, [Int]) -> Int =
  fun f, acc, xs ->
    case xs 
    | [] => acc
    | hd::tl => fold_left(f, f(acc, hd), tl) end in

# Reduce a list from the right. #
let fold_right: ((Int, Int) -> Int, [Int], Int) -> Int =
  fun f, xs, acc ->
    case xs
    | [] => acc
    | hd::tl => f(hd, fold_right(f, tl, acc)) end in


666
LSP: Prelude: String parsed successfully
LSP: Prelude: Info map generated successfully
Debug: true, Constrain: Types
LSP: Init: Recieved string: # Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(
LSP: Init: String parsed successfully
  LSP: Syntax: Leftward is Incomplete Tile: >( )<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: (?, ?)
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {go: ((?, ?) -> [?]), p: ((Int -> Bool), [Int]), filter: (((Int -> Bool), [Int]) -> [Int]), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) in
  LSP: Info: ALL errors:Error in term:
  p
Nature of error: type ((Int -> Bool), [Int]) is not consistent with arrow type
  LSP: Info: BidiCtx: Cls: Empty expression hole
  LSP: Info: BidiCtx: Expected type: (?, ?)
  LSP: Info: Bidi Parent Cls: Application
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [Int]
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {go: ((?, ?) -> [?]), p: ((Int -> Bool), [Int]), filter: (((Int -> Bool), [Int]) -> [Int]), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) in
  LSP: Info: ALL errors:Error in term:
  p
Nature of error: type ((Int -> Bool), [Int]) is not consistent with arrow type
  LSP: Info: BidiCtx: Cls: Function literal
  LSP: Info: BidiCtx: Expected type: (((Int -> Bool), [Int]) -> [Int])
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-convex or complete: (
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 (?, ?)
? <= (?, ?)
? <= (?, ?)
  LSP: Convex: Target types: ?, (?, ?)
  LSP: Convex: Backpack: 
  LSP: Convex: Base: p _ ( case  if  let  type 
  LSP: Convex: Lookahead: ! ( () - AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position S Width [ [] _ abs abs_float acos asin atan bool_of_string case  ceil cos epsilon_float exp false filter float_of_int float_of_string floor fun  go if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod nan neg_infinity p pi sin sqrt string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan test  true type  ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Generating Completions for prefix: (
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: (((Int -> Bool), [Int]) -> [Int])
  LSP: Concave: Infix: Lookahead: 
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: 
  LSP: Convex: Ty paths:
 [Int]
Int <= [Int]
Int <= [Int]
  LSP: Convex: Target types: Int, [Int]
  LSP: Convex: Backpack: 
  LSP: Convex: Base: [] _ ( [ case  if  let  type 
  LSP: Convex: Lookahead: ( - [ [] _ abs case  filter go if  int_of_float int_of_string let  max_int min_int mod string_compare string_length type  ~INTLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new_tokens ::= whitespace | "!" | "(" | "()" | "-" | "AlignItems" | "BackgroundColor" | "Border" | "BorderRadius" | "BoxShadow" | "Color" | "Cursor" | "Display" | "FlexDirection" | "FontFamily" | "FontSize" | "FontStyle" | "Gap" | "Height" | "JustifyContent" | "Margin" | "Opacity" | "Outline" | "Overflow" | "Padding" | "Position" | "S" | "Width" | "[" | "[]" | "_" | "abs" | "abs_float" | "acos" | "asin" | "atan" | "bool_of_string" | "case " | "ceil" | "cos" | "epsilon_float" | "exp" | "false" | "filter" | "float_of_int" | "float_of_string" | "floor" | "fun " | "go" | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "nan" | "neg_infinity" | "p" | "pi" | "sin" | "sqrt" | "string_compare" | "string_concat" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "true" | "type " | floatlit | intlit | stringlit
root ::= new_tokens

Top 20 Logits:
_,:14.8512
xs:14.8028
rev:12.7955
,:12.3234
p:12.2474
acc:11.8994
this:11.5789
x:11.2952
reverse:10.9649
list:10.8681
l:10.714
filter:10.6235
length:10.5366
go:10.475
self:10.4327
.,:10.3094
fold:10.3087
0:10.1271
len:10.117
tl:10.0323
f:9.71107

================
# Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p

LSP: Prelude: Recieved string: ### List ###

# Add an element to the front of a list. #
let cons: (Int, [Int]) -> [Int] = fun x, xs -> x::xs in

# Determine the length of a list. #
let length: [Int] -> Int =
  fun xs ->
    case xs
    | [] => 0
    | _::xs => 1 + length(xs) end in

# Extract the first element of a list. #
let hd: [Int] -> Option =
  fun l ->
    case l
    | [] => None
    | x::xs => Some(x) end in

# Extract the rest of the list. #
let tl: [Int] -> [Int] =
  fun l ->
    case l
    | [] => []
    | x::xs => xs end in

# Determine if a list is empty. #
let is_empty: [Int] -> Bool =
  fun xs ->
    case xs
    | [] => true
    | _::_ => false end in

# Return the element at the index. #
let nth: ([Int], Int) -> Option =
  fun xs, n ->
    case xs, n
    | x::_, 0 => Some(x)
    | _::xs, n => nth(xs, n - 1)
    | [], _ => None end in

# Reverse a List. #
let rev: [Int] -> [Int] =
fun l -> 
let go: ([Int], [Int]) -> [Int] =
  fun xs, acc -> 
    case xs 
    | [] => acc 
    | x::xs => go(xs, x::acc) end in
go(l, []) in

# Check if two lists are equal #
let equal: ([Int], [Int]) -> Bool =
    fun p, xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => x == y && equal(xs, ys)
    | _ => false end
in

# Initialize a list with a given length using an initializer function #
let init: (Int, Int -> Int) -> [Int] =
    fun len, f ->
        let go: (Int, [Int]) -> [Int] =
        fun idx, xs ->
            if idx < len 
            then go(idx + 1, xs @ [f(idx)])   
            else xs
        in
        go(0, [])
in

# Reduce a list from the left. #
let fold_left: ((Int, Int) -> Int, Int, [Int]) -> Int =
  fun f, acc, xs ->
    case xs 
    | [] => acc
    | hd::tl => fold_left(f, f(acc, hd), tl) end in

# Reduce a list from the right. #
let fold_right: ((Int, Int) -> Int, [Int], Int) -> Int =
  fun f, xs, acc ->
    case xs
    | [] => acc
    | hd::tl => f(hd, fold_right(f, tl, acc)) end in


666
LSP: Prelude: String parsed successfully
LSP: Prelude: Info map generated successfully
Debug: true, Constrain: Types
LSP: Init: Recieved string: # Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p
LSP: Init: String parsed successfully
  LSP: Syntax: Leftward is Complete Tile: <p>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: (?, ?)
  LSP: Info: Seft type: ((Int -> Bool), [Int])
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {go: ((?, ?) -> [?]), p: ((Int -> Bool), [Int]), filter: (((Int -> Bool), [Int]) -> [Int]), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) in
  LSP: Info: ALL errors:Error in term:
  p
Nature of error: type ((Int -> Bool), [Int]) is not consistent with arrow type
  LSP: Info: BidiCtx: Cls: Variable reference
  LSP: Info: BidiCtx: Expected type: (?, ?)
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Can insert left-concave or complete: p
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: ((Int -> Bool), [Int])
  LSP: Concave: Infix: Base: 
  LSP: Concave: Infix: Lookahead types: ?, (?, ?)
  LSP: Concave: Infix: Lookahead: ::
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: ::
  LSP: Concave: Postfix: 
LSP: Generating Completions for prefix: p
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: 
  LSP: Concave: Infix: Lookahead types: ?, (?, ?)
  LSP: Concave: Infix: Lookahead: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: 
  LSP: Convex: Ty paths:
 (?, ?)
? <= (?, ?)
? <= (?, ?)
  LSP: Convex: Target types: ?, (?, ?)
  LSP: Convex: Backpack: 
  LSP: Convex: Base: p _ ( case  if  let  type 
  LSP: Convex: Lookahead: ! ( () - AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position S Width [ [] _ abs abs_float acos asin atan bool_of_string case  ceil cos epsilon_float exp false filter float_of_int float_of_string floor fun  go if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod nan neg_infinity p pi sin sqrt string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan test  true type  ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "i"
new_tokens ::= whitespace | ")" | "::"
root ::= completions | new_tokens

Top 20 Logits:
,:16.5313
):15.1091
,[:12.3906
(),:11.9267
(:11.8004
.:11.7042
);:11.4119
([:11.4088
 ,:11.3067
::11.181
()):11.0567
[:10.7061
:::10.3203
)[:10.1455
)(:9.84199
 in:9.78099
 [],:9.74815
 xs:9.64786
)):9.63872
),:9.6113
 (:9.59273

================
# Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p)

LSP: Prelude: Recieved string: ### List ###

# Add an element to the front of a list. #
let cons: (Int, [Int]) -> [Int] = fun x, xs -> x::xs in

# Determine the length of a list. #
let length: [Int] -> Int =
  fun xs ->
    case xs
    | [] => 0
    | _::xs => 1 + length(xs) end in

# Extract the first element of a list. #
let hd: [Int] -> Option =
  fun l ->
    case l
    | [] => None
    | x::xs => Some(x) end in

# Extract the rest of the list. #
let tl: [Int] -> [Int] =
  fun l ->
    case l
    | [] => []
    | x::xs => xs end in

# Determine if a list is empty. #
let is_empty: [Int] -> Bool =
  fun xs ->
    case xs
    | [] => true
    | _::_ => false end in

# Return the element at the index. #
let nth: ([Int], Int) -> Option =
  fun xs, n ->
    case xs, n
    | x::_, 0 => Some(x)
    | _::xs, n => nth(xs, n - 1)
    | [], _ => None end in

# Reverse a List. #
let rev: [Int] -> [Int] =
fun l -> 
let go: ([Int], [Int]) -> [Int] =
  fun xs, acc -> 
    case xs 
    | [] => acc 
    | x::xs => go(xs, x::acc) end in
go(l, []) in

# Check if two lists are equal #
let equal: ([Int], [Int]) -> Bool =
    fun p, xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => x == y && equal(xs, ys)
    | _ => false end
in

# Initialize a list with a given length using an initializer function #
let init: (Int, Int -> Int) -> [Int] =
    fun len, f ->
        let go: (Int, [Int]) -> [Int] =
        fun idx, xs ->
            if idx < len 
            then go(idx + 1, xs @ [f(idx)])   
            else xs
        in
        go(0, [])
in

# Reduce a list from the left. #
let fold_left: ((Int, Int) -> Int, Int, [Int]) -> Int =
  fun f, acc, xs ->
    case xs 
    | [] => acc
    | hd::tl => fold_left(f, f(acc, hd), tl) end in

# Reduce a list from the right. #
let fold_right: ((Int, Int) -> Int, [Int], Int) -> Int =
  fun f, xs, acc ->
    case xs
    | [] => acc
    | hd::tl => f(hd, fold_right(f, tl, acc)) end in


666
LSP: Prelude: String parsed successfully
LSP: Prelude: Info map generated successfully
Debug: true, Constrain: Types
LSP: Init: Recieved string: # Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p)
LSP: Init: String parsed successfully
  LSP: Syntax: Leftward is Complete Tile: >( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [Int]
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {go: ((?, ?) -> [?]), p: ((Int -> Bool), [Int]), filter: (((Int -> Bool), [Int]) -> [Int]), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: in
  LSP: Info: ALL errors:Error in term:
  p
Nature of error: type ((Int -> Bool), [Int]) is not consistent with arrow type
  LSP: Info: BidiCtx: Cls: Function literal
  LSP: Info: BidiCtx: Expected type: (((Int -> Bool), [Int]) -> [Int])
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: [?]
  LSP: Concave: Infix: Base: @
  LSP: Concave: Infix: Lookahead types: (((Int -> Bool), [Int]) -> [Int])
  LSP: Concave: Infix: Lookahead: 
  LSP: Concave: Backpack: in
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: @
  LSP: Concave: Postfix: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new_tokens ::= whitespace | "@" | "in"
root ::= new_tokens

Top 20 Logits:
 in:14.1266

:13.7547
 :12.1437
 end:12.0219
 (:10.637
([:10.5509
 ([:9.77597
  :9.29167
():8.72693
in:8.7052
 []:8.56393
    :8.5125
 ():8.37896
 and:8.36781
 ((:8.25367
end:8.2406
 acc:8.22352
 [:8.13915
 ~:8.04159
 (*:7.78037
 ->:7.75152

================
# Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

LSP: Prelude: Recieved string: ### List ###

# Add an element to the front of a list. #
let cons: (Int, [Int]) -> [Int] = fun x, xs -> x::xs in

# Determine the length of a list. #
let length: [Int] -> Int =
  fun xs ->
    case xs
    | [] => 0
    | _::xs => 1 + length(xs) end in

# Extract the first element of a list. #
let hd: [Int] -> Option =
  fun l ->
    case l
    | [] => None
    | x::xs => Some(x) end in

# Extract the rest of the list. #
let tl: [Int] -> [Int] =
  fun l ->
    case l
    | [] => []
    | x::xs => xs end in

# Determine if a list is empty. #
let is_empty: [Int] -> Bool =
  fun xs ->
    case xs
    | [] => true
    | _::_ => false end in

# Return the element at the index. #
let nth: ([Int], Int) -> Option =
  fun xs, n ->
    case xs, n
    | x::_, 0 => Some(x)
    | _::xs, n => nth(xs, n - 1)
    | [], _ => None end in

# Reverse a List. #
let rev: [Int] -> [Int] =
fun l -> 
let go: ([Int], [Int]) -> [Int] =
  fun xs, acc -> 
    case xs 
    | [] => acc 
    | x::xs => go(xs, x::acc) end in
go(l, []) in

# Check if two lists are equal #
let equal: ([Int], [Int]) -> Bool =
    fun p, xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => x == y && equal(xs, ys)
    | _ => false end
in

# Initialize a list with a given length using an initializer function #
let init: (Int, Int -> Int) -> [Int] =
    fun len, f ->
        let go: (Int, [Int]) -> [Int] =
        fun idx, xs ->
            if idx < len 
            then go(idx + 1, xs @ [f(idx)])   
            else xs
        in
        go(0, [])
in

# Reduce a list from the left. #
let fold_left: ((Int, Int) -> Int, Int, [Int]) -> Int =
  fun f, acc, xs ->
    case xs 
    | [] => acc
    | hd::tl => fold_left(f, f(acc, hd), tl) end in

# Reduce a list from the right. #
let fold_right: ((Int, Int) -> Int, [Int], Int) -> Int =
  fun f, xs, acc ->
    case xs
    | [] => acc
    | hd::tl => f(hd, fold_right(f, tl, acc)) end in


666
LSP: Prelude: String parsed successfully
LSP: Prelude: Info map generated successfully
Debug: true, Constrain: Types
LSP: Init: Recieved string: # Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in
LSP: Init: String parsed successfully
  LSP: Syntax: Leftward is Complete Tile: <let = in<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {filter: (((Int -> Bool), [Int]) -> [Int]), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: 
  LSP: Info: ALL errors:Error in term:
  p
Nature of error: type ((Int -> Bool), [Int]) is not consistent with arrow type
  LSP: Info: BidiCtx: Cls: Let expression
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent: Root
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 ?
  LSP: Convex: Target types: ?
  LSP: Convex: Backpack: 
  LSP: Convex: Base: filter string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position Width S () [] _ false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: ! ( () - AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position S Width [ [] _ abs abs_float acos asin atan bool_of_string case  ceil cos epsilon_float exp false filter float_of_int float_of_string floor fun  if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod nan neg_infinity pi sin sqrt string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan test  true type  ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new_tokens ::= whitespace | "!" | "(" | "()" | "-" | "AlignItems" | "BackgroundColor" | "Border" | "BorderRadius" | "BoxShadow" | "Color" | "Cursor" | "Display" | "FlexDirection" | "FontFamily" | "FontSize" | "FontStyle" | "Gap" | "Height" | "JustifyContent" | "Margin" | "Opacity" | "Outline" | "Overflow" | "Padding" | "Position" | "S" | "Width" | "[" | "[]" | "_" | "abs" | "abs_float" | "acos" | "asin" | "atan" | "bool_of_string" | "case " | "ceil" | "cos" | "epsilon_float" | "exp" | "false" | "filter" | "float_of_int" | "float_of_string" | "floor" | "fun " | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "nan" | "neg_infinity" | "pi" | "sin" | "sqrt" | "string_compare" | "string_concat" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "true" | "type " | floatlit | intlit | stringlit
root ::= new_tokens

Top 20 Logits:

:17.4472
 :15.1071
  :12.8693
    :12.3141
      :10.8809
 rev:10.7098
   :10.5682
;:10.3938
 #:10.2384
        :10.2192
                :10.1702
       :9.99173
            :9.72032
 fol:9.59482
     :9.47116
 reverse:9.43762
	:9.34087
 (:9.30921
          :9.19323
 //:8.99064
 filter:8.75033

================
# Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in


LSP: Prelude: Recieved string: ### List ###

# Add an element to the front of a list. #
let cons: (Int, [Int]) -> [Int] = fun x, xs -> x::xs in

# Determine the length of a list. #
let length: [Int] -> Int =
  fun xs ->
    case xs
    | [] => 0
    | _::xs => 1 + length(xs) end in

# Extract the first element of a list. #
let hd: [Int] -> Option =
  fun l ->
    case l
    | [] => None
    | x::xs => Some(x) end in

# Extract the rest of the list. #
let tl: [Int] -> [Int] =
  fun l ->
    case l
    | [] => []
    | x::xs => xs end in

# Determine if a list is empty. #
let is_empty: [Int] -> Bool =
  fun xs ->
    case xs
    | [] => true
    | _::_ => false end in

# Return the element at the index. #
let nth: ([Int], Int) -> Option =
  fun xs, n ->
    case xs, n
    | x::_, 0 => Some(x)
    | _::xs, n => nth(xs, n - 1)
    | [], _ => None end in

# Reverse a List. #
let rev: [Int] -> [Int] =
fun l -> 
let go: ([Int], [Int]) -> [Int] =
  fun xs, acc -> 
    case xs 
    | [] => acc 
    | x::xs => go(xs, x::acc) end in
go(l, []) in

# Check if two lists are equal #
let equal: ([Int], [Int]) -> Bool =
    fun p, xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => x == y && equal(xs, ys)
    | _ => false end
in

# Initialize a list with a given length using an initializer function #
let init: (Int, Int -> Int) -> [Int] =
    fun len, f ->
        let go: (Int, [Int]) -> [Int] =
        fun idx, xs ->
            if idx < len 
            then go(idx + 1, xs @ [f(idx)])   
            else xs
        in
        go(0, [])
in

# Reduce a list from the left. #
let fold_left: ((Int, Int) -> Int, Int, [Int]) -> Int =
  fun f, acc, xs ->
    case xs 
    | [] => acc
    | hd::tl => fold_left(f, f(acc, hd), tl) end in

# Reduce a list from the right. #
let fold_right: ((Int, Int) -> Int, [Int], Int) -> Int =
  fun f, xs, acc ->
    case xs
    | [] => acc
    | hd::tl => f(hd, fold_right(f, tl, acc)) end in


666
LSP: Prelude: String parsed successfully
LSP: Prelude: Info map generated successfully
Debug: true, Constrain: Types
LSP: Init: Recieved string: # Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

LSP: Init: String parsed successfully
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: <let = in<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {filter: (((Int -> Bool), [Int]) -> [Int]), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: 
  LSP: Info: ALL errors:Error in term:
  p
Nature of error: type ((Int -> Bool), [Int]) is not consistent with arrow type
  LSP: Info: BidiCtx: Cls: Let expression
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent: Root
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 ?
  LSP: Convex: Target types: ?
  LSP: Convex: Backpack: 
  LSP: Convex: Base: filter string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position Width S () [] _ false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: ! ( () - AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position S Width [ [] _ abs abs_float acos asin atan bool_of_string case  ceil cos epsilon_float exp false filter float_of_int float_of_string floor fun  if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod nan neg_infinity pi sin sqrt string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan test  true type  ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new_tokens ::= whitespace | "!" | "(" | "()" | "-" | "AlignItems" | "BackgroundColor" | "Border" | "BorderRadius" | "BoxShadow" | "Color" | "Cursor" | "Display" | "FlexDirection" | "FontFamily" | "FontSize" | "FontStyle" | "Gap" | "Height" | "JustifyContent" | "Margin" | "Opacity" | "Outline" | "Overflow" | "Padding" | "Position" | "S" | "Width" | "[" | "[]" | "_" | "abs" | "abs_float" | "acos" | "asin" | "atan" | "bool_of_string" | "case " | "ceil" | "cos" | "epsilon_float" | "exp" | "false" | "filter" | "float_of_int" | "float_of_string" | "floor" | "fun " | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "nan" | "neg_infinity" | "pi" | "sin" | "sqrt" | "string_compare" | "string_concat" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "true" | "type " | floatlit | intlit | stringlit
root ::= new_tokens

Top 20 Logits:

:18.2586
    :15.8138
  :15.2049
 :14.6608
#:14.0577
let:13.9341
   :13.3698
in:13.2175
        :13.0545
      :12.9588
       :12.3046
filter:12.2884
                :11.899
            :11.838
```:11.7484
rev:11.6627
     :11.5768
	:11.3414
fold:11.2228
          :10.8783
print:10.7542

================
# Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in



LSP: Prelude: Recieved string: ### List ###

# Add an element to the front of a list. #
let cons: (Int, [Int]) -> [Int] = fun x, xs -> x::xs in

# Determine the length of a list. #
let length: [Int] -> Int =
  fun xs ->
    case xs
    | [] => 0
    | _::xs => 1 + length(xs) end in

# Extract the first element of a list. #
let hd: [Int] -> Option =
  fun l ->
    case l
    | [] => None
    | x::xs => Some(x) end in

# Extract the rest of the list. #
let tl: [Int] -> [Int] =
  fun l ->
    case l
    | [] => []
    | x::xs => xs end in

# Determine if a list is empty. #
let is_empty: [Int] -> Bool =
  fun xs ->
    case xs
    | [] => true
    | _::_ => false end in

# Return the element at the index. #
let nth: ([Int], Int) -> Option =
  fun xs, n ->
    case xs, n
    | x::_, 0 => Some(x)
    | _::xs, n => nth(xs, n - 1)
    | [], _ => None end in

# Reverse a List. #
let rev: [Int] -> [Int] =
fun l -> 
let go: ([Int], [Int]) -> [Int] =
  fun xs, acc -> 
    case xs 
    | [] => acc 
    | x::xs => go(xs, x::acc) end in
go(l, []) in

# Check if two lists are equal #
let equal: ([Int], [Int]) -> Bool =
    fun p, xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => x == y && equal(xs, ys)
    | _ => false end
in

# Initialize a list with a given length using an initializer function #
let init: (Int, Int -> Int) -> [Int] =
    fun len, f ->
        let go: (Int, [Int]) -> [Int] =
        fun idx, xs ->
            if idx < len 
            then go(idx + 1, xs @ [f(idx)])   
            else xs
        in
        go(0, [])
in

# Reduce a list from the left. #
let fold_left: ((Int, Int) -> Int, Int, [Int]) -> Int =
  fun f, acc, xs ->
    case xs 
    | [] => acc
    | hd::tl => fold_left(f, f(acc, hd), tl) end in

# Reduce a list from the right. #
let fold_right: ((Int, Int) -> Int, [Int], Int) -> Int =
  fun f, xs, acc ->
    case xs
    | [] => acc
    | hd::tl => f(hd, fold_right(f, tl, acc)) end in


666
LSP: Prelude: String parsed successfully
LSP: Prelude: Info map generated successfully
Debug: true, Constrain: Types
LSP: Init: Recieved string: # Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in


LSP: Init: String parsed successfully
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: <let = in<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {filter: (((Int -> Bool), [Int]) -> [Int]), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: 
  LSP: Info: ALL errors:Error in term:
  p
Nature of error: type ((Int -> Bool), [Int]) is not consistent with arrow type
  LSP: Info: BidiCtx: Cls: Let expression
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent: Root
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 ?
  LSP: Convex: Target types: ?
  LSP: Convex: Backpack: 
  LSP: Convex: Base: filter string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position Width S () [] _ false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: ! ( () - AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position S Width [ [] _ abs abs_float acos asin atan bool_of_string case  ceil cos epsilon_float exp false filter float_of_int float_of_string floor fun  if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod nan neg_infinity pi sin sqrt string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan test  true type  ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new_tokens ::= whitespace | "!" | "(" | "()" | "-" | "AlignItems" | "BackgroundColor" | "Border" | "BorderRadius" | "BoxShadow" | "Color" | "Cursor" | "Display" | "FlexDirection" | "FontFamily" | "FontSize" | "FontStyle" | "Gap" | "Height" | "JustifyContent" | "Margin" | "Opacity" | "Outline" | "Overflow" | "Padding" | "Position" | "S" | "Width" | "[" | "[]" | "_" | "abs" | "abs_float" | "acos" | "asin" | "atan" | "bool_of_string" | "case " | "ceil" | "cos" | "epsilon_float" | "exp" | "false" | "filter" | "float_of_int" | "float_of_string" | "floor" | "fun " | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "nan" | "neg_infinity" | "pi" | "sin" | "sqrt" | "string_compare" | "string_concat" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "true" | "type " | floatlit | intlit | stringlit
root ::= new_tokens

Top 20 Logits:
#:18.8567
let:14.9095

:13.7433
##:12.8559
 :12.1152
################:11.75
print:11.739
[:11.4966
   :11.2836
assert:11.2834
length:11.0991
test:10.9954
cons:10.8702
{:10.7704
  :10.7623
```:10.6844
fold:10.6731
 #:10.6009
(*:10.5468
(:10.5274
    :10.5075

================
# Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let

LSP: Prelude: Recieved string: ### List ###

# Add an element to the front of a list. #
let cons: (Int, [Int]) -> [Int] = fun x, xs -> x::xs in

# Determine the length of a list. #
let length: [Int] -> Int =
  fun xs ->
    case xs
    | [] => 0
    | _::xs => 1 + length(xs) end in

# Extract the first element of a list. #
let hd: [Int] -> Option =
  fun l ->
    case l
    | [] => None
    | x::xs => Some(x) end in

# Extract the rest of the list. #
let tl: [Int] -> [Int] =
  fun l ->
    case l
    | [] => []
    | x::xs => xs end in

# Determine if a list is empty. #
let is_empty: [Int] -> Bool =
  fun xs ->
    case xs
    | [] => true
    | _::_ => false end in

# Return the element at the index. #
let nth: ([Int], Int) -> Option =
  fun xs, n ->
    case xs, n
    | x::_, 0 => Some(x)
    | _::xs, n => nth(xs, n - 1)
    | [], _ => None end in

# Reverse a List. #
let rev: [Int] -> [Int] =
fun l -> 
let go: ([Int], [Int]) -> [Int] =
  fun xs, acc -> 
    case xs 
    | [] => acc 
    | x::xs => go(xs, x::acc) end in
go(l, []) in

# Check if two lists are equal #
let equal: ([Int], [Int]) -> Bool =
    fun p, xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => x == y && equal(xs, ys)
    | _ => false end
in

# Initialize a list with a given length using an initializer function #
let init: (Int, Int -> Int) -> [Int] =
    fun len, f ->
        let go: (Int, [Int]) -> [Int] =
        fun idx, xs ->
            if idx < len 
            then go(idx + 1, xs @ [f(idx)])   
            else xs
        in
        go(0, [])
in

# Reduce a list from the left. #
let fold_left: ((Int, Int) -> Int, Int, [Int]) -> Int =
  fun f, acc, xs ->
    case xs 
    | [] => acc
    | hd::tl => fold_left(f, f(acc, hd), tl) end in

# Reduce a list from the right. #
let fold_right: ((Int, Int) -> Int, [Int], Int) -> Int =
  fun f, xs, acc ->
    case xs
    | [] => acc
    | hd::tl => f(hd, fold_right(f, tl, acc)) end in


666
LSP: Prelude: String parsed successfully
LSP: Prelude: Info map generated successfully
Debug: true, Constrain: Types
LSP: Init: Recieved string: # Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let
LSP: Init: String parsed successfully
  LSP: Syntax: Leftward is Complete Tile: <let>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Exp (FreeVariable "let"))
  LSP: Info: Typing Context: {filter: (((Int -> Bool), [Int]) -> [Int]), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: 
  LSP: Info: ALL errors:Error in term:
  p
Nature of error: type ((Int -> Bool), [Int]) is not consistent with arrow type    
Error in term:
  let
Nature of error: Variable let is not bound
  LSP: Info: BidiCtx: Cls: Let expression
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent: Root
  LSP: Syntax: Can insert left-concave or complete: let
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: && \/ $== == != <= >= < > ==. !=. <=. >=. <. >. + - * / ** +. -. *. /. **. ++ :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Backpack: 
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: let
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: && \/ $== == != <= >= < > ==. !=. <=. >=. <. >. + - * / ** +. -. *. /. **. ++ :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Backpack: 
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Ty paths:
 ?
  LSP: Convex: Target types: ?
  LSP: Convex: Backpack: 
  LSP: Convex: Base: filter string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position Width S () [] _ false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: ! ( () - AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position S Width [ [] _ abs abs_float acos asin atan bool_of_string case  ceil cos epsilon_float exp false filter float_of_int float_of_string floor fun  if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod nan neg_infinity pi sin sqrt string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan test  true type  ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= " "
new_tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/"
root ::= completions | new_tokens

Top 20 Logits:
 map:12.3531
 rec:11.5766
 append:11.1702
 (:11.0242
 ():10.9788
 filter:10.7967
 conc:10.7643
 test:10.674
 f:10.3611
 id:10.3331
 _:10.2148
 l:10.1188
 xs:10.078
 range:10.0061
 sum:9.88186
 list:9.87523
 reverse:9.87003
 main:9.86867
 remove:9.78824
 partition:9.69703
 flat:9.66669

================
# Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (

LSP: Prelude: Recieved string: ### List ###

# Add an element to the front of a list. #
let cons: (Int, [Int]) -> [Int] = fun x, xs -> x::xs in

# Determine the length of a list. #
let length: [Int] -> Int =
  fun xs ->
    case xs
    | [] => 0
    | _::xs => 1 + length(xs) end in

# Extract the first element of a list. #
let hd: [Int] -> Option =
  fun l ->
    case l
    | [] => None
    | x::xs => Some(x) end in

# Extract the rest of the list. #
let tl: [Int] -> [Int] =
  fun l ->
    case l
    | [] => []
    | x::xs => xs end in

# Determine if a list is empty. #
let is_empty: [Int] -> Bool =
  fun xs ->
    case xs
    | [] => true
    | _::_ => false end in

# Return the element at the index. #
let nth: ([Int], Int) -> Option =
  fun xs, n ->
    case xs, n
    | x::_, 0 => Some(x)
    | _::xs, n => nth(xs, n - 1)
    | [], _ => None end in

# Reverse a List. #
let rev: [Int] -> [Int] =
fun l -> 
let go: ([Int], [Int]) -> [Int] =
  fun xs, acc -> 
    case xs 
    | [] => acc 
    | x::xs => go(xs, x::acc) end in
go(l, []) in

# Check if two lists are equal #
let equal: ([Int], [Int]) -> Bool =
    fun p, xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => x == y && equal(xs, ys)
    | _ => false end
in

# Initialize a list with a given length using an initializer function #
let init: (Int, Int -> Int) -> [Int] =
    fun len, f ->
        let go: (Int, [Int]) -> [Int] =
        fun idx, xs ->
            if idx < len 
            then go(idx + 1, xs @ [f(idx)])   
            else xs
        in
        go(0, [])
in

# Reduce a list from the left. #
let fold_left: ((Int, Int) -> Int, Int, [Int]) -> Int =
  fun f, acc, xs ->
    case xs 
    | [] => acc
    | hd::tl => fold_left(f, f(acc, hd), tl) end in

# Reduce a list from the right. #
let fold_right: ((Int, Int) -> Int, [Int], Int) -> Int =
  fun f, xs, acc ->
    case xs
    | [] => acc
    | hd::tl => f(hd, fold_right(f, tl, acc)) end in


666
LSP: Prelude: String parsed successfully
LSP: Prelude: Info map generated successfully
Debug: true, Constrain: Types
LSP: Init: Recieved string: # Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (
LSP: Init: String parsed successfully
  LSP: Syntax: Leftward is Incomplete Tile: <( )<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty pattern hole
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {filter: (((Int -> Bool), [Int]) -> [Int]), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) = in
  LSP: Info: ALL errors:Error in term:
  p
Nature of error: type ((Int -> Bool), [Int]) is not consistent with arrow type
  LSP: Info: BidiCtx: Cls: Empty pattern hole
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Parenthesized pattern
  LSP: Info: Cls: Parenthesized pattern
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {filter: (((Int -> Bool), [Int]) -> [Int]), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) = in
  LSP: Info: ALL errors:Error in term:
  p
Nature of error: type ((Int -> Bool), [Int]) is not consistent with arrow type
  LSP: Info: BidiCtx: Cls: Parenthesized pattern
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-convex or complete: (
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position Width S () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: ( () AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position S Width [ [] _ false true ~FLOATLIT~ ~INTLIT~ ~PATVAR~ ~STRINGLIT~
LSP: Generating Completions for prefix: (
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: : ::
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position Width S () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: ( () AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position S Width [ [] _ false true ~FLOATLIT~ ~INTLIT~ ~PATVAR~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= ")"
new_tokens ::= whitespace | "(" | "()" | "AlignItems" | "BackgroundColor" | "Border" | "BorderRadius" | "BoxShadow" | "Color" | "Cursor" | "Display" | "FlexDirection" | "FontFamily" | "FontSize" | "FontStyle" | "Gap" | "Height" | "JustifyContent" | "Margin" | "Opacity" | "Outline" | "Overflow" | "Padding" | "Position" | "S" | "Width" | "[" | "[]" | "_" | "false" | "true" | floatlit | intlit | patvar | stringlit
root ::= completions | new_tokens

Top 20 Logits:
go:12.6568
map:12.2891
++):11.6715
filter:11.3461
&&:11.0631
test:11.0571
id:10.997
f:10.9811
append:10.8542
==:10.66
x:10.5213
main:10.481
list:10.2426
range:10.2357
||:10.1876
<:10.1739
>>:10.1707
zip:10.1543
compose:10.1375
take:10.0028
p:9.9132

================
# Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go

LSP: Prelude: Recieved string: ### List ###

# Add an element to the front of a list. #
let cons: (Int, [Int]) -> [Int] = fun x, xs -> x::xs in

# Determine the length of a list. #
let length: [Int] -> Int =
  fun xs ->
    case xs
    | [] => 0
    | _::xs => 1 + length(xs) end in

# Extract the first element of a list. #
let hd: [Int] -> Option =
  fun l ->
    case l
    | [] => None
    | x::xs => Some(x) end in

# Extract the rest of the list. #
let tl: [Int] -> [Int] =
  fun l ->
    case l
    | [] => []
    | x::xs => xs end in

# Determine if a list is empty. #
let is_empty: [Int] -> Bool =
  fun xs ->
    case xs
    | [] => true
    | _::_ => false end in

# Return the element at the index. #
let nth: ([Int], Int) -> Option =
  fun xs, n ->
    case xs, n
    | x::_, 0 => Some(x)
    | _::xs, n => nth(xs, n - 1)
    | [], _ => None end in

# Reverse a List. #
let rev: [Int] -> [Int] =
fun l -> 
let go: ([Int], [Int]) -> [Int] =
  fun xs, acc -> 
    case xs 
    | [] => acc 
    | x::xs => go(xs, x::acc) end in
go(l, []) in

# Check if two lists are equal #
let equal: ([Int], [Int]) -> Bool =
    fun p, xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => x == y && equal(xs, ys)
    | _ => false end
in

# Initialize a list with a given length using an initializer function #
let init: (Int, Int -> Int) -> [Int] =
    fun len, f ->
        let go: (Int, [Int]) -> [Int] =
        fun idx, xs ->
            if idx < len 
            then go(idx + 1, xs @ [f(idx)])   
            else xs
        in
        go(0, [])
in

# Reduce a list from the left. #
let fold_left: ((Int, Int) -> Int, Int, [Int]) -> Int =
  fun f, acc, xs ->
    case xs 
    | [] => acc
    | hd::tl => fold_left(f, f(acc, hd), tl) end in

# Reduce a list from the right. #
let fold_right: ((Int, Int) -> Int, [Int], Int) -> Int =
  fun f, xs, acc ->
    case xs
    | [] => acc
    | hd::tl => f(hd, fold_right(f, tl, acc)) end in


666
LSP: Prelude: String parsed successfully
LSP: Prelude: Info map generated successfully
Debug: true, Constrain: Types
LSP: Init: Recieved string: # Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go
LSP: Init: String parsed successfully
  LSP: Syntax: Leftward is Complete Tile: <go>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable binding
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {go: ?, filter: (((Int -> Bool), [Int]) -> [Int]), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) = in
  LSP: Info: ALL errors:Error in term:
  p
Nature of error: type ((Int -> Bool), [Int]) is not consistent with arrow type
  LSP: Info: BidiCtx: Cls: Variable binding
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Parenthesized pattern
  LSP: Syntax: Can insert left-concave or complete: go
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: : ::
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: go
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: : ::
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position Width S () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: ( () AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position S Width [ [] _ false true ~FLOATLIT~ ~INTLIT~ ~PATVAR~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= extend-patvar
new_tokens ::= whitespace | "(" | ")" | ":" | "::"
root ::= completions | new_tokens

Top 20 Logits:
):15.3461
)::13.674
2:12.7538
_:12.6932
1:12.0243
::11.4171
,:10.8365
0:10.6464
)=:10.469
o:10.0996
3:10.0311
)(:9.73603
'):9.57033
 =:9.42702
_):9.40345
),:9.04639
 (:8.99288
)':8.97968
);:8.6363
i:8.27635
:):8.16349

================
# Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go)

LSP: Prelude: Recieved string: ### List ###

# Add an element to the front of a list. #
let cons: (Int, [Int]) -> [Int] = fun x, xs -> x::xs in

# Determine the length of a list. #
let length: [Int] -> Int =
  fun xs ->
    case xs
    | [] => 0
    | _::xs => 1 + length(xs) end in

# Extract the first element of a list. #
let hd: [Int] -> Option =
  fun l ->
    case l
    | [] => None
    | x::xs => Some(x) end in

# Extract the rest of the list. #
let tl: [Int] -> [Int] =
  fun l ->
    case l
    | [] => []
    | x::xs => xs end in

# Determine if a list is empty. #
let is_empty: [Int] -> Bool =
  fun xs ->
    case xs
    | [] => true
    | _::_ => false end in

# Return the element at the index. #
let nth: ([Int], Int) -> Option =
  fun xs, n ->
    case xs, n
    | x::_, 0 => Some(x)
    | _::xs, n => nth(xs, n - 1)
    | [], _ => None end in

# Reverse a List. #
let rev: [Int] -> [Int] =
fun l -> 
let go: ([Int], [Int]) -> [Int] =
  fun xs, acc -> 
    case xs 
    | [] => acc 
    | x::xs => go(xs, x::acc) end in
go(l, []) in

# Check if two lists are equal #
let equal: ([Int], [Int]) -> Bool =
    fun p, xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => x == y && equal(xs, ys)
    | _ => false end
in

# Initialize a list with a given length using an initializer function #
let init: (Int, Int -> Int) -> [Int] =
    fun len, f ->
        let go: (Int, [Int]) -> [Int] =
        fun idx, xs ->
            if idx < len 
            then go(idx + 1, xs @ [f(idx)])   
            else xs
        in
        go(0, [])
in

# Reduce a list from the left. #
let fold_left: ((Int, Int) -> Int, Int, [Int]) -> Int =
  fun f, acc, xs ->
    case xs 
    | [] => acc
    | hd::tl => fold_left(f, f(acc, hd), tl) end in

# Reduce a list from the right. #
let fold_right: ((Int, Int) -> Int, [Int], Int) -> Int =
  fun f, xs, acc ->
    case xs
    | [] => acc
    | hd::tl => f(hd, fold_right(f, tl, acc)) end in


666
LSP: Prelude: String parsed successfully
LSP: Prelude: Info map generated successfully
Debug: true, Constrain: Types
LSP: Init: Recieved string: # Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go)
LSP: Init: String parsed successfully
  LSP: Syntax: Leftward is Complete Tile: <( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Parenthesized pattern
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {go: ?, filter: (((Int -> Bool), [Int]) -> [Int]), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: = in
  LSP: Info: ALL errors:Error in term:
  p
Nature of error: type ((Int -> Bool), [Int]) is not consistent with arrow type
  LSP: Info: BidiCtx: Cls: Parenthesized pattern
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: =
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: : ::
  LSP: Concave: Postfix: (
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new_tokens ::= whitespace | "(" | ":" | "::" | "="
root ::= new_tokens

Top 20 Logits:
 =:19.2886
 (:13.5896
 xs:13.3766
 ::13.3017
 :12.6186
 x:11.6973

:11.4089
 f:11.3546
 l:11.1583
 p:10.6988
 in:10.5657
 :::10.5491
 acc:10.5334
 ->:10.273
 a:10.156
 ((:10.1141
 fun:9.94537
 ([:9.9098
 ():9.72848
 :=:9.69481
 =>:9.45705

================
# Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) =

LSP: Prelude: Recieved string: ### List ###

# Add an element to the front of a list. #
let cons: (Int, [Int]) -> [Int] = fun x, xs -> x::xs in

# Determine the length of a list. #
let length: [Int] -> Int =
  fun xs ->
    case xs
    | [] => 0
    | _::xs => 1 + length(xs) end in

# Extract the first element of a list. #
let hd: [Int] -> Option =
  fun l ->
    case l
    | [] => None
    | x::xs => Some(x) end in

# Extract the rest of the list. #
let tl: [Int] -> [Int] =
  fun l ->
    case l
    | [] => []
    | x::xs => xs end in

# Determine if a list is empty. #
let is_empty: [Int] -> Bool =
  fun xs ->
    case xs
    | [] => true
    | _::_ => false end in

# Return the element at the index. #
let nth: ([Int], Int) -> Option =
  fun xs, n ->
    case xs, n
    | x::_, 0 => Some(x)
    | _::xs, n => nth(xs, n - 1)
    | [], _ => None end in

# Reverse a List. #
let rev: [Int] -> [Int] =
fun l -> 
let go: ([Int], [Int]) -> [Int] =
  fun xs, acc -> 
    case xs 
    | [] => acc 
    | x::xs => go(xs, x::acc) end in
go(l, []) in

# Check if two lists are equal #
let equal: ([Int], [Int]) -> Bool =
    fun p, xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => x == y && equal(xs, ys)
    | _ => false end
in

# Initialize a list with a given length using an initializer function #
let init: (Int, Int -> Int) -> [Int] =
    fun len, f ->
        let go: (Int, [Int]) -> [Int] =
        fun idx, xs ->
            if idx < len 
            then go(idx + 1, xs @ [f(idx)])   
            else xs
        in
        go(0, [])
in

# Reduce a list from the left. #
let fold_left: ((Int, Int) -> Int, Int, [Int]) -> Int =
  fun f, acc, xs ->
    case xs 
    | [] => acc
    | hd::tl => fold_left(f, f(acc, hd), tl) end in

# Reduce a list from the right. #
let fold_right: ((Int, Int) -> Int, [Int], Int) -> Int =
  fun f, xs, acc ->
    case xs
    | [] => acc
    | hd::tl => f(hd, fold_right(f, tl, acc)) end in


666
LSP: Prelude: String parsed successfully
LSP: Prelude: Info map generated successfully
Debug: true, Constrain: Types
LSP: Init: Recieved string: # Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) =
LSP: Init: String parsed successfully
  LSP: Syntax: Leftward is Incomplete Tile: <let = in<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {filter: (((Int -> Bool), [Int]) -> [Int]), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: in
  LSP: Info: ALL errors:Error in term:
  p
Nature of error: type ((Int -> Bool), [Int]) is not consistent with arrow type
  LSP: Info: BidiCtx: Cls: Empty expression hole
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 ?
  LSP: Convex: Target types: ?
  LSP: Convex: Backpack: 
  LSP: Convex: Base: filter string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position Width S () [] _ false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: ! ( () - AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position S Width [ [] _ abs abs_float acos asin atan bool_of_string case  ceil cos epsilon_float exp false filter float_of_int float_of_string floor fun  if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod nan neg_infinity pi sin sqrt string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan test  true type  ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new_tokens ::= whitespace | "!" | "(" | "()" | "-" | "AlignItems" | "BackgroundColor" | "Border" | "BorderRadius" | "BoxShadow" | "Color" | "Cursor" | "Display" | "FlexDirection" | "FontFamily" | "FontSize" | "FontStyle" | "Gap" | "Height" | "JustifyContent" | "Margin" | "Opacity" | "Outline" | "Overflow" | "Padding" | "Position" | "S" | "Width" | "[" | "[]" | "_" | "abs" | "abs_float" | "acos" | "asin" | "atan" | "bool_of_string" | "case " | "ceil" | "cos" | "epsilon_float" | "exp" | "false" | "filter" | "float_of_int" | "float_of_string" | "floor" | "fun " | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "nan" | "neg_infinity" | "pi" | "sin" | "sqrt" | "string_compare" | "string_concat" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "true" | "type " | floatlit | intlit | stringlit
root ::= new_tokens

Top 20 Logits:
 fun:17.1138
 :13.1872

:12.4176
 (:12.2397
 fol:12.1281
 filter:12.0197
 cons:10.8397
 let:10.8264
 rev:10.0023
 {:9.84683
 function:9.49199
 func:9.48252
 go:9.42179
fun:9.38321
 [:9.34162
 list:9.03404
 f:9.0096
 ([:8.92955
 ((:8.92409
 lambda:8.81431
 test:8.79622

================
# Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun

LSP: Prelude: Recieved string: ### List ###

# Add an element to the front of a list. #
let cons: (Int, [Int]) -> [Int] = fun x, xs -> x::xs in

# Determine the length of a list. #
let length: [Int] -> Int =
  fun xs ->
    case xs
    | [] => 0
    | _::xs => 1 + length(xs) end in

# Extract the first element of a list. #
let hd: [Int] -> Option =
  fun l ->
    case l
    | [] => None
    | x::xs => Some(x) end in

# Extract the rest of the list. #
let tl: [Int] -> [Int] =
  fun l ->
    case l
    | [] => []
    | x::xs => xs end in

# Determine if a list is empty. #
let is_empty: [Int] -> Bool =
  fun xs ->
    case xs
    | [] => true
    | _::_ => false end in

# Return the element at the index. #
let nth: ([Int], Int) -> Option =
  fun xs, n ->
    case xs, n
    | x::_, 0 => Some(x)
    | _::xs, n => nth(xs, n - 1)
    | [], _ => None end in

# Reverse a List. #
let rev: [Int] -> [Int] =
fun l -> 
let go: ([Int], [Int]) -> [Int] =
  fun xs, acc -> 
    case xs 
    | [] => acc 
    | x::xs => go(xs, x::acc) end in
go(l, []) in

# Check if two lists are equal #
let equal: ([Int], [Int]) -> Bool =
    fun p, xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => x == y && equal(xs, ys)
    | _ => false end
in

# Initialize a list with a given length using an initializer function #
let init: (Int, Int -> Int) -> [Int] =
    fun len, f ->
        let go: (Int, [Int]) -> [Int] =
        fun idx, xs ->
            if idx < len 
            then go(idx + 1, xs @ [f(idx)])   
            else xs
        in
        go(0, [])
in

# Reduce a list from the left. #
let fold_left: ((Int, Int) -> Int, Int, [Int]) -> Int =
  fun f, acc, xs ->
    case xs 
    | [] => acc
    | hd::tl => fold_left(f, f(acc, hd), tl) end in

# Reduce a list from the right. #
let fold_right: ((Int, Int) -> Int, [Int], Int) -> Int =
  fun f, xs, acc ->
    case xs
    | [] => acc
    | hd::tl => f(hd, fold_right(f, tl, acc)) end in


666
LSP: Prelude: String parsed successfully
LSP: Prelude: Info map generated successfully
Debug: true, Constrain: Types
LSP: Init: Recieved string: # Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun
LSP: Init: String parsed successfully
  LSP: Syntax: Leftward is Complete Tile: <fun>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Exp (FreeVariable "fun"))
  LSP: Info: Typing Context: {filter: (((Int -> Bool), [Int]) -> [Int]), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: in
  LSP: Info: ALL errors:Error in term:
  fun
Nature of error: Variable fun is not bound    
Error in term:
  p
Nature of error: type ((Int -> Bool), [Int]) is not consistent with arrow type
  LSP: Info: BidiCtx: Cls: Variable reference
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-concave or complete: fun
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: && \/ $== == != <= >= < > ==. !=. <=. >=. <. >. + - * / ** +. -. *. /. **. ++ :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Backpack: in
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: fun
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: && \/ $== == != <= >= < > ==. !=. <=. >=. <. >. + - * / ** +. -. *. /. **. ++ :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Backpack: in
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Ty paths:
 ?
  LSP: Convex: Target types: ?
  LSP: Convex: Backpack: 
  LSP: Convex: Base: filter string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position Width S () [] _ false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: ! ( () - AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position S Width [ [] _ abs abs_float acos asin atan bool_of_string case  ceil cos epsilon_float exp false filter float_of_int float_of_string floor fun  if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod nan neg_infinity pi sin sqrt string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan test  true type  ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= " "
new_tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/" | "in"
root ::= completions | new_tokens

Top 20 Logits:
 (:16.8671
 xs:15.4364
 l:14.3672
 x:14.0651
 p:13.8468
 ((:13.3861
(:13.27
 ([:13.1941
 f:13.0421
 n:12.1312
 acc:12.0216
 :11.6509
 ():11.6132
 a:11.5787
 list:11.4951
 len:11.2551
 i:11.237

:11.2248
 s:11.2099
 (_:11.1015
 [:10.9381

================
# Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (

LSP: Prelude: Recieved string: ### List ###

# Add an element to the front of a list. #
let cons: (Int, [Int]) -> [Int] = fun x, xs -> x::xs in

# Determine the length of a list. #
let length: [Int] -> Int =
  fun xs ->
    case xs
    | [] => 0
    | _::xs => 1 + length(xs) end in

# Extract the first element of a list. #
let hd: [Int] -> Option =
  fun l ->
    case l
    | [] => None
    | x::xs => Some(x) end in

# Extract the rest of the list. #
let tl: [Int] -> [Int] =
  fun l ->
    case l
    | [] => []
    | x::xs => xs end in

# Determine if a list is empty. #
let is_empty: [Int] -> Bool =
  fun xs ->
    case xs
    | [] => true
    | _::_ => false end in

# Return the element at the index. #
let nth: ([Int], Int) -> Option =
  fun xs, n ->
    case xs, n
    | x::_, 0 => Some(x)
    | _::xs, n => nth(xs, n - 1)
    | [], _ => None end in

# Reverse a List. #
let rev: [Int] -> [Int] =
fun l -> 
let go: ([Int], [Int]) -> [Int] =
  fun xs, acc -> 
    case xs 
    | [] => acc 
    | x::xs => go(xs, x::acc) end in
go(l, []) in

# Check if two lists are equal #
let equal: ([Int], [Int]) -> Bool =
    fun p, xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => x == y && equal(xs, ys)
    | _ => false end
in

# Initialize a list with a given length using an initializer function #
let init: (Int, Int -> Int) -> [Int] =
    fun len, f ->
        let go: (Int, [Int]) -> [Int] =
        fun idx, xs ->
            if idx < len 
            then go(idx + 1, xs @ [f(idx)])   
            else xs
        in
        go(0, [])
in

# Reduce a list from the left. #
let fold_left: ((Int, Int) -> Int, Int, [Int]) -> Int =
  fun f, acc, xs ->
    case xs 
    | [] => acc
    | hd::tl => fold_left(f, f(acc, hd), tl) end in

# Reduce a list from the right. #
let fold_right: ((Int, Int) -> Int, [Int], Int) -> Int =
  fun f, xs, acc ->
    case xs
    | [] => acc
    | hd::tl => f(hd, fold_right(f, tl, acc)) end in


666
LSP: Prelude: String parsed successfully
LSP: Prelude: Info map generated successfully
Debug: true, Constrain: Types
LSP: Init: Recieved string: # Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (
LSP: Init: String parsed successfully
  LSP: Syntax: Leftward is Incomplete Tile: <( )<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty pattern hole
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {filter: (((Int -> Bool), [Int]) -> [Int]), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) -> in
  LSP: Info: ALL errors:Error in term:
  p
Nature of error: type ((Int -> Bool), [Int]) is not consistent with arrow type
  LSP: Info: BidiCtx: Cls: Empty pattern hole
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Parenthesized pattern
  LSP: Info: Cls: Parenthesized pattern
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {filter: (((Int -> Bool), [Int]) -> [Int]), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) -> in
  LSP: Info: ALL errors:Error in term:
  p
Nature of error: type ((Int -> Bool), [Int]) is not consistent with arrow type
  LSP: Info: BidiCtx: Cls: Parenthesized pattern
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Syntax: Can insert left-convex or complete: (
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position Width S () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: ( () AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position S Width [ [] _ false true ~FLOATLIT~ ~INTLIT~ ~PATVAR~ ~STRINGLIT~
LSP: Generating Completions for prefix: (
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: : ::
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position Width S () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: ( () AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position S Width [ [] _ false true ~FLOATLIT~ ~INTLIT~ ~PATVAR~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= ")"
new_tokens ::= whitespace | "(" | "()" | "AlignItems" | "BackgroundColor" | "Border" | "BorderRadius" | "BoxShadow" | "Color" | "Cursor" | "Display" | "FlexDirection" | "FontFamily" | "FontSize" | "FontStyle" | "Gap" | "Height" | "JustifyContent" | "Margin" | "Opacity" | "Outline" | "Overflow" | "Padding" | "Position" | "S" | "Width" | "[" | "[]" | "_" | "false" | "true" | floatlit | intlit | patvar | stringlit
root ::= completions | new_tokens

Top 20 Logits:
xs:16.0837
f:14.4684
p:13.4765
x:13.3213
n:12.8491
l:12.5773
acc:11.9413
a:11.7169
pred:11.6223
i:11.4344
list:11.274
len:11.2211
_,:11.1652
test:11.1299
lst:11.1282
ys:10.9467
ls:10.7567
s:10.6202
idx:10.5483
k:10.4011
fn:10.2955

================
# Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs

LSP: Prelude: Recieved string: ### List ###

# Add an element to the front of a list. #
let cons: (Int, [Int]) -> [Int] = fun x, xs -> x::xs in

# Determine the length of a list. #
let length: [Int] -> Int =
  fun xs ->
    case xs
    | [] => 0
    | _::xs => 1 + length(xs) end in

# Extract the first element of a list. #
let hd: [Int] -> Option =
  fun l ->
    case l
    | [] => None
    | x::xs => Some(x) end in

# Extract the rest of the list. #
let tl: [Int] -> [Int] =
  fun l ->
    case l
    | [] => []
    | x::xs => xs end in

# Determine if a list is empty. #
let is_empty: [Int] -> Bool =
  fun xs ->
    case xs
    | [] => true
    | _::_ => false end in

# Return the element at the index. #
let nth: ([Int], Int) -> Option =
  fun xs, n ->
    case xs, n
    | x::_, 0 => Some(x)
    | _::xs, n => nth(xs, n - 1)
    | [], _ => None end in

# Reverse a List. #
let rev: [Int] -> [Int] =
fun l -> 
let go: ([Int], [Int]) -> [Int] =
  fun xs, acc -> 
    case xs 
    | [] => acc 
    | x::xs => go(xs, x::acc) end in
go(l, []) in

# Check if two lists are equal #
let equal: ([Int], [Int]) -> Bool =
    fun p, xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => x == y && equal(xs, ys)
    | _ => false end
in

# Initialize a list with a given length using an initializer function #
let init: (Int, Int -> Int) -> [Int] =
    fun len, f ->
        let go: (Int, [Int]) -> [Int] =
        fun idx, xs ->
            if idx < len 
            then go(idx + 1, xs @ [f(idx)])   
            else xs
        in
        go(0, [])
in

# Reduce a list from the left. #
let fold_left: ((Int, Int) -> Int, Int, [Int]) -> Int =
  fun f, acc, xs ->
    case xs 
    | [] => acc
    | hd::tl => fold_left(f, f(acc, hd), tl) end in

# Reduce a list from the right. #
let fold_right: ((Int, Int) -> Int, [Int], Int) -> Int =
  fun f, xs, acc ->
    case xs
    | [] => acc
    | hd::tl => f(hd, fold_right(f, tl, acc)) end in


666
LSP: Prelude: String parsed successfully
LSP: Prelude: Info map generated successfully
Debug: true, Constrain: Types
LSP: Init: Recieved string: # Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs
LSP: Init: String parsed successfully
  LSP: Syntax: Leftward is Complete Tile: <xs>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable binding
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {xs: ?, filter: (((Int -> Bool), [Int]) -> [Int]), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) -> in
  LSP: Info: ALL errors:Error in term:
  p
Nature of error: type ((Int -> Bool), [Int]) is not consistent with arrow type
  LSP: Info: BidiCtx: Cls: Variable binding
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Parenthesized pattern
  LSP: Syntax: Can insert left-concave or complete: xs
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: : ::
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: xs
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: : ::
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position Width S () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: ( () AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position S Width [ [] _ false true ~FLOATLIT~ ~INTLIT~ ~PATVAR~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= extend-patvar
new_tokens ::= whitespace | "(" | ")" | "," | ":" | "::"
root ::= completions | new_tokens

Top 20 Logits:
,:21.6922
):17.2109
::16.2279
)::14.4736
 ,:14.0671
)->:13.9061
1:13.8048
 ::13.5494
',:13.0673
_,:12.9219
_:12.7362
0:12.6925
 ->:12.5026
),:12.3363
 as:11.9531
2:11.6768
@:10.9395
'):10.841
,[:10.8021
)=:10.8007
?,:10.7292

================
# Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs,

LSP: Prelude: Recieved string: ### List ###

# Add an element to the front of a list. #
let cons: (Int, [Int]) -> [Int] = fun x, xs -> x::xs in

# Determine the length of a list. #
let length: [Int] -> Int =
  fun xs ->
    case xs
    | [] => 0
    | _::xs => 1 + length(xs) end in

# Extract the first element of a list. #
let hd: [Int] -> Option =
  fun l ->
    case l
    | [] => None
    | x::xs => Some(x) end in

# Extract the rest of the list. #
let tl: [Int] -> [Int] =
  fun l ->
    case l
    | [] => []
    | x::xs => xs end in

# Determine if a list is empty. #
let is_empty: [Int] -> Bool =
  fun xs ->
    case xs
    | [] => true
    | _::_ => false end in

# Return the element at the index. #
let nth: ([Int], Int) -> Option =
  fun xs, n ->
    case xs, n
    | x::_, 0 => Some(x)
    | _::xs, n => nth(xs, n - 1)
    | [], _ => None end in

# Reverse a List. #
let rev: [Int] -> [Int] =
fun l -> 
let go: ([Int], [Int]) -> [Int] =
  fun xs, acc -> 
    case xs 
    | [] => acc 
    | x::xs => go(xs, x::acc) end in
go(l, []) in

# Check if two lists are equal #
let equal: ([Int], [Int]) -> Bool =
    fun p, xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => x == y && equal(xs, ys)
    | _ => false end
in

# Initialize a list with a given length using an initializer function #
let init: (Int, Int -> Int) -> [Int] =
    fun len, f ->
        let go: (Int, [Int]) -> [Int] =
        fun idx, xs ->
            if idx < len 
            then go(idx + 1, xs @ [f(idx)])   
            else xs
        in
        go(0, [])
in

# Reduce a list from the left. #
let fold_left: ((Int, Int) -> Int, Int, [Int]) -> Int =
  fun f, acc, xs ->
    case xs 
    | [] => acc
    | hd::tl => fold_left(f, f(acc, hd), tl) end in

# Reduce a list from the right. #
let fold_right: ((Int, Int) -> Int, [Int], Int) -> Int =
  fun f, xs, acc ->
    case xs
    | [] => acc
    | hd::tl => f(hd, fold_right(f, tl, acc)) end in


666
LSP: Prelude: String parsed successfully
LSP: Prelude: Info map generated successfully
Debug: true, Constrain: Types
LSP: Init: Recieved string: # Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs,
LSP: Init: String parsed successfully
  LSP: Syntax: Leftward is Complete Tile: >,<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty pattern hole
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {xs: ?, filter: (((Int -> Bool), [Int]) -> [Int]), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) -> in
  LSP: Info: ALL errors:Error in term:
  p
Nature of error: type ((Int -> Bool), [Int]) is not consistent with arrow type
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Parenthesized pattern
  LSP: Info: Cls: Tuple
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: (?, ?)
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {xs: ?, filter: (((Int -> Bool), [Int]) -> [Int]), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) -> in
  LSP: Info: ALL errors:Error in term:
  p
Nature of error: type ((Int -> Bool), [Int]) is not consistent with arrow type
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Parenthesized pattern
  LSP: Syntax: Can insert left-convex or complete: ,
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position Width S () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: ( () AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position S Width [ [] _ false true ~FLOATLIT~ ~INTLIT~ ~PATVAR~ ~STRINGLIT~
LSP: Generating Completions for prefix: ,
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: : ::
  LSP: Concave: Postfix: 
  LSP: Convex: Backpack: 
  LSP: Convex: Base: AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position Width S () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: ( () AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position S Width [ [] _ false true ~FLOATLIT~ ~INTLIT~ ~PATVAR~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new_tokens ::= whitespace | "(" | "()" | "AlignItems" | "BackgroundColor" | "Border" | "BorderRadius" | "BoxShadow" | "Color" | "Cursor" | "Display" | "FlexDirection" | "FontFamily" | "FontSize" | "FontStyle" | "Gap" | "Height" | "JustifyContent" | "Margin" | "Opacity" | "Outline" | "Overflow" | "Padding" | "Position" | "S" | "Width" | "[" | "[]" | "_" | "false" | "true" | floatlit | intlit | patvar | stringlit
root ::= new_tokens

Top 20 Logits:
 acc:14.3378
 f:12.9912
 p:12.6455
 y:11.6199
 n:11.3885
 pred:11.0581
 test:10.7193
 idx:10.3691
 i:9.97554
 xs:9.87478
 res:9.76788
 fn:9.7315
 accum:9.57876
 l:9.55962
 len:9.54544
 x:9.35797
 (:9.13812
 a:9.11944
 c:9.11668
 sum:8.86333
 _,:8.76096

================
# Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc

LSP: Prelude: Recieved string: ### List ###

# Add an element to the front of a list. #
let cons: (Int, [Int]) -> [Int] = fun x, xs -> x::xs in

# Determine the length of a list. #
let length: [Int] -> Int =
  fun xs ->
    case xs
    | [] => 0
    | _::xs => 1 + length(xs) end in

# Extract the first element of a list. #
let hd: [Int] -> Option =
  fun l ->
    case l
    | [] => None
    | x::xs => Some(x) end in

# Extract the rest of the list. #
let tl: [Int] -> [Int] =
  fun l ->
    case l
    | [] => []
    | x::xs => xs end in

# Determine if a list is empty. #
let is_empty: [Int] -> Bool =
  fun xs ->
    case xs
    | [] => true
    | _::_ => false end in

# Return the element at the index. #
let nth: ([Int], Int) -> Option =
  fun xs, n ->
    case xs, n
    | x::_, 0 => Some(x)
    | _::xs, n => nth(xs, n - 1)
    | [], _ => None end in

# Reverse a List. #
let rev: [Int] -> [Int] =
fun l -> 
let go: ([Int], [Int]) -> [Int] =
  fun xs, acc -> 
    case xs 
    | [] => acc 
    | x::xs => go(xs, x::acc) end in
go(l, []) in

# Check if two lists are equal #
let equal: ([Int], [Int]) -> Bool =
    fun p, xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => x == y && equal(xs, ys)
    | _ => false end
in

# Initialize a list with a given length using an initializer function #
let init: (Int, Int -> Int) -> [Int] =
    fun len, f ->
        let go: (Int, [Int]) -> [Int] =
        fun idx, xs ->
            if idx < len 
            then go(idx + 1, xs @ [f(idx)])   
            else xs
        in
        go(0, [])
in

# Reduce a list from the left. #
let fold_left: ((Int, Int) -> Int, Int, [Int]) -> Int =
  fun f, acc, xs ->
    case xs 
    | [] => acc
    | hd::tl => fold_left(f, f(acc, hd), tl) end in

# Reduce a list from the right. #
let fold_right: ((Int, Int) -> Int, [Int], Int) -> Int =
  fun f, xs, acc ->
    case xs
    | [] => acc
    | hd::tl => f(hd, fold_right(f, tl, acc)) end in


666
LSP: Prelude: String parsed successfully
LSP: Prelude: Info map generated successfully
Debug: true, Constrain: Types
LSP: Init: Recieved string: # Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc
LSP: Init: String parsed successfully
  LSP: Syntax: Leftward is Complete Tile: <acc>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable binding
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {acc: ?, xs: ?, filter: (((Int -> Bool), [Int]) -> [Int]), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) -> in
  LSP: Info: ALL errors:Error in term:
  p
Nature of error: type ((Int -> Bool), [Int]) is not consistent with arrow type
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Parenthesized pattern
  LSP: Syntax: Can insert left-concave or complete: acc
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: : ::
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: acc
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: : ::
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position Width S () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: ( () AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position S Width [ [] _ false true ~FLOATLIT~ ~INTLIT~ ~PATVAR~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= extend-patvar
new_tokens ::= whitespace | "(" | ")" | "," | ":" | "::"
root ::= completions | new_tokens

Top 20 Logits:
):19.0427
,:16.4306
)->:15.0026
 ->:14.0622
)::13.7746
1:13.6834
_:12.9687
0:12.7574
::12.673
u:12.1096
 =:12.0673
 ):11.8465
 ,:11.3977
2:11.3548
 ::11.0879
s:11.0334
_):10.9176
),:10.6987
=:10.5858
=[:10.1323
)=:10.1188

================
# Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc)

LSP: Prelude: Recieved string: ### List ###

# Add an element to the front of a list. #
let cons: (Int, [Int]) -> [Int] = fun x, xs -> x::xs in

# Determine the length of a list. #
let length: [Int] -> Int =
  fun xs ->
    case xs
    | [] => 0
    | _::xs => 1 + length(xs) end in

# Extract the first element of a list. #
let hd: [Int] -> Option =
  fun l ->
    case l
    | [] => None
    | x::xs => Some(x) end in

# Extract the rest of the list. #
let tl: [Int] -> [Int] =
  fun l ->
    case l
    | [] => []
    | x::xs => xs end in

# Determine if a list is empty. #
let is_empty: [Int] -> Bool =
  fun xs ->
    case xs
    | [] => true
    | _::_ => false end in

# Return the element at the index. #
let nth: ([Int], Int) -> Option =
  fun xs, n ->
    case xs, n
    | x::_, 0 => Some(x)
    | _::xs, n => nth(xs, n - 1)
    | [], _ => None end in

# Reverse a List. #
let rev: [Int] -> [Int] =
fun l -> 
let go: ([Int], [Int]) -> [Int] =
  fun xs, acc -> 
    case xs 
    | [] => acc 
    | x::xs => go(xs, x::acc) end in
go(l, []) in

# Check if two lists are equal #
let equal: ([Int], [Int]) -> Bool =
    fun p, xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => x == y && equal(xs, ys)
    | _ => false end
in

# Initialize a list with a given length using an initializer function #
let init: (Int, Int -> Int) -> [Int] =
    fun len, f ->
        let go: (Int, [Int]) -> [Int] =
        fun idx, xs ->
            if idx < len 
            then go(idx + 1, xs @ [f(idx)])   
            else xs
        in
        go(0, [])
in

# Reduce a list from the left. #
let fold_left: ((Int, Int) -> Int, Int, [Int]) -> Int =
  fun f, acc, xs ->
    case xs 
    | [] => acc
    | hd::tl => fold_left(f, f(acc, hd), tl) end in

# Reduce a list from the right. #
let fold_right: ((Int, Int) -> Int, [Int], Int) -> Int =
  fun f, xs, acc ->
    case xs
    | [] => acc
    | hd::tl => f(hd, fold_right(f, tl, acc)) end in


666
LSP: Prelude: String parsed successfully
LSP: Prelude: Info map generated successfully
Debug: true, Constrain: Types
LSP: Init: Recieved string: # Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc)
LSP: Init: String parsed successfully
  LSP: Syntax: Leftward is Complete Tile: <( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Parenthesized pattern
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: (?, ?)
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {acc: ?, xs: ?, filter: (((Int -> Bool), [Int]) -> [Int]), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: -> in
  LSP: Info: ALL errors:Error in term:
  p
Nature of error: type ((Int -> Bool), [Int]) is not consistent with arrow type
  LSP: Info: BidiCtx: Cls: Parenthesized pattern
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: ->
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: : ::
  LSP: Concave: Postfix: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new_tokens ::= whitespace | "," | "->" | ":" | "::"
root ::= new_tokens

Top 20 Logits:
 ->:20.0304
 :12.8282

:12.226
 xs:11.858
 =>:11.0205
 (:10.7982
 {:10.7912
 x:10.6162
 ::10.2103
 p:10.0953
 acc:9.97792
 f:9.86454
 -:9.80238
 =:9.57485
 :9.40344
 ~:9.20203
 #:8.92708
 l:8.89136
 match:8.73971
 >:8.69193
 in:8.67545

================
# Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->

LSP: Prelude: Recieved string: ### List ###

# Add an element to the front of a list. #
let cons: (Int, [Int]) -> [Int] = fun x, xs -> x::xs in

# Determine the length of a list. #
let length: [Int] -> Int =
  fun xs ->
    case xs
    | [] => 0
    | _::xs => 1 + length(xs) end in

# Extract the first element of a list. #
let hd: [Int] -> Option =
  fun l ->
    case l
    | [] => None
    | x::xs => Some(x) end in

# Extract the rest of the list. #
let tl: [Int] -> [Int] =
  fun l ->
    case l
    | [] => []
    | x::xs => xs end in

# Determine if a list is empty. #
let is_empty: [Int] -> Bool =
  fun xs ->
    case xs
    | [] => true
    | _::_ => false end in

# Return the element at the index. #
let nth: ([Int], Int) -> Option =
  fun xs, n ->
    case xs, n
    | x::_, 0 => Some(x)
    | _::xs, n => nth(xs, n - 1)
    | [], _ => None end in

# Reverse a List. #
let rev: [Int] -> [Int] =
fun l -> 
let go: ([Int], [Int]) -> [Int] =
  fun xs, acc -> 
    case xs 
    | [] => acc 
    | x::xs => go(xs, x::acc) end in
go(l, []) in

# Check if two lists are equal #
let equal: ([Int], [Int]) -> Bool =
    fun p, xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => x == y && equal(xs, ys)
    | _ => false end
in

# Initialize a list with a given length using an initializer function #
let init: (Int, Int -> Int) -> [Int] =
    fun len, f ->
        let go: (Int, [Int]) -> [Int] =
        fun idx, xs ->
            if idx < len 
            then go(idx + 1, xs @ [f(idx)])   
            else xs
        in
        go(0, [])
in

# Reduce a list from the left. #
let fold_left: ((Int, Int) -> Int, Int, [Int]) -> Int =
  fun f, acc, xs ->
    case xs 
    | [] => acc
    | hd::tl => fold_left(f, f(acc, hd), tl) end in

# Reduce a list from the right. #
let fold_right: ((Int, Int) -> Int, [Int], Int) -> Int =
  fun f, xs, acc ->
    case xs
    | [] => acc
    | hd::tl => f(hd, fold_right(f, tl, acc)) end in


666
LSP: Prelude: String parsed successfully
LSP: Prelude: Info map generated successfully
Debug: true, Constrain: Types
LSP: Init: Recieved string: # Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
LSP: Init: String parsed successfully
  LSP: Syntax: Leftward is Complete Tile: <fun -><
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {acc: ?, xs: ?, filter: (((Int -> Bool), [Int]) -> [Int]), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: in
  LSP: Info: ALL errors:Error in term:
  p
Nature of error: type ((Int -> Bool), [Int]) is not consistent with arrow type
  LSP: Info: BidiCtx: Cls: Function literal
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 ?
  LSP: Convex: Target types: ?
  LSP: Convex: Backpack: 
  LSP: Convex: Base: acc xs filter string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position Width S () [] _ false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: ! ( () - AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position S Width [ [] _ abs abs_float acc acos asin atan bool_of_string case  ceil cos epsilon_float exp false filter float_of_int float_of_string floor fun  if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod nan neg_infinity pi sin sqrt string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan test  true type  xs ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new_tokens ::= whitespace | "!" | "(" | "()" | "-" | "AlignItems" | "BackgroundColor" | "Border" | "BorderRadius" | "BoxShadow" | "Color" | "Cursor" | "Display" | "FlexDirection" | "FontFamily" | "FontSize" | "FontStyle" | "Gap" | "Height" | "JustifyContent" | "Margin" | "Opacity" | "Outline" | "Overflow" | "Padding" | "Position" | "S" | "Width" | "[" | "[]" | "_" | "abs" | "abs_float" | "acc" | "acos" | "asin" | "atan" | "bool_of_string" | "case " | "ceil" | "cos" | "epsilon_float" | "exp" | "false" | "filter" | "float_of_int" | "float_of_string" | "floor" | "fun " | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "nan" | "neg_infinity" | "pi" | "sin" | "sqrt" | "string_compare" | "string_concat" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "true" | "type " | "xs" | floatlit | intlit | stringlit
root ::= new_tokens

Top 20 Logits:

:18.4152
 :17.0824
 case:15.0388
  :13.2883
 fol:13.0277
 filter:12.9845
    :12.8557
 #:12.409
 reverse:12.0345
 match:11.555
                :11.4286
        :11.3444
 cons:11.1503
 (:11.0486
 rev:10.9789
      :10.9592
 let:10.9141
 xs:10.8381
   :10.8304
 acc:10.7825
            :10.6932

================
# Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->


LSP: Prelude: Recieved string: ### List ###

# Add an element to the front of a list. #
let cons: (Int, [Int]) -> [Int] = fun x, xs -> x::xs in

# Determine the length of a list. #
let length: [Int] -> Int =
  fun xs ->
    case xs
    | [] => 0
    | _::xs => 1 + length(xs) end in

# Extract the first element of a list. #
let hd: [Int] -> Option =
  fun l ->
    case l
    | [] => None
    | x::xs => Some(x) end in

# Extract the rest of the list. #
let tl: [Int] -> [Int] =
  fun l ->
    case l
    | [] => []
    | x::xs => xs end in

# Determine if a list is empty. #
let is_empty: [Int] -> Bool =
  fun xs ->
    case xs
    | [] => true
    | _::_ => false end in

# Return the element at the index. #
let nth: ([Int], Int) -> Option =
  fun xs, n ->
    case xs, n
    | x::_, 0 => Some(x)
    | _::xs, n => nth(xs, n - 1)
    | [], _ => None end in

# Reverse a List. #
let rev: [Int] -> [Int] =
fun l -> 
let go: ([Int], [Int]) -> [Int] =
  fun xs, acc -> 
    case xs 
    | [] => acc 
    | x::xs => go(xs, x::acc) end in
go(l, []) in

# Check if two lists are equal #
let equal: ([Int], [Int]) -> Bool =
    fun p, xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => x == y && equal(xs, ys)
    | _ => false end
in

# Initialize a list with a given length using an initializer function #
let init: (Int, Int -> Int) -> [Int] =
    fun len, f ->
        let go: (Int, [Int]) -> [Int] =
        fun idx, xs ->
            if idx < len 
            then go(idx + 1, xs @ [f(idx)])   
            else xs
        in
        go(0, [])
in

# Reduce a list from the left. #
let fold_left: ((Int, Int) -> Int, Int, [Int]) -> Int =
  fun f, acc, xs ->
    case xs 
    | [] => acc
    | hd::tl => fold_left(f, f(acc, hd), tl) end in

# Reduce a list from the right. #
let fold_right: ((Int, Int) -> Int, [Int], Int) -> Int =
  fun f, xs, acc ->
    case xs
    | [] => acc
    | hd::tl => f(hd, fold_right(f, tl, acc)) end in


666
LSP: Prelude: String parsed successfully
LSP: Prelude: Info map generated successfully
Debug: true, Constrain: Types
LSP: Init: Recieved string: # Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->

LSP: Init: String parsed successfully
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: <fun -><
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {acc: ?, xs: ?, filter: (((Int -> Bool), [Int]) -> [Int]), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: in
  LSP: Info: ALL errors:Error in term:
  p
Nature of error: type ((Int -> Bool), [Int]) is not consistent with arrow type
  LSP: Info: BidiCtx: Cls: Function literal
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 ?
  LSP: Convex: Target types: ?
  LSP: Convex: Backpack: 
  LSP: Convex: Base: acc xs filter string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position Width S () [] _ false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: ! ( () - AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position S Width [ [] _ abs abs_float acc acos asin atan bool_of_string case  ceil cos epsilon_float exp false filter float_of_int float_of_string floor fun  if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod nan neg_infinity pi sin sqrt string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan test  true type  xs ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new_tokens ::= whitespace | "!" | "(" | "()" | "-" | "AlignItems" | "BackgroundColor" | "Border" | "BorderRadius" | "BoxShadow" | "Color" | "Cursor" | "Display" | "FlexDirection" | "FontFamily" | "FontSize" | "FontStyle" | "Gap" | "Height" | "JustifyContent" | "Margin" | "Opacity" | "Outline" | "Overflow" | "Padding" | "Position" | "S" | "Width" | "[" | "[]" | "_" | "abs" | "abs_float" | "acc" | "acos" | "asin" | "atan" | "bool_of_string" | "case " | "ceil" | "cos" | "epsilon_float" | "exp" | "false" | "filter" | "float_of_int" | "float_of_string" | "floor" | "fun " | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "nan" | "neg_infinity" | "pi" | "sin" | "sqrt" | "string_compare" | "string_concat" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "true" | "type " | "xs" | floatlit | intlit | stringlit
root ::= new_tokens

Top 20 Logits:
 :18.9124
     :16.4884
   :16.1309
case:15.6297
       :15.6291
           :15.2578
         :14.7975
             :14.0706
  :13.7011
               :13.5493
                :13.4115
	:13.0552
|:12.9549
    :12.6893
      :12.5612
 case:12.462
          :12.125
let:12.1143
#:12.0422
match:12.0401
            :11.9299

================
# Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
 

LSP: Prelude: Recieved string: ### List ###

# Add an element to the front of a list. #
let cons: (Int, [Int]) -> [Int] = fun x, xs -> x::xs in

# Determine the length of a list. #
let length: [Int] -> Int =
  fun xs ->
    case xs
    | [] => 0
    | _::xs => 1 + length(xs) end in

# Extract the first element of a list. #
let hd: [Int] -> Option =
  fun l ->
    case l
    | [] => None
    | x::xs => Some(x) end in

# Extract the rest of the list. #
let tl: [Int] -> [Int] =
  fun l ->
    case l
    | [] => []
    | x::xs => xs end in

# Determine if a list is empty. #
let is_empty: [Int] -> Bool =
  fun xs ->
    case xs
    | [] => true
    | _::_ => false end in

# Return the element at the index. #
let nth: ([Int], Int) -> Option =
  fun xs, n ->
    case xs, n
    | x::_, 0 => Some(x)
    | _::xs, n => nth(xs, n - 1)
    | [], _ => None end in

# Reverse a List. #
let rev: [Int] -> [Int] =
fun l -> 
let go: ([Int], [Int]) -> [Int] =
  fun xs, acc -> 
    case xs 
    | [] => acc 
    | x::xs => go(xs, x::acc) end in
go(l, []) in

# Check if two lists are equal #
let equal: ([Int], [Int]) -> Bool =
    fun p, xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => x == y && equal(xs, ys)
    | _ => false end
in

# Initialize a list with a given length using an initializer function #
let init: (Int, Int -> Int) -> [Int] =
    fun len, f ->
        let go: (Int, [Int]) -> [Int] =
        fun idx, xs ->
            if idx < len 
            then go(idx + 1, xs @ [f(idx)])   
            else xs
        in
        go(0, [])
in

# Reduce a list from the left. #
let fold_left: ((Int, Int) -> Int, Int, [Int]) -> Int =
  fun f, acc, xs ->
    case xs 
    | [] => acc
    | hd::tl => fold_left(f, f(acc, hd), tl) end in

# Reduce a list from the right. #
let fold_right: ((Int, Int) -> Int, [Int], Int) -> Int =
  fun f, xs, acc ->
    case xs
    | [] => acc
    | hd::tl => f(hd, fold_right(f, tl, acc)) end in


666
LSP: Prelude: String parsed successfully
LSP: Prelude: Info map generated successfully
Debug: true, Constrain: Types
LSP: Init: Recieved string: # Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
 
LSP: Init: String parsed successfully
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: <fun -><
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {acc: ?, xs: ?, filter: (((Int -> Bool), [Int]) -> [Int]), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: in
  LSP: Info: ALL errors:Error in term:
  p
Nature of error: type ((Int -> Bool), [Int]) is not consistent with arrow type
  LSP: Info: BidiCtx: Cls: Function literal
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 ?
  LSP: Convex: Target types: ?
  LSP: Convex: Backpack: 
  LSP: Convex: Base: acc xs filter string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position Width S () [] _ false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: ! ( () - AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position S Width [ [] _ abs abs_float acc acos asin atan bool_of_string case  ceil cos epsilon_float exp false filter float_of_int float_of_string floor fun  if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod nan neg_infinity pi sin sqrt string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan test  true type  xs ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new_tokens ::= whitespace | "!" | "(" | "()" | "-" | "AlignItems" | "BackgroundColor" | "Border" | "BorderRadius" | "BoxShadow" | "Color" | "Cursor" | "Display" | "FlexDirection" | "FontFamily" | "FontSize" | "FontStyle" | "Gap" | "Height" | "JustifyContent" | "Margin" | "Opacity" | "Outline" | "Overflow" | "Padding" | "Position" | "S" | "Width" | "[" | "[]" | "_" | "abs" | "abs_float" | "acc" | "acos" | "asin" | "atan" | "bool_of_string" | "case " | "ceil" | "cos" | "epsilon_float" | "exp" | "false" | "filter" | "float_of_int" | "float_of_string" | "floor" | "fun " | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "nan" | "neg_infinity" | "pi" | "sin" | "sqrt" | "string_compare" | "string_concat" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "true" | "type " | "xs" | floatlit | intlit | stringlit
root ::= new_tokens

Top 20 Logits:
 case:21.6022
 match:16.4722
 let:15.621
 if:14.5569
 fol:14.0099
 #:13.4092
 (:13.1332
 xs:12.3192
 acc:11.9983
 print:11.8796
 |:11.7793
 filter:11.4969
 fun:11.3723
 go:10.9152
 length:10.8716
 {:10.8406
 //:10.6323
 is:10.6069
 ((:10.5363
 cases:10.5256
 list:10.4478

================
# Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case

LSP: Prelude: Recieved string: ### List ###

# Add an element to the front of a list. #
let cons: (Int, [Int]) -> [Int] = fun x, xs -> x::xs in

# Determine the length of a list. #
let length: [Int] -> Int =
  fun xs ->
    case xs
    | [] => 0
    | _::xs => 1 + length(xs) end in

# Extract the first element of a list. #
let hd: [Int] -> Option =
  fun l ->
    case l
    | [] => None
    | x::xs => Some(x) end in

# Extract the rest of the list. #
let tl: [Int] -> [Int] =
  fun l ->
    case l
    | [] => []
    | x::xs => xs end in

# Determine if a list is empty. #
let is_empty: [Int] -> Bool =
  fun xs ->
    case xs
    | [] => true
    | _::_ => false end in

# Return the element at the index. #
let nth: ([Int], Int) -> Option =
  fun xs, n ->
    case xs, n
    | x::_, 0 => Some(x)
    | _::xs, n => nth(xs, n - 1)
    | [], _ => None end in

# Reverse a List. #
let rev: [Int] -> [Int] =
fun l -> 
let go: ([Int], [Int]) -> [Int] =
  fun xs, acc -> 
    case xs 
    | [] => acc 
    | x::xs => go(xs, x::acc) end in
go(l, []) in

# Check if two lists are equal #
let equal: ([Int], [Int]) -> Bool =
    fun p, xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => x == y && equal(xs, ys)
    | _ => false end
in

# Initialize a list with a given length using an initializer function #
let init: (Int, Int -> Int) -> [Int] =
    fun len, f ->
        let go: (Int, [Int]) -> [Int] =
        fun idx, xs ->
            if idx < len 
            then go(idx + 1, xs @ [f(idx)])   
            else xs
        in
        go(0, [])
in

# Reduce a list from the left. #
let fold_left: ((Int, Int) -> Int, Int, [Int]) -> Int =
  fun f, acc, xs ->
    case xs 
    | [] => acc
    | hd::tl => fold_left(f, f(acc, hd), tl) end in

# Reduce a list from the right. #
let fold_right: ((Int, Int) -> Int, [Int], Int) -> Int =
  fun f, xs, acc ->
    case xs
    | [] => acc
    | hd::tl => f(hd, fold_right(f, tl, acc)) end in


666
LSP: Prelude: String parsed successfully
LSP: Prelude: Info map generated successfully
Debug: true, Constrain: Types
LSP: Init: Recieved string: # Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case
LSP: Init: String parsed successfully
  LSP: Syntax: Leftward is Complete Tile: <case>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Exp (FreeVariable "case"))
  LSP: Info: Typing Context: {acc: ?, xs: ?, filter: (((Int -> Bool), [Int]) -> [Int]), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: in
  LSP: Info: ALL errors:Error in term:
  p
Nature of error: type ((Int -> Bool), [Int]) is not consistent with arrow type    
Error in term:
  case
Nature of error: Variable case is not bound
  LSP: Info: BidiCtx: Cls: Function literal
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-concave or complete: case
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: && \/ $== == != <= >= < > ==. !=. <=. >=. <. >. + - * / ** +. -. *. /. **. ++ :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Backpack: in
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: case
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: && \/ $== == != <= >= < > ==. !=. <=. >=. <. >. + - * / ** +. -. *. /. **. ++ :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Backpack: in
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Ty paths:
 ?
  LSP: Convex: Target types: ?
  LSP: Convex: Backpack: 
  LSP: Convex: Base: acc xs filter string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position Width S () [] _ false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: ! ( () - AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position S Width [ [] _ abs abs_float acc acos asin atan bool_of_string case  ceil cos epsilon_float exp false filter float_of_int float_of_string floor fun  if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod nan neg_infinity pi sin sqrt string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan test  true type  xs ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= " "
new_tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/" | "in"
root ::= completions | new_tokens

Top 20 Logits:
 xs:19.2167
 (:19.1243
(:14.4211
 ((:12.73
 x:12.599
 p:12.478
 list:12.3545
 acc:11.9714
 l:11.9264
 ():11.7478
 h:11.5617
 t:11.3293
 :11.0321
 ([:11.0028

:11.0012
 [:10.8365
 length:10.7609
 n:10.7276
 len:10.5822
 {:10.2598
 filter:10.2557

================
# Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (

LSP: Prelude: Recieved string: ### List ###

# Add an element to the front of a list. #
let cons: (Int, [Int]) -> [Int] = fun x, xs -> x::xs in

# Determine the length of a list. #
let length: [Int] -> Int =
  fun xs ->
    case xs
    | [] => 0
    | _::xs => 1 + length(xs) end in

# Extract the first element of a list. #
let hd: [Int] -> Option =
  fun l ->
    case l
    | [] => None
    | x::xs => Some(x) end in

# Extract the rest of the list. #
let tl: [Int] -> [Int] =
  fun l ->
    case l
    | [] => []
    | x::xs => xs end in

# Determine if a list is empty. #
let is_empty: [Int] -> Bool =
  fun xs ->
    case xs
    | [] => true
    | _::_ => false end in

# Return the element at the index. #
let nth: ([Int], Int) -> Option =
  fun xs, n ->
    case xs, n
    | x::_, 0 => Some(x)
    | _::xs, n => nth(xs, n - 1)
    | [], _ => None end in

# Reverse a List. #
let rev: [Int] -> [Int] =
fun l -> 
let go: ([Int], [Int]) -> [Int] =
  fun xs, acc -> 
    case xs 
    | [] => acc 
    | x::xs => go(xs, x::acc) end in
go(l, []) in

# Check if two lists are equal #
let equal: ([Int], [Int]) -> Bool =
    fun p, xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => x == y && equal(xs, ys)
    | _ => false end
in

# Initialize a list with a given length using an initializer function #
let init: (Int, Int -> Int) -> [Int] =
    fun len, f ->
        let go: (Int, [Int]) -> [Int] =
        fun idx, xs ->
            if idx < len 
            then go(idx + 1, xs @ [f(idx)])   
            else xs
        in
        go(0, [])
in

# Reduce a list from the left. #
let fold_left: ((Int, Int) -> Int, Int, [Int]) -> Int =
  fun f, acc, xs ->
    case xs 
    | [] => acc
    | hd::tl => fold_left(f, f(acc, hd), tl) end in

# Reduce a list from the right. #
let fold_right: ((Int, Int) -> Int, [Int], Int) -> Int =
  fun f, xs, acc ->
    case xs
    | [] => acc
    | hd::tl => f(hd, fold_right(f, tl, acc)) end in


666
LSP: Prelude: String parsed successfully
LSP: Prelude: Info map generated successfully
Debug: true, Constrain: Types
LSP: Init: Recieved string: # Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (
LSP: Init: String parsed successfully
  LSP: Syntax: Leftward is Incomplete Tile: <( )<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {acc: ?, xs: ?, filter: (((Int -> Bool), [Int]) -> [Int]), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: ALL errors:Error in term:
  p
Nature of error: type ((Int -> Bool), [Int]) is not consistent with arrow type
  LSP: Info: BidiCtx: Cls: Empty expression hole
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Info: Cls: Parenthesized expression
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {acc: ?, xs: ?, filter: (((Int -> Bool), [Int]) -> [Int]), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: ALL errors:Error in term:
  p
Nature of error: type ((Int -> Bool), [Int]) is not consistent with arrow type
  LSP: Info: BidiCtx: Cls: Parenthesized expression
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Syntax: Can insert left-convex or complete: (
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 ?
  LSP: Convex: Target types: ?
  LSP: Convex: Backpack: 
  LSP: Convex: Base: acc xs filter string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position Width S () [] _ false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: ! ( () - AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position S Width [ [] _ abs abs_float acc acos asin atan bool_of_string case  ceil cos epsilon_float exp false filter float_of_int float_of_string floor fun  if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod nan neg_infinity pi sin sqrt string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan test  true type  xs ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Generating Completions for prefix: (
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: && \/ $== == != <= >= < > ==. !=. <=. >=. <. >. + - * / ** +. -. *. /. **. ++ :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: ( |
  LSP: Convex: Ty paths:
 ?
  LSP: Convex: Target types: ?
  LSP: Convex: Backpack: 
  LSP: Convex: Base: acc xs filter string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position Width S () [] _ false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: ! ( () - AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position S Width [ [] _ abs abs_float acc acos asin atan bool_of_string case  ceil cos epsilon_float exp false filter float_of_int float_of_string floor fun  if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod nan neg_infinity pi sin sqrt string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan test  true type  xs ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= ")"
new_tokens ::= whitespace | "!" | "(" | "()" | "-" | "AlignItems" | "BackgroundColor" | "Border" | "BorderRadius" | "BoxShadow" | "Color" | "Cursor" | "Display" | "FlexDirection" | "FontFamily" | "FontSize" | "FontStyle" | "Gap" | "Height" | "JustifyContent" | "Margin" | "Opacity" | "Outline" | "Overflow" | "Padding" | "Position" | "S" | "Width" | "[" | "[]" | "_" | "abs" | "abs_float" | "acc" | "acos" | "asin" | "atan" | "bool_of_string" | "case " | "ceil" | "cos" | "epsilon_float" | "exp" | "false" | "filter" | "float_of_int" | "float_of_string" | "floor" | "fun " | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "nan" | "neg_infinity" | "pi" | "sin" | "sqrt" | "string_compare" | "string_concat" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "true" | "type " | "xs" | floatlit | intlit | stringlit
root ::= completions | new_tokens

Top 20 Logits:
xs:20.4805
filter:13.6264
p:13.4786
acc:13.2471
rev:13.1202
x:13.0251
 xs:12.5495
reverse:11.9506
is:11.9231
length:11.8178
fold:11.4679
f:11.3502
list:11.3384
ys:11.3247
cons:11.3152
hs:11.1035
hd:11.1015
tl:10.8995
len:10.8788
n:10.8756
map:10.7179

================
# Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs

LSP: Prelude: Recieved string: ### List ###

# Add an element to the front of a list. #
let cons: (Int, [Int]) -> [Int] = fun x, xs -> x::xs in

# Determine the length of a list. #
let length: [Int] -> Int =
  fun xs ->
    case xs
    | [] => 0
    | _::xs => 1 + length(xs) end in

# Extract the first element of a list. #
let hd: [Int] -> Option =
  fun l ->
    case l
    | [] => None
    | x::xs => Some(x) end in

# Extract the rest of the list. #
let tl: [Int] -> [Int] =
  fun l ->
    case l
    | [] => []
    | x::xs => xs end in

# Determine if a list is empty. #
let is_empty: [Int] -> Bool =
  fun xs ->
    case xs
    | [] => true
    | _::_ => false end in

# Return the element at the index. #
let nth: ([Int], Int) -> Option =
  fun xs, n ->
    case xs, n
    | x::_, 0 => Some(x)
    | _::xs, n => nth(xs, n - 1)
    | [], _ => None end in

# Reverse a List. #
let rev: [Int] -> [Int] =
fun l -> 
let go: ([Int], [Int]) -> [Int] =
  fun xs, acc -> 
    case xs 
    | [] => acc 
    | x::xs => go(xs, x::acc) end in
go(l, []) in

# Check if two lists are equal #
let equal: ([Int], [Int]) -> Bool =
    fun p, xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => x == y && equal(xs, ys)
    | _ => false end
in

# Initialize a list with a given length using an initializer function #
let init: (Int, Int -> Int) -> [Int] =
    fun len, f ->
        let go: (Int, [Int]) -> [Int] =
        fun idx, xs ->
            if idx < len 
            then go(idx + 1, xs @ [f(idx)])   
            else xs
        in
        go(0, [])
in

# Reduce a list from the left. #
let fold_left: ((Int, Int) -> Int, Int, [Int]) -> Int =
  fun f, acc, xs ->
    case xs 
    | [] => acc
    | hd::tl => fold_left(f, f(acc, hd), tl) end in

# Reduce a list from the right. #
let fold_right: ((Int, Int) -> Int, [Int], Int) -> Int =
  fun f, xs, acc ->
    case xs
    | [] => acc
    | hd::tl => f(hd, fold_right(f, tl, acc)) end in


666
LSP: Prelude: String parsed successfully
LSP: Prelude: Info map generated successfully
Debug: true, Constrain: Types
LSP: Init: Recieved string: # Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs
LSP: Init: String parsed successfully
  LSP: Syntax: Leftward is Complete Tile: <xs>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {acc: ?, xs: ?, filter: (((Int -> Bool), [Int]) -> [Int]), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: ALL errors:Error in term:
  p
Nature of error: type ((Int -> Bool), [Int]) is not consistent with arrow type
  LSP: Info: BidiCtx: Cls: Variable reference
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Can insert left-concave or complete: xs
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: && \/ $== == != <= >= < > ==. !=. <=. >=. <. >. + - * / ** +. -. *. /. **. ++ :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: xs
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: && \/ $== == != <= >= < > ==. !=. <=. >=. <. >. + - * / ** +. -. *. /. **. ++ :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Ty paths:
 ?
  LSP: Convex: Target types: ?
  LSP: Convex: Backpack: 
  LSP: Convex: Base: acc xs filter string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position Width S () [] _ false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: ! ( () - AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position S Width [ [] _ abs abs_float acc acos asin atan bool_of_string case  ceil cos epsilon_float exp false filter float_of_int float_of_string floor fun  if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod nan neg_infinity pi sin sqrt string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan test  true type  xs ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new_tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | ")" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/"
root ::= new_tokens

Top 20 Logits:
):21.9001
,:16.6973
)::15.4485
),:15.3953
::14.8716
 ):14.1699
);:13.5183
 =:12.1654
 ::12.0075
.:11.9773
)[:11.9562
[:11.5965
 ,:11.5189
)(:11.4446
)):11.406
)?:11.3379
)`:11.3022
 |:11.2123
).:11.2114
=:11.1929
)=:11.1877

================
# Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)

LSP: Prelude: Recieved string: ### List ###

# Add an element to the front of a list. #
let cons: (Int, [Int]) -> [Int] = fun x, xs -> x::xs in

# Determine the length of a list. #
let length: [Int] -> Int =
  fun xs ->
    case xs
    | [] => 0
    | _::xs => 1 + length(xs) end in

# Extract the first element of a list. #
let hd: [Int] -> Option =
  fun l ->
    case l
    | [] => None
    | x::xs => Some(x) end in

# Extract the rest of the list. #
let tl: [Int] -> [Int] =
  fun l ->
    case l
    | [] => []
    | x::xs => xs end in

# Determine if a list is empty. #
let is_empty: [Int] -> Bool =
  fun xs ->
    case xs
    | [] => true
    | _::_ => false end in

# Return the element at the index. #
let nth: ([Int], Int) -> Option =
  fun xs, n ->
    case xs, n
    | x::_, 0 => Some(x)
    | _::xs, n => nth(xs, n - 1)
    | [], _ => None end in

# Reverse a List. #
let rev: [Int] -> [Int] =
fun l -> 
let go: ([Int], [Int]) -> [Int] =
  fun xs, acc -> 
    case xs 
    | [] => acc 
    | x::xs => go(xs, x::acc) end in
go(l, []) in

# Check if two lists are equal #
let equal: ([Int], [Int]) -> Bool =
    fun p, xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => x == y && equal(xs, ys)
    | _ => false end
in

# Initialize a list with a given length using an initializer function #
let init: (Int, Int -> Int) -> [Int] =
    fun len, f ->
        let go: (Int, [Int]) -> [Int] =
        fun idx, xs ->
            if idx < len 
            then go(idx + 1, xs @ [f(idx)])   
            else xs
        in
        go(0, [])
in

# Reduce a list from the left. #
let fold_left: ((Int, Int) -> Int, Int, [Int]) -> Int =
  fun f, acc, xs ->
    case xs 
    | [] => acc
    | hd::tl => fold_left(f, f(acc, hd), tl) end in

# Reduce a list from the right. #
let fold_right: ((Int, Int) -> Int, [Int], Int) -> Int =
  fun f, xs, acc ->
    case xs
    | [] => acc
    | hd::tl => f(hd, fold_right(f, tl, acc)) end in


666
LSP: Prelude: String parsed successfully
LSP: Prelude: Info map generated successfully
Debug: true, Constrain: Types
LSP: Init: Recieved string: # Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
LSP: Init: String parsed successfully
  LSP: Syntax: Leftward is Complete Tile: <( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Parenthesized expression
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {acc: ?, xs: ?, filter: (((Int -> Bool), [Int]) -> [Int]), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end in
  LSP: Info: ALL errors:Error in term:
  p
Nature of error: type ((Int -> Bool), [Int]) is not consistent with arrow type
  LSP: Info: BidiCtx: Cls: Parenthesized expression
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: && \/ $== == != <= >= < > ==. !=. <=. >=. <. >. + - * / ** +. -. *. /. **. ++ :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Backpack: end
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: ( |
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new_tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/" | "end" | "|"
root ::= new_tokens

Top 20 Logits:

:19.5551
 :15.9723
 of:13.5631
  :13.2126
 |:12.8693
    :11.7994
 #:11.5447
 as:11.1628
                :11.0598
 in:10.9384
 end:10.4399
      :10.4309
 with:10.2326
   :10.1728
            :10.1001
        :10.077
 {:9.65921
 ||:9.62247
 :::9.45713
          :9.40606
       :9.39889

================
# Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)


LSP: Prelude: Recieved string: ### List ###

# Add an element to the front of a list. #
let cons: (Int, [Int]) -> [Int] = fun x, xs -> x::xs in

# Determine the length of a list. #
let length: [Int] -> Int =
  fun xs ->
    case xs
    | [] => 0
    | _::xs => 1 + length(xs) end in

# Extract the first element of a list. #
let hd: [Int] -> Option =
  fun l ->
    case l
    | [] => None
    | x::xs => Some(x) end in

# Extract the rest of the list. #
let tl: [Int] -> [Int] =
  fun l ->
    case l
    | [] => []
    | x::xs => xs end in

# Determine if a list is empty. #
let is_empty: [Int] -> Bool =
  fun xs ->
    case xs
    | [] => true
    | _::_ => false end in

# Return the element at the index. #
let nth: ([Int], Int) -> Option =
  fun xs, n ->
    case xs, n
    | x::_, 0 => Some(x)
    | _::xs, n => nth(xs, n - 1)
    | [], _ => None end in

# Reverse a List. #
let rev: [Int] -> [Int] =
fun l -> 
let go: ([Int], [Int]) -> [Int] =
  fun xs, acc -> 
    case xs 
    | [] => acc 
    | x::xs => go(xs, x::acc) end in
go(l, []) in

# Check if two lists are equal #
let equal: ([Int], [Int]) -> Bool =
    fun p, xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => x == y && equal(xs, ys)
    | _ => false end
in

# Initialize a list with a given length using an initializer function #
let init: (Int, Int -> Int) -> [Int] =
    fun len, f ->
        let go: (Int, [Int]) -> [Int] =
        fun idx, xs ->
            if idx < len 
            then go(idx + 1, xs @ [f(idx)])   
            else xs
        in
        go(0, [])
in

# Reduce a list from the left. #
let fold_left: ((Int, Int) -> Int, Int, [Int]) -> Int =
  fun f, acc, xs ->
    case xs 
    | [] => acc
    | hd::tl => fold_left(f, f(acc, hd), tl) end in

# Reduce a list from the right. #
let fold_right: ((Int, Int) -> Int, [Int], Int) -> Int =
  fun f, xs, acc ->
    case xs
    | [] => acc
    | hd::tl => f(hd, fold_right(f, tl, acc)) end in


666
LSP: Prelude: String parsed successfully
LSP: Prelude: Info map generated successfully
Debug: true, Constrain: Types
LSP: Init: Recieved string: # Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)

LSP: Init: String parsed successfully
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: <( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Parenthesized expression
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {acc: ?, xs: ?, filter: (((Int -> Bool), [Int]) -> [Int]), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end in
  LSP: Info: ALL errors:Error in term:
  p
Nature of error: type ((Int -> Bool), [Int]) is not consistent with arrow type
  LSP: Info: BidiCtx: Cls: Parenthesized expression
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: && \/ $== == != <= >= < > ==. !=. <=. >=. <. >. + - * / ** +. -. *. /. **. ++ :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Backpack: end
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: ( |
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new_tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/" | "end" | "|"
root ::= new_tokens

Top 20 Logits:
 :21.7837
   :18.1613
  :17.0422
|:16.7377
     :15.6137
    :15.2242
       :14.9337
	:14.8174
 |:13.9425
#:13.8727
         :13.4085
      :13.333
           :12.9627

:12.9323
                :12.1574
        :11.9331
             :11.7918
               :11.5705
          :11.3472
end:10.9105
...:10.8409

================
# Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
 

LSP: Prelude: Recieved string: ### List ###

# Add an element to the front of a list. #
let cons: (Int, [Int]) -> [Int] = fun x, xs -> x::xs in

# Determine the length of a list. #
let length: [Int] -> Int =
  fun xs ->
    case xs
    | [] => 0
    | _::xs => 1 + length(xs) end in

# Extract the first element of a list. #
let hd: [Int] -> Option =
  fun l ->
    case l
    | [] => None
    | x::xs => Some(x) end in

# Extract the rest of the list. #
let tl: [Int] -> [Int] =
  fun l ->
    case l
    | [] => []
    | x::xs => xs end in

# Determine if a list is empty. #
let is_empty: [Int] -> Bool =
  fun xs ->
    case xs
    | [] => true
    | _::_ => false end in

# Return the element at the index. #
let nth: ([Int], Int) -> Option =
  fun xs, n ->
    case xs, n
    | x::_, 0 => Some(x)
    | _::xs, n => nth(xs, n - 1)
    | [], _ => None end in

# Reverse a List. #
let rev: [Int] -> [Int] =
fun l -> 
let go: ([Int], [Int]) -> [Int] =
  fun xs, acc -> 
    case xs 
    | [] => acc 
    | x::xs => go(xs, x::acc) end in
go(l, []) in

# Check if two lists are equal #
let equal: ([Int], [Int]) -> Bool =
    fun p, xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => x == y && equal(xs, ys)
    | _ => false end
in

# Initialize a list with a given length using an initializer function #
let init: (Int, Int -> Int) -> [Int] =
    fun len, f ->
        let go: (Int, [Int]) -> [Int] =
        fun idx, xs ->
            if idx < len 
            then go(idx + 1, xs @ [f(idx)])   
            else xs
        in
        go(0, [])
in

# Reduce a list from the left. #
let fold_left: ((Int, Int) -> Int, Int, [Int]) -> Int =
  fun f, acc, xs ->
    case xs 
    | [] => acc
    | hd::tl => fold_left(f, f(acc, hd), tl) end in

# Reduce a list from the right. #
let fold_right: ((Int, Int) -> Int, [Int], Int) -> Int =
  fun f, xs, acc ->
    case xs
    | [] => acc
    | hd::tl => f(hd, fold_right(f, tl, acc)) end in


666
LSP: Prelude: String parsed successfully
LSP: Prelude: Info map generated successfully
Debug: true, Constrain: Types
LSP: Init: Recieved string: # Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
 
LSP: Init: String parsed successfully
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: <( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Parenthesized expression
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {acc: ?, xs: ?, filter: (((Int -> Bool), [Int]) -> [Int]), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end in
  LSP: Info: ALL errors:Error in term:
  p
Nature of error: type ((Int -> Bool), [Int]) is not consistent with arrow type
  LSP: Info: BidiCtx: Cls: Parenthesized expression
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: && \/ $== == != <= >= < > ==. !=. <=. >=. <. >. + - * / ** +. -. *. /. **. ++ :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Backpack: end
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: ( |
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new_tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/" | "end" | "|"
root ::= new_tokens

Top 20 Logits:
 |:21.6457
 #:14.6684
 ||:13.1904
 map:12.2482
 (*:12.2036
 (:11.7702
 ...:10.9798
 of:10.8576
 []:10.8068
 [:10.7255
 ::10.6561
 end:10.3764
 {:10.3032
 .:10.285
 match:10.1993
 as:10.16
	:9.99976
 any:9.90397
 `:9.87602
 #[:9.70341
 ,:9.65095

================
# Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  |

LSP: Prelude: Recieved string: ### List ###

# Add an element to the front of a list. #
let cons: (Int, [Int]) -> [Int] = fun x, xs -> x::xs in

# Determine the length of a list. #
let length: [Int] -> Int =
  fun xs ->
    case xs
    | [] => 0
    | _::xs => 1 + length(xs) end in

# Extract the first element of a list. #
let hd: [Int] -> Option =
  fun l ->
    case l
    | [] => None
    | x::xs => Some(x) end in

# Extract the rest of the list. #
let tl: [Int] -> [Int] =
  fun l ->
    case l
    | [] => []
    | x::xs => xs end in

# Determine if a list is empty. #
let is_empty: [Int] -> Bool =
  fun xs ->
    case xs
    | [] => true
    | _::_ => false end in

# Return the element at the index. #
let nth: ([Int], Int) -> Option =
  fun xs, n ->
    case xs, n
    | x::_, 0 => Some(x)
    | _::xs, n => nth(xs, n - 1)
    | [], _ => None end in

# Reverse a List. #
let rev: [Int] -> [Int] =
fun l -> 
let go: ([Int], [Int]) -> [Int] =
  fun xs, acc -> 
    case xs 
    | [] => acc 
    | x::xs => go(xs, x::acc) end in
go(l, []) in

# Check if two lists are equal #
let equal: ([Int], [Int]) -> Bool =
    fun p, xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => x == y && equal(xs, ys)
    | _ => false end
in

# Initialize a list with a given length using an initializer function #
let init: (Int, Int -> Int) -> [Int] =
    fun len, f ->
        let go: (Int, [Int]) -> [Int] =
        fun idx, xs ->
            if idx < len 
            then go(idx + 1, xs @ [f(idx)])   
            else xs
        in
        go(0, [])
in

# Reduce a list from the left. #
let fold_left: ((Int, Int) -> Int, Int, [Int]) -> Int =
  fun f, acc, xs ->
    case xs 
    | [] => acc
    | hd::tl => fold_left(f, f(acc, hd), tl) end in

# Reduce a list from the right. #
let fold_right: ((Int, Int) -> Int, [Int], Int) -> Int =
  fun f, xs, acc ->
    case xs
    | [] => acc
    | hd::tl => f(hd, fold_right(f, tl, acc)) end in


666
LSP: Prelude: String parsed successfully
LSP: Prelude: Info map generated successfully
Debug: true, Constrain: Types
LSP: Init: Recieved string: # Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  |
LSP: Init: String parsed successfully
  LSP: Syntax: Leftward is Incomplete Tile: >| =><
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty pattern hole
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {acc: ?, xs: ?, filter: (((Int -> Bool), [Int]) -> [Int]), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: => end in
  LSP: Info: ALL errors:Error in term:
  p
Nature of error: type ((Int -> Bool), [Int]) is not consistent with arrow type
  LSP: Info: BidiCtx: Cls: Empty pattern hole
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position Width S () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: ( () AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position S Width [ [] _ false true ~FLOATLIT~ ~INTLIT~ ~PATVAR~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new_tokens ::= whitespace | "(" | "()" | "AlignItems" | "BackgroundColor" | "Border" | "BorderRadius" | "BoxShadow" | "Color" | "Cursor" | "Display" | "FlexDirection" | "FontFamily" | "FontSize" | "FontStyle" | "Gap" | "Height" | "JustifyContent" | "Margin" | "Opacity" | "Outline" | "Overflow" | "Padding" | "Position" | "S" | "Width" | "[" | "[]" | "_" | "false" | "true" | floatlit | intlit | patvar | stringlit
root ::= new_tokens

Top 20 Logits:
 []:21.6212
[]:14.3913
 [],:13.8394
 x:13.7704
 (:13.6301
 _:13.038
 h:12.6246
 [:12.3586
 ([:12.2812
 :11.7572
 None:11.7266
 y:11.5941
 ():11.5208
 p:11.36
 a:11.3203
 ((:11.2744
 (_:10.9784
 [(:10.9713
 [_:10.9571
 xs:10.8949
 {:10.8332

================
# Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | []

LSP: Prelude: Recieved string: ### List ###

# Add an element to the front of a list. #
let cons: (Int, [Int]) -> [Int] = fun x, xs -> x::xs in

# Determine the length of a list. #
let length: [Int] -> Int =
  fun xs ->
    case xs
    | [] => 0
    | _::xs => 1 + length(xs) end in

# Extract the first element of a list. #
let hd: [Int] -> Option =
  fun l ->
    case l
    | [] => None
    | x::xs => Some(x) end in

# Extract the rest of the list. #
let tl: [Int] -> [Int] =
  fun l ->
    case l
    | [] => []
    | x::xs => xs end in

# Determine if a list is empty. #
let is_empty: [Int] -> Bool =
  fun xs ->
    case xs
    | [] => true
    | _::_ => false end in

# Return the element at the index. #
let nth: ([Int], Int) -> Option =
  fun xs, n ->
    case xs, n
    | x::_, 0 => Some(x)
    | _::xs, n => nth(xs, n - 1)
    | [], _ => None end in

# Reverse a List. #
let rev: [Int] -> [Int] =
fun l -> 
let go: ([Int], [Int]) -> [Int] =
  fun xs, acc -> 
    case xs 
    | [] => acc 
    | x::xs => go(xs, x::acc) end in
go(l, []) in

# Check if two lists are equal #
let equal: ([Int], [Int]) -> Bool =
    fun p, xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => x == y && equal(xs, ys)
    | _ => false end
in

# Initialize a list with a given length using an initializer function #
let init: (Int, Int -> Int) -> [Int] =
    fun len, f ->
        let go: (Int, [Int]) -> [Int] =
        fun idx, xs ->
            if idx < len 
            then go(idx + 1, xs @ [f(idx)])   
            else xs
        in
        go(0, [])
in

# Reduce a list from the left. #
let fold_left: ((Int, Int) -> Int, Int, [Int]) -> Int =
  fun f, acc, xs ->
    case xs 
    | [] => acc
    | hd::tl => fold_left(f, f(acc, hd), tl) end in

# Reduce a list from the right. #
let fold_right: ((Int, Int) -> Int, [Int], Int) -> Int =
  fun f, xs, acc ->
    case xs
    | [] => acc
    | hd::tl => f(hd, fold_right(f, tl, acc)) end in


666
LSP: Prelude: String parsed successfully
LSP: Prelude: Info map generated successfully
Debug: true, Constrain: Types
LSP: Init: Recieved string: # Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | []
LSP: Init: String parsed successfully
  LSP: Syntax: Leftward is Complete Tile: <[]>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: List literal
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {acc: ?, xs: ?, filter: (((Int -> Bool), [Int]) -> [Int]), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: => end in
  LSP: Info: ALL errors:Error in term:
  p
Nature of error: type ((Int -> Bool), [Int]) is not consistent with arrow type
  LSP: Info: BidiCtx: Cls: List literal
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Syntax: Can insert left-concave or complete: []
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: =>
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: : ::
  LSP: Concave: Postfix: 
LSP: Generating Completions for prefix: []
  LSP: Concave: Backpack: =>
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: : ::
  LSP: Concave: Postfix: 
  LSP: Convex: Backpack: 
  LSP: Convex: Base: AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position Width S () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: ( () AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position S Width [ [] _ false true ~FLOATLIT~ ~INTLIT~ ~PATVAR~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new_tokens ::= whitespace | ":" | "::" | "=>"
root ::= new_tokens

Top 20 Logits:
 =>:20.5897
 ->:14.6905
=>:14.2161
 :12.9121
 :::12.8036
 :=:12.6818
  :12.3835
    :12.3034
      :11.9698
     :11.8902
   :11.8841
       :11.6748
         :11.3748
 |:11.0191
:::10.9359
           :10.933
        :10.8939
 ||:10.8568
 ::10.8386
 =:10.5756
                :10.4644

================
# Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] =>

LSP: Prelude: Recieved string: ### List ###

# Add an element to the front of a list. #
let cons: (Int, [Int]) -> [Int] = fun x, xs -> x::xs in

# Determine the length of a list. #
let length: [Int] -> Int =
  fun xs ->
    case xs
    | [] => 0
    | _::xs => 1 + length(xs) end in

# Extract the first element of a list. #
let hd: [Int] -> Option =
  fun l ->
    case l
    | [] => None
    | x::xs => Some(x) end in

# Extract the rest of the list. #
let tl: [Int] -> [Int] =
  fun l ->
    case l
    | [] => []
    | x::xs => xs end in

# Determine if a list is empty. #
let is_empty: [Int] -> Bool =
  fun xs ->
    case xs
    | [] => true
    | _::_ => false end in

# Return the element at the index. #
let nth: ([Int], Int) -> Option =
  fun xs, n ->
    case xs, n
    | x::_, 0 => Some(x)
    | _::xs, n => nth(xs, n - 1)
    | [], _ => None end in

# Reverse a List. #
let rev: [Int] -> [Int] =
fun l -> 
let go: ([Int], [Int]) -> [Int] =
  fun xs, acc -> 
    case xs 
    | [] => acc 
    | x::xs => go(xs, x::acc) end in
go(l, []) in

# Check if two lists are equal #
let equal: ([Int], [Int]) -> Bool =
    fun p, xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => x == y && equal(xs, ys)
    | _ => false end
in

# Initialize a list with a given length using an initializer function #
let init: (Int, Int -> Int) -> [Int] =
    fun len, f ->
        let go: (Int, [Int]) -> [Int] =
        fun idx, xs ->
            if idx < len 
            then go(idx + 1, xs @ [f(idx)])   
            else xs
        in
        go(0, [])
in

# Reduce a list from the left. #
let fold_left: ((Int, Int) -> Int, Int, [Int]) -> Int =
  fun f, acc, xs ->
    case xs 
    | [] => acc
    | hd::tl => fold_left(f, f(acc, hd), tl) end in

# Reduce a list from the right. #
let fold_right: ((Int, Int) -> Int, [Int], Int) -> Int =
  fun f, xs, acc ->
    case xs
    | [] => acc
    | hd::tl => f(hd, fold_right(f, tl, acc)) end in


666
LSP: Prelude: String parsed successfully
LSP: Prelude: Info map generated successfully
Debug: true, Constrain: Types
LSP: Init: Recieved string: # Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] =>
LSP: Init: String parsed successfully
  LSP: Syntax: Leftward is Complete Tile: >| =><
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {acc: ?, xs: ?, filter: (((Int -> Bool), [Int]) -> [Int]), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end in
  LSP: Info: ALL errors:Error in term:
  p
Nature of error: type ((Int -> Bool), [Int]) is not consistent with arrow type
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 ?
  LSP: Convex: Target types: ?
  LSP: Convex: Backpack: 
  LSP: Convex: Base: acc xs filter string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position Width S () [] _ false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: ! ( () - AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position S Width [ [] _ abs abs_float acc acos asin atan bool_of_string case  ceil cos epsilon_float exp false filter float_of_int float_of_string floor fun  if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod nan neg_infinity pi sin sqrt string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan test  true type  xs ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new_tokens ::= whitespace | "!" | "(" | "()" | "-" | "AlignItems" | "BackgroundColor" | "Border" | "BorderRadius" | "BoxShadow" | "Color" | "Cursor" | "Display" | "FlexDirection" | "FontFamily" | "FontSize" | "FontStyle" | "Gap" | "Height" | "JustifyContent" | "Margin" | "Opacity" | "Outline" | "Overflow" | "Padding" | "Position" | "S" | "Width" | "[" | "[]" | "_" | "abs" | "abs_float" | "acc" | "acos" | "asin" | "atan" | "bool_of_string" | "case " | "ceil" | "cos" | "epsilon_float" | "exp" | "false" | "filter" | "float_of_int" | "float_of_string" | "floor" | "fun " | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "nan" | "neg_infinity" | "pi" | "sin" | "sqrt" | "string_compare" | "string_concat" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "true" | "type " | "xs" | floatlit | intlit | stringlit
root ::= new_tokens

Top 20 Logits:
 acc:16.7748
 rev:14.2094
 Some:14.092
 None:13.2642
 reverse:13.2505
 []:12.6704
 (:12.5502
 true:11.6706
 xs:11.382
 List:11.3119
 [:10.8407
 :10.756
 fol:10.7548
 ():10.6243
 ([:10.2894
 cons:10.1538
 t:10.0685
 length:10.0081
 {:9.87144
 list:9.82148
 false:9.80508

================
# Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc

LSP: Prelude: Recieved string: ### List ###

# Add an element to the front of a list. #
let cons: (Int, [Int]) -> [Int] = fun x, xs -> x::xs in

# Determine the length of a list. #
let length: [Int] -> Int =
  fun xs ->
    case xs
    | [] => 0
    | _::xs => 1 + length(xs) end in

# Extract the first element of a list. #
let hd: [Int] -> Option =
  fun l ->
    case l
    | [] => None
    | x::xs => Some(x) end in

# Extract the rest of the list. #
let tl: [Int] -> [Int] =
  fun l ->
    case l
    | [] => []
    | x::xs => xs end in

# Determine if a list is empty. #
let is_empty: [Int] -> Bool =
  fun xs ->
    case xs
    | [] => true
    | _::_ => false end in

# Return the element at the index. #
let nth: ([Int], Int) -> Option =
  fun xs, n ->
    case xs, n
    | x::_, 0 => Some(x)
    | _::xs, n => nth(xs, n - 1)
    | [], _ => None end in

# Reverse a List. #
let rev: [Int] -> [Int] =
fun l -> 
let go: ([Int], [Int]) -> [Int] =
  fun xs, acc -> 
    case xs 
    | [] => acc 
    | x::xs => go(xs, x::acc) end in
go(l, []) in

# Check if two lists are equal #
let equal: ([Int], [Int]) -> Bool =
    fun p, xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => x == y && equal(xs, ys)
    | _ => false end
in

# Initialize a list with a given length using an initializer function #
let init: (Int, Int -> Int) -> [Int] =
    fun len, f ->
        let go: (Int, [Int]) -> [Int] =
        fun idx, xs ->
            if idx < len 
            then go(idx + 1, xs @ [f(idx)])   
            else xs
        in
        go(0, [])
in

# Reduce a list from the left. #
let fold_left: ((Int, Int) -> Int, Int, [Int]) -> Int =
  fun f, acc, xs ->
    case xs 
    | [] => acc
    | hd::tl => fold_left(f, f(acc, hd), tl) end in

# Reduce a list from the right. #
let fold_right: ((Int, Int) -> Int, [Int], Int) -> Int =
  fun f, xs, acc ->
    case xs
    | [] => acc
    | hd::tl => f(hd, fold_right(f, tl, acc)) end in


666
LSP: Prelude: String parsed successfully
LSP: Prelude: Info map generated successfully
Debug: true, Constrain: Types
LSP: Init: Recieved string: # Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
LSP: Init: String parsed successfully
  LSP: Syntax: Leftward is Complete Tile: <acc>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {acc: ?, xs: ?, filter: (((Int -> Bool), [Int]) -> [Int]), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end in
  LSP: Info: ALL errors:Error in term:
  p
Nature of error: type ((Int -> Bool), [Int]) is not consistent with arrow type
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Syntax: Can insert left-concave or complete: acc
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: && \/ $== == != <= >= < > ==. !=. <=. >=. <. >. + - * / ** +. -. *. /. **. ++ :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Backpack: end
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: ( |
LSP: Generating Completions for prefix: acc
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: && \/ $== == != <= >= < > ==. !=. <=. >=. <. >. + - * / ** +. -. *. /. **. ++ :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Backpack: end
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: ( |
  LSP: Convex: Ty paths:
 ?
  LSP: Convex: Target types: ?
  LSP: Convex: Backpack: 
  LSP: Convex: Base: acc xs filter string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position Width S () [] _ false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: ! ( () - AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position S Width [ [] _ abs abs_float acc acos asin atan bool_of_string case  ceil cos epsilon_float exp false filter float_of_int float_of_string floor fun  if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod nan neg_infinity pi sin sqrt string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan test  true type  xs ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new_tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/" | "end" | "|"
root ::= new_tokens

Top 20 Logits:

:19.0441
 :14.0951
  :12.5199
.:12.3571
 |:12.0164
;:11.261
 @:11.0704
 #:10.9219
 reverse:10.8348
    :10.6557
:::10.3728
 +:10.2856
,:10.2834
[:10.1549
 in:10.1251
 //:10.1011
 end:10.0925
                :10.0585
@:10.0485
[]:9.78945
 :::9.78828

================
# Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc


LSP: Prelude: Recieved string: ### List ###

# Add an element to the front of a list. #
let cons: (Int, [Int]) -> [Int] = fun x, xs -> x::xs in

# Determine the length of a list. #
let length: [Int] -> Int =
  fun xs ->
    case xs
    | [] => 0
    | _::xs => 1 + length(xs) end in

# Extract the first element of a list. #
let hd: [Int] -> Option =
  fun l ->
    case l
    | [] => None
    | x::xs => Some(x) end in

# Extract the rest of the list. #
let tl: [Int] -> [Int] =
  fun l ->
    case l
    | [] => []
    | x::xs => xs end in

# Determine if a list is empty. #
let is_empty: [Int] -> Bool =
  fun xs ->
    case xs
    | [] => true
    | _::_ => false end in

# Return the element at the index. #
let nth: ([Int], Int) -> Option =
  fun xs, n ->
    case xs, n
    | x::_, 0 => Some(x)
    | _::xs, n => nth(xs, n - 1)
    | [], _ => None end in

# Reverse a List. #
let rev: [Int] -> [Int] =
fun l -> 
let go: ([Int], [Int]) -> [Int] =
  fun xs, acc -> 
    case xs 
    | [] => acc 
    | x::xs => go(xs, x::acc) end in
go(l, []) in

# Check if two lists are equal #
let equal: ([Int], [Int]) -> Bool =
    fun p, xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => x == y && equal(xs, ys)
    | _ => false end
in

# Initialize a list with a given length using an initializer function #
let init: (Int, Int -> Int) -> [Int] =
    fun len, f ->
        let go: (Int, [Int]) -> [Int] =
        fun idx, xs ->
            if idx < len 
            then go(idx + 1, xs @ [f(idx)])   
            else xs
        in
        go(0, [])
in

# Reduce a list from the left. #
let fold_left: ((Int, Int) -> Int, Int, [Int]) -> Int =
  fun f, acc, xs ->
    case xs 
    | [] => acc
    | hd::tl => fold_left(f, f(acc, hd), tl) end in

# Reduce a list from the right. #
let fold_right: ((Int, Int) -> Int, [Int], Int) -> Int =
  fun f, xs, acc ->
    case xs
    | [] => acc
    | hd::tl => f(hd, fold_right(f, tl, acc)) end in


666
LSP: Prelude: String parsed successfully
LSP: Prelude: Info map generated successfully
Debug: true, Constrain: Types
LSP: Init: Recieved string: # Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc

LSP: Init: String parsed successfully
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: <acc>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {acc: ?, xs: ?, filter: (((Int -> Bool), [Int]) -> [Int]), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end in
  LSP: Info: ALL errors:Error in term:
  p
Nature of error: type ((Int -> Bool), [Int]) is not consistent with arrow type
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: && \/ $== == != <= >= < > ==. !=. <=. >=. <. >. + - * / ** +. -. *. /. **. ++ :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Backpack: end
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: ( |
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new_tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/" | "end" | "|"
root ::= new_tokens

Top 20 Logits:
 :20.7286
|:14.0371
  :13.9003
   :13.0582
#:13.0203
end:12.9987
	:12.883
     :12.7538

:12.1142
 |:11.5499
    :11.1347
       :11.0621
:10.5761
 #:10.3006
      :10.1748
 :9.72377
                :9.68672
else:9.65847
         :9.65371
 end:9.63709
in:9.57739

================
# Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
 

LSP: Prelude: Recieved string: ### List ###

# Add an element to the front of a list. #
let cons: (Int, [Int]) -> [Int] = fun x, xs -> x::xs in

# Determine the length of a list. #
let length: [Int] -> Int =
  fun xs ->
    case xs
    | [] => 0
    | _::xs => 1 + length(xs) end in

# Extract the first element of a list. #
let hd: [Int] -> Option =
  fun l ->
    case l
    | [] => None
    | x::xs => Some(x) end in

# Extract the rest of the list. #
let tl: [Int] -> [Int] =
  fun l ->
    case l
    | [] => []
    | x::xs => xs end in

# Determine if a list is empty. #
let is_empty: [Int] -> Bool =
  fun xs ->
    case xs
    | [] => true
    | _::_ => false end in

# Return the element at the index. #
let nth: ([Int], Int) -> Option =
  fun xs, n ->
    case xs, n
    | x::_, 0 => Some(x)
    | _::xs, n => nth(xs, n - 1)
    | [], _ => None end in

# Reverse a List. #
let rev: [Int] -> [Int] =
fun l -> 
let go: ([Int], [Int]) -> [Int] =
  fun xs, acc -> 
    case xs 
    | [] => acc 
    | x::xs => go(xs, x::acc) end in
go(l, []) in

# Check if two lists are equal #
let equal: ([Int], [Int]) -> Bool =
    fun p, xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => x == y && equal(xs, ys)
    | _ => false end
in

# Initialize a list with a given length using an initializer function #
let init: (Int, Int -> Int) -> [Int] =
    fun len, f ->
        let go: (Int, [Int]) -> [Int] =
        fun idx, xs ->
            if idx < len 
            then go(idx + 1, xs @ [f(idx)])   
            else xs
        in
        go(0, [])
in

# Reduce a list from the left. #
let fold_left: ((Int, Int) -> Int, Int, [Int]) -> Int =
  fun f, acc, xs ->
    case xs 
    | [] => acc
    | hd::tl => fold_left(f, f(acc, hd), tl) end in

# Reduce a list from the right. #
let fold_right: ((Int, Int) -> Int, [Int], Int) -> Int =
  fun f, xs, acc ->
    case xs
    | [] => acc
    | hd::tl => f(hd, fold_right(f, tl, acc)) end in


666
LSP: Prelude: String parsed successfully
LSP: Prelude: Info map generated successfully
Debug: true, Constrain: Types
LSP: Init: Recieved string: # Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
 
LSP: Init: String parsed successfully
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: <acc>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {acc: ?, xs: ?, filter: (((Int -> Bool), [Int]) -> [Int]), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end in
  LSP: Info: ALL errors:Error in term:
  p
Nature of error: type ((Int -> Bool), [Int]) is not consistent with arrow type
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: && \/ $== == != <= >= < > ==. !=. <=. >=. <. >. + - * / ** +. -. *. /. **. ++ :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Backpack: end
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: ( |
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new_tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/" | "end" | "|"
root ::= new_tokens

Top 20 Logits:
 |:22.1239
 #:15.6032
 f:12.5724
 (*:12.5578
 ||:12.4814
 end:12.1226
 (:11.985
 p:11.6643
 @:11.0719
 if:10.8542
 match:10.8505
 ...:10.6189
 //:10.5675
 |\:10.5603
 case:10.4329
 func:10.4125
 else:10.2867
 let:10.271
 map:10.2163
 x:10.1282
 ::10.0778

================
# Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  |

LSP: Prelude: Recieved string: ### List ###

# Add an element to the front of a list. #
let cons: (Int, [Int]) -> [Int] = fun x, xs -> x::xs in

# Determine the length of a list. #
let length: [Int] -> Int =
  fun xs ->
    case xs
    | [] => 0
    | _::xs => 1 + length(xs) end in

# Extract the first element of a list. #
let hd: [Int] -> Option =
  fun l ->
    case l
    | [] => None
    | x::xs => Some(x) end in

# Extract the rest of the list. #
let tl: [Int] -> [Int] =
  fun l ->
    case l
    | [] => []
    | x::xs => xs end in

# Determine if a list is empty. #
let is_empty: [Int] -> Bool =
  fun xs ->
    case xs
    | [] => true
    | _::_ => false end in

# Return the element at the index. #
let nth: ([Int], Int) -> Option =
  fun xs, n ->
    case xs, n
    | x::_, 0 => Some(x)
    | _::xs, n => nth(xs, n - 1)
    | [], _ => None end in

# Reverse a List. #
let rev: [Int] -> [Int] =
fun l -> 
let go: ([Int], [Int]) -> [Int] =
  fun xs, acc -> 
    case xs 
    | [] => acc 
    | x::xs => go(xs, x::acc) end in
go(l, []) in

# Check if two lists are equal #
let equal: ([Int], [Int]) -> Bool =
    fun p, xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => x == y && equal(xs, ys)
    | _ => false end
in

# Initialize a list with a given length using an initializer function #
let init: (Int, Int -> Int) -> [Int] =
    fun len, f ->
        let go: (Int, [Int]) -> [Int] =
        fun idx, xs ->
            if idx < len 
            then go(idx + 1, xs @ [f(idx)])   
            else xs
        in
        go(0, [])
in

# Reduce a list from the left. #
let fold_left: ((Int, Int) -> Int, Int, [Int]) -> Int =
  fun f, acc, xs ->
    case xs 
    | [] => acc
    | hd::tl => fold_left(f, f(acc, hd), tl) end in

# Reduce a list from the right. #
let fold_right: ((Int, Int) -> Int, [Int], Int) -> Int =
  fun f, xs, acc ->
    case xs
    | [] => acc
    | hd::tl => f(hd, fold_right(f, tl, acc)) end in


666
LSP: Prelude: String parsed successfully
LSP: Prelude: Info map generated successfully
Debug: true, Constrain: Types
LSP: Init: Recieved string: # Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  |
LSP: Init: String parsed successfully
  LSP: Syntax: Leftward is Incomplete Tile: >| =><
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty pattern hole
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {acc: ?, xs: ?, filter: (((Int -> Bool), [Int]) -> [Int]), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: => end in
  LSP: Info: ALL errors:Error in term:
  p
Nature of error: type ((Int -> Bool), [Int]) is not consistent with arrow type
  LSP: Info: BidiCtx: Cls: Empty pattern hole
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position Width S () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: ( () AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position S Width [ [] _ false true ~FLOATLIT~ ~INTLIT~ ~PATVAR~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new_tokens ::= whitespace | "(" | "()" | "AlignItems" | "BackgroundColor" | "Border" | "BorderRadius" | "BoxShadow" | "Color" | "Cursor" | "Display" | "FlexDirection" | "FontFamily" | "FontSize" | "FontStyle" | "Gap" | "Height" | "JustifyContent" | "Margin" | "Opacity" | "Outline" | "Overflow" | "Padding" | "Position" | "S" | "Width" | "[" | "[]" | "_" | "false" | "true" | floatlit | intlit | patvar | stringlit
root ::= new_tokens

Top 20 Logits:
 h:19.6347
 x:15.6177
 _:14.6929
 [:13.4533
 (:13.2614
 y:13.2323
 a:12.8912
 f:12.5015
 head:12.3297
 p:12.0467
 true:11.9859
 [_:11.8583
 l:11.821
 xs:11.4224
 (_:11.2941
 e:11.1361
 v:11.0463
 n:10.9672
 ((:10.9059
 z:10.7116
 :10.6838

================
# Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | h

LSP: Prelude: Recieved string: ### List ###

# Add an element to the front of a list. #
let cons: (Int, [Int]) -> [Int] = fun x, xs -> x::xs in

# Determine the length of a list. #
let length: [Int] -> Int =
  fun xs ->
    case xs
    | [] => 0
    | _::xs => 1 + length(xs) end in

# Extract the first element of a list. #
let hd: [Int] -> Option =
  fun l ->
    case l
    | [] => None
    | x::xs => Some(x) end in

# Extract the rest of the list. #
let tl: [Int] -> [Int] =
  fun l ->
    case l
    | [] => []
    | x::xs => xs end in

# Determine if a list is empty. #
let is_empty: [Int] -> Bool =
  fun xs ->
    case xs
    | [] => true
    | _::_ => false end in

# Return the element at the index. #
let nth: ([Int], Int) -> Option =
  fun xs, n ->
    case xs, n
    | x::_, 0 => Some(x)
    | _::xs, n => nth(xs, n - 1)
    | [], _ => None end in

# Reverse a List. #
let rev: [Int] -> [Int] =
fun l -> 
let go: ([Int], [Int]) -> [Int] =
  fun xs, acc -> 
    case xs 
    | [] => acc 
    | x::xs => go(xs, x::acc) end in
go(l, []) in

# Check if two lists are equal #
let equal: ([Int], [Int]) -> Bool =
    fun p, xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => x == y && equal(xs, ys)
    | _ => false end
in

# Initialize a list with a given length using an initializer function #
let init: (Int, Int -> Int) -> [Int] =
    fun len, f ->
        let go: (Int, [Int]) -> [Int] =
        fun idx, xs ->
            if idx < len 
            then go(idx + 1, xs @ [f(idx)])   
            else xs
        in
        go(0, [])
in

# Reduce a list from the left. #
let fold_left: ((Int, Int) -> Int, Int, [Int]) -> Int =
  fun f, acc, xs ->
    case xs 
    | [] => acc
    | hd::tl => fold_left(f, f(acc, hd), tl) end in

# Reduce a list from the right. #
let fold_right: ((Int, Int) -> Int, [Int], Int) -> Int =
  fun f, xs, acc ->
    case xs
    | [] => acc
    | hd::tl => f(hd, fold_right(f, tl, acc)) end in


666
LSP: Prelude: String parsed successfully
LSP: Prelude: Info map generated successfully
Debug: true, Constrain: Types
LSP: Init: Recieved string: # Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | h
LSP: Init: String parsed successfully
  LSP: Syntax: Leftward is Complete Tile: <h>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable binding
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {h: ?, acc: ?, xs: ?, filter: (((Int -> Bool), [Int]) -> [Int]), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: => end in
  LSP: Info: ALL errors:Error in term:
  p
Nature of error: type ((Int -> Bool), [Int]) is not consistent with arrow type
  LSP: Info: BidiCtx: Cls: Variable binding
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Syntax: Can insert left-concave or complete: h
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: =>
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: : ::
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: h
  LSP: Concave: Backpack: =>
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: : ::
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position Width S () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: ( () AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position S Width [ [] _ false true ~FLOATLIT~ ~INTLIT~ ~PATVAR~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= extend-patvar
new_tokens ::= whitespace | "(" | ":" | "::" | "=>"
root ::= completions | new_tokens

Top 20 Logits:
d:22.1049
:::16.1252
1:13.7615
 :::13.2952
dx:11.5331
dr:11.0408
ds:10.6915
::10.3083
s:10.1899
@:10.1481
,:10.1236
da:10.0951
ed:9.95199
h:9.93686
_:9.84497
di:9.6791
0:9.62085
x:9.48147
 =>:9.41747
do:9.38309
dd:9.21613

================
# Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd

LSP: Prelude: Recieved string: ### List ###

# Add an element to the front of a list. #
let cons: (Int, [Int]) -> [Int] = fun x, xs -> x::xs in

# Determine the length of a list. #
let length: [Int] -> Int =
  fun xs ->
    case xs
    | [] => 0
    | _::xs => 1 + length(xs) end in

# Extract the first element of a list. #
let hd: [Int] -> Option =
  fun l ->
    case l
    | [] => None
    | x::xs => Some(x) end in

# Extract the rest of the list. #
let tl: [Int] -> [Int] =
  fun l ->
    case l
    | [] => []
    | x::xs => xs end in

# Determine if a list is empty. #
let is_empty: [Int] -> Bool =
  fun xs ->
    case xs
    | [] => true
    | _::_ => false end in

# Return the element at the index. #
let nth: ([Int], Int) -> Option =
  fun xs, n ->
    case xs, n
    | x::_, 0 => Some(x)
    | _::xs, n => nth(xs, n - 1)
    | [], _ => None end in

# Reverse a List. #
let rev: [Int] -> [Int] =
fun l -> 
let go: ([Int], [Int]) -> [Int] =
  fun xs, acc -> 
    case xs 
    | [] => acc 
    | x::xs => go(xs, x::acc) end in
go(l, []) in

# Check if two lists are equal #
let equal: ([Int], [Int]) -> Bool =
    fun p, xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => x == y && equal(xs, ys)
    | _ => false end
in

# Initialize a list with a given length using an initializer function #
let init: (Int, Int -> Int) -> [Int] =
    fun len, f ->
        let go: (Int, [Int]) -> [Int] =
        fun idx, xs ->
            if idx < len 
            then go(idx + 1, xs @ [f(idx)])   
            else xs
        in
        go(0, [])
in

# Reduce a list from the left. #
let fold_left: ((Int, Int) -> Int, Int, [Int]) -> Int =
  fun f, acc, xs ->
    case xs 
    | [] => acc
    | hd::tl => fold_left(f, f(acc, hd), tl) end in

# Reduce a list from the right. #
let fold_right: ((Int, Int) -> Int, [Int], Int) -> Int =
  fun f, xs, acc ->
    case xs
    | [] => acc
    | hd::tl => f(hd, fold_right(f, tl, acc)) end in


666
LSP: Prelude: String parsed successfully
LSP: Prelude: Info map generated successfully
Debug: true, Constrain: Types
LSP: Init: Recieved string: # Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd
LSP: Init: String parsed successfully
  LSP: Syntax: Leftward is Complete Tile: <hd>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable binding
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {hd: ?, acc: ?, xs: ?, filter: (((Int -> Bool), [Int]) -> [Int]), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: => end in
  LSP: Info: ALL errors:Error in term:
  p
Nature of error: type ((Int -> Bool), [Int]) is not consistent with arrow type
  LSP: Info: BidiCtx: Cls: Variable binding
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Syntax: Can insert left-concave or complete: hd
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: =>
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: : ::
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: hd
  LSP: Concave: Backpack: =>
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: : ::
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position Width S () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: ( () AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position S Width [ [] _ false true ~FLOATLIT~ ~INTLIT~ ~PATVAR~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= extend-patvar
new_tokens ::= whitespace | "(" | ":" | "::" | "=>"
root ::= completions | new_tokens

Top 20 Logits:
:::21.6713
 :::14.9588
1:14.139
::13.0654
_:11.9049
@:11.7563
,:10.9984
|:10.4097
 +:10.1393
0:10.0836
 ::9.81262
*:9.42541
[:9.42402
X:9.35773

:9.28046
2:9.20148
#:9.12646
 =:9.07934
 =>:9.00139
 *:8.94467
:[:8.8877

================
# Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::

LSP: Prelude: Recieved string: ### List ###

# Add an element to the front of a list. #
let cons: (Int, [Int]) -> [Int] = fun x, xs -> x::xs in

# Determine the length of a list. #
let length: [Int] -> Int =
  fun xs ->
    case xs
    | [] => 0
    | _::xs => 1 + length(xs) end in

# Extract the first element of a list. #
let hd: [Int] -> Option =
  fun l ->
    case l
    | [] => None
    | x::xs => Some(x) end in

# Extract the rest of the list. #
let tl: [Int] -> [Int] =
  fun l ->
    case l
    | [] => []
    | x::xs => xs end in

# Determine if a list is empty. #
let is_empty: [Int] -> Bool =
  fun xs ->
    case xs
    | [] => true
    | _::_ => false end in

# Return the element at the index. #
let nth: ([Int], Int) -> Option =
  fun xs, n ->
    case xs, n
    | x::_, 0 => Some(x)
    | _::xs, n => nth(xs, n - 1)
    | [], _ => None end in

# Reverse a List. #
let rev: [Int] -> [Int] =
fun l -> 
let go: ([Int], [Int]) -> [Int] =
  fun xs, acc -> 
    case xs 
    | [] => acc 
    | x::xs => go(xs, x::acc) end in
go(l, []) in

# Check if two lists are equal #
let equal: ([Int], [Int]) -> Bool =
    fun p, xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => x == y && equal(xs, ys)
    | _ => false end
in

# Initialize a list with a given length using an initializer function #
let init: (Int, Int -> Int) -> [Int] =
    fun len, f ->
        let go: (Int, [Int]) -> [Int] =
        fun idx, xs ->
            if idx < len 
            then go(idx + 1, xs @ [f(idx)])   
            else xs
        in
        go(0, [])
in

# Reduce a list from the left. #
let fold_left: ((Int, Int) -> Int, Int, [Int]) -> Int =
  fun f, acc, xs ->
    case xs 
    | [] => acc
    | hd::tl => fold_left(f, f(acc, hd), tl) end in

# Reduce a list from the right. #
let fold_right: ((Int, Int) -> Int, [Int], Int) -> Int =
  fun f, xs, acc ->
    case xs
    | [] => acc
    | hd::tl => f(hd, fold_right(f, tl, acc)) end in


666
LSP: Prelude: String parsed successfully
LSP: Prelude: Info map generated successfully
Debug: true, Constrain: Types
LSP: Init: Recieved string: # Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::
LSP: Init: String parsed successfully
  LSP: Syntax: Leftward is Complete Tile: >::<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty pattern hole
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: [?]
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {hd: ?, acc: ?, xs: ?, filter: (((Int -> Bool), [Int]) -> [Int]), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: => end in
  LSP: Info: ALL errors:Error in term:
  p
Nature of error: type ((Int -> Bool), [Int]) is not consistent with arrow type
  LSP: Info: BidiCtx: Cls: Cons
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Info: Cls: Cons
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {hd: ?, acc: ?, xs: ?, filter: (((Int -> Bool), [Int]) -> [Int]), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: => end in
  LSP: Info: ALL errors:Error in term:
  p
Nature of error: type ((Int -> Bool), [Int]) is not consistent with arrow type
  LSP: Info: BidiCtx: Cls: Cons
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Syntax: Can insert left-convex or complete: ::
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: [] _ ~PATVAR~ ( [
  LSP: Convex: Lookahead: ( () AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position S Width [ [] _ false true ~FLOATLIT~ ~INTLIT~ ~PATVAR~ ~STRINGLIT~
LSP: Generating Completions for prefix: ::
  LSP: Concave: Backpack: =>
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: : ::
  LSP: Concave: Postfix: 
  LSP: Convex: Backpack: 
  LSP: Convex: Base: AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position Width S () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: ( () AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position S Width [ [] _ false true ~FLOATLIT~ ~INTLIT~ ~PATVAR~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new_tokens ::= whitespace | "(" | "()" | "AlignItems" | "BackgroundColor" | "Border" | "BorderRadius" | "BoxShadow" | "Color" | "Cursor" | "Display" | "FlexDirection" | "FontFamily" | "FontSize" | "FontStyle" | "Gap" | "Height" | "JustifyContent" | "Margin" | "Opacity" | "Outline" | "Overflow" | "Padding" | "Position" | "S" | "Width" | "[" | "[]" | "_" | "false" | "true" | floatlit | intlit | patvar | stringlit
root ::= new_tokens

Top 20 Logits:
tl:19.7714
[]:13.9762
tail:12.7292
_:12.0136
xs:11.9521
acc:11.3847
[:10.8847
(:10.8815
 t:10.8414
nil:10.6116
rest:10.5141
t:10.0802
ts:10.0075
xl:9.87469
x:9.86153
hd:9.57886
tt:9.55812
p:9.44759
f:9.30171
Nil:9.22939
td:9.17865

================
# Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl

LSP: Prelude: Recieved string: ### List ###

# Add an element to the front of a list. #
let cons: (Int, [Int]) -> [Int] = fun x, xs -> x::xs in

# Determine the length of a list. #
let length: [Int] -> Int =
  fun xs ->
    case xs
    | [] => 0
    | _::xs => 1 + length(xs) end in

# Extract the first element of a list. #
let hd: [Int] -> Option =
  fun l ->
    case l
    | [] => None
    | x::xs => Some(x) end in

# Extract the rest of the list. #
let tl: [Int] -> [Int] =
  fun l ->
    case l
    | [] => []
    | x::xs => xs end in

# Determine if a list is empty. #
let is_empty: [Int] -> Bool =
  fun xs ->
    case xs
    | [] => true
    | _::_ => false end in

# Return the element at the index. #
let nth: ([Int], Int) -> Option =
  fun xs, n ->
    case xs, n
    | x::_, 0 => Some(x)
    | _::xs, n => nth(xs, n - 1)
    | [], _ => None end in

# Reverse a List. #
let rev: [Int] -> [Int] =
fun l -> 
let go: ([Int], [Int]) -> [Int] =
  fun xs, acc -> 
    case xs 
    | [] => acc 
    | x::xs => go(xs, x::acc) end in
go(l, []) in

# Check if two lists are equal #
let equal: ([Int], [Int]) -> Bool =
    fun p, xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => x == y && equal(xs, ys)
    | _ => false end
in

# Initialize a list with a given length using an initializer function #
let init: (Int, Int -> Int) -> [Int] =
    fun len, f ->
        let go: (Int, [Int]) -> [Int] =
        fun idx, xs ->
            if idx < len 
            then go(idx + 1, xs @ [f(idx)])   
            else xs
        in
        go(0, [])
in

# Reduce a list from the left. #
let fold_left: ((Int, Int) -> Int, Int, [Int]) -> Int =
  fun f, acc, xs ->
    case xs 
    | [] => acc
    | hd::tl => fold_left(f, f(acc, hd), tl) end in

# Reduce a list from the right. #
let fold_right: ((Int, Int) -> Int, [Int], Int) -> Int =
  fun f, xs, acc ->
    case xs
    | [] => acc
    | hd::tl => f(hd, fold_right(f, tl, acc)) end in


666
LSP: Prelude: String parsed successfully
LSP: Prelude: Info map generated successfully
Debug: true, Constrain: Types
LSP: Init: Recieved string: # Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl
LSP: Init: String parsed successfully
  LSP: Syntax: Leftward is Complete Tile: <tl>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable binding
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: [?]
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {tl: [?], hd: ?, acc: ?, xs: ?, filter: (((Int -> Bool), [Int]) -> [Int]), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: => end in
  LSP: Info: ALL errors:Error in term:
  p
Nature of error: type ((Int -> Bool), [Int]) is not consistent with arrow type
  LSP: Info: BidiCtx: Cls: Cons
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Syntax: Can insert left-concave or complete: tl
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: =>
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: : ::
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: tl
  LSP: Concave: Backpack: =>
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: : ::
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: [] _ ~PATVAR~ ( [
  LSP: Convex: Lookahead: ( () AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position S Width [ [] _ false true ~FLOATLIT~ ~INTLIT~ ~PATVAR~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= extend-patvar
new_tokens ::= whitespace | "(" | ":" | "::" | "=>"
root ::= completions | new_tokens

Top 20 Logits:
 =>:20.0628
 ->:14.6447
 if:13.8524
=>:13.5466
 when:13.4242
 :12.2279
,:11.7953

:11.4942
 :::11.108
 =:10.9993
 :=:10.7783
1:10.6129
 acc:10.5582
 then:10.2799
_:10.1918
->:10.1488
 as:9.82079
':9.67004
 |:9.65624
::9.51083
:::9.35286

================
# Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl =>

LSP: Prelude: Recieved string: ### List ###

# Add an element to the front of a list. #
let cons: (Int, [Int]) -> [Int] = fun x, xs -> x::xs in

# Determine the length of a list. #
let length: [Int] -> Int =
  fun xs ->
    case xs
    | [] => 0
    | _::xs => 1 + length(xs) end in

# Extract the first element of a list. #
let hd: [Int] -> Option =
  fun l ->
    case l
    | [] => None
    | x::xs => Some(x) end in

# Extract the rest of the list. #
let tl: [Int] -> [Int] =
  fun l ->
    case l
    | [] => []
    | x::xs => xs end in

# Determine if a list is empty. #
let is_empty: [Int] -> Bool =
  fun xs ->
    case xs
    | [] => true
    | _::_ => false end in

# Return the element at the index. #
let nth: ([Int], Int) -> Option =
  fun xs, n ->
    case xs, n
    | x::_, 0 => Some(x)
    | _::xs, n => nth(xs, n - 1)
    | [], _ => None end in

# Reverse a List. #
let rev: [Int] -> [Int] =
fun l -> 
let go: ([Int], [Int]) -> [Int] =
  fun xs, acc -> 
    case xs 
    | [] => acc 
    | x::xs => go(xs, x::acc) end in
go(l, []) in

# Check if two lists are equal #
let equal: ([Int], [Int]) -> Bool =
    fun p, xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => x == y && equal(xs, ys)
    | _ => false end
in

# Initialize a list with a given length using an initializer function #
let init: (Int, Int -> Int) -> [Int] =
    fun len, f ->
        let go: (Int, [Int]) -> [Int] =
        fun idx, xs ->
            if idx < len 
            then go(idx + 1, xs @ [f(idx)])   
            else xs
        in
        go(0, [])
in

# Reduce a list from the left. #
let fold_left: ((Int, Int) -> Int, Int, [Int]) -> Int =
  fun f, acc, xs ->
    case xs 
    | [] => acc
    | hd::tl => fold_left(f, f(acc, hd), tl) end in

# Reduce a list from the right. #
let fold_right: ((Int, Int) -> Int, [Int], Int) -> Int =
  fun f, xs, acc ->
    case xs
    | [] => acc
    | hd::tl => f(hd, fold_right(f, tl, acc)) end in


666
LSP: Prelude: String parsed successfully
LSP: Prelude: Info map generated successfully
Debug: true, Constrain: Types
LSP: Init: Recieved string: # Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl =>
LSP: Init: String parsed successfully
  LSP: Syntax: Leftward is Complete Tile: >| =><
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {tl: [?], hd: ?, acc: ?, xs: ?, filter: (((Int -> Bool), [Int]) -> [Int]), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end in
  LSP: Info: ALL errors:Error in term:
  p
Nature of error: type ((Int -> Bool), [Int]) is not consistent with arrow type
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 ?
  LSP: Convex: Target types: ?
  LSP: Convex: Backpack: 
  LSP: Convex: Base: tl hd acc xs filter string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position Width S () [] _ false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: ! ( () - AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position S Width [ [] _ abs abs_float acc acos asin atan bool_of_string case  ceil cos epsilon_float exp false filter float_of_int float_of_string floor fun  hd if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod nan neg_infinity pi sin sqrt string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan test  tl true type  xs ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new_tokens ::= whitespace | "!" | "(" | "()" | "-" | "AlignItems" | "BackgroundColor" | "Border" | "BorderRadius" | "BoxShadow" | "Color" | "Cursor" | "Display" | "FlexDirection" | "FontFamily" | "FontSize" | "FontStyle" | "Gap" | "Height" | "JustifyContent" | "Margin" | "Opacity" | "Outline" | "Overflow" | "Padding" | "Position" | "S" | "Width" | "[" | "[]" | "_" | "abs" | "abs_float" | "acc" | "acos" | "asin" | "atan" | "bool_of_string" | "case " | "ceil" | "cos" | "epsilon_float" | "exp" | "false" | "filter" | "float_of_int" | "float_of_string" | "floor" | "fun " | "hd" | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "nan" | "neg_infinity" | "pi" | "sin" | "sqrt" | "string_compare" | "string_concat" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "tl" | "true" | "type " | "xs" | floatlit | intlit | stringlit
root ::= new_tokens

Top 20 Logits:
 if:16.5376
 go:13.265
 (:12.5386
 fol:12.2125

:11.8982
 :11.6335
 acc:11.5072
 filter:11.2208
 h:11.1725
 let:10.6935
 f:10.3229
 cons:10.289
 p:10.27
 fun:9.64522
 match:9.63442
 ((:9.43541
 t:9.34818
 map:9.21574
 [:9.14059
 case:8.25018
 reverse:8.2267

================
# Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if

LSP: Prelude: Recieved string: ### List ###

# Add an element to the front of a list. #
let cons: (Int, [Int]) -> [Int] = fun x, xs -> x::xs in

# Determine the length of a list. #
let length: [Int] -> Int =
  fun xs ->
    case xs
    | [] => 0
    | _::xs => 1 + length(xs) end in

# Extract the first element of a list. #
let hd: [Int] -> Option =
  fun l ->
    case l
    | [] => None
    | x::xs => Some(x) end in

# Extract the rest of the list. #
let tl: [Int] -> [Int] =
  fun l ->
    case l
    | [] => []
    | x::xs => xs end in

# Determine if a list is empty. #
let is_empty: [Int] -> Bool =
  fun xs ->
    case xs
    | [] => true
    | _::_ => false end in

# Return the element at the index. #
let nth: ([Int], Int) -> Option =
  fun xs, n ->
    case xs, n
    | x::_, 0 => Some(x)
    | _::xs, n => nth(xs, n - 1)
    | [], _ => None end in

# Reverse a List. #
let rev: [Int] -> [Int] =
fun l -> 
let go: ([Int], [Int]) -> [Int] =
  fun xs, acc -> 
    case xs 
    | [] => acc 
    | x::xs => go(xs, x::acc) end in
go(l, []) in

# Check if two lists are equal #
let equal: ([Int], [Int]) -> Bool =
    fun p, xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => x == y && equal(xs, ys)
    | _ => false end
in

# Initialize a list with a given length using an initializer function #
let init: (Int, Int -> Int) -> [Int] =
    fun len, f ->
        let go: (Int, [Int]) -> [Int] =
        fun idx, xs ->
            if idx < len 
            then go(idx + 1, xs @ [f(idx)])   
            else xs
        in
        go(0, [])
in

# Reduce a list from the left. #
let fold_left: ((Int, Int) -> Int, Int, [Int]) -> Int =
  fun f, acc, xs ->
    case xs 
    | [] => acc
    | hd::tl => fold_left(f, f(acc, hd), tl) end in

# Reduce a list from the right. #
let fold_right: ((Int, Int) -> Int, [Int], Int) -> Int =
  fun f, xs, acc ->
    case xs
    | [] => acc
    | hd::tl => f(hd, fold_right(f, tl, acc)) end in


666
LSP: Prelude: String parsed successfully
LSP: Prelude: Info map generated successfully
Debug: true, Constrain: Types
LSP: Init: Recieved string: # Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if
LSP: Init: String parsed successfully
  LSP: Syntax: Leftward is Complete Tile: <if>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Exp (FreeVariable "if"))
  LSP: Info: Typing Context: {tl: [?], hd: ?, acc: ?, xs: ?, filter: (((Int -> Bool), [Int]) -> [Int]), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end in
  LSP: Info: ALL errors:Error in term:
  p
Nature of error: type ((Int -> Bool), [Int]) is not consistent with arrow type    
Error in term:
  if
Nature of error: Variable if is not bound
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Syntax: Can insert left-concave or complete: if
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: && \/ $== == != <= >= < > ==. !=. <=. >=. <. >. + - * / ** +. -. *. /. **. ++ :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Backpack: end
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: ( |
LSP: Generating Completions for prefix: if
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: && \/ $== == != <= >= < > ==. !=. <=. >=. <. >. + - * / ** +. -. *. /. **. ++ :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Backpack: end
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: ( |
  LSP: Convex: Ty paths:
 ?
  LSP: Convex: Target types: ?
  LSP: Convex: Backpack: 
  LSP: Convex: Base: tl hd acc xs filter string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position Width S () [] _ false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: ! ( () - AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position S Width [ [] _ abs abs_float acc acos asin atan bool_of_string case  ceil cos epsilon_float exp false filter float_of_int float_of_string floor fun  hd if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod nan neg_infinity pi sin sqrt string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan test  tl true type  xs ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= " "
new_tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/" | "end" | "|"
root ::= completions | new_tokens

Top 20 Logits:
 (:18.0911
 p:16.581
 ((:14.8684
 h:13.8462
 is:13.7693
 not:13.7341
 (!:13.5294
 true:13.2494
 f:13.2386
 xs:13.219
 filter:12.731
 acc:12.6542
 length:12.5603
(:12.419
 !:12.1974
 t:12.1888
 equal:12.1844
 test:12.0426
 pred:11.7041
 x:11.652
 ([:11.5731

================
# Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (

LSP: Prelude: Recieved string: ### List ###

# Add an element to the front of a list. #
let cons: (Int, [Int]) -> [Int] = fun x, xs -> x::xs in

# Determine the length of a list. #
let length: [Int] -> Int =
  fun xs ->
    case xs
    | [] => 0
    | _::xs => 1 + length(xs) end in

# Extract the first element of a list. #
let hd: [Int] -> Option =
  fun l ->
    case l
    | [] => None
    | x::xs => Some(x) end in

# Extract the rest of the list. #
let tl: [Int] -> [Int] =
  fun l ->
    case l
    | [] => []
    | x::xs => xs end in

# Determine if a list is empty. #
let is_empty: [Int] -> Bool =
  fun xs ->
    case xs
    | [] => true
    | _::_ => false end in

# Return the element at the index. #
let nth: ([Int], Int) -> Option =
  fun xs, n ->
    case xs, n
    | x::_, 0 => Some(x)
    | _::xs, n => nth(xs, n - 1)
    | [], _ => None end in

# Reverse a List. #
let rev: [Int] -> [Int] =
fun l -> 
let go: ([Int], [Int]) -> [Int] =
  fun xs, acc -> 
    case xs 
    | [] => acc 
    | x::xs => go(xs, x::acc) end in
go(l, []) in

# Check if two lists are equal #
let equal: ([Int], [Int]) -> Bool =
    fun p, xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => x == y && equal(xs, ys)
    | _ => false end
in

# Initialize a list with a given length using an initializer function #
let init: (Int, Int -> Int) -> [Int] =
    fun len, f ->
        let go: (Int, [Int]) -> [Int] =
        fun idx, xs ->
            if idx < len 
            then go(idx + 1, xs @ [f(idx)])   
            else xs
        in
        go(0, [])
in

# Reduce a list from the left. #
let fold_left: ((Int, Int) -> Int, Int, [Int]) -> Int =
  fun f, acc, xs ->
    case xs 
    | [] => acc
    | hd::tl => fold_left(f, f(acc, hd), tl) end in

# Reduce a list from the right. #
let fold_right: ((Int, Int) -> Int, [Int], Int) -> Int =
  fun f, xs, acc ->
    case xs
    | [] => acc
    | hd::tl => f(hd, fold_right(f, tl, acc)) end in


666
LSP: Prelude: String parsed successfully
LSP: Prelude: Info map generated successfully
Debug: true, Constrain: Types
LSP: Init: Recieved string: # Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (
LSP: Init: String parsed successfully
  LSP: Syntax: Leftward is Incomplete Tile: <( )<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Bool
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {tl: [?], hd: ?, acc: ?, xs: ?, filter: (((Int -> Bool), [Int]) -> [Int]), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) then else end in
  LSP: Info: ALL errors:Error in term:
  p
Nature of error: type ((Int -> Bool), [Int]) is not consistent with arrow type
  LSP: Info: BidiCtx: Cls: Empty expression hole
  LSP: Info: BidiCtx: Expected type: Bool
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Info: Cls: Parenthesized expression
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Bool
  LSP: Info: Seft type: Bool
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {tl: [?], hd: ?, acc: ?, xs: ?, filter: (((Int -> Bool), [Int]) -> [Int]), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) then else end in
  LSP: Info: ALL errors:Error in term:
  p
Nature of error: type ((Int -> Bool), [Int]) is not consistent with arrow type
  LSP: Info: BidiCtx: Cls: Parenthesized expression
  LSP: Info: BidiCtx: Expected type: Bool
  LSP: Info: Bidi Parent Cls: If expression
  LSP: Syntax: Can insert left-convex or complete: (
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 Bool
Int <= Bool
Float <= Bool
String <= Bool
  LSP: Convex: Target types: Int, Float, Bool, String
  LSP: Convex: Backpack: 
  LSP: Convex: Base: hd acc xs _ false true ! ( case  if  let  type 
  LSP: Convex: Lookahead: ! ( - _ abs abs_float acc acos asin atan bool_of_string case  ceil cos epsilon_float exp false float_of_int float_of_string floor hd if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod nan neg_infinity pi sin sqrt string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan true type  xs ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Generating Completions for prefix: (
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: && \/ $== == != <= >= < > ==. !=. <=. >=. <. >.
  LSP: Concave: Infix: Lookahead types: Int, Float, Bool, String
  LSP: Concave: Infix: Lookahead: != !=. $== && * ** **. *. + ++ +. - -. / /. < <. <= <=. == ==. > >. >= >=. \/
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. < <. <= <=. == ==. > >. >= >=. \/
  LSP: Concave: Postfix: 
  LSP: Convex: Ty paths:
 Bool
Int <= Bool
Float <= Bool
String <= Bool
  LSP: Convex: Target types: Int, Float, Bool, String
  LSP: Convex: Backpack: 
  LSP: Convex: Base: hd acc xs _ false true ! ( case  if  let  type 
  LSP: Convex: Lookahead: ! ( - _ abs abs_float acc acos asin atan bool_of_string case  ceil cos epsilon_float exp false float_of_int float_of_string floor hd if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod nan neg_infinity pi sin sqrt string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan true type  xs ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new_tokens ::= whitespace | "!" | "(" | "-" | "_" | "abs" | "abs_float" | "acc" | "acos" | "asin" | "atan" | "bool_of_string" | "case " | "ceil" | "cos" | "epsilon_float" | "exp" | "false" | "float_of_int" | "float_of_string" | "floor" | "hd" | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "nan" | "neg_infinity" | "pi" | "sin" | "sqrt" | "string_compare" | "string_concat" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "true" | "type " | "xs" | floatlit | intlit | stringlit
root ::= new_tokens

Top 20 Logits:
p:16.1151
hd:12.9543
pred:12.9306
f:12.6476
is:12.3262
xs:12.2963
filter:12.1959
x:11.7594
acc:11.6517
not:11.6233
fun:11.396
equal:10.9481
true:10.9053
test:10.7639
cond:10.2742
cons:10.0664
go:9.98265
fn:9.93054
fold:9.81581
a:9.81158
((:9.79555

================
# Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p

LSP: Prelude: Recieved string: ### List ###

# Add an element to the front of a list. #
let cons: (Int, [Int]) -> [Int] = fun x, xs -> x::xs in

# Determine the length of a list. #
let length: [Int] -> Int =
  fun xs ->
    case xs
    | [] => 0
    | _::xs => 1 + length(xs) end in

# Extract the first element of a list. #
let hd: [Int] -> Option =
  fun l ->
    case l
    | [] => None
    | x::xs => Some(x) end in

# Extract the rest of the list. #
let tl: [Int] -> [Int] =
  fun l ->
    case l
    | [] => []
    | x::xs => xs end in

# Determine if a list is empty. #
let is_empty: [Int] -> Bool =
  fun xs ->
    case xs
    | [] => true
    | _::_ => false end in

# Return the element at the index. #
let nth: ([Int], Int) -> Option =
  fun xs, n ->
    case xs, n
    | x::_, 0 => Some(x)
    | _::xs, n => nth(xs, n - 1)
    | [], _ => None end in

# Reverse a List. #
let rev: [Int] -> [Int] =
fun l -> 
let go: ([Int], [Int]) -> [Int] =
  fun xs, acc -> 
    case xs 
    | [] => acc 
    | x::xs => go(xs, x::acc) end in
go(l, []) in

# Check if two lists are equal #
let equal: ([Int], [Int]) -> Bool =
    fun p, xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => x == y && equal(xs, ys)
    | _ => false end
in

# Initialize a list with a given length using an initializer function #
let init: (Int, Int -> Int) -> [Int] =
    fun len, f ->
        let go: (Int, [Int]) -> [Int] =
        fun idx, xs ->
            if idx < len 
            then go(idx + 1, xs @ [f(idx)])   
            else xs
        in
        go(0, [])
in

# Reduce a list from the left. #
let fold_left: ((Int, Int) -> Int, Int, [Int]) -> Int =
  fun f, acc, xs ->
    case xs 
    | [] => acc
    | hd::tl => fold_left(f, f(acc, hd), tl) end in

# Reduce a list from the right. #
let fold_right: ((Int, Int) -> Int, [Int], Int) -> Int =
  fun f, xs, acc ->
    case xs
    | [] => acc
    | hd::tl => f(hd, fold_right(f, tl, acc)) end in


666
LSP: Prelude: String parsed successfully
LSP: Prelude: Info map generated successfully
Debug: true, Constrain: Types
LSP: Init: Recieved string: # Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p
LSP: Init: String parsed successfully
  LSP: Syntax: Leftward is Complete Tile: <p>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Bool
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Exp (FreeVariable "p"))
  LSP: Info: Typing Context: {tl: [?], hd: ?, acc: ?, xs: ?, filter: (((Int -> Bool), [Int]) -> [Int]), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) then else end in
  LSP: Info: ALL errors:Error in term:
  p
Nature of error: type ((Int -> Bool), [Int]) is not consistent with arrow type    
Error in term:
  p
Nature of error: Variable p is not bound
  LSP: Info: BidiCtx: Cls: Variable reference
  LSP: Info: BidiCtx: Expected type: Bool
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Can insert left-concave or complete: p
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: && \/ $== == != <= >= < > ==. !=. <=. >=. <. >.
  LSP: Concave: Infix: Lookahead types: Int, Float, Bool, String
  LSP: Concave: Infix: Lookahead: != !=. $== && * ** **. *. + ++ +. - -. / /. < <. <= <=. == ==. > >. >= >=. \/
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. < <. <= <=. == ==. > >. >= >=. \/
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: p
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: && \/ $== == != <= >= < > ==. !=. <=. >=. <. >.
  LSP: Concave: Infix: Lookahead types: Int, Float, Bool, String
  LSP: Concave: Infix: Lookahead: != !=. $== && * ** **. *. + ++ +. - -. / /. < <. <= <=. == ==. > >. >= >=. \/
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. < <. <= <=. == ==. > >. >= >=. \/
  LSP: Concave: Postfix: (
  LSP: Convex: Ty paths:
 Bool
Int <= Bool
Float <= Bool
String <= Bool
  LSP: Convex: Target types: Int, Float, Bool, String
  LSP: Convex: Backpack: 
  LSP: Convex: Base: hd acc xs _ false true ! ( case  if  let  type 
  LSP: Convex: Lookahead: ! ( - _ abs abs_float acc acos asin atan bool_of_string case  ceil cos epsilon_float exp false float_of_int float_of_string floor hd if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod nan neg_infinity pi sin sqrt string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan true type  xs ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "i"
new_tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | ")" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "-" | "-." | "/" | "/." | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "\\/"
root ::= completions | new_tokens

Top 20 Logits:
):18.137
)(:15.3754
(:13.2648
 h:11.3924
::10.8782
 (:10.7804
1:10.6685
.:10.2334
_:10.1689
()):9.85637
,:9.67351
)):9.66016
 ==:9.65155
).:9.58331
 ):9.57017
)::9.31602
@:9.31583
)?:9.29606
),:9.27232
)=:9.11901
2:9.09262

================
# Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p)

LSP: Prelude: Recieved string: ### List ###

# Add an element to the front of a list. #
let cons: (Int, [Int]) -> [Int] = fun x, xs -> x::xs in

# Determine the length of a list. #
let length: [Int] -> Int =
  fun xs ->
    case xs
    | [] => 0
    | _::xs => 1 + length(xs) end in

# Extract the first element of a list. #
let hd: [Int] -> Option =
  fun l ->
    case l
    | [] => None
    | x::xs => Some(x) end in

# Extract the rest of the list. #
let tl: [Int] -> [Int] =
  fun l ->
    case l
    | [] => []
    | x::xs => xs end in

# Determine if a list is empty. #
let is_empty: [Int] -> Bool =
  fun xs ->
    case xs
    | [] => true
    | _::_ => false end in

# Return the element at the index. #
let nth: ([Int], Int) -> Option =
  fun xs, n ->
    case xs, n
    | x::_, 0 => Some(x)
    | _::xs, n => nth(xs, n - 1)
    | [], _ => None end in

# Reverse a List. #
let rev: [Int] -> [Int] =
fun l -> 
let go: ([Int], [Int]) -> [Int] =
  fun xs, acc -> 
    case xs 
    | [] => acc 
    | x::xs => go(xs, x::acc) end in
go(l, []) in

# Check if two lists are equal #
let equal: ([Int], [Int]) -> Bool =
    fun p, xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => x == y && equal(xs, ys)
    | _ => false end
in

# Initialize a list with a given length using an initializer function #
let init: (Int, Int -> Int) -> [Int] =
    fun len, f ->
        let go: (Int, [Int]) -> [Int] =
        fun idx, xs ->
            if idx < len 
            then go(idx + 1, xs @ [f(idx)])   
            else xs
        in
        go(0, [])
in

# Reduce a list from the left. #
let fold_left: ((Int, Int) -> Int, Int, [Int]) -> Int =
  fun f, acc, xs ->
    case xs 
    | [] => acc
    | hd::tl => fold_left(f, f(acc, hd), tl) end in

# Reduce a list from the right. #
let fold_right: ((Int, Int) -> Int, [Int], Int) -> Int =
  fun f, xs, acc ->
    case xs
    | [] => acc
    | hd::tl => f(hd, fold_right(f, tl, acc)) end in


666
LSP: Prelude: String parsed successfully
LSP: Prelude: Info map generated successfully
Debug: true, Constrain: Types
LSP: Init: Recieved string: # Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p)
LSP: Init: String parsed successfully
  LSP: Syntax: Leftward is Complete Tile: <( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Parenthesized expression
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Bool
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {tl: [?], hd: ?, acc: ?, xs: ?, filter: (((Int -> Bool), [Int]) -> [Int]), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: then else end in
  LSP: Info: ALL errors:Error in term:
  p
Nature of error: Variable p is not bound    
Error in term:
  p
Nature of error: type ((Int -> Bool), [Int]) is not consistent with arrow type
  LSP: Info: BidiCtx: Cls: Parenthesized expression
  LSP: Info: BidiCtx: Expected type: Bool
  LSP: Info: Bidi Parent Cls: If expression
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: && \/ $== == != <= >= < > ==. !=. <=. >=. <. >.
  LSP: Concave: Infix: Lookahead types: Int, Float, Bool, String
  LSP: Concave: Infix: Lookahead: != !=. $== && * ** **. *. + ++ +. - -. / /. < <. <= <=. == ==. > >. >= >=. \/
  LSP: Concave: Backpack: then
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. < <. <= <=. == ==. > >. >= >=. \/
  LSP: Concave: Postfix: (
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new_tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "-" | "-." | "/" | "/." | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "\\/" | "then"
root ::= new_tokens

Top 20 Logits:
 (:20.4899
 h:15.4851
 then:14.9434
 xs:12.7813

:12.5905
 ==:12.497
 t:12.3221
 in:12.0514
 ():11.9958
 ((:11.9315
 :11.9211
 =:11.9054
 x:11.8154
 acc:11.2094
 ?:11.192
 {:11.1097
 [:11.1009
 f:11.0761
 @:10.9666
 ([:10.8632
 ->:10.8071

================
# Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (

LSP: Prelude: Recieved string: ### List ###

# Add an element to the front of a list. #
let cons: (Int, [Int]) -> [Int] = fun x, xs -> x::xs in

# Determine the length of a list. #
let length: [Int] -> Int =
  fun xs ->
    case xs
    | [] => 0
    | _::xs => 1 + length(xs) end in

# Extract the first element of a list. #
let hd: [Int] -> Option =
  fun l ->
    case l
    | [] => None
    | x::xs => Some(x) end in

# Extract the rest of the list. #
let tl: [Int] -> [Int] =
  fun l ->
    case l
    | [] => []
    | x::xs => xs end in

# Determine if a list is empty. #
let is_empty: [Int] -> Bool =
  fun xs ->
    case xs
    | [] => true
    | _::_ => false end in

# Return the element at the index. #
let nth: ([Int], Int) -> Option =
  fun xs, n ->
    case xs, n
    | x::_, 0 => Some(x)
    | _::xs, n => nth(xs, n - 1)
    | [], _ => None end in

# Reverse a List. #
let rev: [Int] -> [Int] =
fun l -> 
let go: ([Int], [Int]) -> [Int] =
  fun xs, acc -> 
    case xs 
    | [] => acc 
    | x::xs => go(xs, x::acc) end in
go(l, []) in

# Check if two lists are equal #
let equal: ([Int], [Int]) -> Bool =
    fun p, xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => x == y && equal(xs, ys)
    | _ => false end
in

# Initialize a list with a given length using an initializer function #
let init: (Int, Int -> Int) -> [Int] =
    fun len, f ->
        let go: (Int, [Int]) -> [Int] =
        fun idx, xs ->
            if idx < len 
            then go(idx + 1, xs @ [f(idx)])   
            else xs
        in
        go(0, [])
in

# Reduce a list from the left. #
let fold_left: ((Int, Int) -> Int, Int, [Int]) -> Int =
  fun f, acc, xs ->
    case xs 
    | [] => acc
    | hd::tl => fold_left(f, f(acc, hd), tl) end in

# Reduce a list from the right. #
let fold_right: ((Int, Int) -> Int, [Int], Int) -> Int =
  fun f, xs, acc ->
    case xs
    | [] => acc
    | hd::tl => f(hd, fold_right(f, tl, acc)) end in


666
LSP: Prelude: String parsed successfully
LSP: Prelude: Info map generated successfully
Debug: true, Constrain: Types
LSP: Init: Recieved string: # Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (
LSP: Init: String parsed successfully
  LSP: Syntax: Leftward is Incomplete Tile: >( )<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {tl: [?], hd: ?, acc: ?, xs: ?, filter: (((Int -> Bool), [Int]) -> [Int]), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) then else end in
  LSP: Info: ALL errors:Error in term:
  p
Nature of error: Variable p is not bound    
Error in term:
  p
Nature of error: type ((Int -> Bool), [Int]) is not consistent with arrow type
  LSP: Info: BidiCtx: Cls: Empty expression hole
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Application
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Bool
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {tl: [?], hd: ?, acc: ?, xs: ?, filter: (((Int -> Bool), [Int]) -> [Int]), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) then else end in
  LSP: Info: ALL errors:Error in term:
  p
Nature of error: Variable p is not bound    
Error in term:
  p
Nature of error: type ((Int -> Bool), [Int]) is not consistent with arrow type
  LSP: Info: BidiCtx: Cls: Application
  LSP: Info: BidiCtx: Expected type: Bool
  LSP: Info: Bidi Parent Cls: If expression
  LSP: Syntax: Can insert left-convex or complete: (
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 ?
  LSP: Convex: Target types: ?
  LSP: Convex: Backpack: 
  LSP: Convex: Base: tl hd acc xs filter string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position Width S () [] _ false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: ! ( () - AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position S Width [ [] _ abs abs_float acc acos asin atan bool_of_string case  ceil cos epsilon_float exp false filter float_of_int float_of_string floor fun  hd if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod nan neg_infinity pi sin sqrt string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan test  tl true type  xs ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Generating Completions for prefix: (
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: && \/ $== == != <= >= < > ==. !=. <=. >=. <. >.
  LSP: Concave: Infix: Lookahead types: Int, Float, Bool, String
  LSP: Concave: Infix: Lookahead: != !=. $== && * ** **. *. + ++ +. - -. / /. < <. <= <=. == ==. > >. >= >=. \/
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. < <. <= <=. == ==. > >. >= >=. \/
  LSP: Concave: Postfix: (
  LSP: Convex: Ty paths:
 Bool
Int <= Bool
Float <= Bool
String <= Bool
  LSP: Convex: Target types: Int, Float, Bool, String
  LSP: Convex: Backpack: 
  LSP: Convex: Base: hd acc xs _ false true ! ( case  if  let  type 
  LSP: Convex: Lookahead: ! ( - _ abs abs_float acc acos asin atan bool_of_string case  ceil cos epsilon_float exp false float_of_int float_of_string floor hd if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod nan neg_infinity pi sin sqrt string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan true type  xs ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new_tokens ::= whitespace | "!" | "(" | "()" | "-" | "AlignItems" | "BackgroundColor" | "Border" | "BorderRadius" | "BoxShadow" | "Color" | "Cursor" | "Display" | "FlexDirection" | "FontFamily" | "FontSize" | "FontStyle" | "Gap" | "Height" | "JustifyContent" | "Margin" | "Opacity" | "Outline" | "Overflow" | "Padding" | "Position" | "S" | "Width" | "[" | "[]" | "_" | "abs" | "abs_float" | "acc" | "acos" | "asin" | "atan" | "bool_of_string" | "case " | "ceil" | "cos" | "epsilon_float" | "exp" | "false" | "filter" | "float_of_int" | "float_of_string" | "floor" | "fun " | "hd" | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "nan" | "neg_infinity" | "pi" | "sin" | "sqrt" | "string_compare" | "string_concat" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "tl" | "true" | "type " | "xs" | floatlit | intlit | stringlit
root ::= new_tokens

Top 20 Logits:
hd:19.9129
f:13.5412
x:13.268
acc:12.4871
h:12.315
hs:12.1912
p:12.1536
xs:12.1099
go:11.3134
hl:11.1795
fd:10.5169
tl:10.509
t:10.4611
true:10.3833
fun:10.3308
a:10.2858
Some:10.2842
n:10.1063
td:10.1018
map:10.0308
head:10.0191

================
# Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd

LSP: Prelude: Recieved string: ### List ###

# Add an element to the front of a list. #
let cons: (Int, [Int]) -> [Int] = fun x, xs -> x::xs in

# Determine the length of a list. #
let length: [Int] -> Int =
  fun xs ->
    case xs
    | [] => 0
    | _::xs => 1 + length(xs) end in

# Extract the first element of a list. #
let hd: [Int] -> Option =
  fun l ->
    case l
    | [] => None
    | x::xs => Some(x) end in

# Extract the rest of the list. #
let tl: [Int] -> [Int] =
  fun l ->
    case l
    | [] => []
    | x::xs => xs end in

# Determine if a list is empty. #
let is_empty: [Int] -> Bool =
  fun xs ->
    case xs
    | [] => true
    | _::_ => false end in

# Return the element at the index. #
let nth: ([Int], Int) -> Option =
  fun xs, n ->
    case xs, n
    | x::_, 0 => Some(x)
    | _::xs, n => nth(xs, n - 1)
    | [], _ => None end in

# Reverse a List. #
let rev: [Int] -> [Int] =
fun l -> 
let go: ([Int], [Int]) -> [Int] =
  fun xs, acc -> 
    case xs 
    | [] => acc 
    | x::xs => go(xs, x::acc) end in
go(l, []) in

# Check if two lists are equal #
let equal: ([Int], [Int]) -> Bool =
    fun p, xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => x == y && equal(xs, ys)
    | _ => false end
in

# Initialize a list with a given length using an initializer function #
let init: (Int, Int -> Int) -> [Int] =
    fun len, f ->
        let go: (Int, [Int]) -> [Int] =
        fun idx, xs ->
            if idx < len 
            then go(idx + 1, xs @ [f(idx)])   
            else xs
        in
        go(0, [])
in

# Reduce a list from the left. #
let fold_left: ((Int, Int) -> Int, Int, [Int]) -> Int =
  fun f, acc, xs ->
    case xs 
    | [] => acc
    | hd::tl => fold_left(f, f(acc, hd), tl) end in

# Reduce a list from the right. #
let fold_right: ((Int, Int) -> Int, [Int], Int) -> Int =
  fun f, xs, acc ->
    case xs
    | [] => acc
    | hd::tl => f(hd, fold_right(f, tl, acc)) end in


666
LSP: Prelude: String parsed successfully
LSP: Prelude: Info map generated successfully
Debug: true, Constrain: Types
LSP: Init: Recieved string: # Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd
LSP: Init: String parsed successfully
  LSP: Syntax: Leftward is Complete Tile: <hd>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {tl: [?], hd: ?, acc: ?, xs: ?, filter: (((Int -> Bool), [Int]) -> [Int]), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) then else end in
  LSP: Info: ALL errors:Error in term:
  p
Nature of error: type ((Int -> Bool), [Int]) is not consistent with arrow type    
Error in term:
  p
Nature of error: Variable p is not bound
  LSP: Info: BidiCtx: Cls: Variable reference
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Can insert left-concave or complete: hd
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: && \/ $== == != <= >= < > ==. !=. <=. >=. <. >. + - * / ** +. -. *. /. **. ++ :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: hd
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: && \/ $== == != <= >= < > ==. !=. <=. >=. <. >. + - * / ** +. -. *. /. **. ++ :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Ty paths:
 ?
  LSP: Convex: Target types: ?
  LSP: Convex: Backpack: 
  LSP: Convex: Base: tl hd acc xs filter string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position Width S () [] _ false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: ! ( () - AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position S Width [ [] _ abs abs_float acc acos asin atan bool_of_string case  ceil cos epsilon_float exp false filter float_of_int float_of_string floor fun  hd if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod nan neg_infinity pi sin sqrt string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan test  tl true type  xs ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new_tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | ")" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/"
root ::= new_tokens

Top 20 Logits:
):19.7844
,:12.062
)(:11.8111
.:11.6604
::11.3549
:::11.152
 +:11.0453
 :::11.015
 ==:10.9069
 /:10.5696
 &&:10.5594
 =:10.5201
 @:10.4987
 ):10.4402
 -:10.4316
)=:10.3864
 *:10.3607
),:10.3082
).:10.2907
[:10.2877
 &:10.1551

================
# Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd)

LSP: Prelude: Recieved string: ### List ###

# Add an element to the front of a list. #
let cons: (Int, [Int]) -> [Int] = fun x, xs -> x::xs in

# Determine the length of a list. #
let length: [Int] -> Int =
  fun xs ->
    case xs
    | [] => 0
    | _::xs => 1 + length(xs) end in

# Extract the first element of a list. #
let hd: [Int] -> Option =
  fun l ->
    case l
    | [] => None
    | x::xs => Some(x) end in

# Extract the rest of the list. #
let tl: [Int] -> [Int] =
  fun l ->
    case l
    | [] => []
    | x::xs => xs end in

# Determine if a list is empty. #
let is_empty: [Int] -> Bool =
  fun xs ->
    case xs
    | [] => true
    | _::_ => false end in

# Return the element at the index. #
let nth: ([Int], Int) -> Option =
  fun xs, n ->
    case xs, n
    | x::_, 0 => Some(x)
    | _::xs, n => nth(xs, n - 1)
    | [], _ => None end in

# Reverse a List. #
let rev: [Int] -> [Int] =
fun l -> 
let go: ([Int], [Int]) -> [Int] =
  fun xs, acc -> 
    case xs 
    | [] => acc 
    | x::xs => go(xs, x::acc) end in
go(l, []) in

# Check if two lists are equal #
let equal: ([Int], [Int]) -> Bool =
    fun p, xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => x == y && equal(xs, ys)
    | _ => false end
in

# Initialize a list with a given length using an initializer function #
let init: (Int, Int -> Int) -> [Int] =
    fun len, f ->
        let go: (Int, [Int]) -> [Int] =
        fun idx, xs ->
            if idx < len 
            then go(idx + 1, xs @ [f(idx)])   
            else xs
        in
        go(0, [])
in

# Reduce a list from the left. #
let fold_left: ((Int, Int) -> Int, Int, [Int]) -> Int =
  fun f, acc, xs ->
    case xs 
    | [] => acc
    | hd::tl => fold_left(f, f(acc, hd), tl) end in

# Reduce a list from the right. #
let fold_right: ((Int, Int) -> Int, [Int], Int) -> Int =
  fun f, xs, acc ->
    case xs
    | [] => acc
    | hd::tl => f(hd, fold_right(f, tl, acc)) end in


666
LSP: Prelude: String parsed successfully
LSP: Prelude: Info map generated successfully
Debug: true, Constrain: Types
LSP: Init: Recieved string: # Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd)
LSP: Init: String parsed successfully
  LSP: Syntax: Leftward is Complete Tile: >( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Bool
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {tl: [?], hd: ?, acc: ?, xs: ?, filter: (((Int -> Bool), [Int]) -> [Int]), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: then else end in
  LSP: Info: ALL errors:Error in term:
  p
Nature of error: Variable p is not bound    
Error in term:
  p
Nature of error: type ((Int -> Bool), [Int]) is not consistent with arrow type
  LSP: Info: BidiCtx: Cls: Application
  LSP: Info: BidiCtx: Expected type: Bool
  LSP: Info: Bidi Parent Cls: If expression
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: && \/ $== == != <= >= < > ==. !=. <=. >=. <. >.
  LSP: Concave: Infix: Lookahead types: Int, Float, Bool, String
  LSP: Concave: Infix: Lookahead: != !=. $== && * ** **. *. + ++ +. - -. / /. < <. <= <=. == ==. > >. >= >=. \/
  LSP: Concave: Backpack: then
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. < <. <= <=. == ==. > >. >= >=. \/
  LSP: Concave: Postfix: (
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new_tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "-" | "-." | "/" | "/." | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "\\/" | "then"
root ::= new_tokens

Top 20 Logits:
 then:19.9741
 :12.461

:12.1963
 (:12.174
 &&:12.0491
 ||:11.7379
 acc:11.6377
 ==:10.8245
 =:10.116
 t:10.0974
 ((:10.0683
 true:9.95571
 ?:9.84124
then:9.81561
 =>:9.59421
 h:9.5201
 @:9.51605
 [:9.45196
 {:9.39769
 p:9.25126
 Then:9.06025

================
# Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then

LSP: Prelude: Recieved string: ### List ###

# Add an element to the front of a list. #
let cons: (Int, [Int]) -> [Int] = fun x, xs -> x::xs in

# Determine the length of a list. #
let length: [Int] -> Int =
  fun xs ->
    case xs
    | [] => 0
    | _::xs => 1 + length(xs) end in

# Extract the first element of a list. #
let hd: [Int] -> Option =
  fun l ->
    case l
    | [] => None
    | x::xs => Some(x) end in

# Extract the rest of the list. #
let tl: [Int] -> [Int] =
  fun l ->
    case l
    | [] => []
    | x::xs => xs end in

# Determine if a list is empty. #
let is_empty: [Int] -> Bool =
  fun xs ->
    case xs
    | [] => true
    | _::_ => false end in

# Return the element at the index. #
let nth: ([Int], Int) -> Option =
  fun xs, n ->
    case xs, n
    | x::_, 0 => Some(x)
    | _::xs, n => nth(xs, n - 1)
    | [], _ => None end in

# Reverse a List. #
let rev: [Int] -> [Int] =
fun l -> 
let go: ([Int], [Int]) -> [Int] =
  fun xs, acc -> 
    case xs 
    | [] => acc 
    | x::xs => go(xs, x::acc) end in
go(l, []) in

# Check if two lists are equal #
let equal: ([Int], [Int]) -> Bool =
    fun p, xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => x == y && equal(xs, ys)
    | _ => false end
in

# Initialize a list with a given length using an initializer function #
let init: (Int, Int -> Int) -> [Int] =
    fun len, f ->
        let go: (Int, [Int]) -> [Int] =
        fun idx, xs ->
            if idx < len 
            then go(idx + 1, xs @ [f(idx)])   
            else xs
        in
        go(0, [])
in

# Reduce a list from the left. #
let fold_left: ((Int, Int) -> Int, Int, [Int]) -> Int =
  fun f, acc, xs ->
    case xs 
    | [] => acc
    | hd::tl => fold_left(f, f(acc, hd), tl) end in

# Reduce a list from the right. #
let fold_right: ((Int, Int) -> Int, [Int], Int) -> Int =
  fun f, xs, acc ->
    case xs
    | [] => acc
    | hd::tl => f(hd, fold_right(f, tl, acc)) end in


666
LSP: Prelude: String parsed successfully
LSP: Prelude: Info map generated successfully
Debug: true, Constrain: Types
LSP: Init: Recieved string: # Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then
LSP: Init: String parsed successfully
  LSP: Syntax: Leftward is Incomplete Tile: <if then else<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {tl: [?], hd: ?, acc: ?, xs: ?, filter: (((Int -> Bool), [Int]) -> [Int]), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: else end in
  LSP: Info: ALL errors:Error in term:
  p
Nature of error: Variable p is not bound    
Error in term:
  p
Nature of error: type ((Int -> Bool), [Int]) is not consistent with arrow type
  LSP: Info: BidiCtx: Cls: Empty expression hole
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: If expression
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 ?
  LSP: Convex: Target types: ?
  LSP: Convex: Backpack: 
  LSP: Convex: Base: tl hd acc xs filter string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position Width S () [] _ false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: ! ( () - AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position S Width [ [] _ abs abs_float acc acos asin atan bool_of_string case  ceil cos epsilon_float exp false filter float_of_int float_of_string floor fun  hd if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod nan neg_infinity pi sin sqrt string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan test  tl true type  xs ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new_tokens ::= whitespace | "!" | "(" | "()" | "-" | "AlignItems" | "BackgroundColor" | "Border" | "BorderRadius" | "BoxShadow" | "Color" | "Cursor" | "Display" | "FlexDirection" | "FontFamily" | "FontSize" | "FontStyle" | "Gap" | "Height" | "JustifyContent" | "Margin" | "Opacity" | "Outline" | "Overflow" | "Padding" | "Position" | "S" | "Width" | "[" | "[]" | "_" | "abs" | "abs_float" | "acc" | "acos" | "asin" | "atan" | "bool_of_string" | "case " | "ceil" | "cos" | "epsilon_float" | "exp" | "false" | "filter" | "float_of_int" | "float_of_string" | "floor" | "fun " | "hd" | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "nan" | "neg_infinity" | "pi" | "sin" | "sqrt" | "string_compare" | "string_concat" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "tl" | "true" | "type " | "xs" | floatlit | intlit | stringlit
root ::= new_tokens

Top 20 Logits:
 (:18.0292
 go:15.433
 ([:14.0605
 ((:14.0578
 [:13.8987
 acc:13.642
 fol:13.5882
 t:12.9989
 filter:12.6633
 h:12.543
 :12.0137
 p:11.861
 cons:11.7696
 (_:11.6759

:11.6577
 reverse:11.2223
 [(:11.1001
 f:10.9222
 ():10.8329
 xs:10.747
 rev:10.7415

================
# Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (

LSP: Prelude: Recieved string: ### List ###

# Add an element to the front of a list. #
let cons: (Int, [Int]) -> [Int] = fun x, xs -> x::xs in

# Determine the length of a list. #
let length: [Int] -> Int =
  fun xs ->
    case xs
    | [] => 0
    | _::xs => 1 + length(xs) end in

# Extract the first element of a list. #
let hd: [Int] -> Option =
  fun l ->
    case l
    | [] => None
    | x::xs => Some(x) end in

# Extract the rest of the list. #
let tl: [Int] -> [Int] =
  fun l ->
    case l
    | [] => []
    | x::xs => xs end in

# Determine if a list is empty. #
let is_empty: [Int] -> Bool =
  fun xs ->
    case xs
    | [] => true
    | _::_ => false end in

# Return the element at the index. #
let nth: ([Int], Int) -> Option =
  fun xs, n ->
    case xs, n
    | x::_, 0 => Some(x)
    | _::xs, n => nth(xs, n - 1)
    | [], _ => None end in

# Reverse a List. #
let rev: [Int] -> [Int] =
fun l -> 
let go: ([Int], [Int]) -> [Int] =
  fun xs, acc -> 
    case xs 
    | [] => acc 
    | x::xs => go(xs, x::acc) end in
go(l, []) in

# Check if two lists are equal #
let equal: ([Int], [Int]) -> Bool =
    fun p, xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => x == y && equal(xs, ys)
    | _ => false end
in

# Initialize a list with a given length using an initializer function #
let init: (Int, Int -> Int) -> [Int] =
    fun len, f ->
        let go: (Int, [Int]) -> [Int] =
        fun idx, xs ->
            if idx < len 
            then go(idx + 1, xs @ [f(idx)])   
            else xs
        in
        go(0, [])
in

# Reduce a list from the left. #
let fold_left: ((Int, Int) -> Int, Int, [Int]) -> Int =
  fun f, acc, xs ->
    case xs 
    | [] => acc
    | hd::tl => fold_left(f, f(acc, hd), tl) end in

# Reduce a list from the right. #
let fold_right: ((Int, Int) -> Int, [Int], Int) -> Int =
  fun f, xs, acc ->
    case xs
    | [] => acc
    | hd::tl => f(hd, fold_right(f, tl, acc)) end in


666
LSP: Prelude: String parsed successfully
LSP: Prelude: Info map generated successfully
Debug: true, Constrain: Types
LSP: Init: Recieved string: # Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (
LSP: Init: String parsed successfully
  LSP: Syntax: Leftward is Incomplete Tile: <( )<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {tl: [?], hd: ?, acc: ?, xs: ?, filter: (((Int -> Bool), [Int]) -> [Int]), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) else end in
  LSP: Info: ALL errors:Error in term:
  p
Nature of error: type ((Int -> Bool), [Int]) is not consistent with arrow type    
Error in term:
  p
Nature of error: Variable p is not bound
  LSP: Info: BidiCtx: Cls: Empty expression hole
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Info: Cls: Parenthesized expression
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {tl: [?], hd: ?, acc: ?, xs: ?, filter: (((Int -> Bool), [Int]) -> [Int]), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) else end in
  LSP: Info: ALL errors:Error in term:
  p
Nature of error: type ((Int -> Bool), [Int]) is not consistent with arrow type    
Error in term:
  p
Nature of error: Variable p is not bound
  LSP: Info: BidiCtx: Cls: Parenthesized expression
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: If expression
  LSP: Syntax: Can insert left-convex or complete: (
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 ?
  LSP: Convex: Target types: ?
  LSP: Convex: Backpack: 
  LSP: Convex: Base: tl hd acc xs filter string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position Width S () [] _ false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: ! ( () - AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position S Width [ [] _ abs abs_float acc acos asin atan bool_of_string case  ceil cos epsilon_float exp false filter float_of_int float_of_string floor fun  hd if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod nan neg_infinity pi sin sqrt string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan test  tl true type  xs ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Generating Completions for prefix: (
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: && \/ $== == != <= >= < > ==. !=. <=. >=. <. >. + - * / ** +. -. *. /. **. ++ :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Ty paths:
 ?
  LSP: Convex: Target types: ?
  LSP: Convex: Backpack: 
  LSP: Convex: Base: tl hd acc xs filter string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position Width S () [] _ false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: ! ( () - AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position S Width [ [] _ abs abs_float acc acos asin atan bool_of_string case  ceil cos epsilon_float exp false filter float_of_int float_of_string floor fun  hd if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod nan neg_infinity pi sin sqrt string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan test  tl true type  xs ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= ")"
new_tokens ::= whitespace | "!" | "(" | "()" | "-" | "AlignItems" | "BackgroundColor" | "Border" | "BorderRadius" | "BoxShadow" | "Color" | "Cursor" | "Display" | "FlexDirection" | "FontFamily" | "FontSize" | "FontStyle" | "Gap" | "Height" | "JustifyContent" | "Margin" | "Opacity" | "Outline" | "Overflow" | "Padding" | "Position" | "S" | "Width" | "[" | "[]" | "_" | "abs" | "abs_float" | "acc" | "acos" | "asin" | "atan" | "bool_of_string" | "case " | "ceil" | "cos" | "epsilon_float" | "exp" | "false" | "filter" | "float_of_int" | "float_of_string" | "floor" | "fun " | "hd" | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "nan" | "neg_infinity" | "pi" | "sin" | "sqrt" | "string_compare" | "string_concat" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "tl" | "true" | "type " | "xs" | floatlit | intlit | stringlit
root ::= completions | new_tokens

Top 20 Logits:
acc:16.8494
go:13.9571
hd:12.7707
filter:12.7558
cons:12.6231
fold:12.364
p:12.262
ac:11.0278
[]:10.7724
f:10.421
xs:10.3682
fun:10.3101
tl:10.2906
rev:10.2614
t:10.1756
x:9.98247
Some:9.64382
h:9.58411
re:9.52982
map:9.5094
tc:9.47368

================
# Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc

LSP: Prelude: Recieved string: ### List ###

# Add an element to the front of a list. #
let cons: (Int, [Int]) -> [Int] = fun x, xs -> x::xs in

# Determine the length of a list. #
let length: [Int] -> Int =
  fun xs ->
    case xs
    | [] => 0
    | _::xs => 1 + length(xs) end in

# Extract the first element of a list. #
let hd: [Int] -> Option =
  fun l ->
    case l
    | [] => None
    | x::xs => Some(x) end in

# Extract the rest of the list. #
let tl: [Int] -> [Int] =
  fun l ->
    case l
    | [] => []
    | x::xs => xs end in

# Determine if a list is empty. #
let is_empty: [Int] -> Bool =
  fun xs ->
    case xs
    | [] => true
    | _::_ => false end in

# Return the element at the index. #
let nth: ([Int], Int) -> Option =
  fun xs, n ->
    case xs, n
    | x::_, 0 => Some(x)
    | _::xs, n => nth(xs, n - 1)
    | [], _ => None end in

# Reverse a List. #
let rev: [Int] -> [Int] =
fun l -> 
let go: ([Int], [Int]) -> [Int] =
  fun xs, acc -> 
    case xs 
    | [] => acc 
    | x::xs => go(xs, x::acc) end in
go(l, []) in

# Check if two lists are equal #
let equal: ([Int], [Int]) -> Bool =
    fun p, xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => x == y && equal(xs, ys)
    | _ => false end
in

# Initialize a list with a given length using an initializer function #
let init: (Int, Int -> Int) -> [Int] =
    fun len, f ->
        let go: (Int, [Int]) -> [Int] =
        fun idx, xs ->
            if idx < len 
            then go(idx + 1, xs @ [f(idx)])   
            else xs
        in
        go(0, [])
in

# Reduce a list from the left. #
let fold_left: ((Int, Int) -> Int, Int, [Int]) -> Int =
  fun f, acc, xs ->
    case xs 
    | [] => acc
    | hd::tl => fold_left(f, f(acc, hd), tl) end in

# Reduce a list from the right. #
let fold_right: ((Int, Int) -> Int, [Int], Int) -> Int =
  fun f, xs, acc ->
    case xs
    | [] => acc
    | hd::tl => f(hd, fold_right(f, tl, acc)) end in


666
LSP: Prelude: String parsed successfully
LSP: Prelude: Info map generated successfully
Debug: true, Constrain: Types
LSP: Init: Recieved string: # Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc
LSP: Init: String parsed successfully
  LSP: Syntax: Leftward is Complete Tile: <acc>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {tl: [?], hd: ?, acc: ?, xs: ?, filter: (((Int -> Bool), [Int]) -> [Int]), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) else end in
  LSP: Info: ALL errors:Error in term:
  p
Nature of error: Variable p is not bound    
Error in term:
  p
Nature of error: type ((Int -> Bool), [Int]) is not consistent with arrow type
  LSP: Info: BidiCtx: Cls: Variable reference
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Can insert left-concave or complete: acc
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: && \/ $== == != <= >= < > ==. !=. <=. >=. <. >. + - * / ** +. -. *. /. **. ++ :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: acc
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: && \/ $== == != <= >= < > ==. !=. <=. >=. <. >. + - * / ** +. -. *. /. **. ++ :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Ty paths:
 ?
  LSP: Convex: Target types: ?
  LSP: Convex: Backpack: 
  LSP: Convex: Base: tl hd acc xs filter string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position Width S () [] _ false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: ! ( () - AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position S Width [ [] _ abs abs_float acc acos asin atan bool_of_string case  ceil cos epsilon_float exp false filter float_of_int float_of_string floor fun  hd if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod nan neg_infinity pi sin sqrt string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan test  tl true type  xs ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new_tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | ")" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/"
root ::= new_tokens

Top 20 Logits:
 @:19.4596
 +:14.2484
@:13.3628
):13.3628
 *:11.9388
 <:11.8231
 &:11.7843
 :::11.6608
 ::11.2701
 ++:11.1865
 ^:10.9779
 [:10.9776
 |:10.9056
 :10.8827
.:10.8439
 <>:10.822
 >:10.82
::10.8118
,:10.7552
 =:10.6684
 &&:10.6532

================
# Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @

LSP: Prelude: Recieved string: ### List ###

# Add an element to the front of a list. #
let cons: (Int, [Int]) -> [Int] = fun x, xs -> x::xs in

# Determine the length of a list. #
let length: [Int] -> Int =
  fun xs ->
    case xs
    | [] => 0
    | _::xs => 1 + length(xs) end in

# Extract the first element of a list. #
let hd: [Int] -> Option =
  fun l ->
    case l
    | [] => None
    | x::xs => Some(x) end in

# Extract the rest of the list. #
let tl: [Int] -> [Int] =
  fun l ->
    case l
    | [] => []
    | x::xs => xs end in

# Determine if a list is empty. #
let is_empty: [Int] -> Bool =
  fun xs ->
    case xs
    | [] => true
    | _::_ => false end in

# Return the element at the index. #
let nth: ([Int], Int) -> Option =
  fun xs, n ->
    case xs, n
    | x::_, 0 => Some(x)
    | _::xs, n => nth(xs, n - 1)
    | [], _ => None end in

# Reverse a List. #
let rev: [Int] -> [Int] =
fun l -> 
let go: ([Int], [Int]) -> [Int] =
  fun xs, acc -> 
    case xs 
    | [] => acc 
    | x::xs => go(xs, x::acc) end in
go(l, []) in

# Check if two lists are equal #
let equal: ([Int], [Int]) -> Bool =
    fun p, xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => x == y && equal(xs, ys)
    | _ => false end
in

# Initialize a list with a given length using an initializer function #
let init: (Int, Int -> Int) -> [Int] =
    fun len, f ->
        let go: (Int, [Int]) -> [Int] =
        fun idx, xs ->
            if idx < len 
            then go(idx + 1, xs @ [f(idx)])   
            else xs
        in
        go(0, [])
in

# Reduce a list from the left. #
let fold_left: ((Int, Int) -> Int, Int, [Int]) -> Int =
  fun f, acc, xs ->
    case xs 
    | [] => acc
    | hd::tl => fold_left(f, f(acc, hd), tl) end in

# Reduce a list from the right. #
let fold_right: ((Int, Int) -> Int, [Int], Int) -> Int =
  fun f, xs, acc ->
    case xs
    | [] => acc
    | hd::tl => f(hd, fold_right(f, tl, acc)) end in


666
LSP: Prelude: String parsed successfully
LSP: Prelude: Info map generated successfully
Debug: true, Constrain: Types
LSP: Init: Recieved string: # Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @
LSP: Init: String parsed successfully
  LSP: Syntax: Leftward is Complete Tile: >@<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [?]
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {tl: [?], hd: ?, acc: ?, xs: ?, filter: (((Int -> Bool), [Int]) -> [Int]), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) else end in
  LSP: Info: ALL errors:Error in term:
  p
Nature of error: Variable p is not bound    
Error in term:
  p
Nature of error: type ((Int -> Bool), [Int]) is not consistent with arrow type
  LSP: Info: BidiCtx: Cls: List Concatenation
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Info: Cls: List Concatenation
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {tl: [?], hd: ?, acc: ?, xs: ?, filter: (((Int -> Bool), [Int]) -> [Int]), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) else end in
  LSP: Info: ALL errors:Error in term:
  p
Nature of error: Variable p is not bound    
Error in term:
  p
Nature of error: type ((Int -> Bool), [Int]) is not consistent with arrow type
  LSP: Info: BidiCtx: Cls: List Concatenation
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Can insert left-convex or complete: @
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 [?]
? <= [?]
? <= [?]
  LSP: Convex: Target types: ?, [?]
  LSP: Convex: Backpack: 
  LSP: Convex: Base: tl hd acc xs [] _ ( [ case  if  let  type 
  LSP: Convex: Lookahead: ! ( () - AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position S Width [ [] _ abs abs_float acc acos asin atan bool_of_string case  ceil cos epsilon_float exp false filter float_of_int float_of_string floor fun  hd if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod nan neg_infinity pi sin sqrt string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan test  tl true type  xs ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Generating Completions for prefix: @
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: && \/ $== == != <= >= < > ==. !=. <=. >=. <. >. + - * / ** +. -. *. /. **. ++ :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: 
  LSP: Convex: Ty paths:
 ?
  LSP: Convex: Target types: ?
  LSP: Convex: Backpack: 
  LSP: Convex: Base: tl hd acc xs filter string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position Width S () [] _ false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: ! ( () - AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position S Width [ [] _ abs abs_float acc acos asin atan bool_of_string case  ceil cos epsilon_float exp false filter float_of_int float_of_string floor fun  hd if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod nan neg_infinity pi sin sqrt string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan test  tl true type  xs ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new_tokens ::= whitespace | "!" | "(" | "()" | "-" | "AlignItems" | "BackgroundColor" | "Border" | "BorderRadius" | "BoxShadow" | "Color" | "Cursor" | "Display" | "FlexDirection" | "FontFamily" | "FontSize" | "FontStyle" | "Gap" | "Height" | "JustifyContent" | "Margin" | "Opacity" | "Outline" | "Overflow" | "Padding" | "Position" | "S" | "Width" | "[" | "[]" | "_" | "abs" | "abs_float" | "acc" | "acos" | "asin" | "atan" | "bool_of_string" | "case " | "ceil" | "cos" | "epsilon_float" | "exp" | "false" | "filter" | "float_of_int" | "float_of_string" | "floor" | "fun " | "hd" | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "nan" | "neg_infinity" | "pi" | "sin" | "sqrt" | "string_compare" | "string_concat" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "tl" | "true" | "type " | "xs" | floatlit | intlit | stringlit
root ::= new_tokens

Top 20 Logits:
 [:21.2412
 t:15.6853
 h:14.2301
 ([:13.8416
 (:13.1621
[:13.0767
 xs:12.5416
 p:12.4365
 [(:12.3593
 go:12.2948
 [[:12.2374
 []:11.7058
 x:11.4424
 :11.3419
 f:11.0106
 acc:10.8846
 tail:10.7726
 g:10.3627
 ((:10.1751
 ):10.0859
 [_:9.98726

================
# Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [

LSP: Prelude: Recieved string: ### List ###

# Add an element to the front of a list. #
let cons: (Int, [Int]) -> [Int] = fun x, xs -> x::xs in

# Determine the length of a list. #
let length: [Int] -> Int =
  fun xs ->
    case xs
    | [] => 0
    | _::xs => 1 + length(xs) end in

# Extract the first element of a list. #
let hd: [Int] -> Option =
  fun l ->
    case l
    | [] => None
    | x::xs => Some(x) end in

# Extract the rest of the list. #
let tl: [Int] -> [Int] =
  fun l ->
    case l
    | [] => []
    | x::xs => xs end in

# Determine if a list is empty. #
let is_empty: [Int] -> Bool =
  fun xs ->
    case xs
    | [] => true
    | _::_ => false end in

# Return the element at the index. #
let nth: ([Int], Int) -> Option =
  fun xs, n ->
    case xs, n
    | x::_, 0 => Some(x)
    | _::xs, n => nth(xs, n - 1)
    | [], _ => None end in

# Reverse a List. #
let rev: [Int] -> [Int] =
fun l -> 
let go: ([Int], [Int]) -> [Int] =
  fun xs, acc -> 
    case xs 
    | [] => acc 
    | x::xs => go(xs, x::acc) end in
go(l, []) in

# Check if two lists are equal #
let equal: ([Int], [Int]) -> Bool =
    fun p, xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => x == y && equal(xs, ys)
    | _ => false end
in

# Initialize a list with a given length using an initializer function #
let init: (Int, Int -> Int) -> [Int] =
    fun len, f ->
        let go: (Int, [Int]) -> [Int] =
        fun idx, xs ->
            if idx < len 
            then go(idx + 1, xs @ [f(idx)])   
            else xs
        in
        go(0, [])
in

# Reduce a list from the left. #
let fold_left: ((Int, Int) -> Int, Int, [Int]) -> Int =
  fun f, acc, xs ->
    case xs 
    | [] => acc
    | hd::tl => fold_left(f, f(acc, hd), tl) end in

# Reduce a list from the right. #
let fold_right: ((Int, Int) -> Int, [Int], Int) -> Int =
  fun f, xs, acc ->
    case xs
    | [] => acc
    | hd::tl => f(hd, fold_right(f, tl, acc)) end in


666
LSP: Prelude: String parsed successfully
LSP: Prelude: Info map generated successfully
Debug: true, Constrain: Types
LSP: Init: Recieved string: # Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [
LSP: Init: String parsed successfully
  LSP: Syntax: Leftward is Incomplete Tile: <[ ]<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {tl: [?], hd: ?, acc: ?, xs: ?, filter: (((Int -> Bool), [Int]) -> [Int]), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ] ) else end in
  LSP: Info: ALL errors:Error in term:
  p
Nature of error: Variable p is not bound    
Error in term:
  p
Nature of error: type ((Int -> Bool), [Int]) is not consistent with arrow type
  LSP: Info: BidiCtx: Cls: Empty expression hole
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: List literal
  LSP: Info: Cls: List literal
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [?]
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {tl: [?], hd: ?, acc: ?, xs: ?, filter: (((Int -> Bool), [Int]) -> [Int]), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ] ) else end in
  LSP: Info: ALL errors:Error in term:
  p
Nature of error: Variable p is not bound    
Error in term:
  p
Nature of error: type ((Int -> Bool), [Int]) is not consistent with arrow type
  LSP: Info: BidiCtx: Cls: List Concatenation
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Can insert left-convex or complete: [
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 ?
  LSP: Convex: Target types: ?
  LSP: Convex: Backpack: 
  LSP: Convex: Base: tl hd acc xs filter string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position Width S () [] _ false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: ! ( () - AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position S Width [ [] _ abs abs_float acc acos asin atan bool_of_string case  ceil cos epsilon_float exp false filter float_of_int float_of_string floor fun  hd if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod nan neg_infinity pi sin sqrt string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan test  tl true type  xs ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Generating Completions for prefix: [
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Backpack: ]
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: 
  LSP: Convex: Ty paths:
 [?]
? <= [?]
? <= [?]
  LSP: Convex: Target types: ?, [?]
  LSP: Convex: Backpack: 
  LSP: Convex: Base: tl hd acc xs [] _ ( [ case  if  let  type 
  LSP: Convex: Lookahead: ! ( () - AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position S Width [ [] _ abs abs_float acc acos asin atan bool_of_string case  ceil cos epsilon_float exp false filter float_of_int float_of_string floor fun  hd if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod nan neg_infinity pi sin sqrt string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan test  tl true type  xs ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "]"
new_tokens ::= whitespace | "!" | "(" | "()" | "-" | "AlignItems" | "BackgroundColor" | "Border" | "BorderRadius" | "BoxShadow" | "Color" | "Cursor" | "Display" | "FlexDirection" | "FontFamily" | "FontSize" | "FontStyle" | "Gap" | "Height" | "JustifyContent" | "Margin" | "Opacity" | "Outline" | "Overflow" | "Padding" | "Position" | "S" | "Width" | "[" | "[]" | "_" | "abs" | "abs_float" | "acc" | "acos" | "asin" | "atan" | "bool_of_string" | "case " | "ceil" | "cos" | "epsilon_float" | "exp" | "false" | "filter" | "float_of_int" | "float_of_string" | "floor" | "fun " | "hd" | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "nan" | "neg_infinity" | "pi" | "sin" | "sqrt" | "string_compare" | "string_concat" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "tl" | "true" | "type " | "xs" | floatlit | intlit | stringlit
root ::= completions | new_tokens

Top 20 Logits:
hd:17.6975
f:12.8683
p:12.0252
x:11.2068
go:11.0799
 h:10.6741
acc:10.6504
fun:10.0202
map:9.97401
Some:9.86695
true:9.67278
h:9.62017
fd:9.60021
fold:9.52091
cons:9.51153
 f:9.34512
((:9.31452
1:9.29236
hs:9.27144
t:9.12676
]):8.88035

================
# Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd

LSP: Prelude: Recieved string: ### List ###

# Add an element to the front of a list. #
let cons: (Int, [Int]) -> [Int] = fun x, xs -> x::xs in

# Determine the length of a list. #
let length: [Int] -> Int =
  fun xs ->
    case xs
    | [] => 0
    | _::xs => 1 + length(xs) end in

# Extract the first element of a list. #
let hd: [Int] -> Option =
  fun l ->
    case l
    | [] => None
    | x::xs => Some(x) end in

# Extract the rest of the list. #
let tl: [Int] -> [Int] =
  fun l ->
    case l
    | [] => []
    | x::xs => xs end in

# Determine if a list is empty. #
let is_empty: [Int] -> Bool =
  fun xs ->
    case xs
    | [] => true
    | _::_ => false end in

# Return the element at the index. #
let nth: ([Int], Int) -> Option =
  fun xs, n ->
    case xs, n
    | x::_, 0 => Some(x)
    | _::xs, n => nth(xs, n - 1)
    | [], _ => None end in

# Reverse a List. #
let rev: [Int] -> [Int] =
fun l -> 
let go: ([Int], [Int]) -> [Int] =
  fun xs, acc -> 
    case xs 
    | [] => acc 
    | x::xs => go(xs, x::acc) end in
go(l, []) in

# Check if two lists are equal #
let equal: ([Int], [Int]) -> Bool =
    fun p, xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => x == y && equal(xs, ys)
    | _ => false end
in

# Initialize a list with a given length using an initializer function #
let init: (Int, Int -> Int) -> [Int] =
    fun len, f ->
        let go: (Int, [Int]) -> [Int] =
        fun idx, xs ->
            if idx < len 
            then go(idx + 1, xs @ [f(idx)])   
            else xs
        in
        go(0, [])
in

# Reduce a list from the left. #
let fold_left: ((Int, Int) -> Int, Int, [Int]) -> Int =
  fun f, acc, xs ->
    case xs 
    | [] => acc
    | hd::tl => fold_left(f, f(acc, hd), tl) end in

# Reduce a list from the right. #
let fold_right: ((Int, Int) -> Int, [Int], Int) -> Int =
  fun f, xs, acc ->
    case xs
    | [] => acc
    | hd::tl => f(hd, fold_right(f, tl, acc)) end in


666
LSP: Prelude: String parsed successfully
LSP: Prelude: Info map generated successfully
Debug: true, Constrain: Types
LSP: Init: Recieved string: # Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd
LSP: Init: String parsed successfully
  LSP: Syntax: Leftward is Complete Tile: <hd>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {tl: [?], hd: ?, acc: ?, xs: ?, filter: (((Int -> Bool), [Int]) -> [Int]), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ] ) else end in
  LSP: Info: ALL errors:Error in term:
  p
Nature of error: Variable p is not bound    
Error in term:
  p
Nature of error: type ((Int -> Bool), [Int]) is not consistent with arrow type
  LSP: Info: BidiCtx: Cls: Variable reference
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: List literal
  LSP: Syntax: Can insert left-concave or complete: hd
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: && \/ $== == != <= >= < > ==. !=. <=. >=. <. >. + - * / ** +. -. *. /. **. ++ :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Backpack: ]
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: hd
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: && \/ $== == != <= >= < > ==. !=. <=. >=. <. >. + - * / ** +. -. *. /. **. ++ :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Backpack: ]
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Ty paths:
 ?
  LSP: Convex: Target types: ?
  LSP: Convex: Backpack: 
  LSP: Convex: Base: tl hd acc xs filter string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position Width S () [] _ false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: ! ( () - AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position S Width [ [] _ abs abs_float acc acos asin atan bool_of_string case  ceil cos epsilon_float exp false filter float_of_int float_of_string floor fun  hd if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod nan neg_infinity pi sin sqrt string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan test  tl true type  xs ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new_tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/" | "]"
root ::= new_tokens

Top 20 Logits:
]:21.5138
]):18.1469
,:12.9156
:::12.6859
 :::12.6039
():12.3371
 @:12.2337
],:11.9959
@:11.7101
 +:11.6796
]),:11.2365
]).:10.9764
 *:10.8402
 &:10.6514
::10.5089
 -:10.4276
*:10.2815
):10.0899
])):10.086
 ]:10.0824
]);:10.0675

================
# Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd]

LSP: Prelude: Recieved string: ### List ###

# Add an element to the front of a list. #
let cons: (Int, [Int]) -> [Int] = fun x, xs -> x::xs in

# Determine the length of a list. #
let length: [Int] -> Int =
  fun xs ->
    case xs
    | [] => 0
    | _::xs => 1 + length(xs) end in

# Extract the first element of a list. #
let hd: [Int] -> Option =
  fun l ->
    case l
    | [] => None
    | x::xs => Some(x) end in

# Extract the rest of the list. #
let tl: [Int] -> [Int] =
  fun l ->
    case l
    | [] => []
    | x::xs => xs end in

# Determine if a list is empty. #
let is_empty: [Int] -> Bool =
  fun xs ->
    case xs
    | [] => true
    | _::_ => false end in

# Return the element at the index. #
let nth: ([Int], Int) -> Option =
  fun xs, n ->
    case xs, n
    | x::_, 0 => Some(x)
    | _::xs, n => nth(xs, n - 1)
    | [], _ => None end in

# Reverse a List. #
let rev: [Int] -> [Int] =
fun l -> 
let go: ([Int], [Int]) -> [Int] =
  fun xs, acc -> 
    case xs 
    | [] => acc 
    | x::xs => go(xs, x::acc) end in
go(l, []) in

# Check if two lists are equal #
let equal: ([Int], [Int]) -> Bool =
    fun p, xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => x == y && equal(xs, ys)
    | _ => false end
in

# Initialize a list with a given length using an initializer function #
let init: (Int, Int -> Int) -> [Int] =
    fun len, f ->
        let go: (Int, [Int]) -> [Int] =
        fun idx, xs ->
            if idx < len 
            then go(idx + 1, xs @ [f(idx)])   
            else xs
        in
        go(0, [])
in

# Reduce a list from the left. #
let fold_left: ((Int, Int) -> Int, Int, [Int]) -> Int =
  fun f, acc, xs ->
    case xs 
    | [] => acc
    | hd::tl => fold_left(f, f(acc, hd), tl) end in

# Reduce a list from the right. #
let fold_right: ((Int, Int) -> Int, [Int], Int) -> Int =
  fun f, xs, acc ->
    case xs
    | [] => acc
    | hd::tl => f(hd, fold_right(f, tl, acc)) end in


666
LSP: Prelude: String parsed successfully
LSP: Prelude: Info map generated successfully
Debug: true, Constrain: Types
LSP: Init: Recieved string: # Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd]
LSP: Init: String parsed successfully
  LSP: Syntax: Leftward is Complete Tile: <[ ]>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: List literal
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [?]
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {tl: [?], hd: ?, acc: ?, xs: ?, filter: (((Int -> Bool), [Int]) -> [Int]), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) else end in
  LSP: Info: ALL errors:Error in term:
  p
Nature of error: Variable p is not bound    
Error in term:
  p
Nature of error: type ((Int -> Bool), [Int]) is not consistent with arrow type
  LSP: Info: BidiCtx: Cls: List Concatenation
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: [?]
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: :: @
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new_tokens ::= whitespace | ")" | "," | "::" | "@"
root ::= new_tokens

Top 20 Logits:
 @:19.5269
@:12.9368
 &:12.3658
 ):12.1838
 t:11.8316
 +:11.5338
 :11.4454
 :::11.3507
 *:11.0899
 &&:10.6407
 and:10.6216
 /:10.3421
 <:10.1317
 ::10.1148
 |:9.87498
 (@:9.75406
 end:9.7333
:::9.47691
 ||:9.46409
 in:9.35517
 %:9.30461

================
# Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @

LSP: Prelude: Recieved string: ### List ###

# Add an element to the front of a list. #
let cons: (Int, [Int]) -> [Int] = fun x, xs -> x::xs in

# Determine the length of a list. #
let length: [Int] -> Int =
  fun xs ->
    case xs
    | [] => 0
    | _::xs => 1 + length(xs) end in

# Extract the first element of a list. #
let hd: [Int] -> Option =
  fun l ->
    case l
    | [] => None
    | x::xs => Some(x) end in

# Extract the rest of the list. #
let tl: [Int] -> [Int] =
  fun l ->
    case l
    | [] => []
    | x::xs => xs end in

# Determine if a list is empty. #
let is_empty: [Int] -> Bool =
  fun xs ->
    case xs
    | [] => true
    | _::_ => false end in

# Return the element at the index. #
let nth: ([Int], Int) -> Option =
  fun xs, n ->
    case xs, n
    | x::_, 0 => Some(x)
    | _::xs, n => nth(xs, n - 1)
    | [], _ => None end in

# Reverse a List. #
let rev: [Int] -> [Int] =
fun l -> 
let go: ([Int], [Int]) -> [Int] =
  fun xs, acc -> 
    case xs 
    | [] => acc 
    | x::xs => go(xs, x::acc) end in
go(l, []) in

# Check if two lists are equal #
let equal: ([Int], [Int]) -> Bool =
    fun p, xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => x == y && equal(xs, ys)
    | _ => false end
in

# Initialize a list with a given length using an initializer function #
let init: (Int, Int -> Int) -> [Int] =
    fun len, f ->
        let go: (Int, [Int]) -> [Int] =
        fun idx, xs ->
            if idx < len 
            then go(idx + 1, xs @ [f(idx)])   
            else xs
        in
        go(0, [])
in

# Reduce a list from the left. #
let fold_left: ((Int, Int) -> Int, Int, [Int]) -> Int =
  fun f, acc, xs ->
    case xs 
    | [] => acc
    | hd::tl => fold_left(f, f(acc, hd), tl) end in

# Reduce a list from the right. #
let fold_right: ((Int, Int) -> Int, [Int], Int) -> Int =
  fun f, xs, acc ->
    case xs
    | [] => acc
    | hd::tl => f(hd, fold_right(f, tl, acc)) end in


666
LSP: Prelude: String parsed successfully
LSP: Prelude: Info map generated successfully
Debug: true, Constrain: Types
LSP: Init: Recieved string: # Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @
LSP: Init: String parsed successfully
  LSP: Syntax: Leftward is Complete Tile: >@<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [?]
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {tl: [?], hd: ?, acc: ?, xs: ?, filter: (((Int -> Bool), [Int]) -> [Int]), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) else end in
  LSP: Info: ALL errors:Error in term:
  p
Nature of error: type ((Int -> Bool), [Int]) is not consistent with arrow type    
Error in term:
  p
Nature of error: Variable p is not bound
  LSP: Info: BidiCtx: Cls: List Concatenation
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Info: Cls: List Concatenation
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {tl: [?], hd: ?, acc: ?, xs: ?, filter: (((Int -> Bool), [Int]) -> [Int]), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) else end in
  LSP: Info: ALL errors:Error in term:
  p
Nature of error: type ((Int -> Bool), [Int]) is not consistent with arrow type    
Error in term:
  p
Nature of error: Variable p is not bound
  LSP: Info: BidiCtx: Cls: List Concatenation
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Can insert left-convex or complete: @
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 [?]
? <= [?]
? <= [?]
  LSP: Convex: Target types: ?, [?]
  LSP: Convex: Backpack: 
  LSP: Convex: Base: tl hd acc xs [] _ ( [ case  if  let  type 
  LSP: Convex: Lookahead: ! ( () - AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position S Width [ [] _ abs abs_float acc acos asin atan bool_of_string case  ceil cos epsilon_float exp false filter float_of_int float_of_string floor fun  hd if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod nan neg_infinity pi sin sqrt string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan test  tl true type  xs ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Generating Completions for prefix: @
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: && \/ $== == != <= >= < > ==. !=. <=. >=. <. >. + - * / ** +. -. *. /. **. ++ :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: 
  LSP: Convex: Ty paths:
 ?
  LSP: Convex: Target types: ?
  LSP: Convex: Backpack: 
  LSP: Convex: Base: tl hd acc xs filter string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position Width S () [] _ false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: ! ( () - AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position S Width [ [] _ abs abs_float acc acos asin atan bool_of_string case  ceil cos epsilon_float exp false filter float_of_int float_of_string floor fun  hd if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod nan neg_infinity pi sin sqrt string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan test  tl true type  xs ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new_tokens ::= whitespace | "!" | "(" | "()" | "-" | "AlignItems" | "BackgroundColor" | "Border" | "BorderRadius" | "BoxShadow" | "Color" | "Cursor" | "Display" | "FlexDirection" | "FontFamily" | "FontSize" | "FontStyle" | "Gap" | "Height" | "JustifyContent" | "Margin" | "Opacity" | "Outline" | "Overflow" | "Padding" | "Position" | "S" | "Width" | "[" | "[]" | "_" | "abs" | "abs_float" | "acc" | "acos" | "asin" | "atan" | "bool_of_string" | "case " | "ceil" | "cos" | "epsilon_float" | "exp" | "false" | "filter" | "float_of_int" | "float_of_string" | "floor" | "fun " | "hd" | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "nan" | "neg_infinity" | "pi" | "sin" | "sqrt" | "string_compare" | "string_concat" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "tl" | "true" | "type " | "xs" | floatlit | intlit | stringlit
root ::= new_tokens

Top 20 Logits:
 t:19.0206
 xs:13.2679
 filter:12.8223
 go:12.7836
 rev:12.4945
 (:12.2052
 tail:11.9613
 [:11.8122
 fol:11.557
 fl:11.5242
 p:11.5137
 f:11.3165
 acc:10.9796
 map:10.4537
 reverse:10.1277
 x:10.1132
 rest:10.0617
 :9.98883
 h:9.8768
 g:9.59353
 list:9.47938

================
# Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ t

LSP: Prelude: Recieved string: ### List ###

# Add an element to the front of a list. #
let cons: (Int, [Int]) -> [Int] = fun x, xs -> x::xs in

# Determine the length of a list. #
let length: [Int] -> Int =
  fun xs ->
    case xs
    | [] => 0
    | _::xs => 1 + length(xs) end in

# Extract the first element of a list. #
let hd: [Int] -> Option =
  fun l ->
    case l
    | [] => None
    | x::xs => Some(x) end in

# Extract the rest of the list. #
let tl: [Int] -> [Int] =
  fun l ->
    case l
    | [] => []
    | x::xs => xs end in

# Determine if a list is empty. #
let is_empty: [Int] -> Bool =
  fun xs ->
    case xs
    | [] => true
    | _::_ => false end in

# Return the element at the index. #
let nth: ([Int], Int) -> Option =
  fun xs, n ->
    case xs, n
    | x::_, 0 => Some(x)
    | _::xs, n => nth(xs, n - 1)
    | [], _ => None end in

# Reverse a List. #
let rev: [Int] -> [Int] =
fun l -> 
let go: ([Int], [Int]) -> [Int] =
  fun xs, acc -> 
    case xs 
    | [] => acc 
    | x::xs => go(xs, x::acc) end in
go(l, []) in

# Check if two lists are equal #
let equal: ([Int], [Int]) -> Bool =
    fun p, xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => x == y && equal(xs, ys)
    | _ => false end
in

# Initialize a list with a given length using an initializer function #
let init: (Int, Int -> Int) -> [Int] =
    fun len, f ->
        let go: (Int, [Int]) -> [Int] =
        fun idx, xs ->
            if idx < len 
            then go(idx + 1, xs @ [f(idx)])   
            else xs
        in
        go(0, [])
in

# Reduce a list from the left. #
let fold_left: ((Int, Int) -> Int, Int, [Int]) -> Int =
  fun f, acc, xs ->
    case xs 
    | [] => acc
    | hd::tl => fold_left(f, f(acc, hd), tl) end in

# Reduce a list from the right. #
let fold_right: ((Int, Int) -> Int, [Int], Int) -> Int =
  fun f, xs, acc ->
    case xs
    | [] => acc
    | hd::tl => f(hd, fold_right(f, tl, acc)) end in


666
LSP: Prelude: String parsed successfully
LSP: Prelude: Info map generated successfully
Debug: true, Constrain: Types
LSP: Init: Recieved string: # Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ t
LSP: Init: String parsed successfully
  LSP: Syntax: Leftward is Complete Tile: <t>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [?]
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Exp (FreeVariable "t"))
  LSP: Info: Typing Context: {tl: [?], hd: ?, acc: ?, xs: ?, filter: (((Int -> Bool), [Int]) -> [Int]), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) else end in
  LSP: Info: ALL errors:Error in term:
  p
Nature of error: Variable p is not bound    
Error in term:
  p
Nature of error: type ((Int -> Bool), [Int]) is not consistent with arrow type    
Error in term:
  t
Nature of error: Variable t is not bound
  LSP: Info: BidiCtx: Cls: List Concatenation
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Can insert left-concave or complete: t
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: t
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Ty paths:
 [?]
? <= [?]
? <= [?]
  LSP: Convex: Target types: ?, [?]
  LSP: Convex: Backpack: 
  LSP: Convex: Base: tl hd acc xs [] _ ( [ case  if  let  type 
  LSP: Convex: Lookahead: ! ( () - AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position S Width [ [] _ abs abs_float acc acos asin atan bool_of_string case  ceil cos epsilon_float exp false filter float_of_int float_of_string floor fun  hd if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod nan neg_infinity pi sin sqrt string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan test  tl true type  xs ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "an" | "est " | "l" | "rue" | "ype "
new_tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | ")" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/"
root ::= completions | new_tokens

Top 20 Logits:
l:24.0347
la:14.9514
L:14.1834
ls:13.3723
al:12.3899
il:12.0126
lt:11.6433
 l:11.5128
lu:11.5124
ld:11.4332
li:11.1869
lr:11.1321
ail:10.8508
sl:10.7608
lb:10.722
lv:10.4781
las:10.4155
cl:10.4031
:10.3046
lp:10.234
ll:10.1515

================
# Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl

LSP: Prelude: Recieved string: ### List ###

# Add an element to the front of a list. #
let cons: (Int, [Int]) -> [Int] = fun x, xs -> x::xs in

# Determine the length of a list. #
let length: [Int] -> Int =
  fun xs ->
    case xs
    | [] => 0
    | _::xs => 1 + length(xs) end in

# Extract the first element of a list. #
let hd: [Int] -> Option =
  fun l ->
    case l
    | [] => None
    | x::xs => Some(x) end in

# Extract the rest of the list. #
let tl: [Int] -> [Int] =
  fun l ->
    case l
    | [] => []
    | x::xs => xs end in

# Determine if a list is empty. #
let is_empty: [Int] -> Bool =
  fun xs ->
    case xs
    | [] => true
    | _::_ => false end in

# Return the element at the index. #
let nth: ([Int], Int) -> Option =
  fun xs, n ->
    case xs, n
    | x::_, 0 => Some(x)
    | _::xs, n => nth(xs, n - 1)
    | [], _ => None end in

# Reverse a List. #
let rev: [Int] -> [Int] =
fun l -> 
let go: ([Int], [Int]) -> [Int] =
  fun xs, acc -> 
    case xs 
    | [] => acc 
    | x::xs => go(xs, x::acc) end in
go(l, []) in

# Check if two lists are equal #
let equal: ([Int], [Int]) -> Bool =
    fun p, xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => x == y && equal(xs, ys)
    | _ => false end
in

# Initialize a list with a given length using an initializer function #
let init: (Int, Int -> Int) -> [Int] =
    fun len, f ->
        let go: (Int, [Int]) -> [Int] =
        fun idx, xs ->
            if idx < len 
            then go(idx + 1, xs @ [f(idx)])   
            else xs
        in
        go(0, [])
in

# Reduce a list from the left. #
let fold_left: ((Int, Int) -> Int, Int, [Int]) -> Int =
  fun f, acc, xs ->
    case xs 
    | [] => acc
    | hd::tl => fold_left(f, f(acc, hd), tl) end in

# Reduce a list from the right. #
let fold_right: ((Int, Int) -> Int, [Int], Int) -> Int =
  fun f, xs, acc ->
    case xs
    | [] => acc
    | hd::tl => f(hd, fold_right(f, tl, acc)) end in


666
LSP: Prelude: String parsed successfully
LSP: Prelude: Info map generated successfully
Debug: true, Constrain: Types
LSP: Init: Recieved string: # Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl
LSP: Init: String parsed successfully
  LSP: Syntax: Leftward is Complete Tile: <tl>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [?]
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {tl: [?], hd: ?, acc: ?, xs: ?, filter: (((Int -> Bool), [Int]) -> [Int]), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) else end in
  LSP: Info: ALL errors:Error in term:
  p
Nature of error: Variable p is not bound    
Error in term:
  p
Nature of error: type ((Int -> Bool), [Int]) is not consistent with arrow type
  LSP: Info: BidiCtx: Cls: List Concatenation
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Can insert left-concave or complete: tl
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: [?]
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: :: @
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: 
LSP: Generating Completions for prefix: tl
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: 
  LSP: Convex: Ty paths:
 [?]
? <= [?]
? <= [?]
  LSP: Convex: Target types: ?, [?]
  LSP: Convex: Backpack: 
  LSP: Convex: Base: tl hd acc xs [] _ ( [ case  if  let  type 
  LSP: Convex: Lookahead: ! ( () - AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position S Width [ [] _ abs abs_float acc acos asin atan bool_of_string case  ceil cos epsilon_float exp false filter float_of_int float_of_string floor fun  hd if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod nan neg_infinity pi sin sqrt string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan test  tl true type  xs ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new_tokens ::= whitespace | ")" | "," | "::" | "@"
root ::= new_tokens

Top 20 Logits:
):19.7199
 ):12.1426
 else:11.7162
)):11.6107
)::10.9742
 @:10.3773
).:10.0144
)(:9.89751
),:9.73984
.:9.42271
 ::9.36358
);:9.32674
,:9.2109

:9.16546
 :::9.08908
[:9.04079
::8.80071
)]:8.77282
@:8.67604
 (:8.40835
1:8.32972

================
# Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl)

LSP: Prelude: Recieved string: ### List ###

# Add an element to the front of a list. #
let cons: (Int, [Int]) -> [Int] = fun x, xs -> x::xs in

# Determine the length of a list. #
let length: [Int] -> Int =
  fun xs ->
    case xs
    | [] => 0
    | _::xs => 1 + length(xs) end in

# Extract the first element of a list. #
let hd: [Int] -> Option =
  fun l ->
    case l
    | [] => None
    | x::xs => Some(x) end in

# Extract the rest of the list. #
let tl: [Int] -> [Int] =
  fun l ->
    case l
    | [] => []
    | x::xs => xs end in

# Determine if a list is empty. #
let is_empty: [Int] -> Bool =
  fun xs ->
    case xs
    | [] => true
    | _::_ => false end in

# Return the element at the index. #
let nth: ([Int], Int) -> Option =
  fun xs, n ->
    case xs, n
    | x::_, 0 => Some(x)
    | _::xs, n => nth(xs, n - 1)
    | [], _ => None end in

# Reverse a List. #
let rev: [Int] -> [Int] =
fun l -> 
let go: ([Int], [Int]) -> [Int] =
  fun xs, acc -> 
    case xs 
    | [] => acc 
    | x::xs => go(xs, x::acc) end in
go(l, []) in

# Check if two lists are equal #
let equal: ([Int], [Int]) -> Bool =
    fun p, xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => x == y && equal(xs, ys)
    | _ => false end
in

# Initialize a list with a given length using an initializer function #
let init: (Int, Int -> Int) -> [Int] =
    fun len, f ->
        let go: (Int, [Int]) -> [Int] =
        fun idx, xs ->
            if idx < len 
            then go(idx + 1, xs @ [f(idx)])   
            else xs
        in
        go(0, [])
in

# Reduce a list from the left. #
let fold_left: ((Int, Int) -> Int, Int, [Int]) -> Int =
  fun f, acc, xs ->
    case xs 
    | [] => acc
    | hd::tl => fold_left(f, f(acc, hd), tl) end in

# Reduce a list from the right. #
let fold_right: ((Int, Int) -> Int, [Int], Int) -> Int =
  fun f, xs, acc ->
    case xs
    | [] => acc
    | hd::tl => f(hd, fold_right(f, tl, acc)) end in


666
LSP: Prelude: String parsed successfully
LSP: Prelude: Info map generated successfully
Debug: true, Constrain: Types
LSP: Init: Recieved string: # Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl)
LSP: Init: String parsed successfully
  LSP: Syntax: Leftward is Complete Tile: <( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Parenthesized expression
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {tl: [?], hd: ?, acc: ?, xs: ?, filter: (((Int -> Bool), [Int]) -> [Int]), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: else end in
  LSP: Info: ALL errors:Error in term:
  p
Nature of error: Variable p is not bound    
Error in term:
  p
Nature of error: type ((Int -> Bool), [Int]) is not consistent with arrow type
  LSP: Info: BidiCtx: Cls: Parenthesized expression
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: If expression
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: [?]
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: :: @
  LSP: Concave: Backpack: else
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new_tokens ::= whitespace | "," | "::" | "@" | "else"
root ::= new_tokens

Top 20 Logits:
 else:22.5037

:13.4348
 :12.9682
else:11.8728
 end:11.4709
 els:10.9099
 elif:10.7329
 ||:10.6009
 acc:10.5521
  :10.3982
 @:10.0165
 (:9.78835
 #:9.7244
 &&:9.69445
 in:9.57341
 ::9.29539
 otherwise:9.25
 !:9.21732
	:9.20992
 t:9.02059
 \:8.95855

================
# Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else

LSP: Prelude: Recieved string: ### List ###

# Add an element to the front of a list. #
let cons: (Int, [Int]) -> [Int] = fun x, xs -> x::xs in

# Determine the length of a list. #
let length: [Int] -> Int =
  fun xs ->
    case xs
    | [] => 0
    | _::xs => 1 + length(xs) end in

# Extract the first element of a list. #
let hd: [Int] -> Option =
  fun l ->
    case l
    | [] => None
    | x::xs => Some(x) end in

# Extract the rest of the list. #
let tl: [Int] -> [Int] =
  fun l ->
    case l
    | [] => []
    | x::xs => xs end in

# Determine if a list is empty. #
let is_empty: [Int] -> Bool =
  fun xs ->
    case xs
    | [] => true
    | _::_ => false end in

# Return the element at the index. #
let nth: ([Int], Int) -> Option =
  fun xs, n ->
    case xs, n
    | x::_, 0 => Some(x)
    | _::xs, n => nth(xs, n - 1)
    | [], _ => None end in

# Reverse a List. #
let rev: [Int] -> [Int] =
fun l -> 
let go: ([Int], [Int]) -> [Int] =
  fun xs, acc -> 
    case xs 
    | [] => acc 
    | x::xs => go(xs, x::acc) end in
go(l, []) in

# Check if two lists are equal #
let equal: ([Int], [Int]) -> Bool =
    fun p, xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => x == y && equal(xs, ys)
    | _ => false end
in

# Initialize a list with a given length using an initializer function #
let init: (Int, Int -> Int) -> [Int] =
    fun len, f ->
        let go: (Int, [Int]) -> [Int] =
        fun idx, xs ->
            if idx < len 
            then go(idx + 1, xs @ [f(idx)])   
            else xs
        in
        go(0, [])
in

# Reduce a list from the left. #
let fold_left: ((Int, Int) -> Int, Int, [Int]) -> Int =
  fun f, acc, xs ->
    case xs 
    | [] => acc
    | hd::tl => fold_left(f, f(acc, hd), tl) end in

# Reduce a list from the right. #
let fold_right: ((Int, Int) -> Int, [Int], Int) -> Int =
  fun f, xs, acc ->
    case xs
    | [] => acc
    | hd::tl => f(hd, fold_right(f, tl, acc)) end in


666
LSP: Prelude: String parsed successfully
LSP: Prelude: Info map generated successfully
Debug: true, Constrain: Types
LSP: Init: Recieved string: # Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else
LSP: Init: String parsed successfully
  LSP: Syntax: Leftward is Complete Tile: <if then else<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {tl: [?], hd: ?, acc: ?, xs: ?, filter: (((Int -> Bool), [Int]) -> [Int]), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end in
  LSP: Info: ALL errors:Error in term:
  p
Nature of error: Variable p is not bound    
Error in term:
  p
Nature of error: type ((Int -> Bool), [Int]) is not consistent with arrow type
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 ?
  LSP: Convex: Target types: ?
  LSP: Convex: Backpack: 
  LSP: Convex: Base: tl hd acc xs filter string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position Width S () [] _ false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: ! ( () - AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position S Width [ [] _ abs abs_float acc acos asin atan bool_of_string case  ceil cos epsilon_float exp false filter float_of_int float_of_string floor fun  hd if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod nan neg_infinity pi sin sqrt string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan test  tl true type  xs ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new_tokens ::= whitespace | "!" | "(" | "()" | "-" | "AlignItems" | "BackgroundColor" | "Border" | "BorderRadius" | "BoxShadow" | "Color" | "Cursor" | "Display" | "FlexDirection" | "FontFamily" | "FontSize" | "FontStyle" | "Gap" | "Height" | "JustifyContent" | "Margin" | "Opacity" | "Outline" | "Overflow" | "Padding" | "Position" | "S" | "Width" | "[" | "[]" | "_" | "abs" | "abs_float" | "acc" | "acos" | "asin" | "atan" | "bool_of_string" | "case " | "ceil" | "cos" | "epsilon_float" | "exp" | "false" | "filter" | "float_of_int" | "float_of_string" | "floor" | "fun " | "hd" | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "nan" | "neg_infinity" | "pi" | "sin" | "sqrt" | "string_compare" | "string_concat" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "tl" | "true" | "type " | "xs" | floatlit | intlit | stringlit
root ::= new_tokens

Top 20 Logits:
 (:20.5192
 acc:14.4895
 go:14.0367
 ([:12.7354
 filter:12.6817
 t:12.6541
(:12.5122
 ((:12.4589
 :12.4456
 ():12.2491

:11.8307
 p:11.8253
 xs:11.8157
 [:11.3144
 fol:11.2064
 h:11.0741
 []:10.9337
 (_:10.8987
 if:10.688
 f:10.6507
 None:10.5265

================
# Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (

LSP: Prelude: Recieved string: ### List ###

# Add an element to the front of a list. #
let cons: (Int, [Int]) -> [Int] = fun x, xs -> x::xs in

# Determine the length of a list. #
let length: [Int] -> Int =
  fun xs ->
    case xs
    | [] => 0
    | _::xs => 1 + length(xs) end in

# Extract the first element of a list. #
let hd: [Int] -> Option =
  fun l ->
    case l
    | [] => None
    | x::xs => Some(x) end in

# Extract the rest of the list. #
let tl: [Int] -> [Int] =
  fun l ->
    case l
    | [] => []
    | x::xs => xs end in

# Determine if a list is empty. #
let is_empty: [Int] -> Bool =
  fun xs ->
    case xs
    | [] => true
    | _::_ => false end in

# Return the element at the index. #
let nth: ([Int], Int) -> Option =
  fun xs, n ->
    case xs, n
    | x::_, 0 => Some(x)
    | _::xs, n => nth(xs, n - 1)
    | [], _ => None end in

# Reverse a List. #
let rev: [Int] -> [Int] =
fun l -> 
let go: ([Int], [Int]) -> [Int] =
  fun xs, acc -> 
    case xs 
    | [] => acc 
    | x::xs => go(xs, x::acc) end in
go(l, []) in

# Check if two lists are equal #
let equal: ([Int], [Int]) -> Bool =
    fun p, xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => x == y && equal(xs, ys)
    | _ => false end
in

# Initialize a list with a given length using an initializer function #
let init: (Int, Int -> Int) -> [Int] =
    fun len, f ->
        let go: (Int, [Int]) -> [Int] =
        fun idx, xs ->
            if idx < len 
            then go(idx + 1, xs @ [f(idx)])   
            else xs
        in
        go(0, [])
in

# Reduce a list from the left. #
let fold_left: ((Int, Int) -> Int, Int, [Int]) -> Int =
  fun f, acc, xs ->
    case xs 
    | [] => acc
    | hd::tl => fold_left(f, f(acc, hd), tl) end in

# Reduce a list from the right. #
let fold_right: ((Int, Int) -> Int, [Int], Int) -> Int =
  fun f, xs, acc ->
    case xs
    | [] => acc
    | hd::tl => f(hd, fold_right(f, tl, acc)) end in


666
LSP: Prelude: String parsed successfully
LSP: Prelude: Info map generated successfully
Debug: true, Constrain: Types
LSP: Init: Recieved string: # Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (
LSP: Init: String parsed successfully
  LSP: Syntax: Leftward is Incomplete Tile: <( )<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {tl: [?], hd: ?, acc: ?, xs: ?, filter: (((Int -> Bool), [Int]) -> [Int]), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: ALL errors:Error in term:
  p
Nature of error: type ((Int -> Bool), [Int]) is not consistent with arrow type    
Error in term:
  p
Nature of error: Variable p is not bound
  LSP: Info: BidiCtx: Cls: Empty expression hole
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Info: Cls: Parenthesized expression
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {tl: [?], hd: ?, acc: ?, xs: ?, filter: (((Int -> Bool), [Int]) -> [Int]), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: ALL errors:Error in term:
  p
Nature of error: type ((Int -> Bool), [Int]) is not consistent with arrow type    
Error in term:
  p
Nature of error: Variable p is not bound
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Syntax: Can insert left-convex or complete: (
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 ?
  LSP: Convex: Target types: ?
  LSP: Convex: Backpack: 
  LSP: Convex: Base: tl hd acc xs filter string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position Width S () [] _ false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: ! ( () - AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position S Width [ [] _ abs abs_float acc acos asin atan bool_of_string case  ceil cos epsilon_float exp false filter float_of_int float_of_string floor fun  hd if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod nan neg_infinity pi sin sqrt string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan test  tl true type  xs ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Generating Completions for prefix: (
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: && \/ $== == != <= >= < > ==. !=. <=. >=. <. >. + - * / ** +. -. *. /. **. ++ :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: ( |
  LSP: Convex: Ty paths:
 ?
  LSP: Convex: Target types: ?
  LSP: Convex: Backpack: 
  LSP: Convex: Base: tl hd acc xs filter string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position Width S () [] _ false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: ! ( () - AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position S Width [ [] _ abs abs_float acc acos asin atan bool_of_string case  ceil cos epsilon_float exp false filter float_of_int float_of_string floor fun  hd if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod nan neg_infinity pi sin sqrt string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan test  tl true type  xs ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= ")"
new_tokens ::= whitespace | "!" | "(" | "()" | "-" | "AlignItems" | "BackgroundColor" | "Border" | "BorderRadius" | "BoxShadow" | "Color" | "Cursor" | "Display" | "FlexDirection" | "FontFamily" | "FontSize" | "FontStyle" | "Gap" | "Height" | "JustifyContent" | "Margin" | "Opacity" | "Outline" | "Overflow" | "Padding" | "Position" | "S" | "Width" | "[" | "[]" | "_" | "abs" | "abs_float" | "acc" | "acos" | "asin" | "atan" | "bool_of_string" | "case " | "ceil" | "cos" | "epsilon_float" | "exp" | "false" | "filter" | "float_of_int" | "float_of_string" | "floor" | "fun " | "hd" | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "nan" | "neg_infinity" | "pi" | "sin" | "sqrt" | "string_compare" | "string_concat" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "tl" | "true" | "type " | "xs" | floatlit | intlit | stringlit
root ::= completions | new_tokens

Top 20 Logits:
acc:19.9592
go:13.3324
filter:12.8031
hd:12.549
ac:12.5067
p:12.0244
[]:12.0063
xs:11.437
tl:11.3045
fold:11.2635
 acc:11.178
x:10.8223
rev:10.7025
t:10.4291
hs:10.3486
f:9.68754
true:9.56417

:9.34568
add:9.3209
tail:9.3116
tc:9.21639

================
# Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc

LSP: Prelude: Recieved string: ### List ###

# Add an element to the front of a list. #
let cons: (Int, [Int]) -> [Int] = fun x, xs -> x::xs in

# Determine the length of a list. #
let length: [Int] -> Int =
  fun xs ->
    case xs
    | [] => 0
    | _::xs => 1 + length(xs) end in

# Extract the first element of a list. #
let hd: [Int] -> Option =
  fun l ->
    case l
    | [] => None
    | x::xs => Some(x) end in

# Extract the rest of the list. #
let tl: [Int] -> [Int] =
  fun l ->
    case l
    | [] => []
    | x::xs => xs end in

# Determine if a list is empty. #
let is_empty: [Int] -> Bool =
  fun xs ->
    case xs
    | [] => true
    | _::_ => false end in

# Return the element at the index. #
let nth: ([Int], Int) -> Option =
  fun xs, n ->
    case xs, n
    | x::_, 0 => Some(x)
    | _::xs, n => nth(xs, n - 1)
    | [], _ => None end in

# Reverse a List. #
let rev: [Int] -> [Int] =
fun l -> 
let go: ([Int], [Int]) -> [Int] =
  fun xs, acc -> 
    case xs 
    | [] => acc 
    | x::xs => go(xs, x::acc) end in
go(l, []) in

# Check if two lists are equal #
let equal: ([Int], [Int]) -> Bool =
    fun p, xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => x == y && equal(xs, ys)
    | _ => false end
in

# Initialize a list with a given length using an initializer function #
let init: (Int, Int -> Int) -> [Int] =
    fun len, f ->
        let go: (Int, [Int]) -> [Int] =
        fun idx, xs ->
            if idx < len 
            then go(idx + 1, xs @ [f(idx)])   
            else xs
        in
        go(0, [])
in

# Reduce a list from the left. #
let fold_left: ((Int, Int) -> Int, Int, [Int]) -> Int =
  fun f, acc, xs ->
    case xs 
    | [] => acc
    | hd::tl => fold_left(f, f(acc, hd), tl) end in

# Reduce a list from the right. #
let fold_right: ((Int, Int) -> Int, [Int], Int) -> Int =
  fun f, xs, acc ->
    case xs
    | [] => acc
    | hd::tl => f(hd, fold_right(f, tl, acc)) end in


666
LSP: Prelude: String parsed successfully
LSP: Prelude: Info map generated successfully
Debug: true, Constrain: Types
LSP: Init: Recieved string: # Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc
LSP: Init: String parsed successfully
  LSP: Syntax: Leftward is Complete Tile: <acc>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {tl: [?], hd: ?, acc: ?, xs: ?, filter: (((Int -> Bool), [Int]) -> [Int]), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: ALL errors:Error in term:
  p
Nature of error: Variable p is not bound    
Error in term:
  p
Nature of error: type ((Int -> Bool), [Int]) is not consistent with arrow type
  LSP: Info: BidiCtx: Cls: Variable reference
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Can insert left-concave or complete: acc
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: && \/ $== == != <= >= < > ==. !=. <=. >=. <. >. + - * / ** +. -. *. /. **. ++ :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: acc
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: && \/ $== == != <= >= < > ==. !=. <=. >=. <. >. + - * / ** +. -. *. /. **. ++ :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Ty paths:
 ?
  LSP: Convex: Target types: ?
  LSP: Convex: Backpack: 
  LSP: Convex: Base: tl hd acc xs filter string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position Width S () [] _ false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: ! ( () - AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position S Width [ [] _ abs abs_float acc acos asin atan bool_of_string case  ceil cos epsilon_float exp false filter float_of_int float_of_string floor fun  hd if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod nan neg_infinity pi sin sqrt string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan test  tl true type  xs ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new_tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | ")" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/"
root ::= new_tokens

Top 20 Logits:
 @:19.8772
@:12.405
):12.1892
 *:11.8335
 :11.6895
 +:10.9429
 t:10.3808
(@:10.3415
 end:10.2289
 &:10.0563
 :::9.7216
 <:9.30932
.:9.28565
 (@:9.28099
 ):9.17693
 ::9.1522
,:9.13527
 /:8.97913

:8.78567
 x:8.74696
[@:8.61121

================
# Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @

LSP: Prelude: Recieved string: ### List ###

# Add an element to the front of a list. #
let cons: (Int, [Int]) -> [Int] = fun x, xs -> x::xs in

# Determine the length of a list. #
let length: [Int] -> Int =
  fun xs ->
    case xs
    | [] => 0
    | _::xs => 1 + length(xs) end in

# Extract the first element of a list. #
let hd: [Int] -> Option =
  fun l ->
    case l
    | [] => None
    | x::xs => Some(x) end in

# Extract the rest of the list. #
let tl: [Int] -> [Int] =
  fun l ->
    case l
    | [] => []
    | x::xs => xs end in

# Determine if a list is empty. #
let is_empty: [Int] -> Bool =
  fun xs ->
    case xs
    | [] => true
    | _::_ => false end in

# Return the element at the index. #
let nth: ([Int], Int) -> Option =
  fun xs, n ->
    case xs, n
    | x::_, 0 => Some(x)
    | _::xs, n => nth(xs, n - 1)
    | [], _ => None end in

# Reverse a List. #
let rev: [Int] -> [Int] =
fun l -> 
let go: ([Int], [Int]) -> [Int] =
  fun xs, acc -> 
    case xs 
    | [] => acc 
    | x::xs => go(xs, x::acc) end in
go(l, []) in

# Check if two lists are equal #
let equal: ([Int], [Int]) -> Bool =
    fun p, xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => x == y && equal(xs, ys)
    | _ => false end
in

# Initialize a list with a given length using an initializer function #
let init: (Int, Int -> Int) -> [Int] =
    fun len, f ->
        let go: (Int, [Int]) -> [Int] =
        fun idx, xs ->
            if idx < len 
            then go(idx + 1, xs @ [f(idx)])   
            else xs
        in
        go(0, [])
in

# Reduce a list from the left. #
let fold_left: ((Int, Int) -> Int, Int, [Int]) -> Int =
  fun f, acc, xs ->
    case xs 
    | [] => acc
    | hd::tl => fold_left(f, f(acc, hd), tl) end in

# Reduce a list from the right. #
let fold_right: ((Int, Int) -> Int, [Int], Int) -> Int =
  fun f, xs, acc ->
    case xs
    | [] => acc
    | hd::tl => f(hd, fold_right(f, tl, acc)) end in


666
LSP: Prelude: String parsed successfully
LSP: Prelude: Info map generated successfully
Debug: true, Constrain: Types
LSP: Init: Recieved string: # Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @
LSP: Init: String parsed successfully
  LSP: Syntax: Leftward is Complete Tile: >@<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [?]
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {tl: [?], hd: ?, acc: ?, xs: ?, filter: (((Int -> Bool), [Int]) -> [Int]), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: ALL errors:Error in term:
  p
Nature of error: type ((Int -> Bool), [Int]) is not consistent with arrow type    
Error in term:
  p
Nature of error: Variable p is not bound
  LSP: Info: BidiCtx: Cls: List Concatenation
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Info: Cls: List Concatenation
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {tl: [?], hd: ?, acc: ?, xs: ?, filter: (((Int -> Bool), [Int]) -> [Int]), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: ALL errors:Error in term:
  p
Nature of error: type ((Int -> Bool), [Int]) is not consistent with arrow type    
Error in term:
  p
Nature of error: Variable p is not bound
  LSP: Info: BidiCtx: Cls: List Concatenation
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Can insert left-convex or complete: @
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 [?]
? <= [?]
? <= [?]
  LSP: Convex: Target types: ?, [?]
  LSP: Convex: Backpack: 
  LSP: Convex: Base: tl hd acc xs [] _ ( [ case  if  let  type 
  LSP: Convex: Lookahead: ! ( () - AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position S Width [ [] _ abs abs_float acc acos asin atan bool_of_string case  ceil cos epsilon_float exp false filter float_of_int float_of_string floor fun  hd if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod nan neg_infinity pi sin sqrt string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan test  tl true type  xs ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Generating Completions for prefix: @
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: && \/ $== == != <= >= < > ==. !=. <=. >=. <. >. + - * / ** +. -. *. /. **. ++ :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: 
  LSP: Convex: Ty paths:
 ?
  LSP: Convex: Target types: ?
  LSP: Convex: Backpack: 
  LSP: Convex: Base: tl hd acc xs filter string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position Width S () [] _ false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: ! ( () - AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position S Width [ [] _ abs abs_float acc acos asin atan bool_of_string case  ceil cos epsilon_float exp false filter float_of_int float_of_string floor fun  hd if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod nan neg_infinity pi sin sqrt string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan test  tl true type  xs ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new_tokens ::= whitespace | "!" | "(" | "()" | "-" | "AlignItems" | "BackgroundColor" | "Border" | "BorderRadius" | "BoxShadow" | "Color" | "Cursor" | "Display" | "FlexDirection" | "FontFamily" | "FontSize" | "FontStyle" | "Gap" | "Height" | "JustifyContent" | "Margin" | "Opacity" | "Outline" | "Overflow" | "Padding" | "Position" | "S" | "Width" | "[" | "[]" | "_" | "abs" | "abs_float" | "acc" | "acos" | "asin" | "atan" | "bool_of_string" | "case " | "ceil" | "cos" | "epsilon_float" | "exp" | "false" | "filter" | "float_of_int" | "float_of_string" | "floor" | "fun " | "hd" | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "nan" | "neg_infinity" | "pi" | "sin" | "sqrt" | "string_compare" | "string_concat" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "tl" | "true" | "type " | "xs" | floatlit | intlit | stringlit
root ::= new_tokens

Top 20 Logits:
 t:19.8958
 [:13.5826
 xs:13.2176
 h:12.2751
 tail:11.7619
 p:11.7304
 go:11.6472
 (:11.4847
 acc:11.3325
 :11.2755
 filter:10.8234
 []:10.3727
[:10.3679
tl:10.2149
 x:10.1271
 f:10.0252
 list:9.83622
 @:9.75693
 rev:9.53289
 ):9.49822
 tr:9.1398

================
# Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ t

LSP: Prelude: Recieved string: ### List ###

# Add an element to the front of a list. #
let cons: (Int, [Int]) -> [Int] = fun x, xs -> x::xs in

# Determine the length of a list. #
let length: [Int] -> Int =
  fun xs ->
    case xs
    | [] => 0
    | _::xs => 1 + length(xs) end in

# Extract the first element of a list. #
let hd: [Int] -> Option =
  fun l ->
    case l
    | [] => None
    | x::xs => Some(x) end in

# Extract the rest of the list. #
let tl: [Int] -> [Int] =
  fun l ->
    case l
    | [] => []
    | x::xs => xs end in

# Determine if a list is empty. #
let is_empty: [Int] -> Bool =
  fun xs ->
    case xs
    | [] => true
    | _::_ => false end in

# Return the element at the index. #
let nth: ([Int], Int) -> Option =
  fun xs, n ->
    case xs, n
    | x::_, 0 => Some(x)
    | _::xs, n => nth(xs, n - 1)
    | [], _ => None end in

# Reverse a List. #
let rev: [Int] -> [Int] =
fun l -> 
let go: ([Int], [Int]) -> [Int] =
  fun xs, acc -> 
    case xs 
    | [] => acc 
    | x::xs => go(xs, x::acc) end in
go(l, []) in

# Check if two lists are equal #
let equal: ([Int], [Int]) -> Bool =
    fun p, xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => x == y && equal(xs, ys)
    | _ => false end
in

# Initialize a list with a given length using an initializer function #
let init: (Int, Int -> Int) -> [Int] =
    fun len, f ->
        let go: (Int, [Int]) -> [Int] =
        fun idx, xs ->
            if idx < len 
            then go(idx + 1, xs @ [f(idx)])   
            else xs
        in
        go(0, [])
in

# Reduce a list from the left. #
let fold_left: ((Int, Int) -> Int, Int, [Int]) -> Int =
  fun f, acc, xs ->
    case xs 
    | [] => acc
    | hd::tl => fold_left(f, f(acc, hd), tl) end in

# Reduce a list from the right. #
let fold_right: ((Int, Int) -> Int, [Int], Int) -> Int =
  fun f, xs, acc ->
    case xs
    | [] => acc
    | hd::tl => f(hd, fold_right(f, tl, acc)) end in


666
LSP: Prelude: String parsed successfully
LSP: Prelude: Info map generated successfully
Debug: true, Constrain: Types
LSP: Init: Recieved string: # Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ t
LSP: Init: String parsed successfully
  LSP: Syntax: Leftward is Complete Tile: <t>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [?]
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Exp (FreeVariable "t"))
  LSP: Info: Typing Context: {tl: [?], hd: ?, acc: ?, xs: ?, filter: (((Int -> Bool), [Int]) -> [Int]), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: ALL errors:Error in term:
  p
Nature of error: Variable p is not bound    
Error in term:
  p
Nature of error: type ((Int -> Bool), [Int]) is not consistent with arrow type    
Error in term:
  t
Nature of error: Variable t is not bound
  LSP: Info: BidiCtx: Cls: List Concatenation
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Can insert left-concave or complete: t
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: t
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Ty paths:
 [?]
? <= [?]
? <= [?]
  LSP: Convex: Target types: ?, [?]
  LSP: Convex: Backpack: 
  LSP: Convex: Base: tl hd acc xs [] _ ( [ case  if  let  type 
  LSP: Convex: Lookahead: ! ( () - AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position S Width [ [] _ abs abs_float acc acos asin atan bool_of_string case  ceil cos epsilon_float exp false filter float_of_int float_of_string floor fun  hd if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod nan neg_infinity pi sin sqrt string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan test  tl true type  xs ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "an" | "est " | "l" | "rue" | "ype "
new_tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | ")" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/"
root ::= completions | new_tokens

Top 20 Logits:
l:26.216
ls:16.5354
ld:16.5223
la:15.0354
L:15.0051
dl:14.8653
il:13.9828
d:13.9224
 l:13.6286
al:13.0436
le:12.9825
lt:12.6205
:11.6582
sl:11.5372
lo:11.443
s:11.1263
li:11.1108
1:10.9644
ail:10.7162
len:10.5584
ol:10.5408

================
# Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl

LSP: Prelude: Recieved string: ### List ###

# Add an element to the front of a list. #
let cons: (Int, [Int]) -> [Int] = fun x, xs -> x::xs in

# Determine the length of a list. #
let length: [Int] -> Int =
  fun xs ->
    case xs
    | [] => 0
    | _::xs => 1 + length(xs) end in

# Extract the first element of a list. #
let hd: [Int] -> Option =
  fun l ->
    case l
    | [] => None
    | x::xs => Some(x) end in

# Extract the rest of the list. #
let tl: [Int] -> [Int] =
  fun l ->
    case l
    | [] => []
    | x::xs => xs end in

# Determine if a list is empty. #
let is_empty: [Int] -> Bool =
  fun xs ->
    case xs
    | [] => true
    | _::_ => false end in

# Return the element at the index. #
let nth: ([Int], Int) -> Option =
  fun xs, n ->
    case xs, n
    | x::_, 0 => Some(x)
    | _::xs, n => nth(xs, n - 1)
    | [], _ => None end in

# Reverse a List. #
let rev: [Int] -> [Int] =
fun l -> 
let go: ([Int], [Int]) -> [Int] =
  fun xs, acc -> 
    case xs 
    | [] => acc 
    | x::xs => go(xs, x::acc) end in
go(l, []) in

# Check if two lists are equal #
let equal: ([Int], [Int]) -> Bool =
    fun p, xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => x == y && equal(xs, ys)
    | _ => false end
in

# Initialize a list with a given length using an initializer function #
let init: (Int, Int -> Int) -> [Int] =
    fun len, f ->
        let go: (Int, [Int]) -> [Int] =
        fun idx, xs ->
            if idx < len 
            then go(idx + 1, xs @ [f(idx)])   
            else xs
        in
        go(0, [])
in

# Reduce a list from the left. #
let fold_left: ((Int, Int) -> Int, Int, [Int]) -> Int =
  fun f, acc, xs ->
    case xs 
    | [] => acc
    | hd::tl => fold_left(f, f(acc, hd), tl) end in

# Reduce a list from the right. #
let fold_right: ((Int, Int) -> Int, [Int], Int) -> Int =
  fun f, xs, acc ->
    case xs
    | [] => acc
    | hd::tl => f(hd, fold_right(f, tl, acc)) end in


666
LSP: Prelude: String parsed successfully
LSP: Prelude: Info map generated successfully
Debug: true, Constrain: Types
LSP: Init: Recieved string: # Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl
LSP: Init: String parsed successfully
  LSP: Syntax: Leftward is Complete Tile: <tl>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [?]
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {tl: [?], hd: ?, acc: ?, xs: ?, filter: (((Int -> Bool), [Int]) -> [Int]), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: ALL errors:Error in term:
  p
Nature of error: Variable p is not bound    
Error in term:
  p
Nature of error: type ((Int -> Bool), [Int]) is not consistent with arrow type
  LSP: Info: BidiCtx: Cls: List Concatenation
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Can insert left-concave or complete: tl
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: [?]
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: :: @
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: 
LSP: Generating Completions for prefix: tl
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: 
  LSP: Convex: Ty paths:
 [?]
? <= [?]
? <= [?]
  LSP: Convex: Target types: ?, [?]
  LSP: Convex: Backpack: 
  LSP: Convex: Base: tl hd acc xs [] _ ( [ case  if  let  type 
  LSP: Convex: Lookahead: ! ( () - AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position S Width [ [] _ abs abs_float acc acos asin atan bool_of_string case  ceil cos epsilon_float exp false filter float_of_int float_of_string floor fun  hd if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod nan neg_infinity pi sin sqrt string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan test  tl true type  xs ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new_tokens ::= whitespace | ")" | "," | "::" | "@"
root ::= new_tokens

Top 20 Logits:
):19.5578
 end:13.4352
)):13.1818
);:12.305
 ):11.7763
)]:11.7573
),:10.6036
)::10.4611
)`:10.3457

:10.1456
));:10.077
).:9.62199
)(:9.60867
 @:9.40252
)))):9.28099
)*:9.07457
,:9.06958
))):9.03535
)}:8.99774
)":8.86611
 *:8.75023

================
# Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl)

LSP: Prelude: Recieved string: ### List ###

# Add an element to the front of a list. #
let cons: (Int, [Int]) -> [Int] = fun x, xs -> x::xs in

# Determine the length of a list. #
let length: [Int] -> Int =
  fun xs ->
    case xs
    | [] => 0
    | _::xs => 1 + length(xs) end in

# Extract the first element of a list. #
let hd: [Int] -> Option =
  fun l ->
    case l
    | [] => None
    | x::xs => Some(x) end in

# Extract the rest of the list. #
let tl: [Int] -> [Int] =
  fun l ->
    case l
    | [] => []
    | x::xs => xs end in

# Determine if a list is empty. #
let is_empty: [Int] -> Bool =
  fun xs ->
    case xs
    | [] => true
    | _::_ => false end in

# Return the element at the index. #
let nth: ([Int], Int) -> Option =
  fun xs, n ->
    case xs, n
    | x::_, 0 => Some(x)
    | _::xs, n => nth(xs, n - 1)
    | [], _ => None end in

# Reverse a List. #
let rev: [Int] -> [Int] =
fun l -> 
let go: ([Int], [Int]) -> [Int] =
  fun xs, acc -> 
    case xs 
    | [] => acc 
    | x::xs => go(xs, x::acc) end in
go(l, []) in

# Check if two lists are equal #
let equal: ([Int], [Int]) -> Bool =
    fun p, xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => x == y && equal(xs, ys)
    | _ => false end
in

# Initialize a list with a given length using an initializer function #
let init: (Int, Int -> Int) -> [Int] =
    fun len, f ->
        let go: (Int, [Int]) -> [Int] =
        fun idx, xs ->
            if idx < len 
            then go(idx + 1, xs @ [f(idx)])   
            else xs
        in
        go(0, [])
in

# Reduce a list from the left. #
let fold_left: ((Int, Int) -> Int, Int, [Int]) -> Int =
  fun f, acc, xs ->
    case xs 
    | [] => acc
    | hd::tl => fold_left(f, f(acc, hd), tl) end in

# Reduce a list from the right. #
let fold_right: ((Int, Int) -> Int, [Int], Int) -> Int =
  fun f, xs, acc ->
    case xs
    | [] => acc
    | hd::tl => f(hd, fold_right(f, tl, acc)) end in


666
LSP: Prelude: String parsed successfully
LSP: Prelude: Info map generated successfully
Debug: true, Constrain: Types
LSP: Init: Recieved string: # Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl)
LSP: Init: String parsed successfully
  LSP: Syntax: Leftward is Complete Tile: <( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Parenthesized expression
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {tl: [?], hd: ?, acc: ?, xs: ?, filter: (((Int -> Bool), [Int]) -> [Int]), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end in
  LSP: Info: ALL errors:Error in term:
  p
Nature of error: Variable p is not bound    
Error in term:
  p
Nature of error: type ((Int -> Bool), [Int]) is not consistent with arrow type
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: [?]
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: :: @
  LSP: Concave: Backpack: end
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: |
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new_tokens ::= whitespace | "," | "::" | "@" | "end" | "|"
root ::= new_tokens

Top 20 Logits:
 end:18.9881

:13.252
 in:12.1902
 :11.9952
end:11.1075
  :9.32635
 and:8.76834
   :8.21297
 with:8.15079
 return:7.94401
 (:7.93549
 #:7.80364
 acc:7.63023
 x:7.56034
 fun:7.53025
 ::7.43892
 f:7.42067
 done:7.35198
 e:7.35077
    :7.34271
 xs:7.28267

================
# Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end

LSP: Prelude: Recieved string: ### List ###

# Add an element to the front of a list. #
let cons: (Int, [Int]) -> [Int] = fun x, xs -> x::xs in

# Determine the length of a list. #
let length: [Int] -> Int =
  fun xs ->
    case xs
    | [] => 0
    | _::xs => 1 + length(xs) end in

# Extract the first element of a list. #
let hd: [Int] -> Option =
  fun l ->
    case l
    | [] => None
    | x::xs => Some(x) end in

# Extract the rest of the list. #
let tl: [Int] -> [Int] =
  fun l ->
    case l
    | [] => []
    | x::xs => xs end in

# Determine if a list is empty. #
let is_empty: [Int] -> Bool =
  fun xs ->
    case xs
    | [] => true
    | _::_ => false end in

# Return the element at the index. #
let nth: ([Int], Int) -> Option =
  fun xs, n ->
    case xs, n
    | x::_, 0 => Some(x)
    | _::xs, n => nth(xs, n - 1)
    | [], _ => None end in

# Reverse a List. #
let rev: [Int] -> [Int] =
fun l -> 
let go: ([Int], [Int]) -> [Int] =
  fun xs, acc -> 
    case xs 
    | [] => acc 
    | x::xs => go(xs, x::acc) end in
go(l, []) in

# Check if two lists are equal #
let equal: ([Int], [Int]) -> Bool =
    fun p, xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => x == y && equal(xs, ys)
    | _ => false end
in

# Initialize a list with a given length using an initializer function #
let init: (Int, Int -> Int) -> [Int] =
    fun len, f ->
        let go: (Int, [Int]) -> [Int] =
        fun idx, xs ->
            if idx < len 
            then go(idx + 1, xs @ [f(idx)])   
            else xs
        in
        go(0, [])
in

# Reduce a list from the left. #
let fold_left: ((Int, Int) -> Int, Int, [Int]) -> Int =
  fun f, acc, xs ->
    case xs 
    | [] => acc
    | hd::tl => fold_left(f, f(acc, hd), tl) end in

# Reduce a list from the right. #
let fold_right: ((Int, Int) -> Int, [Int], Int) -> Int =
  fun f, xs, acc ->
    case xs
    | [] => acc
    | hd::tl => f(hd, fold_right(f, tl, acc)) end in


666
LSP: Prelude: String parsed successfully
LSP: Prelude: Info map generated successfully
Debug: true, Constrain: Types
LSP: Init: Recieved string: # Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end
LSP: Init: String parsed successfully
  LSP: Syntax: Leftward is Complete Tile: <case end>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Case expression
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {acc: ?, xs: ?, filter: (((Int -> Bool), [Int]) -> [Int]), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: in
  LSP: Info: ALL errors:Error in term:
  p
Nature of error: Variable p is not bound    
Error in term:
  p
Nature of error: type ((Int -> Bool), [Int]) is not consistent with arrow type
  LSP: Info: BidiCtx: Cls: Function literal
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: [?]
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: :: @
  LSP: Concave: Backpack: in
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new_tokens ::= whitespace | "," | "::" | "@" | "in"
root ::= new_tokens

Top 20 Logits:
 in:17.8099

:14.2991
 :12.914
;:11.9598
in:11.0745
  :10.8499
 and:10.7954
 end:10.3828
):10.3794
.:10.0717
   :9.88893
(:9.78162
    :9.73882
 (:9.57478
,:9.29696
 with:9.21232
 &&:8.76369
 #:8.70837
 ;:8.68985
():8.57134
);:8.55381

================
# Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in

LSP: Prelude: Recieved string: ### List ###

# Add an element to the front of a list. #
let cons: (Int, [Int]) -> [Int] = fun x, xs -> x::xs in

# Determine the length of a list. #
let length: [Int] -> Int =
  fun xs ->
    case xs
    | [] => 0
    | _::xs => 1 + length(xs) end in

# Extract the first element of a list. #
let hd: [Int] -> Option =
  fun l ->
    case l
    | [] => None
    | x::xs => Some(x) end in

# Extract the rest of the list. #
let tl: [Int] -> [Int] =
  fun l ->
    case l
    | [] => []
    | x::xs => xs end in

# Determine if a list is empty. #
let is_empty: [Int] -> Bool =
  fun xs ->
    case xs
    | [] => true
    | _::_ => false end in

# Return the element at the index. #
let nth: ([Int], Int) -> Option =
  fun xs, n ->
    case xs, n
    | x::_, 0 => Some(x)
    | _::xs, n => nth(xs, n - 1)
    | [], _ => None end in

# Reverse a List. #
let rev: [Int] -> [Int] =
fun l -> 
let go: ([Int], [Int]) -> [Int] =
  fun xs, acc -> 
    case xs 
    | [] => acc 
    | x::xs => go(xs, x::acc) end in
go(l, []) in

# Check if two lists are equal #
let equal: ([Int], [Int]) -> Bool =
    fun p, xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => x == y && equal(xs, ys)
    | _ => false end
in

# Initialize a list with a given length using an initializer function #
let init: (Int, Int -> Int) -> [Int] =
    fun len, f ->
        let go: (Int, [Int]) -> [Int] =
        fun idx, xs ->
            if idx < len 
            then go(idx + 1, xs @ [f(idx)])   
            else xs
        in
        go(0, [])
in

# Reduce a list from the left. #
let fold_left: ((Int, Int) -> Int, Int, [Int]) -> Int =
  fun f, acc, xs ->
    case xs 
    | [] => acc
    | hd::tl => fold_left(f, f(acc, hd), tl) end in

# Reduce a list from the right. #
let fold_right: ((Int, Int) -> Int, [Int], Int) -> Int =
  fun f, xs, acc ->
    case xs
    | [] => acc
    | hd::tl => f(hd, fold_right(f, tl, acc)) end in


666
LSP: Prelude: String parsed successfully
LSP: Prelude: Info map generated successfully
Debug: true, Constrain: Types
LSP: Init: Recieved string: # Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
LSP: Init: String parsed successfully
  LSP: Syntax: Leftward is Complete Tile: <let = in<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {go: ((?, ?) -> [?]), filter: (((Int -> Bool), [Int]) -> [Int]), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: 
  LSP: Info: ALL errors:Error in term:
  p
Nature of error: Variable p is not bound    
Error in term:
  p
Nature of error: type ((Int -> Bool), [Int]) is not consistent with arrow type
  LSP: Info: BidiCtx: Cls: Let expression
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent: Root
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 ?
  LSP: Convex: Target types: ?
  LSP: Convex: Backpack: 
  LSP: Convex: Base: go filter string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position Width S () [] _ false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: ! ( () - AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position S Width [ [] _ abs abs_float acos asin atan bool_of_string case  ceil cos epsilon_float exp false filter float_of_int float_of_string floor fun  go if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod nan neg_infinity pi sin sqrt string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan test  true type  ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new_tokens ::= whitespace | "!" | "(" | "()" | "-" | "AlignItems" | "BackgroundColor" | "Border" | "BorderRadius" | "BoxShadow" | "Color" | "Cursor" | "Display" | "FlexDirection" | "FontFamily" | "FontSize" | "FontStyle" | "Gap" | "Height" | "JustifyContent" | "Margin" | "Opacity" | "Outline" | "Overflow" | "Padding" | "Position" | "S" | "Width" | "[" | "[]" | "_" | "abs" | "abs_float" | "acos" | "asin" | "atan" | "bool_of_string" | "case " | "ceil" | "cos" | "epsilon_float" | "exp" | "false" | "filter" | "float_of_int" | "float_of_string" | "floor" | "fun " | "go" | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "nan" | "neg_infinity" | "pi" | "sin" | "sqrt" | "string_compare" | "string_concat" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "true" | "type " | floatlit | intlit | stringlit
root ::= new_tokens

Top 20 Logits:

:18.1317
 :13.8584
  :13.5471
    :12.9909
 go:12.7668
   :11.9179
      :11.2683
        :10.9619
     :10.8239
                :10.552
       :10.152
;:10.144
            :10.0011
          :9.73493
 (:9.60636
 #:9.18676
         :9.13138
	:9.11756
           :8.56383
 ;:8.52214
              :8.45511

================
# Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in


LSP: Prelude: Recieved string: ### List ###

# Add an element to the front of a list. #
let cons: (Int, [Int]) -> [Int] = fun x, xs -> x::xs in

# Determine the length of a list. #
let length: [Int] -> Int =
  fun xs ->
    case xs
    | [] => 0
    | _::xs => 1 + length(xs) end in

# Extract the first element of a list. #
let hd: [Int] -> Option =
  fun l ->
    case l
    | [] => None
    | x::xs => Some(x) end in

# Extract the rest of the list. #
let tl: [Int] -> [Int] =
  fun l ->
    case l
    | [] => []
    | x::xs => xs end in

# Determine if a list is empty. #
let is_empty: [Int] -> Bool =
  fun xs ->
    case xs
    | [] => true
    | _::_ => false end in

# Return the element at the index. #
let nth: ([Int], Int) -> Option =
  fun xs, n ->
    case xs, n
    | x::_, 0 => Some(x)
    | _::xs, n => nth(xs, n - 1)
    | [], _ => None end in

# Reverse a List. #
let rev: [Int] -> [Int] =
fun l -> 
let go: ([Int], [Int]) -> [Int] =
  fun xs, acc -> 
    case xs 
    | [] => acc 
    | x::xs => go(xs, x::acc) end in
go(l, []) in

# Check if two lists are equal #
let equal: ([Int], [Int]) -> Bool =
    fun p, xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => x == y && equal(xs, ys)
    | _ => false end
in

# Initialize a list with a given length using an initializer function #
let init: (Int, Int -> Int) -> [Int] =
    fun len, f ->
        let go: (Int, [Int]) -> [Int] =
        fun idx, xs ->
            if idx < len 
            then go(idx + 1, xs @ [f(idx)])   
            else xs
        in
        go(0, [])
in

# Reduce a list from the left. #
let fold_left: ((Int, Int) -> Int, Int, [Int]) -> Int =
  fun f, acc, xs ->
    case xs 
    | [] => acc
    | hd::tl => fold_left(f, f(acc, hd), tl) end in

# Reduce a list from the right. #
let fold_right: ((Int, Int) -> Int, [Int], Int) -> Int =
  fun f, xs, acc ->
    case xs
    | [] => acc
    | hd::tl => f(hd, fold_right(f, tl, acc)) end in


666
LSP: Prelude: String parsed successfully
LSP: Prelude: Info map generated successfully
Debug: true, Constrain: Types
LSP: Init: Recieved string: # Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in

LSP: Init: String parsed successfully
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: <let = in<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {go: ((?, ?) -> [?]), filter: (((Int -> Bool), [Int]) -> [Int]), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: 
  LSP: Info: ALL errors:Error in term:
  p
Nature of error: Variable p is not bound    
Error in term:
  p
Nature of error: type ((Int -> Bool), [Int]) is not consistent with arrow type
  LSP: Info: BidiCtx: Cls: Let expression
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent: Root
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 ?
  LSP: Convex: Target types: ?
  LSP: Convex: Backpack: 
  LSP: Convex: Base: go filter string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position Width S () [] _ false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: ! ( () - AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position S Width [ [] _ abs abs_float acos asin atan bool_of_string case  ceil cos epsilon_float exp false filter float_of_int float_of_string floor fun  go if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod nan neg_infinity pi sin sqrt string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan test  true type  ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new_tokens ::= whitespace | "!" | "(" | "()" | "-" | "AlignItems" | "BackgroundColor" | "Border" | "BorderRadius" | "BoxShadow" | "Color" | "Cursor" | "Display" | "FlexDirection" | "FontFamily" | "FontSize" | "FontStyle" | "Gap" | "Height" | "JustifyContent" | "Margin" | "Opacity" | "Outline" | "Overflow" | "Padding" | "Position" | "S" | "Width" | "[" | "[]" | "_" | "abs" | "abs_float" | "acos" | "asin" | "atan" | "bool_of_string" | "case " | "ceil" | "cos" | "epsilon_float" | "exp" | "false" | "filter" | "float_of_int" | "float_of_string" | "floor" | "fun " | "go" | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "nan" | "neg_infinity" | "pi" | "sin" | "sqrt" | "string_compare" | "string_concat" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "true" | "type " | floatlit | intlit | stringlit
root ::= new_tokens

Top 20 Logits:
go:15.6451

:14.7972
   :14.5618
 :13.8274
in:13.7425
(:12.9036
  :12.8411
    :12.0806
       :11.9131
fold:11.6844
     :11.6115
 go:11.1729
#:11.0661
filter:10.8529
let:10.8191
fun:10.4918
        :10.3285
rev:10.3277
           :10.136
      :10.1205
```:9.86603

================
# Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go

LSP: Prelude: Recieved string: ### List ###

# Add an element to the front of a list. #
let cons: (Int, [Int]) -> [Int] = fun x, xs -> x::xs in

# Determine the length of a list. #
let length: [Int] -> Int =
  fun xs ->
    case xs
    | [] => 0
    | _::xs => 1 + length(xs) end in

# Extract the first element of a list. #
let hd: [Int] -> Option =
  fun l ->
    case l
    | [] => None
    | x::xs => Some(x) end in

# Extract the rest of the list. #
let tl: [Int] -> [Int] =
  fun l ->
    case l
    | [] => []
    | x::xs => xs end in

# Determine if a list is empty. #
let is_empty: [Int] -> Bool =
  fun xs ->
    case xs
    | [] => true
    | _::_ => false end in

# Return the element at the index. #
let nth: ([Int], Int) -> Option =
  fun xs, n ->
    case xs, n
    | x::_, 0 => Some(x)
    | _::xs, n => nth(xs, n - 1)
    | [], _ => None end in

# Reverse a List. #
let rev: [Int] -> [Int] =
fun l -> 
let go: ([Int], [Int]) -> [Int] =
  fun xs, acc -> 
    case xs 
    | [] => acc 
    | x::xs => go(xs, x::acc) end in
go(l, []) in

# Check if two lists are equal #
let equal: ([Int], [Int]) -> Bool =
    fun p, xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => x == y && equal(xs, ys)
    | _ => false end
in

# Initialize a list with a given length using an initializer function #
let init: (Int, Int -> Int) -> [Int] =
    fun len, f ->
        let go: (Int, [Int]) -> [Int] =
        fun idx, xs ->
            if idx < len 
            then go(idx + 1, xs @ [f(idx)])   
            else xs
        in
        go(0, [])
in

# Reduce a list from the left. #
let fold_left: ((Int, Int) -> Int, Int, [Int]) -> Int =
  fun f, acc, xs ->
    case xs 
    | [] => acc
    | hd::tl => fold_left(f, f(acc, hd), tl) end in

# Reduce a list from the right. #
let fold_right: ((Int, Int) -> Int, [Int], Int) -> Int =
  fun f, xs, acc ->
    case xs
    | [] => acc
    | hd::tl => f(hd, fold_right(f, tl, acc)) end in


666
LSP: Prelude: String parsed successfully
LSP: Prelude: Info map generated successfully
Debug: true, Constrain: Types
LSP: Init: Recieved string: # Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go
LSP: Init: String parsed successfully
  LSP: Syntax: Leftward is Complete Tile: <go>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ((?, ?) -> [?])
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {go: ((?, ?) -> [?]), filter: (((Int -> Bool), [Int]) -> [Int]), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: 
  LSP: Info: ALL errors:Error in term:
  p
Nature of error: type ((Int -> Bool), [Int]) is not consistent with arrow type    
Error in term:
  p
Nature of error: Variable p is not bound
  LSP: Info: BidiCtx: Cls: Let expression
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent: Root
  LSP: Syntax: Can insert left-concave or complete: go
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: ((?, ?) -> [?])
  LSP: Concave: Infix: Base: ::
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: ::
  LSP: Concave: Backpack: 
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: ::
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: go
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: && \/ $== == != <= >= < > ==. !=. <=. >=. <. >. + - * / ** +. -. *. /. **. ++ :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Backpack: 
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Ty paths:
 ?
  LSP: Convex: Target types: ?
  LSP: Convex: Backpack: 
  LSP: Convex: Base: go filter string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position Width S () [] _ false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: ! ( () - AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position S Width [ [] _ abs abs_float acos asin atan bool_of_string case  ceil cos epsilon_float exp false filter float_of_int float_of_string floor fun  go if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod nan neg_infinity pi sin sqrt string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan test  true type  ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new_tokens ::= whitespace | "(" | "," | "::"
root ::= new_tokens

Top 20 Logits:
(:20.1834
([:16.0311

:14.8431
():14.7858
 in:14.0884
 (:13.9378
((:13.2986
 xs:13.2061
;:12.9946
();:12.8839
 ([:12.0283
(_:11.8776
(":11.6265
 :11.265
 end:11.0448
 p:11.0338
 ():10.867
.:10.8619
_:10.8348
 []:10.6642
::10.6479

================
# Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(

LSP: Prelude: Recieved string: ### List ###

# Add an element to the front of a list. #
let cons: (Int, [Int]) -> [Int] = fun x, xs -> x::xs in

# Determine the length of a list. #
let length: [Int] -> Int =
  fun xs ->
    case xs
    | [] => 0
    | _::xs => 1 + length(xs) end in

# Extract the first element of a list. #
let hd: [Int] -> Option =
  fun l ->
    case l
    | [] => None
    | x::xs => Some(x) end in

# Extract the rest of the list. #
let tl: [Int] -> [Int] =
  fun l ->
    case l
    | [] => []
    | x::xs => xs end in

# Determine if a list is empty. #
let is_empty: [Int] -> Bool =
  fun xs ->
    case xs
    | [] => true
    | _::_ => false end in

# Return the element at the index. #
let nth: ([Int], Int) -> Option =
  fun xs, n ->
    case xs, n
    | x::_, 0 => Some(x)
    | _::xs, n => nth(xs, n - 1)
    | [], _ => None end in

# Reverse a List. #
let rev: [Int] -> [Int] =
fun l -> 
let go: ([Int], [Int]) -> [Int] =
  fun xs, acc -> 
    case xs 
    | [] => acc 
    | x::xs => go(xs, x::acc) end in
go(l, []) in

# Check if two lists are equal #
let equal: ([Int], [Int]) -> Bool =
    fun p, xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => x == y && equal(xs, ys)
    | _ => false end
in

# Initialize a list with a given length using an initializer function #
let init: (Int, Int -> Int) -> [Int] =
    fun len, f ->
        let go: (Int, [Int]) -> [Int] =
        fun idx, xs ->
            if idx < len 
            then go(idx + 1, xs @ [f(idx)])   
            else xs
        in
        go(0, [])
in

# Reduce a list from the left. #
let fold_left: ((Int, Int) -> Int, Int, [Int]) -> Int =
  fun f, acc, xs ->
    case xs 
    | [] => acc
    | hd::tl => fold_left(f, f(acc, hd), tl) end in

# Reduce a list from the right. #
let fold_right: ((Int, Int) -> Int, [Int], Int) -> Int =
  fun f, xs, acc ->
    case xs
    | [] => acc
    | hd::tl => f(hd, fold_right(f, tl, acc)) end in


666
LSP: Prelude: String parsed successfully
LSP: Prelude: Info map generated successfully
Debug: true, Constrain: Types
LSP: Init: Recieved string: # Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(
LSP: Init: String parsed successfully
  LSP: Syntax: Leftward is Incomplete Tile: >( )<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: (?, ?)
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {go: ((?, ?) -> [?]), filter: (((Int -> Bool), [Int]) -> [Int]), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: )
  LSP: Info: ALL errors:Error in term:
  p
Nature of error: Variable p is not bound    
Error in term:
  p
Nature of error: type ((Int -> Bool), [Int]) is not consistent with arrow type
  LSP: Info: BidiCtx: Cls: Empty expression hole
  LSP: Info: BidiCtx: Expected type: (?, ?)
  LSP: Info: Bidi Parent Cls: Application
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {go: ((?, ?) -> [?]), filter: (((Int -> Bool), [Int]) -> [Int]), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: )
  LSP: Info: ALL errors:Error in term:
  p
Nature of error: Variable p is not bound    
Error in term:
  p
Nature of error: type ((Int -> Bool), [Int]) is not consistent with arrow type
  LSP: Info: BidiCtx: Cls: Let expression
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent: Root
  LSP: Syntax: Can insert left-convex or complete: (
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 (?, ?)
? <= (?, ?)
? <= (?, ?)
  LSP: Convex: Target types: ?, (?, ?)
  LSP: Convex: Backpack: 
  LSP: Convex: Base: _ ( case  if  let  type 
  LSP: Convex: Lookahead: ! ( () - AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position S Width [ [] _ abs abs_float acos asin atan bool_of_string case  ceil cos epsilon_float exp false filter float_of_int float_of_string floor fun  go if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod nan neg_infinity pi sin sqrt string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan test  true type  ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Generating Completions for prefix: (
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: && \/ $== == != <= >= < > ==. !=. <=. >=. <. >. + - * / ** +. -. *. /. **. ++ :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: 
  LSP: Convex: Ty paths:
 ?
  LSP: Convex: Target types: ?
  LSP: Convex: Backpack: 
  LSP: Convex: Base: go filter string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position Width S () [] _ false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: ! ( () - AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position S Width [ [] _ abs abs_float acos asin atan bool_of_string case  ceil cos epsilon_float exp false filter float_of_int float_of_string floor fun  go if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod nan neg_infinity pi sin sqrt string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan test  true type  ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= ")"
new_tokens ::= whitespace | "!" | "(" | "()" | "-" | "AlignItems" | "BackgroundColor" | "Border" | "BorderRadius" | "BoxShadow" | "Color" | "Cursor" | "Display" | "FlexDirection" | "FontFamily" | "FontSize" | "FontStyle" | "Gap" | "Height" | "JustifyContent" | "Margin" | "Opacity" | "Outline" | "Overflow" | "Padding" | "Position" | "S" | "Width" | "[" | "[]" | "_" | "abs" | "abs_float" | "acos" | "asin" | "atan" | "bool_of_string" | "case " | "ceil" | "cos" | "epsilon_float" | "exp" | "false" | "filter" | "float_of_int" | "float_of_string" | "floor" | "fun " | "go" | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "nan" | "neg_infinity" | "pi" | "sin" | "sqrt" | "string_compare" | "string_concat" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "true" | "type " | floatlit | intlit | stringlit
root ::= completions | new_tokens

Top 20 Logits:
p:16.8812
xs:15.6778
x:13.3903
l:12.4311
list:11.9714
acc:11.8249
f:11.7875
lst:11.4748
_,:11.444
filter:11.3652
[]:11.2754
a:11.0872
0:10.9324
ls:10.6473
cons:10.3113
t:10.1049
1:9.97796
pred:9.90293
tl:9.86899
s:9.85182
n:9.84578

================
# Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p

LSP: Prelude: Recieved string: ### List ###

# Add an element to the front of a list. #
let cons: (Int, [Int]) -> [Int] = fun x, xs -> x::xs in

# Determine the length of a list. #
let length: [Int] -> Int =
  fun xs ->
    case xs
    | [] => 0
    | _::xs => 1 + length(xs) end in

# Extract the first element of a list. #
let hd: [Int] -> Option =
  fun l ->
    case l
    | [] => None
    | x::xs => Some(x) end in

# Extract the rest of the list. #
let tl: [Int] -> [Int] =
  fun l ->
    case l
    | [] => []
    | x::xs => xs end in

# Determine if a list is empty. #
let is_empty: [Int] -> Bool =
  fun xs ->
    case xs
    | [] => true
    | _::_ => false end in

# Return the element at the index. #
let nth: ([Int], Int) -> Option =
  fun xs, n ->
    case xs, n
    | x::_, 0 => Some(x)
    | _::xs, n => nth(xs, n - 1)
    | [], _ => None end in

# Reverse a List. #
let rev: [Int] -> [Int] =
fun l -> 
let go: ([Int], [Int]) -> [Int] =
  fun xs, acc -> 
    case xs 
    | [] => acc 
    | x::xs => go(xs, x::acc) end in
go(l, []) in

# Check if two lists are equal #
let equal: ([Int], [Int]) -> Bool =
    fun p, xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => x == y && equal(xs, ys)
    | _ => false end
in

# Initialize a list with a given length using an initializer function #
let init: (Int, Int -> Int) -> [Int] =
    fun len, f ->
        let go: (Int, [Int]) -> [Int] =
        fun idx, xs ->
            if idx < len 
            then go(idx + 1, xs @ [f(idx)])   
            else xs
        in
        go(0, [])
in

# Reduce a list from the left. #
let fold_left: ((Int, Int) -> Int, Int, [Int]) -> Int =
  fun f, acc, xs ->
    case xs 
    | [] => acc
    | hd::tl => fold_left(f, f(acc, hd), tl) end in

# Reduce a list from the right. #
let fold_right: ((Int, Int) -> Int, [Int], Int) -> Int =
  fun f, xs, acc ->
    case xs
    | [] => acc
    | hd::tl => f(hd, fold_right(f, tl, acc)) end in


666
LSP: Prelude: String parsed successfully
LSP: Prelude: Info map generated successfully
Debug: true, Constrain: Types
LSP: Init: Recieved string: # Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p
LSP: Init: String parsed successfully
  LSP: Syntax: Leftward is Complete Tile: <p>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: (?, ?)
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Exp (FreeVariable "p"))
  LSP: Info: Typing Context: {go: ((?, ?) -> [?]), filter: (((Int -> Bool), [Int]) -> [Int]), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: )
  LSP: Info: ALL errors:Error in term:
  p
Nature of error: Variable p is not bound    
Error in term:
  p
Nature of error: Variable p is not bound    
Error in term:
  p
Nature of error: type ((Int -> Bool), [Int]) is not consistent with arrow type
  LSP: Info: BidiCtx: Cls: Variable reference
  LSP: Info: BidiCtx: Expected type: (?, ?)
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Can insert left-concave or complete: p
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: 
  LSP: Concave: Infix: Lookahead types: ?, (?, ?)
  LSP: Concave: Infix: Lookahead: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: p
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: 
  LSP: Concave: Infix: Lookahead types: ?, (?, ?)
  LSP: Concave: Infix: Lookahead: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Ty paths:
 (?, ?)
? <= (?, ?)
? <= (?, ?)
  LSP: Convex: Target types: ?, (?, ?)
  LSP: Convex: Backpack: 
  LSP: Convex: Base: _ ( case  if  let  type 
  LSP: Convex: Lookahead: ! ( () - AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position S Width [ [] _ abs abs_float acos asin atan bool_of_string case  ceil cos epsilon_float exp false filter float_of_int float_of_string floor fun  go if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod nan neg_infinity pi sin sqrt string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan test  true type  ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "i"
new_tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | ")" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/"
root ::= completions | new_tokens

Top 20 Logits:
):17.6013
);:16.2183
,:15.4067
),:12.9715
::12.6261
)):12.3966
)(:12.3521
)]:11.989
)`:11.4476
));:11.1866
).:10.7449
)[:10.6179
)::10.5501

:10.5457
,[:10.5237
.:10.3947
)];:10.229
 in:9.96919
 =:9.65726
)}:9.61874
 xs:9.60375

================
# Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)

LSP: Prelude: Recieved string: ### List ###

# Add an element to the front of a list. #
let cons: (Int, [Int]) -> [Int] = fun x, xs -> x::xs in

# Determine the length of a list. #
let length: [Int] -> Int =
  fun xs ->
    case xs
    | [] => 0
    | _::xs => 1 + length(xs) end in

# Extract the first element of a list. #
let hd: [Int] -> Option =
  fun l ->
    case l
    | [] => None
    | x::xs => Some(x) end in

# Extract the rest of the list. #
let tl: [Int] -> [Int] =
  fun l ->
    case l
    | [] => []
    | x::xs => xs end in

# Determine if a list is empty. #
let is_empty: [Int] -> Bool =
  fun xs ->
    case xs
    | [] => true
    | _::_ => false end in

# Return the element at the index. #
let nth: ([Int], Int) -> Option =
  fun xs, n ->
    case xs, n
    | x::_, 0 => Some(x)
    | _::xs, n => nth(xs, n - 1)
    | [], _ => None end in

# Reverse a List. #
let rev: [Int] -> [Int] =
fun l -> 
let go: ([Int], [Int]) -> [Int] =
  fun xs, acc -> 
    case xs 
    | [] => acc 
    | x::xs => go(xs, x::acc) end in
go(l, []) in

# Check if two lists are equal #
let equal: ([Int], [Int]) -> Bool =
    fun p, xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => x == y && equal(xs, ys)
    | _ => false end
in

# Initialize a list with a given length using an initializer function #
let init: (Int, Int -> Int) -> [Int] =
    fun len, f ->
        let go: (Int, [Int]) -> [Int] =
        fun idx, xs ->
            if idx < len 
            then go(idx + 1, xs @ [f(idx)])   
            else xs
        in
        go(0, [])
in

# Reduce a list from the left. #
let fold_left: ((Int, Int) -> Int, Int, [Int]) -> Int =
  fun f, acc, xs ->
    case xs 
    | [] => acc
    | hd::tl => fold_left(f, f(acc, hd), tl) end in

# Reduce a list from the right. #
let fold_right: ((Int, Int) -> Int, [Int], Int) -> Int =
  fun f, xs, acc ->
    case xs
    | [] => acc
    | hd::tl => f(hd, fold_right(f, tl, acc)) end in


666
LSP: Prelude: String parsed successfully
LSP: Prelude: Info map generated successfully
Debug: true, Constrain: Types
LSP: Init: Recieved string: # Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)
LSP: Init: String parsed successfully
  LSP: Syntax: Leftward is Complete Tile: >( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {go: ((?, ?) -> [?]), filter: (((Int -> Bool), [Int]) -> [Int]), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: 
  LSP: Info: ALL errors:Error in term:
  p
Nature of error: Variable p is not bound    
Error in term:
  p
Nature of error: Variable p is not bound    
Error in term:
  p
Nature of error: type ((Int -> Bool), [Int]) is not consistent with arrow type
  LSP: Info: BidiCtx: Cls: Let expression
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent: Root
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: [?]
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: :: @
  LSP: Concave: Backpack: 
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new_tokens ::= whitespace | "," | "::" | "@"
root ::= new_tokens

Top 20 Logits:
 in:14.969

:13.5302
 :11.3311
in:9.94464
 end:9.8475
  :9.36226
 (:8.57532
 and:8.4197
   :8.23762
    :8.23059
 ;:7.75451
 with:7.71975
 #:7.63452
 |:7.49016
 p:7.45647
 ;;:7.40588
 xs:7.30222
 [:7.26781
 on:7.00706
end:6.92044
                :6.89424

================
# Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)


LSP: Prelude: Recieved string: ### List ###

# Add an element to the front of a list. #
let cons: (Int, [Int]) -> [Int] = fun x, xs -> x::xs in

# Determine the length of a list. #
let length: [Int] -> Int =
  fun xs ->
    case xs
    | [] => 0
    | _::xs => 1 + length(xs) end in

# Extract the first element of a list. #
let hd: [Int] -> Option =
  fun l ->
    case l
    | [] => None
    | x::xs => Some(x) end in

# Extract the rest of the list. #
let tl: [Int] -> [Int] =
  fun l ->
    case l
    | [] => []
    | x::xs => xs end in

# Determine if a list is empty. #
let is_empty: [Int] -> Bool =
  fun xs ->
    case xs
    | [] => true
    | _::_ => false end in

# Return the element at the index. #
let nth: ([Int], Int) -> Option =
  fun xs, n ->
    case xs, n
    | x::_, 0 => Some(x)
    | _::xs, n => nth(xs, n - 1)
    | [], _ => None end in

# Reverse a List. #
let rev: [Int] -> [Int] =
fun l -> 
let go: ([Int], [Int]) -> [Int] =
  fun xs, acc -> 
    case xs 
    | [] => acc 
    | x::xs => go(xs, x::acc) end in
go(l, []) in

# Check if two lists are equal #
let equal: ([Int], [Int]) -> Bool =
    fun p, xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => x == y && equal(xs, ys)
    | _ => false end
in

# Initialize a list with a given length using an initializer function #
let init: (Int, Int -> Int) -> [Int] =
    fun len, f ->
        let go: (Int, [Int]) -> [Int] =
        fun idx, xs ->
            if idx < len 
            then go(idx + 1, xs @ [f(idx)])   
            else xs
        in
        go(0, [])
in

# Reduce a list from the left. #
let fold_left: ((Int, Int) -> Int, Int, [Int]) -> Int =
  fun f, acc, xs ->
    case xs 
    | [] => acc
    | hd::tl => fold_left(f, f(acc, hd), tl) end in

# Reduce a list from the right. #
let fold_right: ((Int, Int) -> Int, [Int], Int) -> Int =
  fun f, xs, acc ->
    case xs
    | [] => acc
    | hd::tl => f(hd, fold_right(f, tl, acc)) end in


666
LSP: Prelude: String parsed successfully
LSP: Prelude: Info map generated successfully
Debug: true, Constrain: Types
LSP: Init: Recieved string: # Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)

LSP: Init: String parsed successfully
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: >( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {go: ((?, ?) -> [?]), filter: (((Int -> Bool), [Int]) -> [Int]), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: 
  LSP: Info: ALL errors:Error in term:
  p
Nature of error: type ((Int -> Bool), [Int]) is not consistent with arrow type    
Error in term:
  p
Nature of error: Variable p is not bound    
Error in term:
  p
Nature of error: Variable p is not bound
  LSP: Info: BidiCtx: Cls: Let expression
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent: Root
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: [?]
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: :: @
  LSP: Concave: Backpack: 
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new_tokens ::= whitespace | "," | "::" | "@"
root ::= new_tokens

Top 20 Logits:
in:17.3355

:17.281
#:14.4364
  :14.0316
end:13.9366
    :13.6885
   :13.4325
let:13.2788
```:13.0938
|:13.0616
 :12.5036
;:12.3829
~:11.7239
;;:11.7159
};:11.5964
}:11.5892
      :11.2818
);:10.8975
//:10.8495
(*:10.7826
     :10.7404

================
# Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)



LSP: Prelude: Recieved string: ### List ###

# Add an element to the front of a list. #
let cons: (Int, [Int]) -> [Int] = fun x, xs -> x::xs in

# Determine the length of a list. #
let length: [Int] -> Int =
  fun xs ->
    case xs
    | [] => 0
    | _::xs => 1 + length(xs) end in

# Extract the first element of a list. #
let hd: [Int] -> Option =
  fun l ->
    case l
    | [] => None
    | x::xs => Some(x) end in

# Extract the rest of the list. #
let tl: [Int] -> [Int] =
  fun l ->
    case l
    | [] => []
    | x::xs => xs end in

# Determine if a list is empty. #
let is_empty: [Int] -> Bool =
  fun xs ->
    case xs
    | [] => true
    | _::_ => false end in

# Return the element at the index. #
let nth: ([Int], Int) -> Option =
  fun xs, n ->
    case xs, n
    | x::_, 0 => Some(x)
    | _::xs, n => nth(xs, n - 1)
    | [], _ => None end in

# Reverse a List. #
let rev: [Int] -> [Int] =
fun l -> 
let go: ([Int], [Int]) -> [Int] =
  fun xs, acc -> 
    case xs 
    | [] => acc 
    | x::xs => go(xs, x::acc) end in
go(l, []) in

# Check if two lists are equal #
let equal: ([Int], [Int]) -> Bool =
    fun p, xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => x == y && equal(xs, ys)
    | _ => false end
in

# Initialize a list with a given length using an initializer function #
let init: (Int, Int -> Int) -> [Int] =
    fun len, f ->
        let go: (Int, [Int]) -> [Int] =
        fun idx, xs ->
            if idx < len 
            then go(idx + 1, xs @ [f(idx)])   
            else xs
        in
        go(0, [])
in

# Reduce a list from the left. #
let fold_left: ((Int, Int) -> Int, Int, [Int]) -> Int =
  fun f, acc, xs ->
    case xs 
    | [] => acc
    | hd::tl => fold_left(f, f(acc, hd), tl) end in

# Reduce a list from the right. #
let fold_right: ((Int, Int) -> Int, [Int], Int) -> Int =
  fun f, xs, acc ->
    case xs
    | [] => acc
    | hd::tl => f(hd, fold_right(f, tl, acc)) end in


666
LSP: Prelude: String parsed successfully
LSP: Prelude: Info map generated successfully
Debug: true, Constrain: Types
LSP: Init: Recieved string: # Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)


LSP: Init: String parsed successfully
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: >( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {go: ((?, ?) -> [?]), filter: (((Int -> Bool), [Int]) -> [Int]), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: 
  LSP: Info: ALL errors:Error in term:
  p
Nature of error: Variable p is not bound    
Error in term:
  p
Nature of error: Variable p is not bound    
Error in term:
  p
Nature of error: type ((Int -> Bool), [Int]) is not consistent with arrow type
  LSP: Info: BidiCtx: Cls: Let expression
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent: Root
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: [?]
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: :: @
  LSP: Concave: Backpack: 
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new_tokens ::= whitespace | "," | "::" | "@"
root ::= new_tokens

Top 20 Logits:
#:16.7322
let:13.5988

:13.2147
in:13.1533
##:12.2523
   :10.7376
(*:10.5551
  :10.4121
################:10.4085
~:10.3687
```:10.1324
(:10.0276
[:10.0065
 :9.83445
    :9.78495
{:9.77068
/*:9.76974
 #:9.69899
####:9.67812
|:9.35779
test:9.34247

================
# Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)




LSP: Prelude: Recieved string: ### List ###

# Add an element to the front of a list. #
let cons: (Int, [Int]) -> [Int] = fun x, xs -> x::xs in

# Determine the length of a list. #
let length: [Int] -> Int =
  fun xs ->
    case xs
    | [] => 0
    | _::xs => 1 + length(xs) end in

# Extract the first element of a list. #
let hd: [Int] -> Option =
  fun l ->
    case l
    | [] => None
    | x::xs => Some(x) end in

# Extract the rest of the list. #
let tl: [Int] -> [Int] =
  fun l ->
    case l
    | [] => []
    | x::xs => xs end in

# Determine if a list is empty. #
let is_empty: [Int] -> Bool =
  fun xs ->
    case xs
    | [] => true
    | _::_ => false end in

# Return the element at the index. #
let nth: ([Int], Int) -> Option =
  fun xs, n ->
    case xs, n
    | x::_, 0 => Some(x)
    | _::xs, n => nth(xs, n - 1)
    | [], _ => None end in

# Reverse a List. #
let rev: [Int] -> [Int] =
fun l -> 
let go: ([Int], [Int]) -> [Int] =
  fun xs, acc -> 
    case xs 
    | [] => acc 
    | x::xs => go(xs, x::acc) end in
go(l, []) in

# Check if two lists are equal #
let equal: ([Int], [Int]) -> Bool =
    fun p, xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => x == y && equal(xs, ys)
    | _ => false end
in

# Initialize a list with a given length using an initializer function #
let init: (Int, Int -> Int) -> [Int] =
    fun len, f ->
        let go: (Int, [Int]) -> [Int] =
        fun idx, xs ->
            if idx < len 
            then go(idx + 1, xs @ [f(idx)])   
            else xs
        in
        go(0, [])
in

# Reduce a list from the left. #
let fold_left: ((Int, Int) -> Int, Int, [Int]) -> Int =
  fun f, acc, xs ->
    case xs 
    | [] => acc
    | hd::tl => fold_left(f, f(acc, hd), tl) end in

# Reduce a list from the right. #
let fold_right: ((Int, Int) -> Int, [Int], Int) -> Int =
  fun f, xs, acc ->
    case xs
    | [] => acc
    | hd::tl => f(hd, fold_right(f, tl, acc)) end in


666
LSP: Prelude: String parsed successfully
LSP: Prelude: Info map generated successfully
Debug: true, Constrain: Types
LSP: Init: Recieved string: # Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)



LSP: Init: String parsed successfully
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: >( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {go: ((?, ?) -> [?]), filter: (((Int -> Bool), [Int]) -> [Int]), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: 
  LSP: Info: ALL errors:Error in term:
  p
Nature of error: Variable p is not bound    
Error in term:
  p
Nature of error: type ((Int -> Bool), [Int]) is not consistent with arrow type    
Error in term:
  p
Nature of error: Variable p is not bound
  LSP: Info: BidiCtx: Cls: Let expression
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent: Root
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: [?]
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: :: @
  LSP: Concave: Backpack: 
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new_tokens ::= whitespace | "," | "::" | "@"
root ::= new_tokens

Top 20 Logits:
#:15.9164
let:13.7593
##:13.3151

:13.2893
in:11.7106
################:11.4326
####:10.6523
~:10.4394
  :10.2612
   :10.2108
    :9.96535
########:9.92924
```:9.77859
(*:9.58031
{:9.55758
(:9.54203
[:9.53835
assert:9.43709
/*:9.40132
 :9.32714
test:9.24615

================
# Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)





LSP: Prelude: Recieved string: ### List ###

# Add an element to the front of a list. #
let cons: (Int, [Int]) -> [Int] = fun x, xs -> x::xs in

# Determine the length of a list. #
let length: [Int] -> Int =
  fun xs ->
    case xs
    | [] => 0
    | _::xs => 1 + length(xs) end in

# Extract the first element of a list. #
let hd: [Int] -> Option =
  fun l ->
    case l
    | [] => None
    | x::xs => Some(x) end in

# Extract the rest of the list. #
let tl: [Int] -> [Int] =
  fun l ->
    case l
    | [] => []
    | x::xs => xs end in

# Determine if a list is empty. #
let is_empty: [Int] -> Bool =
  fun xs ->
    case xs
    | [] => true
    | _::_ => false end in

# Return the element at the index. #
let nth: ([Int], Int) -> Option =
  fun xs, n ->
    case xs, n
    | x::_, 0 => Some(x)
    | _::xs, n => nth(xs, n - 1)
    | [], _ => None end in

# Reverse a List. #
let rev: [Int] -> [Int] =
fun l -> 
let go: ([Int], [Int]) -> [Int] =
  fun xs, acc -> 
    case xs 
    | [] => acc 
    | x::xs => go(xs, x::acc) end in
go(l, []) in

# Check if two lists are equal #
let equal: ([Int], [Int]) -> Bool =
    fun p, xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => x == y && equal(xs, ys)
    | _ => false end
in

# Initialize a list with a given length using an initializer function #
let init: (Int, Int -> Int) -> [Int] =
    fun len, f ->
        let go: (Int, [Int]) -> [Int] =
        fun idx, xs ->
            if idx < len 
            then go(idx + 1, xs @ [f(idx)])   
            else xs
        in
        go(0, [])
in

# Reduce a list from the left. #
let fold_left: ((Int, Int) -> Int, Int, [Int]) -> Int =
  fun f, acc, xs ->
    case xs 
    | [] => acc
    | hd::tl => fold_left(f, f(acc, hd), tl) end in

# Reduce a list from the right. #
let fold_right: ((Int, Int) -> Int, [Int], Int) -> Int =
  fun f, xs, acc ->
    case xs
    | [] => acc
    | hd::tl => f(hd, fold_right(f, tl, acc)) end in


666
LSP: Prelude: String parsed successfully
LSP: Prelude: Info map generated successfully
Debug: true, Constrain: Types
LSP: Init: Recieved string: # Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)




LSP: Init: String parsed successfully
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: >( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {go: ((?, ?) -> [?]), filter: (((Int -> Bool), [Int]) -> [Int]), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: 
  LSP: Info: ALL errors:Error in term:
  p
Nature of error: Variable p is not bound    
Error in term:
  p
Nature of error: Variable p is not bound    
Error in term:
  p
Nature of error: type ((Int -> Bool), [Int]) is not consistent with arrow type
  LSP: Info: BidiCtx: Cls: Let expression
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent: Root
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: [?]
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: :: @
  LSP: Concave: Backpack: 
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new_tokens ::= whitespace | "," | "::" | "@"
root ::= new_tokens

Top 20 Logits:
#:15.1746

:13.6452
let:13.4672
##:13.2526
in:11.2453
################:11.2257
  :10.5785
    :10.4268
####:10.3946
   :10.2246
~:10.0449
```:9.94604
########:9.76217
(*:9.66745
[:9.65896
/*:9.65028
{:9.60542
 :9.49337
(:9.48902
assert:9.35025
fold:9.16752

================
# Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)






LSP: Prelude: Recieved string: ### List ###

# Add an element to the front of a list. #
let cons: (Int, [Int]) -> [Int] = fun x, xs -> x::xs in

# Determine the length of a list. #
let length: [Int] -> Int =
  fun xs ->
    case xs
    | [] => 0
    | _::xs => 1 + length(xs) end in

# Extract the first element of a list. #
let hd: [Int] -> Option =
  fun l ->
    case l
    | [] => None
    | x::xs => Some(x) end in

# Extract the rest of the list. #
let tl: [Int] -> [Int] =
  fun l ->
    case l
    | [] => []
    | x::xs => xs end in

# Determine if a list is empty. #
let is_empty: [Int] -> Bool =
  fun xs ->
    case xs
    | [] => true
    | _::_ => false end in

# Return the element at the index. #
let nth: ([Int], Int) -> Option =
  fun xs, n ->
    case xs, n
    | x::_, 0 => Some(x)
    | _::xs, n => nth(xs, n - 1)
    | [], _ => None end in

# Reverse a List. #
let rev: [Int] -> [Int] =
fun l -> 
let go: ([Int], [Int]) -> [Int] =
  fun xs, acc -> 
    case xs 
    | [] => acc 
    | x::xs => go(xs, x::acc) end in
go(l, []) in

# Check if two lists are equal #
let equal: ([Int], [Int]) -> Bool =
    fun p, xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => x == y && equal(xs, ys)
    | _ => false end
in

# Initialize a list with a given length using an initializer function #
let init: (Int, Int -> Int) -> [Int] =
    fun len, f ->
        let go: (Int, [Int]) -> [Int] =
        fun idx, xs ->
            if idx < len 
            then go(idx + 1, xs @ [f(idx)])   
            else xs
        in
        go(0, [])
in

# Reduce a list from the left. #
let fold_left: ((Int, Int) -> Int, Int, [Int]) -> Int =
  fun f, acc, xs ->
    case xs 
    | [] => acc
    | hd::tl => fold_left(f, f(acc, hd), tl) end in

# Reduce a list from the right. #
let fold_right: ((Int, Int) -> Int, [Int], Int) -> Int =
  fun f, xs, acc ->
    case xs
    | [] => acc
    | hd::tl => f(hd, fold_right(f, tl, acc)) end in


666
LSP: Prelude: String parsed successfully
LSP: Prelude: Info map generated successfully
Debug: true, Constrain: Types
LSP: Init: Recieved string: # Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)





LSP: Init: String parsed successfully
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: >( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {go: ((?, ?) -> [?]), filter: (((Int -> Bool), [Int]) -> [Int]), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: 
  LSP: Info: ALL errors:Error in term:
  p
Nature of error: Variable p is not bound    
Error in term:
  p
Nature of error: Variable p is not bound    
Error in term:
  p
Nature of error: type ((Int -> Bool), [Int]) is not consistent with arrow type
  LSP: Info: BidiCtx: Cls: Let expression
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent: Root
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: [?]
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: :: @
  LSP: Concave: Backpack: 
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new_tokens ::= whitespace | "," | "::" | "@"
root ::= new_tokens

Top 20 Logits:
#:14.743

:14.1635
##:13.6114
let:13.2386
################:11.4336
in:11.0051
    :10.859
  :10.7602
####:10.5798
   :10.4449
########:10.1596
```:10.1096
[:9.85913
~:9.77821
{:9.71017
 :9.69971
/*:9.61505
(*:9.5705
(:9.51533
fold:9.38824
//:9.221

================
# Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)







LSP: Prelude: Recieved string: ### List ###

# Add an element to the front of a list. #
let cons: (Int, [Int]) -> [Int] = fun x, xs -> x::xs in

# Determine the length of a list. #
let length: [Int] -> Int =
  fun xs ->
    case xs
    | [] => 0
    | _::xs => 1 + length(xs) end in

# Extract the first element of a list. #
let hd: [Int] -> Option =
  fun l ->
    case l
    | [] => None
    | x::xs => Some(x) end in

# Extract the rest of the list. #
let tl: [Int] -> [Int] =
  fun l ->
    case l
    | [] => []
    | x::xs => xs end in

# Determine if a list is empty. #
let is_empty: [Int] -> Bool =
  fun xs ->
    case xs
    | [] => true
    | _::_ => false end in

# Return the element at the index. #
let nth: ([Int], Int) -> Option =
  fun xs, n ->
    case xs, n
    | x::_, 0 => Some(x)
    | _::xs, n => nth(xs, n - 1)
    | [], _ => None end in

# Reverse a List. #
let rev: [Int] -> [Int] =
fun l -> 
let go: ([Int], [Int]) -> [Int] =
  fun xs, acc -> 
    case xs 
    | [] => acc 
    | x::xs => go(xs, x::acc) end in
go(l, []) in

# Check if two lists are equal #
let equal: ([Int], [Int]) -> Bool =
    fun p, xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => x == y && equal(xs, ys)
    | _ => false end
in

# Initialize a list with a given length using an initializer function #
let init: (Int, Int -> Int) -> [Int] =
    fun len, f ->
        let go: (Int, [Int]) -> [Int] =
        fun idx, xs ->
            if idx < len 
            then go(idx + 1, xs @ [f(idx)])   
            else xs
        in
        go(0, [])
in

# Reduce a list from the left. #
let fold_left: ((Int, Int) -> Int, Int, [Int]) -> Int =
  fun f, acc, xs ->
    case xs 
    | [] => acc
    | hd::tl => fold_left(f, f(acc, hd), tl) end in

# Reduce a list from the right. #
let fold_right: ((Int, Int) -> Int, [Int], Int) -> Int =
  fun f, xs, acc ->
    case xs
    | [] => acc
    | hd::tl => f(hd, fold_right(f, tl, acc)) end in


666
LSP: Prelude: String parsed successfully
LSP: Prelude: Info map generated successfully
Debug: true, Constrain: Types
LSP: Init: Recieved string: # Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)






LSP: Init: String parsed successfully
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: >( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {go: ((?, ?) -> [?]), filter: (((Int -> Bool), [Int]) -> [Int]), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: 
  LSP: Info: ALL errors:Error in term:
  p
Nature of error: type ((Int -> Bool), [Int]) is not consistent with arrow type    
Error in term:
  p
Nature of error: Variable p is not bound    
Error in term:
  p
Nature of error: Variable p is not bound
  LSP: Info: BidiCtx: Cls: Let expression
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent: Root
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: [?]
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: :: @
  LSP: Concave: Backpack: 
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new_tokens ::= whitespace | "," | "::" | "@"
root ::= new_tokens

Top 20 Logits:

:15.0397
#:14.9421
##:14.0574
let:13.466
################:11.8944
    :11.635
  :11.4522
in:11.1455
####:11.1225
   :10.9544
########:10.7622
```:10.5582
[:10.3524
 :10.2629
~:10.1069
{:10.1032
/*:10.067
        :9.86955
(:9.8097
//:9.739
(*:9.73225

================
# Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)








LSP: Prelude: Recieved string: ### List ###

# Add an element to the front of a list. #
let cons: (Int, [Int]) -> [Int] = fun x, xs -> x::xs in

# Determine the length of a list. #
let length: [Int] -> Int =
  fun xs ->
    case xs
    | [] => 0
    | _::xs => 1 + length(xs) end in

# Extract the first element of a list. #
let hd: [Int] -> Option =
  fun l ->
    case l
    | [] => None
    | x::xs => Some(x) end in

# Extract the rest of the list. #
let tl: [Int] -> [Int] =
  fun l ->
    case l
    | [] => []
    | x::xs => xs end in

# Determine if a list is empty. #
let is_empty: [Int] -> Bool =
  fun xs ->
    case xs
    | [] => true
    | _::_ => false end in

# Return the element at the index. #
let nth: ([Int], Int) -> Option =
  fun xs, n ->
    case xs, n
    | x::_, 0 => Some(x)
    | _::xs, n => nth(xs, n - 1)
    | [], _ => None end in

# Reverse a List. #
let rev: [Int] -> [Int] =
fun l -> 
let go: ([Int], [Int]) -> [Int] =
  fun xs, acc -> 
    case xs 
    | [] => acc 
    | x::xs => go(xs, x::acc) end in
go(l, []) in

# Check if two lists are equal #
let equal: ([Int], [Int]) -> Bool =
    fun p, xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => x == y && equal(xs, ys)
    | _ => false end
in

# Initialize a list with a given length using an initializer function #
let init: (Int, Int -> Int) -> [Int] =
    fun len, f ->
        let go: (Int, [Int]) -> [Int] =
        fun idx, xs ->
            if idx < len 
            then go(idx + 1, xs @ [f(idx)])   
            else xs
        in
        go(0, [])
in

# Reduce a list from the left. #
let fold_left: ((Int, Int) -> Int, Int, [Int]) -> Int =
  fun f, acc, xs ->
    case xs 
    | [] => acc
    | hd::tl => fold_left(f, f(acc, hd), tl) end in

# Reduce a list from the right. #
let fold_right: ((Int, Int) -> Int, [Int], Int) -> Int =
  fun f, xs, acc ->
    case xs
    | [] => acc
    | hd::tl => f(hd, fold_right(f, tl, acc)) end in


666
LSP: Prelude: String parsed successfully
LSP: Prelude: Info map generated successfully
Debug: true, Constrain: Types
LSP: Init: Recieved string: # Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)







LSP: Init: String parsed successfully
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: >( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {go: ((?, ?) -> [?]), filter: (((Int -> Bool), [Int]) -> [Int]), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: 
  LSP: Info: ALL errors:Error in term:
  p
Nature of error: Variable p is not bound    
Error in term:
  p
Nature of error: type ((Int -> Bool), [Int]) is not consistent with arrow type    
Error in term:
  p
Nature of error: Variable p is not bound
  LSP: Info: BidiCtx: Cls: Let expression
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent: Root
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: [?]
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: :: @
  LSP: Concave: Backpack: 
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new_tokens ::= whitespace | "," | "::" | "@"
root ::= new_tokens

Top 20 Logits:

:15.7949
#:15.2294
##:14.3992
let:13.7523
    :12.1983
################:12.1547
  :11.9652
in:11.7204
####:11.5253
   :11.4193
########:11.1888
```:11.1129
[:10.794
 :10.7564
{:10.4704
/*:10.439
        :10.4047
~:10.3003
//:10.2225
                :10.1752
(:10.0956

================
# Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)









LSP: Prelude: Recieved string: ### List ###

# Add an element to the front of a list. #
let cons: (Int, [Int]) -> [Int] = fun x, xs -> x::xs in

# Determine the length of a list. #
let length: [Int] -> Int =
  fun xs ->
    case xs
    | [] => 0
    | _::xs => 1 + length(xs) end in

# Extract the first element of a list. #
let hd: [Int] -> Option =
  fun l ->
    case l
    | [] => None
    | x::xs => Some(x) end in

# Extract the rest of the list. #
let tl: [Int] -> [Int] =
  fun l ->
    case l
    | [] => []
    | x::xs => xs end in

# Determine if a list is empty. #
let is_empty: [Int] -> Bool =
  fun xs ->
    case xs
    | [] => true
    | _::_ => false end in

# Return the element at the index. #
let nth: ([Int], Int) -> Option =
  fun xs, n ->
    case xs, n
    | x::_, 0 => Some(x)
    | _::xs, n => nth(xs, n - 1)
    | [], _ => None end in

# Reverse a List. #
let rev: [Int] -> [Int] =
fun l -> 
let go: ([Int], [Int]) -> [Int] =
  fun xs, acc -> 
    case xs 
    | [] => acc 
    | x::xs => go(xs, x::acc) end in
go(l, []) in

# Check if two lists are equal #
let equal: ([Int], [Int]) -> Bool =
    fun p, xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => x == y && equal(xs, ys)
    | _ => false end
in

# Initialize a list with a given length using an initializer function #
let init: (Int, Int -> Int) -> [Int] =
    fun len, f ->
        let go: (Int, [Int]) -> [Int] =
        fun idx, xs ->
            if idx < len 
            then go(idx + 1, xs @ [f(idx)])   
            else xs
        in
        go(0, [])
in

# Reduce a list from the left. #
let fold_left: ((Int, Int) -> Int, Int, [Int]) -> Int =
  fun f, acc, xs ->
    case xs 
    | [] => acc
    | hd::tl => fold_left(f, f(acc, hd), tl) end in

# Reduce a list from the right. #
let fold_right: ((Int, Int) -> Int, [Int], Int) -> Int =
  fun f, xs, acc ->
    case xs
    | [] => acc
    | hd::tl => f(hd, fold_right(f, tl, acc)) end in


666
LSP: Prelude: String parsed successfully
LSP: Prelude: Info map generated successfully
Debug: true, Constrain: Types
LSP: Init: Recieved string: # Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)








LSP: Init: String parsed successfully
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: >( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {go: ((?, ?) -> [?]), filter: (((Int -> Bool), [Int]) -> [Int]), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: 
  LSP: Info: ALL errors:Error in term:
  p
Nature of error: Variable p is not bound    
Error in term:
  p
Nature of error: type ((Int -> Bool), [Int]) is not consistent with arrow type    
Error in term:
  p
Nature of error: Variable p is not bound
  LSP: Info: BidiCtx: Cls: Let expression
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent: Root
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: [?]
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: :: @
  LSP: Concave: Backpack: 
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new_tokens ::= whitespace | "," | "::" | "@"
root ::= new_tokens

Top 20 Logits:

:16.2976
#:15.3639
##:14.5574
let:13.9818
    :12.6381
  :12.311
################:12.306
in:12.0888
   :11.7856
####:11.7559
########:11.3955
```:11.3052
 :11.1209
[:11.0677
        :10.8662
/*:10.7276
{:10.7075
                :10.6233
//:10.569
cons:10.5084
            :10.3065

================
# Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)










LSP: Prelude: Recieved string: ### List ###

# Add an element to the front of a list. #
let cons: (Int, [Int]) -> [Int] = fun x, xs -> x::xs in

# Determine the length of a list. #
let length: [Int] -> Int =
  fun xs ->
    case xs
    | [] => 0
    | _::xs => 1 + length(xs) end in

# Extract the first element of a list. #
let hd: [Int] -> Option =
  fun l ->
    case l
    | [] => None
    | x::xs => Some(x) end in

# Extract the rest of the list. #
let tl: [Int] -> [Int] =
  fun l ->
    case l
    | [] => []
    | x::xs => xs end in

# Determine if a list is empty. #
let is_empty: [Int] -> Bool =
  fun xs ->
    case xs
    | [] => true
    | _::_ => false end in

# Return the element at the index. #
let nth: ([Int], Int) -> Option =
  fun xs, n ->
    case xs, n
    | x::_, 0 => Some(x)
    | _::xs, n => nth(xs, n - 1)
    | [], _ => None end in

# Reverse a List. #
let rev: [Int] -> [Int] =
fun l -> 
let go: ([Int], [Int]) -> [Int] =
  fun xs, acc -> 
    case xs 
    | [] => acc 
    | x::xs => go(xs, x::acc) end in
go(l, []) in

# Check if two lists are equal #
let equal: ([Int], [Int]) -> Bool =
    fun p, xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => x == y && equal(xs, ys)
    | _ => false end
in

# Initialize a list with a given length using an initializer function #
let init: (Int, Int -> Int) -> [Int] =
    fun len, f ->
        let go: (Int, [Int]) -> [Int] =
        fun idx, xs ->
            if idx < len 
            then go(idx + 1, xs @ [f(idx)])   
            else xs
        in
        go(0, [])
in

# Reduce a list from the left. #
let fold_left: ((Int, Int) -> Int, Int, [Int]) -> Int =
  fun f, acc, xs ->
    case xs 
    | [] => acc
    | hd::tl => fold_left(f, f(acc, hd), tl) end in

# Reduce a list from the right. #
let fold_right: ((Int, Int) -> Int, [Int], Int) -> Int =
  fun f, xs, acc ->
    case xs
    | [] => acc
    | hd::tl => f(hd, fold_right(f, tl, acc)) end in


666
LSP: Prelude: String parsed successfully
LSP: Prelude: Info map generated successfully
Debug: true, Constrain: Types
LSP: Init: Recieved string: # Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)









LSP: Init: String parsed successfully
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: >( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {go: ((?, ?) -> [?]), filter: (((Int -> Bool), [Int]) -> [Int]), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: 
  LSP: Info: ALL errors:Error in term:
  p
Nature of error: type ((Int -> Bool), [Int]) is not consistent with arrow type    
Error in term:
  p
Nature of error: Variable p is not bound    
Error in term:
  p
Nature of error: Variable p is not bound
  LSP: Info: BidiCtx: Cls: Let expression
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent: Root
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: [?]
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: :: @
  LSP: Concave: Backpack: 
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new_tokens ::= whitespace | "," | "::" | "@"
root ::= new_tokens

Top 20 Logits:

:16.5854
#:15.4122
##:14.6237
let:14.0784
    :12.8116
  :12.4574
################:12.3488
in:12.2129
   :11.9577
####:11.8322
########:11.4569
```:11.431
 :11.2977
[:11.1526
        :11.0477
/*:10.8778
                :10.83
//:10.794
cons:10.7475
{:10.7251
            :10.4678

================
# Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)











LSP: Prelude: Recieved string: ### List ###

# Add an element to the front of a list. #
let cons: (Int, [Int]) -> [Int] = fun x, xs -> x::xs in

# Determine the length of a list. #
let length: [Int] -> Int =
  fun xs ->
    case xs
    | [] => 0
    | _::xs => 1 + length(xs) end in

# Extract the first element of a list. #
let hd: [Int] -> Option =
  fun l ->
    case l
    | [] => None
    | x::xs => Some(x) end in

# Extract the rest of the list. #
let tl: [Int] -> [Int] =
  fun l ->
    case l
    | [] => []
    | x::xs => xs end in

# Determine if a list is empty. #
let is_empty: [Int] -> Bool =
  fun xs ->
    case xs
    | [] => true
    | _::_ => false end in

# Return the element at the index. #
let nth: ([Int], Int) -> Option =
  fun xs, n ->
    case xs, n
    | x::_, 0 => Some(x)
    | _::xs, n => nth(xs, n - 1)
    | [], _ => None end in

# Reverse a List. #
let rev: [Int] -> [Int] =
fun l -> 
let go: ([Int], [Int]) -> [Int] =
  fun xs, acc -> 
    case xs 
    | [] => acc 
    | x::xs => go(xs, x::acc) end in
go(l, []) in

# Check if two lists are equal #
let equal: ([Int], [Int]) -> Bool =
    fun p, xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => x == y && equal(xs, ys)
    | _ => false end
in

# Initialize a list with a given length using an initializer function #
let init: (Int, Int -> Int) -> [Int] =
    fun len, f ->
        let go: (Int, [Int]) -> [Int] =
        fun idx, xs ->
            if idx < len 
            then go(idx + 1, xs @ [f(idx)])   
            else xs
        in
        go(0, [])
in

# Reduce a list from the left. #
let fold_left: ((Int, Int) -> Int, Int, [Int]) -> Int =
  fun f, acc, xs ->
    case xs 
    | [] => acc
    | hd::tl => fold_left(f, f(acc, hd), tl) end in

# Reduce a list from the right. #
let fold_right: ((Int, Int) -> Int, [Int], Int) -> Int =
  fun f, xs, acc ->
    case xs
    | [] => acc
    | hd::tl => f(hd, fold_right(f, tl, acc)) end in


666
LSP: Prelude: String parsed successfully
LSP: Prelude: Info map generated successfully
Debug: true, Constrain: Types
LSP: Init: Recieved string: # Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)










LSP: Init: String parsed successfully
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: >( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {go: ((?, ?) -> [?]), filter: (((Int -> Bool), [Int]) -> [Int]), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: 
  LSP: Info: ALL errors:Error in term:
  p
Nature of error: type ((Int -> Bool), [Int]) is not consistent with arrow type    
Error in term:
  p
Nature of error: Variable p is not bound    
Error in term:
  p
Nature of error: Variable p is not bound
  LSP: Info: BidiCtx: Cls: Let expression
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent: Root
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: [?]
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: :: @
  LSP: Concave: Backpack: 
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new_tokens ::= whitespace | "," | "::" | "@"
root ::= new_tokens

Top 20 Logits:

:16.8178
#:15.4264
##:14.704
let:14.0787
    :12.9476
  :12.5967
################:12.3851
in:12.3431
   :12.0884
####:11.9611
```:11.5917
########:11.5195
 :11.4347
        :11.2453
[:11.2013
/*:11.1055
//:11.0568
                :11.0035
cons:10.7216
{:10.7146
       :10.6283

================
# Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)












LSP: Prelude: Recieved string: ### List ###

# Add an element to the front of a list. #
let cons: (Int, [Int]) -> [Int] = fun x, xs -> x::xs in

# Determine the length of a list. #
let length: [Int] -> Int =
  fun xs ->
    case xs
    | [] => 0
    | _::xs => 1 + length(xs) end in

# Extract the first element of a list. #
let hd: [Int] -> Option =
  fun l ->
    case l
    | [] => None
    | x::xs => Some(x) end in

# Extract the rest of the list. #
let tl: [Int] -> [Int] =
  fun l ->
    case l
    | [] => []
    | x::xs => xs end in

# Determine if a list is empty. #
let is_empty: [Int] -> Bool =
  fun xs ->
    case xs
    | [] => true
    | _::_ => false end in

# Return the element at the index. #
let nth: ([Int], Int) -> Option =
  fun xs, n ->
    case xs, n
    | x::_, 0 => Some(x)
    | _::xs, n => nth(xs, n - 1)
    | [], _ => None end in

# Reverse a List. #
let rev: [Int] -> [Int] =
fun l -> 
let go: ([Int], [Int]) -> [Int] =
  fun xs, acc -> 
    case xs 
    | [] => acc 
    | x::xs => go(xs, x::acc) end in
go(l, []) in

# Check if two lists are equal #
let equal: ([Int], [Int]) -> Bool =
    fun p, xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => x == y && equal(xs, ys)
    | _ => false end
in

# Initialize a list with a given length using an initializer function #
let init: (Int, Int -> Int) -> [Int] =
    fun len, f ->
        let go: (Int, [Int]) -> [Int] =
        fun idx, xs ->
            if idx < len 
            then go(idx + 1, xs @ [f(idx)])   
            else xs
        in
        go(0, [])
in

# Reduce a list from the left. #
let fold_left: ((Int, Int) -> Int, Int, [Int]) -> Int =
  fun f, acc, xs ->
    case xs 
    | [] => acc
    | hd::tl => fold_left(f, f(acc, hd), tl) end in

# Reduce a list from the right. #
let fold_right: ((Int, Int) -> Int, [Int], Int) -> Int =
  fun f, xs, acc ->
    case xs
    | [] => acc
    | hd::tl => f(hd, fold_right(f, tl, acc)) end in


666
LSP: Prelude: String parsed successfully
LSP: Prelude: Info map generated successfully
Debug: true, Constrain: Types
LSP: Init: Recieved string: # Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)











LSP: Init: String parsed successfully
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: >( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {go: ((?, ?) -> [?]), filter: (((Int -> Bool), [Int]) -> [Int]), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: 
  LSP: Info: ALL errors:Error in term:
  p
Nature of error: Variable p is not bound    
Error in term:
  p
Nature of error: type ((Int -> Bool), [Int]) is not consistent with arrow type    
Error in term:
  p
Nature of error: Variable p is not bound
  LSP: Info: BidiCtx: Cls: Let expression
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent: Root
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: [?]
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: :: @
  LSP: Concave: Backpack: 
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new_tokens ::= whitespace | "," | "::" | "@"
root ::= new_tokens

Top 20 Logits:

:16.994
#:15.4361
##:14.6969
let:14.0809
    :13.0424
  :12.721
in:12.5383
################:12.4604
   :12.1861
####:12.0554
```:11.6926
 :11.547
########:11.5462
        :11.3714
/*:11.2656
[:11.2273
//:11.1837
                :11.1557
       :10.7654
{:10.718
            :10.6976

================
# Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)













LSP: Prelude: Recieved string: ### List ###

# Add an element to the front of a list. #
let cons: (Int, [Int]) -> [Int] = fun x, xs -> x::xs in

# Determine the length of a list. #
let length: [Int] -> Int =
  fun xs ->
    case xs
    | [] => 0
    | _::xs => 1 + length(xs) end in

# Extract the first element of a list. #
let hd: [Int] -> Option =
  fun l ->
    case l
    | [] => None
    | x::xs => Some(x) end in

# Extract the rest of the list. #
let tl: [Int] -> [Int] =
  fun l ->
    case l
    | [] => []
    | x::xs => xs end in

# Determine if a list is empty. #
let is_empty: [Int] -> Bool =
  fun xs ->
    case xs
    | [] => true
    | _::_ => false end in

# Return the element at the index. #
let nth: ([Int], Int) -> Option =
  fun xs, n ->
    case xs, n
    | x::_, 0 => Some(x)
    | _::xs, n => nth(xs, n - 1)
    | [], _ => None end in

# Reverse a List. #
let rev: [Int] -> [Int] =
fun l -> 
let go: ([Int], [Int]) -> [Int] =
  fun xs, acc -> 
    case xs 
    | [] => acc 
    | x::xs => go(xs, x::acc) end in
go(l, []) in

# Check if two lists are equal #
let equal: ([Int], [Int]) -> Bool =
    fun p, xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => x == y && equal(xs, ys)
    | _ => false end
in

# Initialize a list with a given length using an initializer function #
let init: (Int, Int -> Int) -> [Int] =
    fun len, f ->
        let go: (Int, [Int]) -> [Int] =
        fun idx, xs ->
            if idx < len 
            then go(idx + 1, xs @ [f(idx)])   
            else xs
        in
        go(0, [])
in

# Reduce a list from the left. #
let fold_left: ((Int, Int) -> Int, Int, [Int]) -> Int =
  fun f, acc, xs ->
    case xs 
    | [] => acc
    | hd::tl => fold_left(f, f(acc, hd), tl) end in

# Reduce a list from the right. #
let fold_right: ((Int, Int) -> Int, [Int], Int) -> Int =
  fun f, xs, acc ->
    case xs
    | [] => acc
    | hd::tl => f(hd, fold_right(f, tl, acc)) end in


666
LSP: Prelude: String parsed successfully
LSP: Prelude: Info map generated successfully
Debug: true, Constrain: Types
LSP: Init: Recieved string: # Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)












LSP: Init: String parsed successfully
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: >( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {go: ((?, ?) -> [?]), filter: (((Int -> Bool), [Int]) -> [Int]), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: 
  LSP: Info: ALL errors:Error in term:
  p
Nature of error: Variable p is not bound    
Error in term:
  p
Nature of error: Variable p is not bound    
Error in term:
  p
Nature of error: type ((Int -> Bool), [Int]) is not consistent with arrow type
  LSP: Info: BidiCtx: Cls: Let expression
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent: Root
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: [?]
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: :: @
  LSP: Concave: Backpack: 
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new_tokens ::= whitespace | "," | "::" | "@"
root ::= new_tokens

Top 20 Logits:

:17.1601
#:15.4879
##:14.7448
let:14.1445
    :13.1282
  :12.8255
in:12.6726
################:12.5807
   :12.2996
####:12.1566
```:11.7945
 :11.6536
########:11.6001
        :11.4548
/*:11.4103
//:11.307
                :11.295
[:11.2477
       :10.8765
{:10.7899
            :10.7839

================
# Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)














LSP: Prelude: Recieved string: ### List ###

# Add an element to the front of a list. #
let cons: (Int, [Int]) -> [Int] = fun x, xs -> x::xs in

# Determine the length of a list. #
let length: [Int] -> Int =
  fun xs ->
    case xs
    | [] => 0
    | _::xs => 1 + length(xs) end in

# Extract the first element of a list. #
let hd: [Int] -> Option =
  fun l ->
    case l
    | [] => None
    | x::xs => Some(x) end in

# Extract the rest of the list. #
let tl: [Int] -> [Int] =
  fun l ->
    case l
    | [] => []
    | x::xs => xs end in

# Determine if a list is empty. #
let is_empty: [Int] -> Bool =
  fun xs ->
    case xs
    | [] => true
    | _::_ => false end in

# Return the element at the index. #
let nth: ([Int], Int) -> Option =
  fun xs, n ->
    case xs, n
    | x::_, 0 => Some(x)
    | _::xs, n => nth(xs, n - 1)
    | [], _ => None end in

# Reverse a List. #
let rev: [Int] -> [Int] =
fun l -> 
let go: ([Int], [Int]) -> [Int] =
  fun xs, acc -> 
    case xs 
    | [] => acc 
    | x::xs => go(xs, x::acc) end in
go(l, []) in

# Check if two lists are equal #
let equal: ([Int], [Int]) -> Bool =
    fun p, xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => x == y && equal(xs, ys)
    | _ => false end
in

# Initialize a list with a given length using an initializer function #
let init: (Int, Int -> Int) -> [Int] =
    fun len, f ->
        let go: (Int, [Int]) -> [Int] =
        fun idx, xs ->
            if idx < len 
            then go(idx + 1, xs @ [f(idx)])   
            else xs
        in
        go(0, [])
in

# Reduce a list from the left. #
let fold_left: ((Int, Int) -> Int, Int, [Int]) -> Int =
  fun f, acc, xs ->
    case xs 
    | [] => acc
    | hd::tl => fold_left(f, f(acc, hd), tl) end in

# Reduce a list from the right. #
let fold_right: ((Int, Int) -> Int, [Int], Int) -> Int =
  fun f, xs, acc ->
    case xs
    | [] => acc
    | hd::tl => f(hd, fold_right(f, tl, acc)) end in


666
LSP: Prelude: String parsed successfully
LSP: Prelude: Info map generated successfully
Debug: true, Constrain: Types
LSP: Init: Recieved string: # Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)













LSP: Init: String parsed successfully
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: >( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {go: ((?, ?) -> [?]), filter: (((Int -> Bool), [Int]) -> [Int]), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: 
  LSP: Info: ALL errors:Error in term:
  p
Nature of error: Variable p is not bound    
Error in term:
  p
Nature of error: Variable p is not bound    
Error in term:
  p
Nature of error: type ((Int -> Bool), [Int]) is not consistent with arrow type
  LSP: Info: BidiCtx: Cls: Let expression
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent: Root
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: [?]
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: :: @
  LSP: Concave: Backpack: 
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new_tokens ::= whitespace | "," | "::" | "@"
root ::= new_tokens

Top 20 Logits:

:17.3039
#:15.5547
##:14.8056
let:14.2224
    :13.2097
  :12.9039
in:12.7766
################:12.7087
   :12.4085
####:12.26
```:11.869
 :11.7424
########:11.6955
/*:11.5444
        :11.5272
//:11.4338
                :11.409
[:11.2708
       :10.9681
            :10.8666
{:10.8648

================
# Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)















LSP: Prelude: Recieved string: ### List ###

# Add an element to the front of a list. #
let cons: (Int, [Int]) -> [Int] = fun x, xs -> x::xs in

# Determine the length of a list. #
let length: [Int] -> Int =
  fun xs ->
    case xs
    | [] => 0
    | _::xs => 1 + length(xs) end in

# Extract the first element of a list. #
let hd: [Int] -> Option =
  fun l ->
    case l
    | [] => None
    | x::xs => Some(x) end in

# Extract the rest of the list. #
let tl: [Int] -> [Int] =
  fun l ->
    case l
    | [] => []
    | x::xs => xs end in

# Determine if a list is empty. #
let is_empty: [Int] -> Bool =
  fun xs ->
    case xs
    | [] => true
    | _::_ => false end in

# Return the element at the index. #
let nth: ([Int], Int) -> Option =
  fun xs, n ->
    case xs, n
    | x::_, 0 => Some(x)
    | _::xs, n => nth(xs, n - 1)
    | [], _ => None end in

# Reverse a List. #
let rev: [Int] -> [Int] =
fun l -> 
let go: ([Int], [Int]) -> [Int] =
  fun xs, acc -> 
    case xs 
    | [] => acc 
    | x::xs => go(xs, x::acc) end in
go(l, []) in

# Check if two lists are equal #
let equal: ([Int], [Int]) -> Bool =
    fun p, xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => x == y && equal(xs, ys)
    | _ => false end
in

# Initialize a list with a given length using an initializer function #
let init: (Int, Int -> Int) -> [Int] =
    fun len, f ->
        let go: (Int, [Int]) -> [Int] =
        fun idx, xs ->
            if idx < len 
            then go(idx + 1, xs @ [f(idx)])   
            else xs
        in
        go(0, [])
in

# Reduce a list from the left. #
let fold_left: ((Int, Int) -> Int, Int, [Int]) -> Int =
  fun f, acc, xs ->
    case xs 
    | [] => acc
    | hd::tl => fold_left(f, f(acc, hd), tl) end in

# Reduce a list from the right. #
let fold_right: ((Int, Int) -> Int, [Int], Int) -> Int =
  fun f, xs, acc ->
    case xs
    | [] => acc
    | hd::tl => f(hd, fold_right(f, tl, acc)) end in


666
LSP: Prelude: String parsed successfully
LSP: Prelude: Info map generated successfully
Debug: true, Constrain: Types
LSP: Init: Recieved string: # Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)














LSP: Init: String parsed successfully
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: >( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {go: ((?, ?) -> [?]), filter: (((Int -> Bool), [Int]) -> [Int]), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: 
  LSP: Info: ALL errors:Error in term:
  p
Nature of error: Variable p is not bound    
Error in term:
  p
Nature of error: Variable p is not bound    
Error in term:
  p
Nature of error: type ((Int -> Bool), [Int]) is not consistent with arrow type
  LSP: Info: BidiCtx: Cls: Let expression
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent: Root
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: [?]
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: :: @
  LSP: Concave: Backpack: 
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new_tokens ::= whitespace | "," | "::" | "@"
root ::= new_tokens

Top 20 Logits:

:17.4179
#:15.6112
##:14.8602
let:14.2914
    :13.267
  :12.9433
in:12.8301
################:12.7938
   :12.4907
####:12.3426
```:11.9031
 :11.8059
########:11.7985
/*:11.6466
        :11.5809
//:11.5112
                :11.4785
[:11.2904
       :11.0326
            :10.9303
{:10.9134

================
# Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)
















LSP: Prelude: Recieved string: ### List ###

# Add an element to the front of a list. #
let cons: (Int, [Int]) -> [Int] = fun x, xs -> x::xs in

# Determine the length of a list. #
let length: [Int] -> Int =
  fun xs ->
    case xs
    | [] => 0
    | _::xs => 1 + length(xs) end in

# Extract the first element of a list. #
let hd: [Int] -> Option =
  fun l ->
    case l
    | [] => None
    | x::xs => Some(x) end in

# Extract the rest of the list. #
let tl: [Int] -> [Int] =
  fun l ->
    case l
    | [] => []
    | x::xs => xs end in

# Determine if a list is empty. #
let is_empty: [Int] -> Bool =
  fun xs ->
    case xs
    | [] => true
    | _::_ => false end in

# Return the element at the index. #
let nth: ([Int], Int) -> Option =
  fun xs, n ->
    case xs, n
    | x::_, 0 => Some(x)
    | _::xs, n => nth(xs, n - 1)
    | [], _ => None end in

# Reverse a List. #
let rev: [Int] -> [Int] =
fun l -> 
let go: ([Int], [Int]) -> [Int] =
  fun xs, acc -> 
    case xs 
    | [] => acc 
    | x::xs => go(xs, x::acc) end in
go(l, []) in

# Check if two lists are equal #
let equal: ([Int], [Int]) -> Bool =
    fun p, xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => x == y && equal(xs, ys)
    | _ => false end
in

# Initialize a list with a given length using an initializer function #
let init: (Int, Int -> Int) -> [Int] =
    fun len, f ->
        let go: (Int, [Int]) -> [Int] =
        fun idx, xs ->
            if idx < len 
            then go(idx + 1, xs @ [f(idx)])   
            else xs
        in
        go(0, [])
in

# Reduce a list from the left. #
let fold_left: ((Int, Int) -> Int, Int, [Int]) -> Int =
  fun f, acc, xs ->
    case xs 
    | [] => acc
    | hd::tl => fold_left(f, f(acc, hd), tl) end in

# Reduce a list from the right. #
let fold_right: ((Int, Int) -> Int, [Int], Int) -> Int =
  fun f, xs, acc ->
    case xs
    | [] => acc
    | hd::tl => f(hd, fold_right(f, tl, acc)) end in


666
LSP: Prelude: String parsed successfully
LSP: Prelude: Info map generated successfully
Debug: true, Constrain: Types
LSP: Init: Recieved string: # Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)















LSP: Init: String parsed successfully
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: >( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {go: ((?, ?) -> [?]), filter: (((Int -> Bool), [Int]) -> [Int]), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: 
  LSP: Info: ALL errors:Error in term:
  p
Nature of error: type ((Int -> Bool), [Int]) is not consistent with arrow type    
Error in term:
  p
Nature of error: Variable p is not bound    
Error in term:
  p
Nature of error: Variable p is not bound
  LSP: Info: BidiCtx: Cls: Let expression
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent: Root
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: [?]
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: :: @
  LSP: Concave: Backpack: 
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new_tokens ::= whitespace | "," | "::" | "@"
root ::= new_tokens

Top 20 Logits:

:17.5024
#:15.6435
##:14.907
let:14.3408
    :13.293
  :12.9445
################:12.8358
in:12.8225
   :12.5438
####:12.39
```:11.9199
########:11.8829
 :11.8432
/*:11.7184
        :11.6081
//:11.547
                :11.5066
[:11.3059
       :11.0729
            :10.9591
{:10.9366

================
# Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)

















LSP: Prelude: Recieved string: ### List ###

# Add an element to the front of a list. #
let cons: (Int, [Int]) -> [Int] = fun x, xs -> x::xs in

# Determine the length of a list. #
let length: [Int] -> Int =
  fun xs ->
    case xs
    | [] => 0
    | _::xs => 1 + length(xs) end in

# Extract the first element of a list. #
let hd: [Int] -> Option =
  fun l ->
    case l
    | [] => None
    | x::xs => Some(x) end in

# Extract the rest of the list. #
let tl: [Int] -> [Int] =
  fun l ->
    case l
    | [] => []
    | x::xs => xs end in

# Determine if a list is empty. #
let is_empty: [Int] -> Bool =
  fun xs ->
    case xs
    | [] => true
    | _::_ => false end in

# Return the element at the index. #
let nth: ([Int], Int) -> Option =
  fun xs, n ->
    case xs, n
    | x::_, 0 => Some(x)
    | _::xs, n => nth(xs, n - 1)
    | [], _ => None end in

# Reverse a List. #
let rev: [Int] -> [Int] =
fun l -> 
let go: ([Int], [Int]) -> [Int] =
  fun xs, acc -> 
    case xs 
    | [] => acc 
    | x::xs => go(xs, x::acc) end in
go(l, []) in

# Check if two lists are equal #
let equal: ([Int], [Int]) -> Bool =
    fun p, xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => x == y && equal(xs, ys)
    | _ => false end
in

# Initialize a list with a given length using an initializer function #
let init: (Int, Int -> Int) -> [Int] =
    fun len, f ->
        let go: (Int, [Int]) -> [Int] =
        fun idx, xs ->
            if idx < len 
            then go(idx + 1, xs @ [f(idx)])   
            else xs
        in
        go(0, [])
in

# Reduce a list from the left. #
let fold_left: ((Int, Int) -> Int, Int, [Int]) -> Int =
  fun f, acc, xs ->
    case xs 
    | [] => acc
    | hd::tl => fold_left(f, f(acc, hd), tl) end in

# Reduce a list from the right. #
let fold_right: ((Int, Int) -> Int, [Int], Int) -> Int =
  fun f, xs, acc ->
    case xs
    | [] => acc
    | hd::tl => f(hd, fold_right(f, tl, acc)) end in


666
LSP: Prelude: String parsed successfully
LSP: Prelude: Info map generated successfully
Debug: true, Constrain: Types
LSP: Init: Recieved string: # Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)
















LSP: Init: String parsed successfully
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: >( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {go: ((?, ?) -> [?]), filter: (((Int -> Bool), [Int]) -> [Int]), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: 
  LSP: Info: ALL errors:Error in term:
  p
Nature of error: Variable p is not bound    
Error in term:
  p
Nature of error: Variable p is not bound    
Error in term:
  p
Nature of error: type ((Int -> Bool), [Int]) is not consistent with arrow type
  LSP: Info: BidiCtx: Cls: Let expression
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent: Root
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: [?]
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: :: @
  LSP: Concave: Backpack: 
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new_tokens ::= whitespace | "," | "::" | "@"
root ::= new_tokens

Top 20 Logits:

:17.5613
#:15.6515
##:14.9349
let:14.3605
    :13.2847
  :12.9161
################:12.8458
in:12.7948
   :12.5697
####:12.404
```:11.9391
########:11.9307
 :11.8563
/*:11.763
        :11.602
//:11.5617
                :11.5019
[:11.3114
       :11.0907
            :10.9446
{:10.94

================
# Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)


















LSP: Prelude: Recieved string: ### List ###

# Add an element to the front of a list. #
let cons: (Int, [Int]) -> [Int] = fun x, xs -> x::xs in

# Determine the length of a list. #
let length: [Int] -> Int =
  fun xs ->
    case xs
    | [] => 0
    | _::xs => 1 + length(xs) end in

# Extract the first element of a list. #
let hd: [Int] -> Option =
  fun l ->
    case l
    | [] => None
    | x::xs => Some(x) end in

# Extract the rest of the list. #
let tl: [Int] -> [Int] =
  fun l ->
    case l
    | [] => []
    | x::xs => xs end in

# Determine if a list is empty. #
let is_empty: [Int] -> Bool =
  fun xs ->
    case xs
    | [] => true
    | _::_ => false end in

# Return the element at the index. #
let nth: ([Int], Int) -> Option =
  fun xs, n ->
    case xs, n
    | x::_, 0 => Some(x)
    | _::xs, n => nth(xs, n - 1)
    | [], _ => None end in

# Reverse a List. #
let rev: [Int] -> [Int] =
fun l -> 
let go: ([Int], [Int]) -> [Int] =
  fun xs, acc -> 
    case xs 
    | [] => acc 
    | x::xs => go(xs, x::acc) end in
go(l, []) in

# Check if two lists are equal #
let equal: ([Int], [Int]) -> Bool =
    fun p, xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => x == y && equal(xs, ys)
    | _ => false end
in

# Initialize a list with a given length using an initializer function #
let init: (Int, Int -> Int) -> [Int] =
    fun len, f ->
        let go: (Int, [Int]) -> [Int] =
        fun idx, xs ->
            if idx < len 
            then go(idx + 1, xs @ [f(idx)])   
            else xs
        in
        go(0, [])
in

# Reduce a list from the left. #
let fold_left: ((Int, Int) -> Int, Int, [Int]) -> Int =
  fun f, acc, xs ->
    case xs 
    | [] => acc
    | hd::tl => fold_left(f, f(acc, hd), tl) end in

# Reduce a list from the right. #
let fold_right: ((Int, Int) -> Int, [Int], Int) -> Int =
  fun f, xs, acc ->
    case xs
    | [] => acc
    | hd::tl => f(hd, fold_right(f, tl, acc)) end in


666
LSP: Prelude: String parsed successfully
LSP: Prelude: Info map generated successfully
Debug: true, Constrain: Types
LSP: Init: Recieved string: # Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)

















LSP: Init: String parsed successfully
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: >( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {go: ((?, ?) -> [?]), filter: (((Int -> Bool), [Int]) -> [Int]), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: 
  LSP: Info: ALL errors:Error in term:
  p
Nature of error: Variable p is not bound    
Error in term:
  p
Nature of error: Variable p is not bound    
Error in term:
  p
Nature of error: type ((Int -> Bool), [Int]) is not consistent with arrow type
  LSP: Info: BidiCtx: Cls: Let expression
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent: Root
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: [?]
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: :: @
  LSP: Concave: Backpack: 
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new_tokens ::= whitespace | "," | "::" | "@"
root ::= new_tokens

Top 20 Logits:

:17.5931
#:15.6386
##:14.927
let:14.3453
    :13.2432
  :12.8652
################:12.8248
in:12.7972
   :12.5675
####:12.3884
```:11.9558
########:11.9247
 :11.8454
/*:11.7842
//:11.567
        :11.5638
                :11.4726
[:11.2999
       :11.0845
{:10.9189
fun:10.8967

================
# Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)



















LSP: Prelude: Recieved string: ### List ###

# Add an element to the front of a list. #
let cons: (Int, [Int]) -> [Int] = fun x, xs -> x::xs in

# Determine the length of a list. #
let length: [Int] -> Int =
  fun xs ->
    case xs
    | [] => 0
    | _::xs => 1 + length(xs) end in

# Extract the first element of a list. #
let hd: [Int] -> Option =
  fun l ->
    case l
    | [] => None
    | x::xs => Some(x) end in

# Extract the rest of the list. #
let tl: [Int] -> [Int] =
  fun l ->
    case l
    | [] => []
    | x::xs => xs end in

# Determine if a list is empty. #
let is_empty: [Int] -> Bool =
  fun xs ->
    case xs
    | [] => true
    | _::_ => false end in

# Return the element at the index. #
let nth: ([Int], Int) -> Option =
  fun xs, n ->
    case xs, n
    | x::_, 0 => Some(x)
    | _::xs, n => nth(xs, n - 1)
    | [], _ => None end in

# Reverse a List. #
let rev: [Int] -> [Int] =
fun l -> 
let go: ([Int], [Int]) -> [Int] =
  fun xs, acc -> 
    case xs 
    | [] => acc 
    | x::xs => go(xs, x::acc) end in
go(l, []) in

# Check if two lists are equal #
let equal: ([Int], [Int]) -> Bool =
    fun p, xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => x == y && equal(xs, ys)
    | _ => false end
in

# Initialize a list with a given length using an initializer function #
let init: (Int, Int -> Int) -> [Int] =
    fun len, f ->
        let go: (Int, [Int]) -> [Int] =
        fun idx, xs ->
            if idx < len 
            then go(idx + 1, xs @ [f(idx)])   
            else xs
        in
        go(0, [])
in

# Reduce a list from the left. #
let fold_left: ((Int, Int) -> Int, Int, [Int]) -> Int =
  fun f, acc, xs ->
    case xs 
    | [] => acc
    | hd::tl => fold_left(f, f(acc, hd), tl) end in

# Reduce a list from the right. #
let fold_right: ((Int, Int) -> Int, [Int], Int) -> Int =
  fun f, xs, acc ->
    case xs
    | [] => acc
    | hd::tl => f(hd, fold_right(f, tl, acc)) end in


666
LSP: Prelude: String parsed successfully
LSP: Prelude: Info map generated successfully
Debug: true, Constrain: Types
LSP: Init: Recieved string: # Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)


















LSP: Init: String parsed successfully
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: >( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {go: ((?, ?) -> [?]), filter: (((Int -> Bool), [Int]) -> [Int]), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: 
  LSP: Info: ALL errors:Error in term:
  p
Nature of error: type ((Int -> Bool), [Int]) is not consistent with arrow type    
Error in term:
  p
Nature of error: Variable p is not bound    
Error in term:
  p
Nature of error: Variable p is not bound
  LSP: Info: BidiCtx: Cls: Let expression
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent: Root
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: [?]
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: :: @
  LSP: Concave: Backpack: 
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new_tokens ::= whitespace | "," | "::" | "@"
root ::= new_tokens

Top 20 Logits:

:17.5999
#:15.6117
##:14.879
let:14.2999
    :13.1798
in:12.8462
  :12.7983
################:12.774
   :12.543
####:12.3508
```:11.9582
########:11.8645
 :11.8142
/*:11.7903
//:11.5666
        :11.5053
                :11.4269
[:11.2733
       :11.0582
fun:10.8911
{:10.8744

================
# Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)




















LSP: Prelude: Recieved string: ### List ###

# Add an element to the front of a list. #
let cons: (Int, [Int]) -> [Int] = fun x, xs -> x::xs in

# Determine the length of a list. #
let length: [Int] -> Int =
  fun xs ->
    case xs
    | [] => 0
    | _::xs => 1 + length(xs) end in

# Extract the first element of a list. #
let hd: [Int] -> Option =
  fun l ->
    case l
    | [] => None
    | x::xs => Some(x) end in

# Extract the rest of the list. #
let tl: [Int] -> [Int] =
  fun l ->
    case l
    | [] => []
    | x::xs => xs end in

# Determine if a list is empty. #
let is_empty: [Int] -> Bool =
  fun xs ->
    case xs
    | [] => true
    | _::_ => false end in

# Return the element at the index. #
let nth: ([Int], Int) -> Option =
  fun xs, n ->
    case xs, n
    | x::_, 0 => Some(x)
    | _::xs, n => nth(xs, n - 1)
    | [], _ => None end in

# Reverse a List. #
let rev: [Int] -> [Int] =
fun l -> 
let go: ([Int], [Int]) -> [Int] =
  fun xs, acc -> 
    case xs 
    | [] => acc 
    | x::xs => go(xs, x::acc) end in
go(l, []) in

# Check if two lists are equal #
let equal: ([Int], [Int]) -> Bool =
    fun p, xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => x == y && equal(xs, ys)
    | _ => false end
in

# Initialize a list with a given length using an initializer function #
let init: (Int, Int -> Int) -> [Int] =
    fun len, f ->
        let go: (Int, [Int]) -> [Int] =
        fun idx, xs ->
            if idx < len 
            then go(idx + 1, xs @ [f(idx)])   
            else xs
        in
        go(0, [])
in

# Reduce a list from the left. #
let fold_left: ((Int, Int) -> Int, Int, [Int]) -> Int =
  fun f, acc, xs ->
    case xs 
    | [] => acc
    | hd::tl => fold_left(f, f(acc, hd), tl) end in

# Reduce a list from the right. #
let fold_right: ((Int, Int) -> Int, [Int], Int) -> Int =
  fun f, xs, acc ->
    case xs
    | [] => acc
    | hd::tl => f(hd, fold_right(f, tl, acc)) end in


666
LSP: Prelude: String parsed successfully
LSP: Prelude: Info map generated successfully
Debug: true, Constrain: Types
LSP: Init: Recieved string: # Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)



















LSP: Init: String parsed successfully
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: >( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {go: ((?, ?) -> [?]), filter: (((Int -> Bool), [Int]) -> [Int]), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: 
  LSP: Info: ALL errors:Error in term:
  p
Nature of error: type ((Int -> Bool), [Int]) is not consistent with arrow type    
Error in term:
  p
Nature of error: Variable p is not bound    
Error in term:
  p
Nature of error: Variable p is not bound
  LSP: Info: BidiCtx: Cls: Let expression
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent: Root
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: [?]
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: :: @
  LSP: Concave: Backpack: 
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new_tokens ::= whitespace | "," | "::" | "@"
root ::= new_tokens

Top 20 Logits:

:17.5926
#:15.5819
##:14.8102
let:14.2434
    :13.1139
in:12.9028
  :12.7246
################:12.71
   :12.5125
####:12.3042
```:11.9409
/*:11.7883
########:11.7769
 :11.7748
//:11.5566
        :11.4444
                :11.3761
[:11.2435
       :11.0229
fun:10.8631
|:10.8342

================
# Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)





















LSP: Prelude: Recieved string: ### List ###

# Add an element to the front of a list. #
let cons: (Int, [Int]) -> [Int] = fun x, xs -> x::xs in

# Determine the length of a list. #
let length: [Int] -> Int =
  fun xs ->
    case xs
    | [] => 0
    | _::xs => 1 + length(xs) end in

# Extract the first element of a list. #
let hd: [Int] -> Option =
  fun l ->
    case l
    | [] => None
    | x::xs => Some(x) end in

# Extract the rest of the list. #
let tl: [Int] -> [Int] =
  fun l ->
    case l
    | [] => []
    | x::xs => xs end in

# Determine if a list is empty. #
let is_empty: [Int] -> Bool =
  fun xs ->
    case xs
    | [] => true
    | _::_ => false end in

# Return the element at the index. #
let nth: ([Int], Int) -> Option =
  fun xs, n ->
    case xs, n
    | x::_, 0 => Some(x)
    | _::xs, n => nth(xs, n - 1)
    | [], _ => None end in

# Reverse a List. #
let rev: [Int] -> [Int] =
fun l -> 
let go: ([Int], [Int]) -> [Int] =
  fun xs, acc -> 
    case xs 
    | [] => acc 
    | x::xs => go(xs, x::acc) end in
go(l, []) in

# Check if two lists are equal #
let equal: ([Int], [Int]) -> Bool =
    fun p, xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => x == y && equal(xs, ys)
    | _ => false end
in

# Initialize a list with a given length using an initializer function #
let init: (Int, Int -> Int) -> [Int] =
    fun len, f ->
        let go: (Int, [Int]) -> [Int] =
        fun idx, xs ->
            if idx < len 
            then go(idx + 1, xs @ [f(idx)])   
            else xs
        in
        go(0, [])
in

# Reduce a list from the left. #
let fold_left: ((Int, Int) -> Int, Int, [Int]) -> Int =
  fun f, acc, xs ->
    case xs 
    | [] => acc
    | hd::tl => fold_left(f, f(acc, hd), tl) end in

# Reduce a list from the right. #
let fold_right: ((Int, Int) -> Int, [Int], Int) -> Int =
  fun f, xs, acc ->
    case xs
    | [] => acc
    | hd::tl => f(hd, fold_right(f, tl, acc)) end in


666
LSP: Prelude: String parsed successfully
LSP: Prelude: Info map generated successfully
Debug: true, Constrain: Types
LSP: Init: Recieved string: # Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)




















LSP: Init: String parsed successfully
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: >( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {go: ((?, ?) -> [?]), filter: (((Int -> Bool), [Int]) -> [Int]), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: 
  LSP: Info: ALL errors:Error in term:
  p
Nature of error: type ((Int -> Bool), [Int]) is not consistent with arrow type    
Error in term:
  p
Nature of error: Variable p is not bound    
Error in term:
  p
Nature of error: Variable p is not bound
  LSP: Info: BidiCtx: Cls: Let expression
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent: Root
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: [?]
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: :: @
  LSP: Concave: Backpack: 
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new_tokens ::= whitespace | "," | "::" | "@"
root ::= new_tokens

Top 20 Logits:

:17.5882
#:15.5594
##:14.753
let:14.1982
    :13.0641
in:12.9216
  :12.658
################:12.6565
   :12.4935
####:12.2653
```:11.9143
/*:11.7831
 :11.7434
########:11.7004
//:11.538
        :11.4002
                :11.3369
[:11.2234
       :10.9967
|:10.8634
fun:10.8353

================
# Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)






















LSP: Prelude: Recieved string: ### List ###

# Add an element to the front of a list. #
let cons: (Int, [Int]) -> [Int] = fun x, xs -> x::xs in

# Determine the length of a list. #
let length: [Int] -> Int =
  fun xs ->
    case xs
    | [] => 0
    | _::xs => 1 + length(xs) end in

# Extract the first element of a list. #
let hd: [Int] -> Option =
  fun l ->
    case l
    | [] => None
    | x::xs => Some(x) end in

# Extract the rest of the list. #
let tl: [Int] -> [Int] =
  fun l ->
    case l
    | [] => []
    | x::xs => xs end in

# Determine if a list is empty. #
let is_empty: [Int] -> Bool =
  fun xs ->
    case xs
    | [] => true
    | _::_ => false end in

# Return the element at the index. #
let nth: ([Int], Int) -> Option =
  fun xs, n ->
    case xs, n
    | x::_, 0 => Some(x)
    | _::xs, n => nth(xs, n - 1)
    | [], _ => None end in

# Reverse a List. #
let rev: [Int] -> [Int] =
fun l -> 
let go: ([Int], [Int]) -> [Int] =
  fun xs, acc -> 
    case xs 
    | [] => acc 
    | x::xs => go(xs, x::acc) end in
go(l, []) in

# Check if two lists are equal #
let equal: ([Int], [Int]) -> Bool =
    fun p, xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => x == y && equal(xs, ys)
    | _ => false end
in

# Initialize a list with a given length using an initializer function #
let init: (Int, Int -> Int) -> [Int] =
    fun len, f ->
        let go: (Int, [Int]) -> [Int] =
        fun idx, xs ->
            if idx < len 
            then go(idx + 1, xs @ [f(idx)])   
            else xs
        in
        go(0, [])
in

# Reduce a list from the left. #
let fold_left: ((Int, Int) -> Int, Int, [Int]) -> Int =
  fun f, acc, xs ->
    case xs 
    | [] => acc
    | hd::tl => fold_left(f, f(acc, hd), tl) end in

# Reduce a list from the right. #
let fold_right: ((Int, Int) -> Int, [Int], Int) -> Int =
  fun f, xs, acc ->
    case xs
    | [] => acc
    | hd::tl => f(hd, fold_right(f, tl, acc)) end in


666
LSP: Prelude: String parsed successfully
LSP: Prelude: Info map generated successfully
Debug: true, Constrain: Types
LSP: Init: Recieved string: # Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)





















LSP: Init: String parsed successfully
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: >( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {go: ((?, ?) -> [?]), filter: (((Int -> Bool), [Int]) -> [Int]), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: 
  LSP: Info: ALL errors:Error in term:
  p
Nature of error: Variable p is not bound    
Error in term:
  p
Nature of error: type ((Int -> Bool), [Int]) is not consistent with arrow type    
Error in term:
  p
Nature of error: Variable p is not bound
  LSP: Info: BidiCtx: Cls: Let expression
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent: Root
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: [?]
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: :: @
  LSP: Concave: Backpack: 
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new_tokens ::= whitespace | "," | "::" | "@"
root ::= new_tokens

Top 20 Logits:

:17.6006
#:15.548
##:14.7298
let:14.1735
    :13.0337
in:12.8987
################:12.6282
  :12.6087
   :12.4917
####:12.2469
```:11.901
/*:11.7758
 :11.7299
########:11.6599
//:11.5214
        :11.3799
                :11.3214
[:11.2203
       :10.9925
|:10.8773
":10.8427

================
# Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)























LSP: Prelude: Recieved string: ### List ###

# Add an element to the front of a list. #
let cons: (Int, [Int]) -> [Int] = fun x, xs -> x::xs in

# Determine the length of a list. #
let length: [Int] -> Int =
  fun xs ->
    case xs
    | [] => 0
    | _::xs => 1 + length(xs) end in

# Extract the first element of a list. #
let hd: [Int] -> Option =
  fun l ->
    case l
    | [] => None
    | x::xs => Some(x) end in

# Extract the rest of the list. #
let tl: [Int] -> [Int] =
  fun l ->
    case l
    | [] => []
    | x::xs => xs end in

# Determine if a list is empty. #
let is_empty: [Int] -> Bool =
  fun xs ->
    case xs
    | [] => true
    | _::_ => false end in

# Return the element at the index. #
let nth: ([Int], Int) -> Option =
  fun xs, n ->
    case xs, n
    | x::_, 0 => Some(x)
    | _::xs, n => nth(xs, n - 1)
    | [], _ => None end in

# Reverse a List. #
let rev: [Int] -> [Int] =
fun l -> 
let go: ([Int], [Int]) -> [Int] =
  fun xs, acc -> 
    case xs 
    | [] => acc 
    | x::xs => go(xs, x::acc) end in
go(l, []) in

# Check if two lists are equal #
let equal: ([Int], [Int]) -> Bool =
    fun p, xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => x == y && equal(xs, ys)
    | _ => false end
in

# Initialize a list with a given length using an initializer function #
let init: (Int, Int -> Int) -> [Int] =
    fun len, f ->
        let go: (Int, [Int]) -> [Int] =
        fun idx, xs ->
            if idx < len 
            then go(idx + 1, xs @ [f(idx)])   
            else xs
        in
        go(0, [])
in

# Reduce a list from the left. #
let fold_left: ((Int, Int) -> Int, Int, [Int]) -> Int =
  fun f, acc, xs ->
    case xs 
    | [] => acc
    | hd::tl => fold_left(f, f(acc, hd), tl) end in

# Reduce a list from the right. #
let fold_right: ((Int, Int) -> Int, [Int], Int) -> Int =
  fun f, xs, acc ->
    case xs
    | [] => acc
    | hd::tl => f(hd, fold_right(f, tl, acc)) end in


666
LSP: Prelude: String parsed successfully
LSP: Prelude: Info map generated successfully
Debug: true, Constrain: Types
LSP: Init: Recieved string: # Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)






















LSP: Init: String parsed successfully
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: >( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {go: ((?, ?) -> [?]), filter: (((Int -> Bool), [Int]) -> [Int]), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: 
  LSP: Info: ALL errors:Error in term:
  p
Nature of error: type ((Int -> Bool), [Int]) is not consistent with arrow type    
Error in term:
  p
Nature of error: Variable p is not bound    
Error in term:
  p
Nature of error: Variable p is not bound
  LSP: Info: BidiCtx: Cls: Let expression
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent: Root
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: [?]
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: :: @
  LSP: Concave: Backpack: 
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new_tokens ::= whitespace | "," | "::" | "@"
root ::= new_tokens

Top 20 Logits:

:17.632
#:15.5469
##:14.7372
let:14.1594
    :13.0142
in:12.8642
################:12.6205
  :12.5769
   :12.5018
####:12.2504
```:11.9136
/*:11.7674
 :11.7318
########:11.6523
//:11.5164
        :11.3758
                :11.327
[:11.2284
       :11.009
|:10.8891
":10.8616

================
# Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)
























LSP: Prelude: Recieved string: ### List ###

# Add an element to the front of a list. #
let cons: (Int, [Int]) -> [Int] = fun x, xs -> x::xs in

# Determine the length of a list. #
let length: [Int] -> Int =
  fun xs ->
    case xs
    | [] => 0
    | _::xs => 1 + length(xs) end in

# Extract the first element of a list. #
let hd: [Int] -> Option =
  fun l ->
    case l
    | [] => None
    | x::xs => Some(x) end in

# Extract the rest of the list. #
let tl: [Int] -> [Int] =
  fun l ->
    case l
    | [] => []
    | x::xs => xs end in

# Determine if a list is empty. #
let is_empty: [Int] -> Bool =
  fun xs ->
    case xs
    | [] => true
    | _::_ => false end in

# Return the element at the index. #
let nth: ([Int], Int) -> Option =
  fun xs, n ->
    case xs, n
    | x::_, 0 => Some(x)
    | _::xs, n => nth(xs, n - 1)
    | [], _ => None end in

# Reverse a List. #
let rev: [Int] -> [Int] =
fun l -> 
let go: ([Int], [Int]) -> [Int] =
  fun xs, acc -> 
    case xs 
    | [] => acc 
    | x::xs => go(xs, x::acc) end in
go(l, []) in

# Check if two lists are equal #
let equal: ([Int], [Int]) -> Bool =
    fun p, xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => x == y && equal(xs, ys)
    | _ => false end
in

# Initialize a list with a given length using an initializer function #
let init: (Int, Int -> Int) -> [Int] =
    fun len, f ->
        let go: (Int, [Int]) -> [Int] =
        fun idx, xs ->
            if idx < len 
            then go(idx + 1, xs @ [f(idx)])   
            else xs
        in
        go(0, [])
in

# Reduce a list from the left. #
let fold_left: ((Int, Int) -> Int, Int, [Int]) -> Int =
  fun f, acc, xs ->
    case xs 
    | [] => acc
    | hd::tl => fold_left(f, f(acc, hd), tl) end in

# Reduce a list from the right. #
let fold_right: ((Int, Int) -> Int, [Int], Int) -> Int =
  fun f, xs, acc ->
    case xs
    | [] => acc
    | hd::tl => f(hd, fold_right(f, tl, acc)) end in


666
LSP: Prelude: String parsed successfully
LSP: Prelude: Info map generated successfully
Debug: true, Constrain: Types
LSP: Init: Recieved string: # Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)























LSP: Init: String parsed successfully
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: >( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {go: ((?, ?) -> [?]), filter: (((Int -> Bool), [Int]) -> [Int]), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: 
  LSP: Info: ALL errors:Error in term:
  p
Nature of error: Variable p is not bound    
Error in term:
  p
Nature of error: Variable p is not bound    
Error in term:
  p
Nature of error: type ((Int -> Bool), [Int]) is not consistent with arrow type
  LSP: Info: BidiCtx: Cls: Let expression
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent: Root
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: [?]
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: :: @
  LSP: Concave: Backpack: 
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new_tokens ::= whitespace | "," | "::" | "@"
root ::= new_tokens

Top 20 Logits:

:17.6752
#:15.5559
##:14.7577
let:14.1456
    :12.9984
in:12.8507
################:12.6201
  :12.5577
   :12.5161
####:12.2685
```:11.9483
/*:11.7609
 :11.7407
########:11.6578
//:11.527
        :11.3808
                :11.3444
[:11.2365
       :11.0392
|:10.9058
":10.8759

================
# Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)

























LSP: Prelude: Recieved string: ### List ###

# Add an element to the front of a list. #
let cons: (Int, [Int]) -> [Int] = fun x, xs -> x::xs in

# Determine the length of a list. #
let length: [Int] -> Int =
  fun xs ->
    case xs
    | [] => 0
    | _::xs => 1 + length(xs) end in

# Extract the first element of a list. #
let hd: [Int] -> Option =
  fun l ->
    case l
    | [] => None
    | x::xs => Some(x) end in

# Extract the rest of the list. #
let tl: [Int] -> [Int] =
  fun l ->
    case l
    | [] => []
    | x::xs => xs end in

# Determine if a list is empty. #
let is_empty: [Int] -> Bool =
  fun xs ->
    case xs
    | [] => true
    | _::_ => false end in

# Return the element at the index. #
let nth: ([Int], Int) -> Option =
  fun xs, n ->
    case xs, n
    | x::_, 0 => Some(x)
    | _::xs, n => nth(xs, n - 1)
    | [], _ => None end in

# Reverse a List. #
let rev: [Int] -> [Int] =
fun l -> 
let go: ([Int], [Int]) -> [Int] =
  fun xs, acc -> 
    case xs 
    | [] => acc 
    | x::xs => go(xs, x::acc) end in
go(l, []) in

# Check if two lists are equal #
let equal: ([Int], [Int]) -> Bool =
    fun p, xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => x == y && equal(xs, ys)
    | _ => false end
in

# Initialize a list with a given length using an initializer function #
let init: (Int, Int -> Int) -> [Int] =
    fun len, f ->
        let go: (Int, [Int]) -> [Int] =
        fun idx, xs ->
            if idx < len 
            then go(idx + 1, xs @ [f(idx)])   
            else xs
        in
        go(0, [])
in

# Reduce a list from the left. #
let fold_left: ((Int, Int) -> Int, Int, [Int]) -> Int =
  fun f, acc, xs ->
    case xs 
    | [] => acc
    | hd::tl => fold_left(f, f(acc, hd), tl) end in

# Reduce a list from the right. #
let fold_right: ((Int, Int) -> Int, [Int], Int) -> Int =
  fun f, xs, acc ->
    case xs
    | [] => acc
    | hd::tl => f(hd, fold_right(f, tl, acc)) end in


666
LSP: Prelude: String parsed successfully
LSP: Prelude: Info map generated successfully
Debug: true, Constrain: Types
LSP: Init: Recieved string: # Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)
























LSP: Init: String parsed successfully
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: >( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {go: ((?, ?) -> [?]), filter: (((Int -> Bool), [Int]) -> [Int]), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: 
  LSP: Info: ALL errors:Error in term:
  p
Nature of error: type ((Int -> Bool), [Int]) is not consistent with arrow type    
Error in term:
  p
Nature of error: Variable p is not bound    
Error in term:
  p
Nature of error: Variable p is not bound
  LSP: Info: BidiCtx: Cls: Let expression
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent: Root
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: [?]
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: :: @
  LSP: Concave: Backpack: 
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new_tokens ::= whitespace | "," | "::" | "@"
root ::= new_tokens

Top 20 Logits:

:17.7207
#:15.5714
##:14.7734
let:14.1282
    :12.9844
in:12.8697
################:12.6186
  :12.5501
   :12.531
####:12.2907
```:11.991
/*:11.7603
 :11.752
########:11.6609
//:11.5501
        :11.3917
                :11.3662
[:11.2367
       :11.076
|:10.9251
":10.8797

================
# Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)


























LSP: Prelude: Recieved string: ### List ###

# Add an element to the front of a list. #
let cons: (Int, [Int]) -> [Int] = fun x, xs -> x::xs in

# Determine the length of a list. #
let length: [Int] -> Int =
  fun xs ->
    case xs
    | [] => 0
    | _::xs => 1 + length(xs) end in

# Extract the first element of a list. #
let hd: [Int] -> Option =
  fun l ->
    case l
    | [] => None
    | x::xs => Some(x) end in

# Extract the rest of the list. #
let tl: [Int] -> [Int] =
  fun l ->
    case l
    | [] => []
    | x::xs => xs end in

# Determine if a list is empty. #
let is_empty: [Int] -> Bool =
  fun xs ->
    case xs
    | [] => true
    | _::_ => false end in

# Return the element at the index. #
let nth: ([Int], Int) -> Option =
  fun xs, n ->
    case xs, n
    | x::_, 0 => Some(x)
    | _::xs, n => nth(xs, n - 1)
    | [], _ => None end in

# Reverse a List. #
let rev: [Int] -> [Int] =
fun l -> 
let go: ([Int], [Int]) -> [Int] =
  fun xs, acc -> 
    case xs 
    | [] => acc 
    | x::xs => go(xs, x::acc) end in
go(l, []) in

# Check if two lists are equal #
let equal: ([Int], [Int]) -> Bool =
    fun p, xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => x == y && equal(xs, ys)
    | _ => false end
in

# Initialize a list with a given length using an initializer function #
let init: (Int, Int -> Int) -> [Int] =
    fun len, f ->
        let go: (Int, [Int]) -> [Int] =
        fun idx, xs ->
            if idx < len 
            then go(idx + 1, xs @ [f(idx)])   
            else xs
        in
        go(0, [])
in

# Reduce a list from the left. #
let fold_left: ((Int, Int) -> Int, Int, [Int]) -> Int =
  fun f, acc, xs ->
    case xs 
    | [] => acc
    | hd::tl => fold_left(f, f(acc, hd), tl) end in

# Reduce a list from the right. #
let fold_right: ((Int, Int) -> Int, [Int], Int) -> Int =
  fun f, xs, acc ->
    case xs
    | [] => acc
    | hd::tl => f(hd, fold_right(f, tl, acc)) end in


666
LSP: Prelude: String parsed successfully
LSP: Prelude: Info map generated successfully
Debug: true, Constrain: Types
LSP: Init: Recieved string: # Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)

























LSP: Init: String parsed successfully
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: >( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {go: ((?, ?) -> [?]), filter: (((Int -> Bool), [Int]) -> [Int]), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: 
  LSP: Info: ALL errors:Error in term:
  p
Nature of error: Variable p is not bound    
Error in term:
  p
Nature of error: type ((Int -> Bool), [Int]) is not consistent with arrow type    
Error in term:
  p
Nature of error: Variable p is not bound
  LSP: Info: BidiCtx: Cls: Let expression
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent: Root
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: [?]
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: :: @
  LSP: Concave: Backpack: 
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new_tokens ::= whitespace | "," | "::" | "@"
root ::= new_tokens

Top 20 Logits:

:17.7617
#:15.5881
##:14.7798
let:14.1095
    :12.9757
in:12.9085
################:12.618
  :12.555
   :12.5468
####:12.3112
```:12.028
/*:11.7668
 :11.7655
########:11.6612
//:11.5782
        :11.4068
                :11.3871
[:11.2279
       :11.1126
|:10.9388
":10.8765

================
# Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)



























LSP: Prelude: Recieved string: ### List ###

# Add an element to the front of a list. #
let cons: (Int, [Int]) -> [Int] = fun x, xs -> x::xs in

# Determine the length of a list. #
let length: [Int] -> Int =
  fun xs ->
    case xs
    | [] => 0
    | _::xs => 1 + length(xs) end in

# Extract the first element of a list. #
let hd: [Int] -> Option =
  fun l ->
    case l
    | [] => None
    | x::xs => Some(x) end in

# Extract the rest of the list. #
let tl: [Int] -> [Int] =
  fun l ->
    case l
    | [] => []
    | x::xs => xs end in

# Determine if a list is empty. #
let is_empty: [Int] -> Bool =
  fun xs ->
    case xs
    | [] => true
    | _::_ => false end in

# Return the element at the index. #
let nth: ([Int], Int) -> Option =
  fun xs, n ->
    case xs, n
    | x::_, 0 => Some(x)
    | _::xs, n => nth(xs, n - 1)
    | [], _ => None end in

# Reverse a List. #
let rev: [Int] -> [Int] =
fun l -> 
let go: ([Int], [Int]) -> [Int] =
  fun xs, acc -> 
    case xs 
    | [] => acc 
    | x::xs => go(xs, x::acc) end in
go(l, []) in

# Check if two lists are equal #
let equal: ([Int], [Int]) -> Bool =
    fun p, xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => x == y && equal(xs, ys)
    | _ => false end
in

# Initialize a list with a given length using an initializer function #
let init: (Int, Int -> Int) -> [Int] =
    fun len, f ->
        let go: (Int, [Int]) -> [Int] =
        fun idx, xs ->
            if idx < len 
            then go(idx + 1, xs @ [f(idx)])   
            else xs
        in
        go(0, [])
in

# Reduce a list from the left. #
let fold_left: ((Int, Int) -> Int, Int, [Int]) -> Int =
  fun f, acc, xs ->
    case xs 
    | [] => acc
    | hd::tl => fold_left(f, f(acc, hd), tl) end in

# Reduce a list from the right. #
let fold_right: ((Int, Int) -> Int, [Int], Int) -> Int =
  fun f, xs, acc ->
    case xs
    | [] => acc
    | hd::tl => f(hd, fold_right(f, tl, acc)) end in


666
LSP: Prelude: String parsed successfully
LSP: Prelude: Info map generated successfully
Debug: true, Constrain: Types
LSP: Init: Recieved string: # Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)


























LSP: Init: String parsed successfully
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: >( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {go: ((?, ?) -> [?]), filter: (((Int -> Bool), [Int]) -> [Int]), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: 
  LSP: Info: ALL errors:Error in term:
  p
Nature of error: Variable p is not bound    
Error in term:
  p
Nature of error: Variable p is not bound    
Error in term:
  p
Nature of error: type ((Int -> Bool), [Int]) is not consistent with arrow type
  LSP: Info: BidiCtx: Cls: Let expression
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent: Root
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: [?]
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: :: @
  LSP: Concave: Backpack: 
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new_tokens ::= whitespace | "," | "::" | "@"
root ::= new_tokens

Top 20 Logits:

:17.7966
#:15.6034
##:14.7846
let:14.0968
    :12.9767
 :12.9606
in:12.9441
################:12.6224
  :12.5705
   :12.5646
####:12.3298
```:12.0524
/*:11.7806
########:11.6666
//:11.6042
        :11.4258
                :11.4064
[:11.2164
       :11.1452
|:10.9436
-:10.9002

================
# Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)




























LSP: Prelude: Recieved string: ### List ###

# Add an element to the front of a list. #
let cons: (Int, [Int]) -> [Int] = fun x, xs -> x::xs in

# Determine the length of a list. #
let length: [Int] -> Int =
  fun xs ->
    case xs
    | [] => 0
    | _::xs => 1 + length(xs) end in

# Extract the first element of a list. #
let hd: [Int] -> Option =
  fun l ->
    case l
    | [] => None
    | x::xs => Some(x) end in

# Extract the rest of the list. #
let tl: [Int] -> [Int] =
  fun l ->
    case l
    | [] => []
    | x::xs => xs end in

# Determine if a list is empty. #
let is_empty: [Int] -> Bool =
  fun xs ->
    case xs
    | [] => true
    | _::_ => false end in

# Return the element at the index. #
let nth: ([Int], Int) -> Option =
  fun xs, n ->
    case xs, n
    | x::_, 0 => Some(x)
    | _::xs, n => nth(xs, n - 1)
    | [], _ => None end in

# Reverse a List. #
let rev: [Int] -> [Int] =
fun l -> 
let go: ([Int], [Int]) -> [Int] =
  fun xs, acc -> 
    case xs 
    | [] => acc 
    | x::xs => go(xs, x::acc) end in
go(l, []) in

# Check if two lists are equal #
let equal: ([Int], [Int]) -> Bool =
    fun p, xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => x == y && equal(xs, ys)
    | _ => false end
in

# Initialize a list with a given length using an initializer function #
let init: (Int, Int -> Int) -> [Int] =
    fun len, f ->
        let go: (Int, [Int]) -> [Int] =
        fun idx, xs ->
            if idx < len 
            then go(idx + 1, xs @ [f(idx)])   
            else xs
        in
        go(0, [])
in

# Reduce a list from the left. #
let fold_left: ((Int, Int) -> Int, Int, [Int]) -> Int =
  fun f, acc, xs ->
    case xs 
    | [] => acc
    | hd::tl => fold_left(f, f(acc, hd), tl) end in

# Reduce a list from the right. #
let fold_right: ((Int, Int) -> Int, [Int], Int) -> Int =
  fun f, xs, acc ->
    case xs
    | [] => acc
    | hd::tl => f(hd, fold_right(f, tl, acc)) end in


666
LSP: Prelude: String parsed successfully
LSP: Prelude: Info map generated successfully
Debug: true, Constrain: Types
LSP: Init: Recieved string: # Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)



























LSP: Init: String parsed successfully
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: >( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {go: ((?, ?) -> [?]), filter: (((Int -> Bool), [Int]) -> [Int]), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: 
  LSP: Info: ALL errors:Error in term:
  p
Nature of error: Variable p is not bound    
Error in term:
  p
Nature of error: Variable p is not bound    
Error in term:
  p
Nature of error: type ((Int -> Bool), [Int]) is not consistent with arrow type
  LSP: Info: BidiCtx: Cls: Let expression
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent: Root
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: [?]
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: :: @
  LSP: Concave: Backpack: 
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new_tokens ::= whitespace | "," | "::" | "@"
root ::= new_tokens

Top 20 Logits:

:17.832
#:15.6202
##:14.7993
let:14.0993
    :12.9884
 :12.9861
in:12.9638
################:12.6362
  :12.5945
   :12.586
####:12.3525
```:12.0725
/*:11.8004
########:11.6842
//:11.6266
        :11.4511
                :11.4293
[:11.2132
       :11.1777
|:10.9467
-:10.9292

================
# Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)





























LSP: Prelude: Recieved string: ### List ###

# Add an element to the front of a list. #
let cons: (Int, [Int]) -> [Int] = fun x, xs -> x::xs in

# Determine the length of a list. #
let length: [Int] -> Int =
  fun xs ->
    case xs
    | [] => 0
    | _::xs => 1 + length(xs) end in

# Extract the first element of a list. #
let hd: [Int] -> Option =
  fun l ->
    case l
    | [] => None
    | x::xs => Some(x) end in

# Extract the rest of the list. #
let tl: [Int] -> [Int] =
  fun l ->
    case l
    | [] => []
    | x::xs => xs end in

# Determine if a list is empty. #
let is_empty: [Int] -> Bool =
  fun xs ->
    case xs
    | [] => true
    | _::_ => false end in

# Return the element at the index. #
let nth: ([Int], Int) -> Option =
  fun xs, n ->
    case xs, n
    | x::_, 0 => Some(x)
    | _::xs, n => nth(xs, n - 1)
    | [], _ => None end in

# Reverse a List. #
let rev: [Int] -> [Int] =
fun l -> 
let go: ([Int], [Int]) -> [Int] =
  fun xs, acc -> 
    case xs 
    | [] => acc 
    | x::xs => go(xs, x::acc) end in
go(l, []) in

# Check if two lists are equal #
let equal: ([Int], [Int]) -> Bool =
    fun p, xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => x == y && equal(xs, ys)
    | _ => false end
in

# Initialize a list with a given length using an initializer function #
let init: (Int, Int -> Int) -> [Int] =
    fun len, f ->
        let go: (Int, [Int]) -> [Int] =
        fun idx, xs ->
            if idx < len 
            then go(idx + 1, xs @ [f(idx)])   
            else xs
        in
        go(0, [])
in

# Reduce a list from the left. #
let fold_left: ((Int, Int) -> Int, Int, [Int]) -> Int =
  fun f, acc, xs ->
    case xs 
    | [] => acc
    | hd::tl => fold_left(f, f(acc, hd), tl) end in

# Reduce a list from the right. #
let fold_right: ((Int, Int) -> Int, [Int], Int) -> Int =
  fun f, xs, acc ->
    case xs
    | [] => acc
    | hd::tl => f(hd, fold_right(f, tl, acc)) end in


666
LSP: Prelude: String parsed successfully
LSP: Prelude: Info map generated successfully
Debug: true, Constrain: Types
LSP: Init: Recieved string: # Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)




























LSP: Init: String parsed successfully
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: >( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {go: ((?, ?) -> [?]), filter: (((Int -> Bool), [Int]) -> [Int]), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: 
  LSP: Info: ALL errors:Error in term:
  p
Nature of error: type ((Int -> Bool), [Int]) is not consistent with arrow type    
Error in term:
  p
Nature of error: Variable p is not bound    
Error in term:
  p
Nature of error: Variable p is not bound
  LSP: Info: BidiCtx: Cls: Let expression
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent: Root
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: [?]
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: :: @
  LSP: Concave: Backpack: 
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new_tokens ::= whitespace | "," | "::" | "@"
root ::= new_tokens

Top 20 Logits:

:17.8729
#:15.6426
##:14.8281
let:14.1231
 :13.0172
    :13.0063
in:12.9689
################:12.661
  :12.6217
   :12.6106
####:12.3828
```:12.0995
/*:11.8213
########:11.7141
//:11.645
        :11.4808
                :11.458
[:11.2239
       :11.2132
-:10.9606
|:10.9519

================
# Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)






























LSP: Prelude: Recieved string: ### List ###

# Add an element to the front of a list. #
let cons: (Int, [Int]) -> [Int] = fun x, xs -> x::xs in

# Determine the length of a list. #
let length: [Int] -> Int =
  fun xs ->
    case xs
    | [] => 0
    | _::xs => 1 + length(xs) end in

# Extract the first element of a list. #
let hd: [Int] -> Option =
  fun l ->
    case l
    | [] => None
    | x::xs => Some(x) end in

# Extract the rest of the list. #
let tl: [Int] -> [Int] =
  fun l ->
    case l
    | [] => []
    | x::xs => xs end in

# Determine if a list is empty. #
let is_empty: [Int] -> Bool =
  fun xs ->
    case xs
    | [] => true
    | _::_ => false end in

# Return the element at the index. #
let nth: ([Int], Int) -> Option =
  fun xs, n ->
    case xs, n
    | x::_, 0 => Some(x)
    | _::xs, n => nth(xs, n - 1)
    | [], _ => None end in

# Reverse a List. #
let rev: [Int] -> [Int] =
fun l -> 
let go: ([Int], [Int]) -> [Int] =
  fun xs, acc -> 
    case xs 
    | [] => acc 
    | x::xs => go(xs, x::acc) end in
go(l, []) in

# Check if two lists are equal #
let equal: ([Int], [Int]) -> Bool =
    fun p, xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => x == y && equal(xs, ys)
    | _ => false end
in

# Initialize a list with a given length using an initializer function #
let init: (Int, Int -> Int) -> [Int] =
    fun len, f ->
        let go: (Int, [Int]) -> [Int] =
        fun idx, xs ->
            if idx < len 
            then go(idx + 1, xs @ [f(idx)])   
            else xs
        in
        go(0, [])
in

# Reduce a list from the left. #
let fold_left: ((Int, Int) -> Int, Int, [Int]) -> Int =
  fun f, acc, xs ->
    case xs 
    | [] => acc
    | hd::tl => fold_left(f, f(acc, hd), tl) end in

# Reduce a list from the right. #
let fold_right: ((Int, Int) -> Int, [Int], Int) -> Int =
  fun f, xs, acc ->
    case xs
    | [] => acc
    | hd::tl => f(hd, fold_right(f, tl, acc)) end in


666
LSP: Prelude: String parsed successfully
LSP: Prelude: Info map generated successfully
Debug: true, Constrain: Types
LSP: Init: Recieved string: # Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)





























LSP: Init: String parsed successfully
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: >( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {go: ((?, ?) -> [?]), filter: (((Int -> Bool), [Int]) -> [Int]), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: 
  LSP: Info: ALL errors:Error in term:
  p
Nature of error: Variable p is not bound    
Error in term:
  p
Nature of error: type ((Int -> Bool), [Int]) is not consistent with arrow type    
Error in term:
  p
Nature of error: Variable p is not bound
  LSP: Info: BidiCtx: Cls: Let expression
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent: Root
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: [?]
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: :: @
  LSP: Concave: Backpack: 
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new_tokens ::= whitespace | "," | "::" | "@"
root ::= new_tokens

Top 20 Logits:

:17.9149
#:15.6682
##:14.8623
let:14.1638
 :13.0453
    :13.0205
in:12.9657
################:12.6898
  :12.6424
   :12.6332
####:12.4129
```:12.1328
/*:11.8342
########:11.7446
//:11.6569
        :11.5066
                :11.4871
       :11.2474
[:11.243
-:10.987
|:10.9525

================
# Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)































LSP: Prelude: Recieved string: ### List ###

# Add an element to the front of a list. #
let cons: (Int, [Int]) -> [Int] = fun x, xs -> x::xs in

# Determine the length of a list. #
let length: [Int] -> Int =
  fun xs ->
    case xs
    | [] => 0
    | _::xs => 1 + length(xs) end in

# Extract the first element of a list. #
let hd: [Int] -> Option =
  fun l ->
    case l
    | [] => None
    | x::xs => Some(x) end in

# Extract the rest of the list. #
let tl: [Int] -> [Int] =
  fun l ->
    case l
    | [] => []
    | x::xs => xs end in

# Determine if a list is empty. #
let is_empty: [Int] -> Bool =
  fun xs ->
    case xs
    | [] => true
    | _::_ => false end in

# Return the element at the index. #
let nth: ([Int], Int) -> Option =
  fun xs, n ->
    case xs, n
    | x::_, 0 => Some(x)
    | _::xs, n => nth(xs, n - 1)
    | [], _ => None end in

# Reverse a List. #
let rev: [Int] -> [Int] =
fun l -> 
let go: ([Int], [Int]) -> [Int] =
  fun xs, acc -> 
    case xs 
    | [] => acc 
    | x::xs => go(xs, x::acc) end in
go(l, []) in

# Check if two lists are equal #
let equal: ([Int], [Int]) -> Bool =
    fun p, xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => x == y && equal(xs, ys)
    | _ => false end
in

# Initialize a list with a given length using an initializer function #
let init: (Int, Int -> Int) -> [Int] =
    fun len, f ->
        let go: (Int, [Int]) -> [Int] =
        fun idx, xs ->
            if idx < len 
            then go(idx + 1, xs @ [f(idx)])   
            else xs
        in
        go(0, [])
in

# Reduce a list from the left. #
let fold_left: ((Int, Int) -> Int, Int, [Int]) -> Int =
  fun f, acc, xs ->
    case xs 
    | [] => acc
    | hd::tl => fold_left(f, f(acc, hd), tl) end in

# Reduce a list from the right. #
let fold_right: ((Int, Int) -> Int, [Int], Int) -> Int =
  fun f, xs, acc ->
    case xs
    | [] => acc
    | hd::tl => f(hd, fold_right(f, tl, acc)) end in


666
LSP: Prelude: String parsed successfully
LSP: Prelude: Info map generated successfully
Debug: true, Constrain: Types
LSP: Init: Recieved string: # Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)






























LSP: Init: String parsed successfully
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: >( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {go: ((?, ?) -> [?]), filter: (((Int -> Bool), [Int]) -> [Int]), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: 
  LSP: Info: ALL errors:Error in term:
  p
Nature of error: type ((Int -> Bool), [Int]) is not consistent with arrow type    
Error in term:
  p
Nature of error: Variable p is not bound    
Error in term:
  p
Nature of error: Variable p is not bound
  LSP: Info: BidiCtx: Cls: Let expression
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent: Root
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: [?]
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: :: @
  LSP: Concave: Backpack: 
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new_tokens ::= whitespace | "," | "::" | "@"
root ::= new_tokens

Top 20 Logits:

:17.9496
#:15.6897
##:14.887
let:14.2071
 :13.0646
    :13.0245
in:12.9573
################:12.7134
  :12.6527
   :12.6506
####:12.4325
```:12.1634
/*:11.8335
########:11.761
//:11.6603
        :11.5223
                :11.5115
       :11.2754
[:11.259
-:11.0018
(*:10.954

================
# Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)
































LSP: Prelude: Recieved string: ### List ###

# Add an element to the front of a list. #
let cons: (Int, [Int]) -> [Int] = fun x, xs -> x::xs in

# Determine the length of a list. #
let length: [Int] -> Int =
  fun xs ->
    case xs
    | [] => 0
    | _::xs => 1 + length(xs) end in

# Extract the first element of a list. #
let hd: [Int] -> Option =
  fun l ->
    case l
    | [] => None
    | x::xs => Some(x) end in

# Extract the rest of the list. #
let tl: [Int] -> [Int] =
  fun l ->
    case l
    | [] => []
    | x::xs => xs end in

# Determine if a list is empty. #
let is_empty: [Int] -> Bool =
  fun xs ->
    case xs
    | [] => true
    | _::_ => false end in

# Return the element at the index. #
let nth: ([Int], Int) -> Option =
  fun xs, n ->
    case xs, n
    | x::_, 0 => Some(x)
    | _::xs, n => nth(xs, n - 1)
    | [], _ => None end in

# Reverse a List. #
let rev: [Int] -> [Int] =
fun l -> 
let go: ([Int], [Int]) -> [Int] =
  fun xs, acc -> 
    case xs 
    | [] => acc 
    | x::xs => go(xs, x::acc) end in
go(l, []) in

# Check if two lists are equal #
let equal: ([Int], [Int]) -> Bool =
    fun p, xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => x == y && equal(xs, ys)
    | _ => false end
in

# Initialize a list with a given length using an initializer function #
let init: (Int, Int -> Int) -> [Int] =
    fun len, f ->
        let go: (Int, [Int]) -> [Int] =
        fun idx, xs ->
            if idx < len 
            then go(idx + 1, xs @ [f(idx)])   
            else xs
        in
        go(0, [])
in

# Reduce a list from the left. #
let fold_left: ((Int, Int) -> Int, Int, [Int]) -> Int =
  fun f, acc, xs ->
    case xs 
    | [] => acc
    | hd::tl => fold_left(f, f(acc, hd), tl) end in

# Reduce a list from the right. #
let fold_right: ((Int, Int) -> Int, [Int], Int) -> Int =
  fun f, xs, acc ->
    case xs
    | [] => acc
    | hd::tl => f(hd, fold_right(f, tl, acc)) end in


666
LSP: Prelude: String parsed successfully
LSP: Prelude: Info map generated successfully
Debug: true, Constrain: Types
LSP: Init: Recieved string: # Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)































LSP: Init: String parsed successfully
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: >( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {go: ((?, ?) -> [?]), filter: (((Int -> Bool), [Int]) -> [Int]), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: 
  LSP: Info: ALL errors:Error in term:
  p
Nature of error: Variable p is not bound    
Error in term:
  p
Nature of error: type ((Int -> Bool), [Int]) is not consistent with arrow type    
Error in term:
  p
Nature of error: Variable p is not bound
  LSP: Info: BidiCtx: Cls: Let expression
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent: Root
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: [?]
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: :: @
  LSP: Concave: Backpack: 
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new_tokens ::= whitespace | "," | "::" | "@"
root ::= new_tokens

Top 20 Logits:

:17.9756
#:15.7037
##:14.8978
let:14.2433
 :13.0794
    :13.0233
in:12.9464
################:12.7325
   :12.6668
  :12.6602
####:12.4426
```:12.1836
/*:11.8244
########:11.7641
//:11.6572
                :11.5313
        :11.5308
       :11.2972
[:11.2653
-:11.0047
(*:10.974

================
# Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)

































LSP: Prelude: Recieved string: ### List ###

# Add an element to the front of a list. #
let cons: (Int, [Int]) -> [Int] = fun x, xs -> x::xs in

# Determine the length of a list. #
let length: [Int] -> Int =
  fun xs ->
    case xs
    | [] => 0
    | _::xs => 1 + length(xs) end in

# Extract the first element of a list. #
let hd: [Int] -> Option =
  fun l ->
    case l
    | [] => None
    | x::xs => Some(x) end in

# Extract the rest of the list. #
let tl: [Int] -> [Int] =
  fun l ->
    case l
    | [] => []
    | x::xs => xs end in

# Determine if a list is empty. #
let is_empty: [Int] -> Bool =
  fun xs ->
    case xs
    | [] => true
    | _::_ => false end in

# Return the element at the index. #
let nth: ([Int], Int) -> Option =
  fun xs, n ->
    case xs, n
    | x::_, 0 => Some(x)
    | _::xs, n => nth(xs, n - 1)
    | [], _ => None end in

# Reverse a List. #
let rev: [Int] -> [Int] =
fun l -> 
let go: ([Int], [Int]) -> [Int] =
  fun xs, acc -> 
    case xs 
    | [] => acc 
    | x::xs => go(xs, x::acc) end in
go(l, []) in

# Check if two lists are equal #
let equal: ([Int], [Int]) -> Bool =
    fun p, xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => x == y && equal(xs, ys)
    | _ => false end
in

# Initialize a list with a given length using an initializer function #
let init: (Int, Int -> Int) -> [Int] =
    fun len, f ->
        let go: (Int, [Int]) -> [Int] =
        fun idx, xs ->
            if idx < len 
            then go(idx + 1, xs @ [f(idx)])   
            else xs
        in
        go(0, [])
in

# Reduce a list from the left. #
let fold_left: ((Int, Int) -> Int, Int, [Int]) -> Int =
  fun f, acc, xs ->
    case xs 
    | [] => acc
    | hd::tl => fold_left(f, f(acc, hd), tl) end in

# Reduce a list from the right. #
let fold_right: ((Int, Int) -> Int, [Int], Int) -> Int =
  fun f, xs, acc ->
    case xs
    | [] => acc
    | hd::tl => f(hd, fold_right(f, tl, acc)) end in


666
LSP: Prelude: String parsed successfully
LSP: Prelude: Info map generated successfully
Debug: true, Constrain: Types
LSP: Init: Recieved string: # Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)
































LSP: Init: String parsed successfully
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: >( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {go: ((?, ?) -> [?]), filter: (((Int -> Bool), [Int]) -> [Int]), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: 
  LSP: Info: ALL errors:Error in term:
  p
Nature of error: Variable p is not bound    
Error in term:
  p
Nature of error: type ((Int -> Bool), [Int]) is not consistent with arrow type    
Error in term:
  p
Nature of error: Variable p is not bound
  LSP: Info: BidiCtx: Cls: Let expression
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent: Root
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: [?]
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: :: @
  LSP: Concave: Backpack: 
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new_tokens ::= whitespace | "," | "::" | "@"
root ::= new_tokens

Top 20 Logits:

:17.9957
#:15.7099
##:14.9006
let:14.2718
 :13.0964
    :13.0255
in:12.931
################:12.7514
   :12.6875
  :12.6723
####:12.4487
```:12.1927
/*:11.8183
########:11.7645
//:11.6537
                :11.5482
        :11.5371
       :11.3144
[:11.2626
-:10.9981
(*:10.9875

================
# Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)


































LSP: Prelude: Recieved string: ### List ###

# Add an element to the front of a list. #
let cons: (Int, [Int]) -> [Int] = fun x, xs -> x::xs in

# Determine the length of a list. #
let length: [Int] -> Int =
  fun xs ->
    case xs
    | [] => 0
    | _::xs => 1 + length(xs) end in

# Extract the first element of a list. #
let hd: [Int] -> Option =
  fun l ->
    case l
    | [] => None
    | x::xs => Some(x) end in

# Extract the rest of the list. #
let tl: [Int] -> [Int] =
  fun l ->
    case l
    | [] => []
    | x::xs => xs end in

# Determine if a list is empty. #
let is_empty: [Int] -> Bool =
  fun xs ->
    case xs
    | [] => true
    | _::_ => false end in

# Return the element at the index. #
let nth: ([Int], Int) -> Option =
  fun xs, n ->
    case xs, n
    | x::_, 0 => Some(x)
    | _::xs, n => nth(xs, n - 1)
    | [], _ => None end in

# Reverse a List. #
let rev: [Int] -> [Int] =
fun l -> 
let go: ([Int], [Int]) -> [Int] =
  fun xs, acc -> 
    case xs 
    | [] => acc 
    | x::xs => go(xs, x::acc) end in
go(l, []) in

# Check if two lists are equal #
let equal: ([Int], [Int]) -> Bool =
    fun p, xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => x == y && equal(xs, ys)
    | _ => false end
in

# Initialize a list with a given length using an initializer function #
let init: (Int, Int -> Int) -> [Int] =
    fun len, f ->
        let go: (Int, [Int]) -> [Int] =
        fun idx, xs ->
            if idx < len 
            then go(idx + 1, xs @ [f(idx)])   
            else xs
        in
        go(0, [])
in

# Reduce a list from the left. #
let fold_left: ((Int, Int) -> Int, Int, [Int]) -> Int =
  fun f, acc, xs ->
    case xs 
    | [] => acc
    | hd::tl => fold_left(f, f(acc, hd), tl) end in

# Reduce a list from the right. #
let fold_right: ((Int, Int) -> Int, [Int], Int) -> Int =
  fun f, xs, acc ->
    case xs
    | [] => acc
    | hd::tl => f(hd, fold_right(f, tl, acc)) end in


666
LSP: Prelude: String parsed successfully
LSP: Prelude: Info map generated successfully
Debug: true, Constrain: Types
LSP: Init: Recieved string: # Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)

































LSP: Init: String parsed successfully
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: >( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {go: ((?, ?) -> [?]), filter: (((Int -> Bool), [Int]) -> [Int]), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: 
  LSP: Info: ALL errors:Error in term:
  p
Nature of error: type ((Int -> Bool), [Int]) is not consistent with arrow type    
Error in term:
  p
Nature of error: Variable p is not bound    
Error in term:
  p
Nature of error: Variable p is not bound
  LSP: Info: BidiCtx: Cls: Let expression
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent: Root
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: [?]
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: :: @
  LSP: Concave: Backpack: 
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new_tokens ::= whitespace | "," | "::" | "@"
root ::= new_tokens

Top 20 Logits:

:18.0143
#:15.7114
##:14.9028
let:14.2975
 :13.1167
    :13.0335
in:12.9125
################:12.7707
   :12.7122
  :12.6881
####:12.4566
```:12.1953
/*:11.8221
########:11.7717
//:11.6535
                :11.5625
        :11.5439
       :11.3284
[:11.2555
(*:11.0037
-:10.9868

================
# Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)



































LSP: Prelude: Recieved string: ### List ###

# Add an element to the front of a list. #
let cons: (Int, [Int]) -> [Int] = fun x, xs -> x::xs in

# Determine the length of a list. #
let length: [Int] -> Int =
  fun xs ->
    case xs
    | [] => 0
    | _::xs => 1 + length(xs) end in

# Extract the first element of a list. #
let hd: [Int] -> Option =
  fun l ->
    case l
    | [] => None
    | x::xs => Some(x) end in

# Extract the rest of the list. #
let tl: [Int] -> [Int] =
  fun l ->
    case l
    | [] => []
    | x::xs => xs end in

# Determine if a list is empty. #
let is_empty: [Int] -> Bool =
  fun xs ->
    case xs
    | [] => true
    | _::_ => false end in

# Return the element at the index. #
let nth: ([Int], Int) -> Option =
  fun xs, n ->
    case xs, n
    | x::_, 0 => Some(x)
    | _::xs, n => nth(xs, n - 1)
    | [], _ => None end in

# Reverse a List. #
let rev: [Int] -> [Int] =
fun l -> 
let go: ([Int], [Int]) -> [Int] =
  fun xs, acc -> 
    case xs 
    | [] => acc 
    | x::xs => go(xs, x::acc) end in
go(l, []) in

# Check if two lists are equal #
let equal: ([Int], [Int]) -> Bool =
    fun p, xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => x == y && equal(xs, ys)
    | _ => false end
in

# Initialize a list with a given length using an initializer function #
let init: (Int, Int -> Int) -> [Int] =
    fun len, f ->
        let go: (Int, [Int]) -> [Int] =
        fun idx, xs ->
            if idx < len 
            then go(idx + 1, xs @ [f(idx)])   
            else xs
        in
        go(0, [])
in

# Reduce a list from the left. #
let fold_left: ((Int, Int) -> Int, Int, [Int]) -> Int =
  fun f, acc, xs ->
    case xs 
    | [] => acc
    | hd::tl => fold_left(f, f(acc, hd), tl) end in

# Reduce a list from the right. #
let fold_right: ((Int, Int) -> Int, [Int], Int) -> Int =
  fun f, xs, acc ->
    case xs
    | [] => acc
    | hd::tl => f(hd, fold_right(f, tl, acc)) end in


666
LSP: Prelude: String parsed successfully
LSP: Prelude: Info map generated successfully
Debug: true, Constrain: Types
LSP: Init: Recieved string: # Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)


































LSP: Init: String parsed successfully
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: >( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {go: ((?, ?) -> [?]), filter: (((Int -> Bool), [Int]) -> [Int]), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: 
  LSP: Info: ALL errors:Error in term:
  p
Nature of error: type ((Int -> Bool), [Int]) is not consistent with arrow type    
Error in term:
  p
Nature of error: Variable p is not bound    
Error in term:
  p
Nature of error: Variable p is not bound
  LSP: Info: BidiCtx: Cls: Let expression
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent: Root
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: [?]
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: :: @
  LSP: Concave: Backpack: 
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new_tokens ::= whitespace | "," | "::" | "@"
root ::= new_tokens

Top 20 Logits:

:18.0358
#:15.7146
##:14.9068
let:14.3242
 :13.1366
    :13.0429
in:12.8969
################:12.7884
   :12.7342
  :12.7031
####:12.4694
```:12.1995
/*:11.8342
########:11.7879
//:11.6555
                :11.5725
        :11.5499
       :11.3388
[:11.2483
(*:11.0271
fun:10.9852

================
# Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)




































LSP: Prelude: Recieved string: ### List ###

# Add an element to the front of a list. #
let cons: (Int, [Int]) -> [Int] = fun x, xs -> x::xs in

# Determine the length of a list. #
let length: [Int] -> Int =
  fun xs ->
    case xs
    | [] => 0
    | _::xs => 1 + length(xs) end in

# Extract the first element of a list. #
let hd: [Int] -> Option =
  fun l ->
    case l
    | [] => None
    | x::xs => Some(x) end in

# Extract the rest of the list. #
let tl: [Int] -> [Int] =
  fun l ->
    case l
    | [] => []
    | x::xs => xs end in

# Determine if a list is empty. #
let is_empty: [Int] -> Bool =
  fun xs ->
    case xs
    | [] => true
    | _::_ => false end in

# Return the element at the index. #
let nth: ([Int], Int) -> Option =
  fun xs, n ->
    case xs, n
    | x::_, 0 => Some(x)
    | _::xs, n => nth(xs, n - 1)
    | [], _ => None end in

# Reverse a List. #
let rev: [Int] -> [Int] =
fun l -> 
let go: ([Int], [Int]) -> [Int] =
  fun xs, acc -> 
    case xs 
    | [] => acc 
    | x::xs => go(xs, x::acc) end in
go(l, []) in

# Check if two lists are equal #
let equal: ([Int], [Int]) -> Bool =
    fun p, xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => x == y && equal(xs, ys)
    | _ => false end
in

# Initialize a list with a given length using an initializer function #
let init: (Int, Int -> Int) -> [Int] =
    fun len, f ->
        let go: (Int, [Int]) -> [Int] =
        fun idx, xs ->
            if idx < len 
            then go(idx + 1, xs @ [f(idx)])   
            else xs
        in
        go(0, [])
in

# Reduce a list from the left. #
let fold_left: ((Int, Int) -> Int, Int, [Int]) -> Int =
  fun f, acc, xs ->
    case xs 
    | [] => acc
    | hd::tl => fold_left(f, f(acc, hd), tl) end in

# Reduce a list from the right. #
let fold_right: ((Int, Int) -> Int, [Int], Int) -> Int =
  fun f, xs, acc ->
    case xs
    | [] => acc
    | hd::tl => f(hd, fold_right(f, tl, acc)) end in


666
LSP: Prelude: String parsed successfully
LSP: Prelude: Info map generated successfully
Debug: true, Constrain: Types
LSP: Init: Recieved string: # Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)



































LSP: Init: String parsed successfully
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: >( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {go: ((?, ?) -> [?]), filter: (((Int -> Bool), [Int]) -> [Int]), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: 
  LSP: Info: ALL errors:Error in term:
  p
Nature of error: Variable p is not bound    
Error in term:
  p
Nature of error: type ((Int -> Bool), [Int]) is not consistent with arrow type    
Error in term:
  p
Nature of error: Variable p is not bound
  LSP: Info: BidiCtx: Cls: Let expression
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent: Root
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: [?]
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: :: @
  LSP: Concave: Backpack: 
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new_tokens ::= whitespace | "," | "::" | "@"
root ::= new_tokens

Top 20 Logits:

:18.0583
#:15.7219
##:14.9086
let:14.3495
 :13.1478
    :13.0443
in:12.8912
################:12.7985
   :12.7439
  :12.7091
####:12.4839
```:12.2061
/*:11.8488
########:11.8051
//:11.6569
                :11.5731
        :11.5501
       :11.3405
[:11.2409
(*:11.0527
fun:10.9873

================
# Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)





































LSP: Prelude: Recieved string: ### List ###

# Add an element to the front of a list. #
let cons: (Int, [Int]) -> [Int] = fun x, xs -> x::xs in

# Determine the length of a list. #
let length: [Int] -> Int =
  fun xs ->
    case xs
    | [] => 0
    | _::xs => 1 + length(xs) end in

# Extract the first element of a list. #
let hd: [Int] -> Option =
  fun l ->
    case l
    | [] => None
    | x::xs => Some(x) end in

# Extract the rest of the list. #
let tl: [Int] -> [Int] =
  fun l ->
    case l
    | [] => []
    | x::xs => xs end in

# Determine if a list is empty. #
let is_empty: [Int] -> Bool =
  fun xs ->
    case xs
    | [] => true
    | _::_ => false end in

# Return the element at the index. #
let nth: ([Int], Int) -> Option =
  fun xs, n ->
    case xs, n
    | x::_, 0 => Some(x)
    | _::xs, n => nth(xs, n - 1)
    | [], _ => None end in

# Reverse a List. #
let rev: [Int] -> [Int] =
fun l -> 
let go: ([Int], [Int]) -> [Int] =
  fun xs, acc -> 
    case xs 
    | [] => acc 
    | x::xs => go(xs, x::acc) end in
go(l, []) in

# Check if two lists are equal #
let equal: ([Int], [Int]) -> Bool =
    fun p, xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => x == y && equal(xs, ys)
    | _ => false end
in

# Initialize a list with a given length using an initializer function #
let init: (Int, Int -> Int) -> [Int] =
    fun len, f ->
        let go: (Int, [Int]) -> [Int] =
        fun idx, xs ->
            if idx < len 
            then go(idx + 1, xs @ [f(idx)])   
            else xs
        in
        go(0, [])
in

# Reduce a list from the left. #
let fold_left: ((Int, Int) -> Int, Int, [Int]) -> Int =
  fun f, acc, xs ->
    case xs 
    | [] => acc
    | hd::tl => fold_left(f, f(acc, hd), tl) end in

# Reduce a list from the right. #
let fold_right: ((Int, Int) -> Int, [Int], Int) -> Int =
  fun f, xs, acc ->
    case xs
    | [] => acc
    | hd::tl => f(hd, fold_right(f, tl, acc)) end in


666
LSP: Prelude: String parsed successfully
LSP: Prelude: Info map generated successfully
Debug: true, Constrain: Types
LSP: Init: Recieved string: # Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)




































LSP: Init: String parsed successfully
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: >( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {go: ((?, ?) -> [?]), filter: (((Int -> Bool), [Int]) -> [Int]), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: 
  LSP: Info: ALL errors:Error in term:
  p
Nature of error: type ((Int -> Bool), [Int]) is not consistent with arrow type    
Error in term:
  p
Nature of error: Variable p is not bound    
Error in term:
  p
Nature of error: Variable p is not bound
  LSP: Info: BidiCtx: Cls: Let expression
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent: Root
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: [?]
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: :: @
  LSP: Concave: Backpack: 
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new_tokens ::= whitespace | "," | "::" | "@"
root ::= new_tokens

Top 20 Logits:

:18.0754
#:15.728
##:14.9005
let:14.3649
 :13.1439
    :13.0314
in:12.8934
################:12.7952
   :12.736
  :12.7002
####:12.4922
```:12.208
/*:11.8603
########:11.8109
//:11.6549
                :11.5598
        :11.5398
       :11.3294
[:11.2282
(*:11.0731
fun:10.9797

================
# Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)






































LSP: Prelude: Recieved string: ### List ###

# Add an element to the front of a list. #
let cons: (Int, [Int]) -> [Int] = fun x, xs -> x::xs in

# Determine the length of a list. #
let length: [Int] -> Int =
  fun xs ->
    case xs
    | [] => 0
    | _::xs => 1 + length(xs) end in

# Extract the first element of a list. #
let hd: [Int] -> Option =
  fun l ->
    case l
    | [] => None
    | x::xs => Some(x) end in

# Extract the rest of the list. #
let tl: [Int] -> [Int] =
  fun l ->
    case l
    | [] => []
    | x::xs => xs end in

# Determine if a list is empty. #
let is_empty: [Int] -> Bool =
  fun xs ->
    case xs
    | [] => true
    | _::_ => false end in

# Return the element at the index. #
let nth: ([Int], Int) -> Option =
  fun xs, n ->
    case xs, n
    | x::_, 0 => Some(x)
    | _::xs, n => nth(xs, n - 1)
    | [], _ => None end in

# Reverse a List. #
let rev: [Int] -> [Int] =
fun l -> 
let go: ([Int], [Int]) -> [Int] =
  fun xs, acc -> 
    case xs 
    | [] => acc 
    | x::xs => go(xs, x::acc) end in
go(l, []) in

# Check if two lists are equal #
let equal: ([Int], [Int]) -> Bool =
    fun p, xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => x == y && equal(xs, ys)
    | _ => false end
in

# Initialize a list with a given length using an initializer function #
let init: (Int, Int -> Int) -> [Int] =
    fun len, f ->
        let go: (Int, [Int]) -> [Int] =
        fun idx, xs ->
            if idx < len 
            then go(idx + 1, xs @ [f(idx)])   
            else xs
        in
        go(0, [])
in

# Reduce a list from the left. #
let fold_left: ((Int, Int) -> Int, Int, [Int]) -> Int =
  fun f, acc, xs ->
    case xs 
    | [] => acc
    | hd::tl => fold_left(f, f(acc, hd), tl) end in

# Reduce a list from the right. #
let fold_right: ((Int, Int) -> Int, [Int], Int) -> Int =
  fun f, xs, acc ->
    case xs
    | [] => acc
    | hd::tl => f(hd, fold_right(f, tl, acc)) end in


666
LSP: Prelude: String parsed successfully
LSP: Prelude: Info map generated successfully
Debug: true, Constrain: Types
LSP: Init: Recieved string: # Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)





































LSP: Init: String parsed successfully
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: >( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {go: ((?, ?) -> [?]), filter: (((Int -> Bool), [Int]) -> [Int]), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: 
  LSP: Info: ALL errors:Error in term:
  p
Nature of error: type ((Int -> Bool), [Int]) is not consistent with arrow type    
Error in term:
  p
Nature of error: Variable p is not bound    
Error in term:
  p
Nature of error: Variable p is not bound
  LSP: Info: BidiCtx: Cls: Let expression
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent: Root
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: [?]
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: :: @
  LSP: Concave: Backpack: 
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new_tokens ::= whitespace | "," | "::" | "@"
root ::= new_tokens

Top 20 Logits:

:18.0842
#:15.7267
##:14.8804
let:14.3652
 :13.1281
    :13.0092
in:12.8867
################:12.779
   :12.7157
  :12.6809
####:12.4894
```:12.1987
/*:11.8669
########:11.8011
//:11.646
                :11.5344
        :11.5215
       :11.3075
[:11.2069
(*:11.0837
fun:10.9665

================
# Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)







































LSP: Prelude: Recieved string: ### List ###

# Add an element to the front of a list. #
let cons: (Int, [Int]) -> [Int] = fun x, xs -> x::xs in

# Determine the length of a list. #
let length: [Int] -> Int =
  fun xs ->
    case xs
    | [] => 0
    | _::xs => 1 + length(xs) end in

# Extract the first element of a list. #
let hd: [Int] -> Option =
  fun l ->
    case l
    | [] => None
    | x::xs => Some(x) end in

# Extract the rest of the list. #
let tl: [Int] -> [Int] =
  fun l ->
    case l
    | [] => []
    | x::xs => xs end in

# Determine if a list is empty. #
let is_empty: [Int] -> Bool =
  fun xs ->
    case xs
    | [] => true
    | _::_ => false end in

# Return the element at the index. #
let nth: ([Int], Int) -> Option =
  fun xs, n ->
    case xs, n
    | x::_, 0 => Some(x)
    | _::xs, n => nth(xs, n - 1)
    | [], _ => None end in

# Reverse a List. #
let rev: [Int] -> [Int] =
fun l -> 
let go: ([Int], [Int]) -> [Int] =
  fun xs, acc -> 
    case xs 
    | [] => acc 
    | x::xs => go(xs, x::acc) end in
go(l, []) in

# Check if two lists are equal #
let equal: ([Int], [Int]) -> Bool =
    fun p, xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => x == y && equal(xs, ys)
    | _ => false end
in

# Initialize a list with a given length using an initializer function #
let init: (Int, Int -> Int) -> [Int] =
    fun len, f ->
        let go: (Int, [Int]) -> [Int] =
        fun idx, xs ->
            if idx < len 
            then go(idx + 1, xs @ [f(idx)])   
            else xs
        in
        go(0, [])
in

# Reduce a list from the left. #
let fold_left: ((Int, Int) -> Int, Int, [Int]) -> Int =
  fun f, acc, xs ->
    case xs 
    | [] => acc
    | hd::tl => fold_left(f, f(acc, hd), tl) end in

# Reduce a list from the right. #
let fold_right: ((Int, Int) -> Int, [Int], Int) -> Int =
  fun f, xs, acc ->
    case xs
    | [] => acc
    | hd::tl => f(hd, fold_right(f, tl, acc)) end in


666
LSP: Prelude: String parsed successfully
LSP: Prelude: Info map generated successfully
Debug: true, Constrain: Types
LSP: Init: Recieved string: # Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)






































LSP: Init: String parsed successfully
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: >( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {go: ((?, ?) -> [?]), filter: (((Int -> Bool), [Int]) -> [Int]), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: 
  LSP: Info: ALL errors:Error in term:
  p
Nature of error: Variable p is not bound    
Error in term:
  p
Nature of error: Variable p is not bound    
Error in term:
  p
Nature of error: type ((Int -> Bool), [Int]) is not consistent with arrow type
  LSP: Info: BidiCtx: Cls: Let expression
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent: Root
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: [?]
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: :: @
  LSP: Concave: Backpack: 
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new_tokens ::= whitespace | "," | "::" | "@"
root ::= new_tokens

Top 20 Logits:

:18.087
#:15.7157
##:14.8575
let:14.3527
 :13.1103
    :12.9891
in:12.8525
################:12.7572
   :12.6946
  :12.6602
####:12.4788
```:12.1787
/*:11.8707
########:11.7843
//:11.6286
                :11.503
        :11.5025
       :11.282
[:11.1806
(*:11.0837
fun:10.9541

================
# Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)








































LSP: Prelude: Recieved string: ### List ###

# Add an element to the front of a list. #
let cons: (Int, [Int]) -> [Int] = fun x, xs -> x::xs in

# Determine the length of a list. #
let length: [Int] -> Int =
  fun xs ->
    case xs
    | [] => 0
    | _::xs => 1 + length(xs) end in

# Extract the first element of a list. #
let hd: [Int] -> Option =
  fun l ->
    case l
    | [] => None
    | x::xs => Some(x) end in

# Extract the rest of the list. #
let tl: [Int] -> [Int] =
  fun l ->
    case l
    | [] => []
    | x::xs => xs end in

# Determine if a list is empty. #
let is_empty: [Int] -> Bool =
  fun xs ->
    case xs
    | [] => true
    | _::_ => false end in

# Return the element at the index. #
let nth: ([Int], Int) -> Option =
  fun xs, n ->
    case xs, n
    | x::_, 0 => Some(x)
    | _::xs, n => nth(xs, n - 1)
    | [], _ => None end in

# Reverse a List. #
let rev: [Int] -> [Int] =
fun l -> 
let go: ([Int], [Int]) -> [Int] =
  fun xs, acc -> 
    case xs 
    | [] => acc 
    | x::xs => go(xs, x::acc) end in
go(l, []) in

# Check if two lists are equal #
let equal: ([Int], [Int]) -> Bool =
    fun p, xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => x == y && equal(xs, ys)
    | _ => false end
in

# Initialize a list with a given length using an initializer function #
let init: (Int, Int -> Int) -> [Int] =
    fun len, f ->
        let go: (Int, [Int]) -> [Int] =
        fun idx, xs ->
            if idx < len 
            then go(idx + 1, xs @ [f(idx)])   
            else xs
        in
        go(0, [])
in

# Reduce a list from the left. #
let fold_left: ((Int, Int) -> Int, Int, [Int]) -> Int =
  fun f, acc, xs ->
    case xs 
    | [] => acc
    | hd::tl => fold_left(f, f(acc, hd), tl) end in

# Reduce a list from the right. #
let fold_right: ((Int, Int) -> Int, [Int], Int) -> Int =
  fun f, xs, acc ->
    case xs
    | [] => acc
    | hd::tl => f(hd, fold_right(f, tl, acc)) end in


666
LSP: Prelude: String parsed successfully
LSP: Prelude: Info map generated successfully
Debug: true, Constrain: Types
LSP: Init: Recieved string: # Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)







































LSP: Init: String parsed successfully
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: >( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {go: ((?, ?) -> [?]), filter: (((Int -> Bool), [Int]) -> [Int]), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: 
  LSP: Info: ALL errors:Error in term:
  p
Nature of error: Variable p is not bound    
Error in term:
  p
Nature of error: type ((Int -> Bool), [Int]) is not consistent with arrow type    
Error in term:
  p
Nature of error: Variable p is not bound
  LSP: Info: BidiCtx: Cls: Let expression
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent: Root
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: [?]
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: :: @
  LSP: Concave: Backpack: 
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new_tokens ::= whitespace | "," | "::" | "@"
root ::= new_tokens

Top 20 Logits:

:18.0888
#:15.6985
##:14.8429
let:14.3335
 :13.0984
    :12.9779
in:12.7929
################:12.7359
   :12.6815
  :12.6444
####:12.4669
```:12.1527
/*:11.8748
########:11.7714
//:11.6072
        :11.4875
                :11.4742
       :11.2603
[:11.1564
(*:11.0807
fun:10.9468

================
# Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)









































LSP: Prelude: Recieved string: ### List ###

# Add an element to the front of a list. #
let cons: (Int, [Int]) -> [Int] = fun x, xs -> x::xs in

# Determine the length of a list. #
let length: [Int] -> Int =
  fun xs ->
    case xs
    | [] => 0
    | _::xs => 1 + length(xs) end in

# Extract the first element of a list. #
let hd: [Int] -> Option =
  fun l ->
    case l
    | [] => None
    | x::xs => Some(x) end in

# Extract the rest of the list. #
let tl: [Int] -> [Int] =
  fun l ->
    case l
    | [] => []
    | x::xs => xs end in

# Determine if a list is empty. #
let is_empty: [Int] -> Bool =
  fun xs ->
    case xs
    | [] => true
    | _::_ => false end in

# Return the element at the index. #
let nth: ([Int], Int) -> Option =
  fun xs, n ->
    case xs, n
    | x::_, 0 => Some(x)
    | _::xs, n => nth(xs, n - 1)
    | [], _ => None end in

# Reverse a List. #
let rev: [Int] -> [Int] =
fun l -> 
let go: ([Int], [Int]) -> [Int] =
  fun xs, acc -> 
    case xs 
    | [] => acc 
    | x::xs => go(xs, x::acc) end in
go(l, []) in

# Check if two lists are equal #
let equal: ([Int], [Int]) -> Bool =
    fun p, xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => x == y && equal(xs, ys)
    | _ => false end
in

# Initialize a list with a given length using an initializer function #
let init: (Int, Int -> Int) -> [Int] =
    fun len, f ->
        let go: (Int, [Int]) -> [Int] =
        fun idx, xs ->
            if idx < len 
            then go(idx + 1, xs @ [f(idx)])   
            else xs
        in
        go(0, [])
in

# Reduce a list from the left. #
let fold_left: ((Int, Int) -> Int, Int, [Int]) -> Int =
  fun f, acc, xs ->
    case xs 
    | [] => acc
    | hd::tl => fold_left(f, f(acc, hd), tl) end in

# Reduce a list from the right. #
let fold_right: ((Int, Int) -> Int, [Int], Int) -> Int =
  fun f, xs, acc ->
    case xs
    | [] => acc
    | hd::tl => f(hd, fold_right(f, tl, acc)) end in


666
LSP: Prelude: String parsed successfully
LSP: Prelude: Info map generated successfully
Debug: true, Constrain: Types
LSP: Init: Recieved string: # Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)








































LSP: Init: String parsed successfully
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: >( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {go: ((?, ?) -> [?]), filter: (((Int -> Bool), [Int]) -> [Int]), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: 
  LSP: Info: ALL errors:Error in term:
  p
Nature of error: Variable p is not bound    
Error in term:
  p
Nature of error: Variable p is not bound    
Error in term:
  p
Nature of error: type ((Int -> Bool), [Int]) is not consistent with arrow type
  LSP: Info: BidiCtx: Cls: Let expression
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent: Root
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: [?]
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: :: @
  LSP: Concave: Backpack: 
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new_tokens ::= whitespace | "," | "::" | "@"
root ::= new_tokens

Top 20 Logits:

:18.0943
#:15.6818
##:14.8396
let:14.3126
 :13.0936
    :12.9708
in:12.7354
################:12.7177
   :12.6764
  :12.6339
####:12.458
```:12.1294
/*:11.8789
########:11.7653
//:11.5869
        :11.4739
                :11.4524
       :11.2446
[:11.1408
(*:11.0852
fun:10.9465

================
# Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)










































LSP: Prelude: Recieved string: ### List ###

# Add an element to the front of a list. #
let cons: (Int, [Int]) -> [Int] = fun x, xs -> x::xs in

# Determine the length of a list. #
let length: [Int] -> Int =
  fun xs ->
    case xs
    | [] => 0
    | _::xs => 1 + length(xs) end in

# Extract the first element of a list. #
let hd: [Int] -> Option =
  fun l ->
    case l
    | [] => None
    | x::xs => Some(x) end in

# Extract the rest of the list. #
let tl: [Int] -> [Int] =
  fun l ->
    case l
    | [] => []
    | x::xs => xs end in

# Determine if a list is empty. #
let is_empty: [Int] -> Bool =
  fun xs ->
    case xs
    | [] => true
    | _::_ => false end in

# Return the element at the index. #
let nth: ([Int], Int) -> Option =
  fun xs, n ->
    case xs, n
    | x::_, 0 => Some(x)
    | _::xs, n => nth(xs, n - 1)
    | [], _ => None end in

# Reverse a List. #
let rev: [Int] -> [Int] =
fun l -> 
let go: ([Int], [Int]) -> [Int] =
  fun xs, acc -> 
    case xs 
    | [] => acc 
    | x::xs => go(xs, x::acc) end in
go(l, []) in

# Check if two lists are equal #
let equal: ([Int], [Int]) -> Bool =
    fun p, xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => x == y && equal(xs, ys)
    | _ => false end
in

# Initialize a list with a given length using an initializer function #
let init: (Int, Int -> Int) -> [Int] =
    fun len, f ->
        let go: (Int, [Int]) -> [Int] =
        fun idx, xs ->
            if idx < len 
            then go(idx + 1, xs @ [f(idx)])   
            else xs
        in
        go(0, [])
in

# Reduce a list from the left. #
let fold_left: ((Int, Int) -> Int, Int, [Int]) -> Int =
  fun f, acc, xs ->
    case xs 
    | [] => acc
    | hd::tl => fold_left(f, f(acc, hd), tl) end in

# Reduce a list from the right. #
let fold_right: ((Int, Int) -> Int, [Int], Int) -> Int =
  fun f, xs, acc ->
    case xs
    | [] => acc
    | hd::tl => f(hd, fold_right(f, tl, acc)) end in


666
LSP: Prelude: String parsed successfully
LSP: Prelude: Info map generated successfully
Debug: true, Constrain: Types
LSP: Init: Recieved string: # Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)









































LSP: Init: String parsed successfully
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: >( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {go: ((?, ?) -> [?]), filter: (((Int -> Bool), [Int]) -> [Int]), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: 
  LSP: Info: ALL errors:Error in term:
  p
Nature of error: type ((Int -> Bool), [Int]) is not consistent with arrow type    
Error in term:
  p
Nature of error: Variable p is not bound    
Error in term:
  p
Nature of error: Variable p is not bound
  LSP: Info: BidiCtx: Cls: Let expression
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent: Root
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: [?]
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: :: @
  LSP: Concave: Backpack: 
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new_tokens ::= whitespace | "," | "::" | "@"
root ::= new_tokens

Top 20 Logits:

:18.1024
#:15.6703
##:14.8378
let:14.2926
 :13.0902
    :12.9564
in:12.7067
################:12.6988
   :12.6731
  :12.6219
####:12.4514
```:12.1159
/*:11.8809
########:11.7563
//:11.5698
        :11.4555
                :11.4353
       :11.2313
[:11.134
(*:11.0975
fun:10.9462

================
# Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)











































LSP: Prelude: Recieved string: ### List ###

# Add an element to the front of a list. #
let cons: (Int, [Int]) -> [Int] = fun x, xs -> x::xs in

# Determine the length of a list. #
let length: [Int] -> Int =
  fun xs ->
    case xs
    | [] => 0
    | _::xs => 1 + length(xs) end in

# Extract the first element of a list. #
let hd: [Int] -> Option =
  fun l ->
    case l
    | [] => None
    | x::xs => Some(x) end in

# Extract the rest of the list. #
let tl: [Int] -> [Int] =
  fun l ->
    case l
    | [] => []
    | x::xs => xs end in

# Determine if a list is empty. #
let is_empty: [Int] -> Bool =
  fun xs ->
    case xs
    | [] => true
    | _::_ => false end in

# Return the element at the index. #
let nth: ([Int], Int) -> Option =
  fun xs, n ->
    case xs, n
    | x::_, 0 => Some(x)
    | _::xs, n => nth(xs, n - 1)
    | [], _ => None end in

# Reverse a List. #
let rev: [Int] -> [Int] =
fun l -> 
let go: ([Int], [Int]) -> [Int] =
  fun xs, acc -> 
    case xs 
    | [] => acc 
    | x::xs => go(xs, x::acc) end in
go(l, []) in

# Check if two lists are equal #
let equal: ([Int], [Int]) -> Bool =
    fun p, xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => x == y && equal(xs, ys)
    | _ => false end
in

# Initialize a list with a given length using an initializer function #
let init: (Int, Int -> Int) -> [Int] =
    fun len, f ->
        let go: (Int, [Int]) -> [Int] =
        fun idx, xs ->
            if idx < len 
            then go(idx + 1, xs @ [f(idx)])   
            else xs
        in
        go(0, [])
in

# Reduce a list from the left. #
let fold_left: ((Int, Int) -> Int, Int, [Int]) -> Int =
  fun f, acc, xs ->
    case xs 
    | [] => acc
    | hd::tl => fold_left(f, f(acc, hd), tl) end in

# Reduce a list from the right. #
let fold_right: ((Int, Int) -> Int, [Int], Int) -> Int =
  fun f, xs, acc ->
    case xs
    | [] => acc
    | hd::tl => f(hd, fold_right(f, tl, acc)) end in


666
LSP: Prelude: String parsed successfully
LSP: Prelude: Info map generated successfully
Debug: true, Constrain: Types
LSP: Init: Recieved string: # Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)










































LSP: Init: String parsed successfully
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: >( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {go: ((?, ?) -> [?]), filter: (((Int -> Bool), [Int]) -> [Int]), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: 
  LSP: Info: ALL errors:Error in term:
  p
Nature of error: type ((Int -> Bool), [Int]) is not consistent with arrow type    
Error in term:
  p
Nature of error: Variable p is not bound    
Error in term:
  p
Nature of error: Variable p is not bound
  LSP: Info: BidiCtx: Cls: Let expression
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent: Root
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: [?]
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: :: @
  LSP: Concave: Backpack: 
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new_tokens ::= whitespace | "," | "::" | "@"
root ::= new_tokens

Top 20 Logits:

:18.1088
#:15.6634
##:14.824
let:14.2729
 :13.0813
    :12.9271
in:12.7128
################:12.6716
   :12.6636
  :12.6024
####:12.4413
```:12.1097
/*:11.8824
########:11.7299
//:11.5572
        :11.4288
                :11.4199
       :11.2157
[:11.1297
(*:11.1098
fun:10.9374

================
# Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)












































LSP: Prelude: Recieved string: ### List ###

# Add an element to the front of a list. #
let cons: (Int, [Int]) -> [Int] = fun x, xs -> x::xs in

# Determine the length of a list. #
let length: [Int] -> Int =
  fun xs ->
    case xs
    | [] => 0
    | _::xs => 1 + length(xs) end in

# Extract the first element of a list. #
let hd: [Int] -> Option =
  fun l ->
    case l
    | [] => None
    | x::xs => Some(x) end in

# Extract the rest of the list. #
let tl: [Int] -> [Int] =
  fun l ->
    case l
    | [] => []
    | x::xs => xs end in

# Determine if a list is empty. #
let is_empty: [Int] -> Bool =
  fun xs ->
    case xs
    | [] => true
    | _::_ => false end in

# Return the element at the index. #
let nth: ([Int], Int) -> Option =
  fun xs, n ->
    case xs, n
    | x::_, 0 => Some(x)
    | _::xs, n => nth(xs, n - 1)
    | [], _ => None end in

# Reverse a List. #
let rev: [Int] -> [Int] =
fun l -> 
let go: ([Int], [Int]) -> [Int] =
  fun xs, acc -> 
    case xs 
    | [] => acc 
    | x::xs => go(xs, x::acc) end in
go(l, []) in

# Check if two lists are equal #
let equal: ([Int], [Int]) -> Bool =
    fun p, xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => x == y && equal(xs, ys)
    | _ => false end
in

# Initialize a list with a given length using an initializer function #
let init: (Int, Int -> Int) -> [Int] =
    fun len, f ->
        let go: (Int, [Int]) -> [Int] =
        fun idx, xs ->
            if idx < len 
            then go(idx + 1, xs @ [f(idx)])   
            else xs
        in
        go(0, [])
in

# Reduce a list from the left. #
let fold_left: ((Int, Int) -> Int, Int, [Int]) -> Int =
  fun f, acc, xs ->
    case xs 
    | [] => acc
    | hd::tl => fold_left(f, f(acc, hd), tl) end in

# Reduce a list from the right. #
let fold_right: ((Int, Int) -> Int, [Int], Int) -> Int =
  fun f, xs, acc ->
    case xs
    | [] => acc
    | hd::tl => f(hd, fold_right(f, tl, acc)) end in


666
LSP: Prelude: String parsed successfully
LSP: Prelude: Info map generated successfully
Debug: true, Constrain: Types
LSP: Init: Recieved string: # Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)











































LSP: Init: String parsed successfully
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: >( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {go: ((?, ?) -> [?]), filter: (((Int -> Bool), [Int]) -> [Int]), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: 
  LSP: Info: ALL errors:Error in term:
  p
Nature of error: type ((Int -> Bool), [Int]) is not consistent with arrow type    
Error in term:
  p
Nature of error: Variable p is not bound    
Error in term:
  p
Nature of error: Variable p is not bound
  LSP: Info: BidiCtx: Cls: Let expression
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent: Root
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: [?]
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: :: @
  LSP: Concave: Backpack: 
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new_tokens ::= whitespace | "," | "::" | "@"
root ::= new_tokens

Top 20 Logits:

:18.1113
#:15.6567
##:14.7936
let:14.2503
 :13.0652
    :12.8858
in:12.7324
   :12.6447
################:12.6346
  :12.576
####:12.4235
```:12.1049
/*:11.8849
########:11.6809
//:11.5468
                :11.4054
        :11.3967
       :11.1959
[:11.1243
(*:11.1137
fun:10.9203

================
# Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)













































LSP: Prelude: Recieved string: ### List ###

# Add an element to the front of a list. #
let cons: (Int, [Int]) -> [Int] = fun x, xs -> x::xs in

# Determine the length of a list. #
let length: [Int] -> Int =
  fun xs ->
    case xs
    | [] => 0
    | _::xs => 1 + length(xs) end in

# Extract the first element of a list. #
let hd: [Int] -> Option =
  fun l ->
    case l
    | [] => None
    | x::xs => Some(x) end in

# Extract the rest of the list. #
let tl: [Int] -> [Int] =
  fun l ->
    case l
    | [] => []
    | x::xs => xs end in

# Determine if a list is empty. #
let is_empty: [Int] -> Bool =
  fun xs ->
    case xs
    | [] => true
    | _::_ => false end in

# Return the element at the index. #
let nth: ([Int], Int) -> Option =
  fun xs, n ->
    case xs, n
    | x::_, 0 => Some(x)
    | _::xs, n => nth(xs, n - 1)
    | [], _ => None end in

# Reverse a List. #
let rev: [Int] -> [Int] =
fun l -> 
let go: ([Int], [Int]) -> [Int] =
  fun xs, acc -> 
    case xs 
    | [] => acc 
    | x::xs => go(xs, x::acc) end in
go(l, []) in

# Check if two lists are equal #
let equal: ([Int], [Int]) -> Bool =
    fun p, xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => x == y && equal(xs, ys)
    | _ => false end
in

# Initialize a list with a given length using an initializer function #
let init: (Int, Int -> Int) -> [Int] =
    fun len, f ->
        let go: (Int, [Int]) -> [Int] =
        fun idx, xs ->
            if idx < len 
            then go(idx + 1, xs @ [f(idx)])   
            else xs
        in
        go(0, [])
in

# Reduce a list from the left. #
let fold_left: ((Int, Int) -> Int, Int, [Int]) -> Int =
  fun f, acc, xs ->
    case xs 
    | [] => acc
    | hd::tl => fold_left(f, f(acc, hd), tl) end in

# Reduce a list from the right. #
let fold_right: ((Int, Int) -> Int, [Int], Int) -> Int =
  fun f, xs, acc ->
    case xs
    | [] => acc
    | hd::tl => f(hd, fold_right(f, tl, acc)) end in


666
LSP: Prelude: String parsed successfully
LSP: Prelude: Info map generated successfully
Debug: true, Constrain: Types
LSP: Init: Recieved string: # Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)












































LSP: Init: String parsed successfully
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: >( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {go: ((?, ?) -> [?]), filter: (((Int -> Bool), [Int]) -> [Int]), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: 
  LSP: Info: ALL errors:Error in term:
  p
Nature of error: Variable p is not bound    
Error in term:
  p
Nature of error: Variable p is not bound    
Error in term:
  p
Nature of error: type ((Int -> Bool), [Int]) is not consistent with arrow type
  LSP: Info: BidiCtx: Cls: Let expression
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent: Root
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: [?]
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: :: @
  LSP: Concave: Backpack: 
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new_tokens ::= whitespace | "," | "::" | "@"
root ::= new_tokens

Top 20 Logits:

:18.1126
#:15.646
##:14.761
let:14.2262
 :13.0488
    :12.8465
in:12.7288
   :12.622
################:12.5989
  :12.5508
####:12.4032
```:12.097
/*:11.8917
########:11.6248
//:11.5372
                :11.3917
        :11.368
       :11.1745
[:11.122
(*:11.1065
-:10.922

================
# Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)














































LSP: Prelude: Recieved string: ### List ###

# Add an element to the front of a list. #
let cons: (Int, [Int]) -> [Int] = fun x, xs -> x::xs in

# Determine the length of a list. #
let length: [Int] -> Int =
  fun xs ->
    case xs
    | [] => 0
    | _::xs => 1 + length(xs) end in

# Extract the first element of a list. #
let hd: [Int] -> Option =
  fun l ->
    case l
    | [] => None
    | x::xs => Some(x) end in

# Extract the rest of the list. #
let tl: [Int] -> [Int] =
  fun l ->
    case l
    | [] => []
    | x::xs => xs end in

# Determine if a list is empty. #
let is_empty: [Int] -> Bool =
  fun xs ->
    case xs
    | [] => true
    | _::_ => false end in

# Return the element at the index. #
let nth: ([Int], Int) -> Option =
  fun xs, n ->
    case xs, n
    | x::_, 0 => Some(x)
    | _::xs, n => nth(xs, n - 1)
    | [], _ => None end in

# Reverse a List. #
let rev: [Int] -> [Int] =
fun l -> 
let go: ([Int], [Int]) -> [Int] =
  fun xs, acc -> 
    case xs 
    | [] => acc 
    | x::xs => go(xs, x::acc) end in
go(l, []) in

# Check if two lists are equal #
let equal: ([Int], [Int]) -> Bool =
    fun p, xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => x == y && equal(xs, ys)
    | _ => false end
in

# Initialize a list with a given length using an initializer function #
let init: (Int, Int -> Int) -> [Int] =
    fun len, f ->
        let go: (Int, [Int]) -> [Int] =
        fun idx, xs ->
            if idx < len 
            then go(idx + 1, xs @ [f(idx)])   
            else xs
        in
        go(0, [])
in

# Reduce a list from the left. #
let fold_left: ((Int, Int) -> Int, Int, [Int]) -> Int =
  fun f, acc, xs ->
    case xs 
    | [] => acc
    | hd::tl => fold_left(f, f(acc, hd), tl) end in

# Reduce a list from the right. #
let fold_right: ((Int, Int) -> Int, [Int], Int) -> Int =
  fun f, xs, acc ->
    case xs
    | [] => acc
    | hd::tl => f(hd, fold_right(f, tl, acc)) end in


666
LSP: Prelude: String parsed successfully
LSP: Prelude: Info map generated successfully
Debug: true, Constrain: Types
LSP: Init: Recieved string: # Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)













































LSP: Init: String parsed successfully
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: >( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {go: ((?, ?) -> [?]), filter: (((Int -> Bool), [Int]) -> [Int]), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: 
  LSP: Info: ALL errors:Error in term:
  p
Nature of error: type ((Int -> Bool), [Int]) is not consistent with arrow type    
Error in term:
  p
Nature of error: Variable p is not bound    
Error in term:
  p
Nature of error: Variable p is not bound
  LSP: Info: BidiCtx: Cls: Let expression
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent: Root
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: [?]
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: :: @
  LSP: Concave: Backpack: 
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new_tokens ::= whitespace | "," | "::" | "@"
root ::= new_tokens

Top 20 Logits:

:18.1183
#:15.6289
##:14.7474
let:14.2046
 :13.041
    :12.8225
in:12.6856
   :12.6057
################:12.5763
  :12.5357
####:12.3912
```:12.0893
/*:11.9047
########:11.5846
//:11.5313
                :11.3825
        :11.3514
       :11.1591
[:11.1266
(*:11.0954
-:10.9268

================
# Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)















































LSP: Prelude: Recieved string: ### List ###

# Add an element to the front of a list. #
let cons: (Int, [Int]) -> [Int] = fun x, xs -> x::xs in

# Determine the length of a list. #
let length: [Int] -> Int =
  fun xs ->
    case xs
    | [] => 0
    | _::xs => 1 + length(xs) end in

# Extract the first element of a list. #
let hd: [Int] -> Option =
  fun l ->
    case l
    | [] => None
    | x::xs => Some(x) end in

# Extract the rest of the list. #
let tl: [Int] -> [Int] =
  fun l ->
    case l
    | [] => []
    | x::xs => xs end in

# Determine if a list is empty. #
let is_empty: [Int] -> Bool =
  fun xs ->
    case xs
    | [] => true
    | _::_ => false end in

# Return the element at the index. #
let nth: ([Int], Int) -> Option =
  fun xs, n ->
    case xs, n
    | x::_, 0 => Some(x)
    | _::xs, n => nth(xs, n - 1)
    | [], _ => None end in

# Reverse a List. #
let rev: [Int] -> [Int] =
fun l -> 
let go: ([Int], [Int]) -> [Int] =
  fun xs, acc -> 
    case xs 
    | [] => acc 
    | x::xs => go(xs, x::acc) end in
go(l, []) in

# Check if two lists are equal #
let equal: ([Int], [Int]) -> Bool =
    fun p, xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => x == y && equal(xs, ys)
    | _ => false end
in

# Initialize a list with a given length using an initializer function #
let init: (Int, Int -> Int) -> [Int] =
    fun len, f ->
        let go: (Int, [Int]) -> [Int] =
        fun idx, xs ->
            if idx < len 
            then go(idx + 1, xs @ [f(idx)])   
            else xs
        in
        go(0, [])
in

# Reduce a list from the left. #
let fold_left: ((Int, Int) -> Int, Int, [Int]) -> Int =
  fun f, acc, xs ->
    case xs 
    | [] => acc
    | hd::tl => fold_left(f, f(acc, hd), tl) end in

# Reduce a list from the right. #
let fold_right: ((Int, Int) -> Int, [Int], Int) -> Int =
  fun f, xs, acc ->
    case xs
    | [] => acc
    | hd::tl => f(hd, fold_right(f, tl, acc)) end in


666
LSP: Prelude: String parsed successfully
LSP: Prelude: Info map generated successfully
Debug: true, Constrain: Types
LSP: Init: Recieved string: # Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)














































LSP: Init: String parsed successfully
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: >( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {go: ((?, ?) -> [?]), filter: (((Int -> Bool), [Int]) -> [Int]), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: 
  LSP: Info: ALL errors:Error in term:
  p
Nature of error: type ((Int -> Bool), [Int]) is not consistent with arrow type    
Error in term:
  p
Nature of error: Variable p is not bound    
Error in term:
  p
Nature of error: Variable p is not bound
  LSP: Info: BidiCtx: Cls: Let expression
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent: Root
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: [?]
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: :: @
  LSP: Concave: Backpack: 
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new_tokens ::= whitespace | "," | "::" | "@"
root ::= new_tokens

Top 20 Logits:

:18.1357
#:15.6084
##:14.7636
let:14.1862
 :13.0474
    :12.8189
in:12.623
   :12.6026
################:12.5709
  :12.5365
####:12.397
```:12.0911
/*:11.9191
########:11.5725
//:11.5294
                :11.3834
        :11.3506
       :11.1566
[:11.1378
(*:11.0932
-:10.9322

================
# Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)
















































LSP: Prelude: Recieved string: ### List ###

# Add an element to the front of a list. #
let cons: (Int, [Int]) -> [Int] = fun x, xs -> x::xs in

# Determine the length of a list. #
let length: [Int] -> Int =
  fun xs ->
    case xs
    | [] => 0
    | _::xs => 1 + length(xs) end in

# Extract the first element of a list. #
let hd: [Int] -> Option =
  fun l ->
    case l
    | [] => None
    | x::xs => Some(x) end in

# Extract the rest of the list. #
let tl: [Int] -> [Int] =
  fun l ->
    case l
    | [] => []
    | x::xs => xs end in

# Determine if a list is empty. #
let is_empty: [Int] -> Bool =
  fun xs ->
    case xs
    | [] => true
    | _::_ => false end in

# Return the element at the index. #
let nth: ([Int], Int) -> Option =
  fun xs, n ->
    case xs, n
    | x::_, 0 => Some(x)
    | _::xs, n => nth(xs, n - 1)
    | [], _ => None end in

# Reverse a List. #
let rev: [Int] -> [Int] =
fun l -> 
let go: ([Int], [Int]) -> [Int] =
  fun xs, acc -> 
    case xs 
    | [] => acc 
    | x::xs => go(xs, x::acc) end in
go(l, []) in

# Check if two lists are equal #
let equal: ([Int], [Int]) -> Bool =
    fun p, xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => x == y && equal(xs, ys)
    | _ => false end
in

# Initialize a list with a given length using an initializer function #
let init: (Int, Int -> Int) -> [Int] =
    fun len, f ->
        let go: (Int, [Int]) -> [Int] =
        fun idx, xs ->
            if idx < len 
            then go(idx + 1, xs @ [f(idx)])   
            else xs
        in
        go(0, [])
in

# Reduce a list from the left. #
let fold_left: ((Int, Int) -> Int, Int, [Int]) -> Int =
  fun f, acc, xs ->
    case xs 
    | [] => acc
    | hd::tl => fold_left(f, f(acc, hd), tl) end in

# Reduce a list from the right. #
let fold_right: ((Int, Int) -> Int, [Int], Int) -> Int =
  fun f, xs, acc ->
    case xs
    | [] => acc
    | hd::tl => f(hd, fold_right(f, tl, acc)) end in


666
LSP: Prelude: String parsed successfully
LSP: Prelude: Info map generated successfully
Debug: true, Constrain: Types
LSP: Init: Recieved string: # Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)















































LSP: Init: String parsed successfully
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: >( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {go: ((?, ?) -> [?]), filter: (((Int -> Bool), [Int]) -> [Int]), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: 
  LSP: Info: ALL errors:Error in term:
  p
Nature of error: Variable p is not bound    
Error in term:
  p
Nature of error: Variable p is not bound    
Error in term:
  p
Nature of error: type ((Int -> Bool), [Int]) is not consistent with arrow type
  LSP: Info: BidiCtx: Cls: Let expression
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent: Root
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: [?]
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: :: @
  LSP: Concave: Backpack: 
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new_tokens ::= whitespace | "," | "::" | "@"
root ::= new_tokens

Top 20 Logits:

:18.1648
#:15.5904
##:14.7983
let:14.1688
 :13.064
    :12.8274
   :12.609
in:12.5778
################:12.5759
  :12.5487
####:12.4177
```:12.1057
/*:11.9276
########:11.5796
//:11.5268
                :11.3927
        :11.3602
       :11.1653
[:11.1534
(*:11.102
-:10.939

================
# Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)

















































LSP: Prelude: Recieved string: ### List ###

# Add an element to the front of a list. #
let cons: (Int, [Int]) -> [Int] = fun x, xs -> x::xs in

# Determine the length of a list. #
let length: [Int] -> Int =
  fun xs ->
    case xs
    | [] => 0
    | _::xs => 1 + length(xs) end in

# Extract the first element of a list. #
let hd: [Int] -> Option =
  fun l ->
    case l
    | [] => None
    | x::xs => Some(x) end in

# Extract the rest of the list. #
let tl: [Int] -> [Int] =
  fun l ->
    case l
    | [] => []
    | x::xs => xs end in

# Determine if a list is empty. #
let is_empty: [Int] -> Bool =
  fun xs ->
    case xs
    | [] => true
    | _::_ => false end in

# Return the element at the index. #
let nth: ([Int], Int) -> Option =
  fun xs, n ->
    case xs, n
    | x::_, 0 => Some(x)
    | _::xs, n => nth(xs, n - 1)
    | [], _ => None end in

# Reverse a List. #
let rev: [Int] -> [Int] =
fun l -> 
let go: ([Int], [Int]) -> [Int] =
  fun xs, acc -> 
    case xs 
    | [] => acc 
    | x::xs => go(xs, x::acc) end in
go(l, []) in

# Check if two lists are equal #
let equal: ([Int], [Int]) -> Bool =
    fun p, xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => x == y && equal(xs, ys)
    | _ => false end
in

# Initialize a list with a given length using an initializer function #
let init: (Int, Int -> Int) -> [Int] =
    fun len, f ->
        let go: (Int, [Int]) -> [Int] =
        fun idx, xs ->
            if idx < len 
            then go(idx + 1, xs @ [f(idx)])   
            else xs
        in
        go(0, [])
in

# Reduce a list from the left. #
let fold_left: ((Int, Int) -> Int, Int, [Int]) -> Int =
  fun f, acc, xs ->
    case xs 
    | [] => acc
    | hd::tl => fold_left(f, f(acc, hd), tl) end in

# Reduce a list from the right. #
let fold_right: ((Int, Int) -> Int, [Int], Int) -> Int =
  fun f, xs, acc ->
    case xs
    | [] => acc
    | hd::tl => f(hd, fold_right(f, tl, acc)) end in


666
LSP: Prelude: String parsed successfully
LSP: Prelude: Info map generated successfully
Debug: true, Constrain: Types
LSP: Init: Recieved string: # Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)
















































LSP: Init: String parsed successfully
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: >( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {go: ((?, ?) -> [?]), filter: (((Int -> Bool), [Int]) -> [Int]), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: 
  LSP: Info: ALL errors:Error in term:
  p
Nature of error: Variable p is not bound    
Error in term:
  p
Nature of error: type ((Int -> Bool), [Int]) is not consistent with arrow type    
Error in term:
  p
Nature of error: Variable p is not bound
  LSP: Info: BidiCtx: Cls: Let expression
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent: Root
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: [?]
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: :: @
  LSP: Concave: Backpack: 
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new_tokens ::= whitespace | "," | "::" | "@"
root ::= new_tokens

Top 20 Logits:

:18.1978
#:15.5777
##:14.8281
let:14.1526
 :13.08
    :12.8336
   :12.6143
################:12.5798
in:12.5785
  :12.5609
####:12.4398
```:12.1257
/*:11.9284
########:11.5852
//:11.5221
                :11.4042
        :11.3711
       :11.1781
[:11.1683
(*:11.1139
module:10.9538

================
# Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)


















































LSP: Prelude: Recieved string: ### List ###

# Add an element to the front of a list. #
let cons: (Int, [Int]) -> [Int] = fun x, xs -> x::xs in

# Determine the length of a list. #
let length: [Int] -> Int =
  fun xs ->
    case xs
    | [] => 0
    | _::xs => 1 + length(xs) end in

# Extract the first element of a list. #
let hd: [Int] -> Option =
  fun l ->
    case l
    | [] => None
    | x::xs => Some(x) end in

# Extract the rest of the list. #
let tl: [Int] -> [Int] =
  fun l ->
    case l
    | [] => []
    | x::xs => xs end in

# Determine if a list is empty. #
let is_empty: [Int] -> Bool =
  fun xs ->
    case xs
    | [] => true
    | _::_ => false end in

# Return the element at the index. #
let nth: ([Int], Int) -> Option =
  fun xs, n ->
    case xs, n
    | x::_, 0 => Some(x)
    | _::xs, n => nth(xs, n - 1)
    | [], _ => None end in

# Reverse a List. #
let rev: [Int] -> [Int] =
fun l -> 
let go: ([Int], [Int]) -> [Int] =
  fun xs, acc -> 
    case xs 
    | [] => acc 
    | x::xs => go(xs, x::acc) end in
go(l, []) in

# Check if two lists are equal #
let equal: ([Int], [Int]) -> Bool =
    fun p, xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => x == y && equal(xs, ys)
    | _ => false end
in

# Initialize a list with a given length using an initializer function #
let init: (Int, Int -> Int) -> [Int] =
    fun len, f ->
        let go: (Int, [Int]) -> [Int] =
        fun idx, xs ->
            if idx < len 
            then go(idx + 1, xs @ [f(idx)])   
            else xs
        in
        go(0, [])
in

# Reduce a list from the left. #
let fold_left: ((Int, Int) -> Int, Int, [Int]) -> Int =
  fun f, acc, xs ->
    case xs 
    | [] => acc
    | hd::tl => fold_left(f, f(acc, hd), tl) end in

# Reduce a list from the right. #
let fold_right: ((Int, Int) -> Int, [Int], Int) -> Int =
  fun f, xs, acc ->
    case xs
    | [] => acc
    | hd::tl => f(hd, fold_right(f, tl, acc)) end in


666
LSP: Prelude: String parsed successfully
LSP: Prelude: Info map generated successfully
Debug: true, Constrain: Types
LSP: Init: Recieved string: # Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)

















































LSP: Init: String parsed successfully
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: >( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {go: ((?, ?) -> [?]), filter: (((Int -> Bool), [Int]) -> [Int]), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: 
  LSP: Info: ALL errors:Error in term:
  p
Nature of error: type ((Int -> Bool), [Int]) is not consistent with arrow type    
Error in term:
  p
Nature of error: Variable p is not bound    
Error in term:
  p
Nature of error: Variable p is not bound
  LSP: Info: BidiCtx: Cls: Let expression
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent: Root
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: [?]
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: :: @
  LSP: Concave: Backpack: 
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new_tokens ::= whitespace | "," | "::" | "@"
root ::= new_tokens

Top 20 Logits:

:18.2281
#:15.5682
##:14.8362
let:14.1377
 :13.088
    :12.8328
in:12.6336
   :12.6136
################:12.5743
  :12.566
####:12.4516
```:12.142
/*:11.9266
########:11.5728
//:11.5208
                :11.4139
        :11.3798
       :11.191
[:11.1759
(*:11.1225
module:10.9604

================
# Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)



















































LSP: Prelude: Recieved string: ### List ###

# Add an element to the front of a list. #
let cons: (Int, [Int]) -> [Int] = fun x, xs -> x::xs in

# Determine the length of a list. #
let length: [Int] -> Int =
  fun xs ->
    case xs
    | [] => 0
    | _::xs => 1 + length(xs) end in

# Extract the first element of a list. #
let hd: [Int] -> Option =
  fun l ->
    case l
    | [] => None
    | x::xs => Some(x) end in

# Extract the rest of the list. #
let tl: [Int] -> [Int] =
  fun l ->
    case l
    | [] => []
    | x::xs => xs end in

# Determine if a list is empty. #
let is_empty: [Int] -> Bool =
  fun xs ->
    case xs
    | [] => true
    | _::_ => false end in

# Return the element at the index. #
let nth: ([Int], Int) -> Option =
  fun xs, n ->
    case xs, n
    | x::_, 0 => Some(x)
    | _::xs, n => nth(xs, n - 1)
    | [], _ => None end in

# Reverse a List. #
let rev: [Int] -> [Int] =
fun l -> 
let go: ([Int], [Int]) -> [Int] =
  fun xs, acc -> 
    case xs 
    | [] => acc 
    | x::xs => go(xs, x::acc) end in
go(l, []) in

# Check if two lists are equal #
let equal: ([Int], [Int]) -> Bool =
    fun p, xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => x == y && equal(xs, ys)
    | _ => false end
in

# Initialize a list with a given length using an initializer function #
let init: (Int, Int -> Int) -> [Int] =
    fun len, f ->
        let go: (Int, [Int]) -> [Int] =
        fun idx, xs ->
            if idx < len 
            then go(idx + 1, xs @ [f(idx)])   
            else xs
        in
        go(0, [])
in

# Reduce a list from the left. #
let fold_left: ((Int, Int) -> Int, Int, [Int]) -> Int =
  fun f, acc, xs ->
    case xs 
    | [] => acc
    | hd::tl => fold_left(f, f(acc, hd), tl) end in

# Reduce a list from the right. #
let fold_right: ((Int, Int) -> Int, [Int], Int) -> Int =
  fun f, xs, acc ->
    case xs
    | [] => acc
    | hd::tl => f(hd, fold_right(f, tl, acc)) end in


666
LSP: Prelude: String parsed successfully
LSP: Prelude: Info map generated successfully
Debug: true, Constrain: Types
LSP: Init: Recieved string: # Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)


















































LSP: Init: String parsed successfully
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: >( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {go: ((?, ?) -> [?]), filter: (((Int -> Bool), [Int]) -> [Int]), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: 
  LSP: Info: ALL errors:Error in term:
  p
Nature of error: Variable p is not bound    
Error in term:
  p
Nature of error: type ((Int -> Bool), [Int]) is not consistent with arrow type    
Error in term:
  p
Nature of error: Variable p is not bound
  LSP: Info: BidiCtx: Cls: Let expression
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent: Root
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: [?]
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: :: @
  LSP: Concave: Backpack: 
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new_tokens ::= whitespace | "," | "::" | "@"
root ::= new_tokens

Top 20 Logits:

:18.2529
#:15.5593
##:14.821
let:14.1251
 :13.0882
    :12.8272
in:12.7164
   :12.6083
  :12.562
################:12.5597
####:12.4493
```:12.1495
/*:11.9269
########:11.541
//:11.5235
                :11.4194
        :11.3854
       :11.2012
[:11.1755
(*:11.1261
-:10.9549

================
# Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)




















































LSP: Prelude: Recieved string: ### List ###

# Add an element to the front of a list. #
let cons: (Int, [Int]) -> [Int] = fun x, xs -> x::xs in

# Determine the length of a list. #
let length: [Int] -> Int =
  fun xs ->
    case xs
    | [] => 0
    | _::xs => 1 + length(xs) end in

# Extract the first element of a list. #
let hd: [Int] -> Option =
  fun l ->
    case l
    | [] => None
    | x::xs => Some(x) end in

# Extract the rest of the list. #
let tl: [Int] -> [Int] =
  fun l ->
    case l
    | [] => []
    | x::xs => xs end in

# Determine if a list is empty. #
let is_empty: [Int] -> Bool =
  fun xs ->
    case xs
    | [] => true
    | _::_ => false end in

# Return the element at the index. #
let nth: ([Int], Int) -> Option =
  fun xs, n ->
    case xs, n
    | x::_, 0 => Some(x)
    | _::xs, n => nth(xs, n - 1)
    | [], _ => None end in

# Reverse a List. #
let rev: [Int] -> [Int] =
fun l -> 
let go: ([Int], [Int]) -> [Int] =
  fun xs, acc -> 
    case xs 
    | [] => acc 
    | x::xs => go(xs, x::acc) end in
go(l, []) in

# Check if two lists are equal #
let equal: ([Int], [Int]) -> Bool =
    fun p, xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => x == y && equal(xs, ys)
    | _ => false end
in

# Initialize a list with a given length using an initializer function #
let init: (Int, Int -> Int) -> [Int] =
    fun len, f ->
        let go: (Int, [Int]) -> [Int] =
        fun idx, xs ->
            if idx < len 
            then go(idx + 1, xs @ [f(idx)])   
            else xs
        in
        go(0, [])
in

# Reduce a list from the left. #
let fold_left: ((Int, Int) -> Int, Int, [Int]) -> Int =
  fun f, acc, xs ->
    case xs 
    | [] => acc
    | hd::tl => fold_left(f, f(acc, hd), tl) end in

# Reduce a list from the right. #
let fold_right: ((Int, Int) -> Int, [Int], Int) -> Int =
  fun f, xs, acc ->
    case xs
    | [] => acc
    | hd::tl => f(hd, fold_right(f, tl, acc)) end in


666
LSP: Prelude: String parsed successfully
LSP: Prelude: Info map generated successfully
Debug: true, Constrain: Types
LSP: Init: Recieved string: # Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)



















































LSP: Init: String parsed successfully
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: >( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {go: ((?, ?) -> [?]), filter: (((Int -> Bool), [Int]) -> [Int]), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: 
  LSP: Info: ALL errors:Error in term:
  p
Nature of error: type ((Int -> Bool), [Int]) is not consistent with arrow type    
Error in term:
  p
Nature of error: Variable p is not bound    
Error in term:
  p
Nature of error: Variable p is not bound
  LSP: Info: BidiCtx: Cls: Let expression
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent: Root
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: [?]
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: :: @
  LSP: Concave: Backpack: 
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new_tokens ::= whitespace | "," | "::" | "@"
root ::= new_tokens

Top 20 Logits:

:18.2731
#:15.5527
##:14.7978
let:14.1211
 :13.0864
    :12.8218
in:12.7745
   :12.6043
  :12.5522
################:12.5445
####:12.4374
```:12.1476
/*:11.9317
//:11.5265
########:11.5054
                :11.4206
        :11.3888
       :11.2091
[:11.1747
(*:11.1273
-:10.9582

================
# Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)





















































LSP: Prelude: Recieved string: ### List ###

# Add an element to the front of a list. #
let cons: (Int, [Int]) -> [Int] = fun x, xs -> x::xs in

# Determine the length of a list. #
let length: [Int] -> Int =
  fun xs ->
    case xs
    | [] => 0
    | _::xs => 1 + length(xs) end in

# Extract the first element of a list. #
let hd: [Int] -> Option =
  fun l ->
    case l
    | [] => None
    | x::xs => Some(x) end in

# Extract the rest of the list. #
let tl: [Int] -> [Int] =
  fun l ->
    case l
    | [] => []
    | x::xs => xs end in

# Determine if a list is empty. #
let is_empty: [Int] -> Bool =
  fun xs ->
    case xs
    | [] => true
    | _::_ => false end in

# Return the element at the index. #
let nth: ([Int], Int) -> Option =
  fun xs, n ->
    case xs, n
    | x::_, 0 => Some(x)
    | _::xs, n => nth(xs, n - 1)
    | [], _ => None end in

# Reverse a List. #
let rev: [Int] -> [Int] =
fun l -> 
let go: ([Int], [Int]) -> [Int] =
  fun xs, acc -> 
    case xs 
    | [] => acc 
    | x::xs => go(xs, x::acc) end in
go(l, []) in

# Check if two lists are equal #
let equal: ([Int], [Int]) -> Bool =
    fun p, xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => x == y && equal(xs, ys)
    | _ => false end
in

# Initialize a list with a given length using an initializer function #
let init: (Int, Int -> Int) -> [Int] =
    fun len, f ->
        let go: (Int, [Int]) -> [Int] =
        fun idx, xs ->
            if idx < len 
            then go(idx + 1, xs @ [f(idx)])   
            else xs
        in
        go(0, [])
in

# Reduce a list from the left. #
let fold_left: ((Int, Int) -> Int, Int, [Int]) -> Int =
  fun f, acc, xs ->
    case xs 
    | [] => acc
    | hd::tl => fold_left(f, f(acc, hd), tl) end in

# Reduce a list from the right. #
let fold_right: ((Int, Int) -> Int, [Int], Int) -> Int =
  fun f, xs, acc ->
    case xs
    | [] => acc
    | hd::tl => f(hd, fold_right(f, tl, acc)) end in


666
LSP: Prelude: String parsed successfully
LSP: Prelude: Info map generated successfully
Debug: true, Constrain: Types
LSP: Init: Recieved string: # Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)




















































LSP: Init: String parsed successfully
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: >( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {go: ((?, ?) -> [?]), filter: (((Int -> Bool), [Int]) -> [Int]), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: 
  LSP: Info: ALL errors:Error in term:
  p
Nature of error: Variable p is not bound    
Error in term:
  p
Nature of error: type ((Int -> Bool), [Int]) is not consistent with arrow type    
Error in term:
  p
Nature of error: Variable p is not bound
  LSP: Info: BidiCtx: Cls: Let expression
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent: Root
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: [?]
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: :: @
  LSP: Concave: Backpack: 
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new_tokens ::= whitespace | "," | "::" | "@"
root ::= new_tokens

Top 20 Logits:

:18.294
#:15.5508
##:14.7897
let:14.1291
 :13.0888
    :12.8209
in:12.7788
   :12.6074
  :12.5428
################:12.5401
####:12.4281
```:12.1478
/*:11.9399
//:11.5293
########:11.4879
                :11.4229
        :11.3944
       :11.2212
[:11.182
(*:11.1338
-:10.9614

================
# Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)






















































LSP: Prelude: Recieved string: ### List ###

# Add an element to the front of a list. #
let cons: (Int, [Int]) -> [Int] = fun x, xs -> x::xs in

# Determine the length of a list. #
let length: [Int] -> Int =
  fun xs ->
    case xs
    | [] => 0
    | _::xs => 1 + length(xs) end in

# Extract the first element of a list. #
let hd: [Int] -> Option =
  fun l ->
    case l
    | [] => None
    | x::xs => Some(x) end in

# Extract the rest of the list. #
let tl: [Int] -> [Int] =
  fun l ->
    case l
    | [] => []
    | x::xs => xs end in

# Determine if a list is empty. #
let is_empty: [Int] -> Bool =
  fun xs ->
    case xs
    | [] => true
    | _::_ => false end in

# Return the element at the index. #
let nth: ([Int], Int) -> Option =
  fun xs, n ->
    case xs, n
    | x::_, 0 => Some(x)
    | _::xs, n => nth(xs, n - 1)
    | [], _ => None end in

# Reverse a List. #
let rev: [Int] -> [Int] =
fun l -> 
let go: ([Int], [Int]) -> [Int] =
  fun xs, acc -> 
    case xs 
    | [] => acc 
    | x::xs => go(xs, x::acc) end in
go(l, []) in

# Check if two lists are equal #
let equal: ([Int], [Int]) -> Bool =
    fun p, xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => x == y && equal(xs, ys)
    | _ => false end
in

# Initialize a list with a given length using an initializer function #
let init: (Int, Int -> Int) -> [Int] =
    fun len, f ->
        let go: (Int, [Int]) -> [Int] =
        fun idx, xs ->
            if idx < len 
            then go(idx + 1, xs @ [f(idx)])   
            else xs
        in
        go(0, [])
in

# Reduce a list from the left. #
let fold_left: ((Int, Int) -> Int, Int, [Int]) -> Int =
  fun f, acc, xs ->
    case xs 
    | [] => acc
    | hd::tl => fold_left(f, f(acc, hd), tl) end in

# Reduce a list from the right. #
let fold_right: ((Int, Int) -> Int, [Int], Int) -> Int =
  fun f, xs, acc ->
    case xs
    | [] => acc
    | hd::tl => f(hd, fold_right(f, tl, acc)) end in


666
LSP: Prelude: String parsed successfully
LSP: Prelude: Info map generated successfully
Debug: true, Constrain: Types
LSP: Init: Recieved string: # Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)





















































LSP: Init: String parsed successfully
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: >( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {go: ((?, ?) -> [?]), filter: (((Int -> Bool), [Int]) -> [Int]), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: 
  LSP: Info: ALL errors:Error in term:
  p
Nature of error: type ((Int -> Bool), [Int]) is not consistent with arrow type    
Error in term:
  p
Nature of error: Variable p is not bound    
Error in term:
  p
Nature of error: Variable p is not bound
  LSP: Info: BidiCtx: Cls: Let expression
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent: Root
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: [?]
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: :: @
  LSP: Concave: Backpack: 
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new_tokens ::= whitespace | "," | "::" | "@"
root ::= new_tokens

Top 20 Logits:

:18.3204
#:15.553
##:14.8079
let:14.1446
 :13.0969
    :12.8238
in:12.7475
   :12.6178
################:12.552
  :12.5382
####:12.4312
```:12.1632
/*:11.9459
//:11.5323
########:11.497
                :11.4296
        :11.4035
       :11.2417
[:11.1996
(*:11.1499
-:10.9683

================
# Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)























































LSP: Prelude: Recieved string: ### List ###

# Add an element to the front of a list. #
let cons: (Int, [Int]) -> [Int] = fun x, xs -> x::xs in

# Determine the length of a list. #
let length: [Int] -> Int =
  fun xs ->
    case xs
    | [] => 0
    | _::xs => 1 + length(xs) end in

# Extract the first element of a list. #
let hd: [Int] -> Option =
  fun l ->
    case l
    | [] => None
    | x::xs => Some(x) end in

# Extract the rest of the list. #
let tl: [Int] -> [Int] =
  fun l ->
    case l
    | [] => []
    | x::xs => xs end in

# Determine if a list is empty. #
let is_empty: [Int] -> Bool =
  fun xs ->
    case xs
    | [] => true
    | _::_ => false end in

# Return the element at the index. #
let nth: ([Int], Int) -> Option =
  fun xs, n ->
    case xs, n
    | x::_, 0 => Some(x)
    | _::xs, n => nth(xs, n - 1)
    | [], _ => None end in

# Reverse a List. #
let rev: [Int] -> [Int] =
fun l -> 
let go: ([Int], [Int]) -> [Int] =
  fun xs, acc -> 
    case xs 
    | [] => acc 
    | x::xs => go(xs, x::acc) end in
go(l, []) in

# Check if two lists are equal #
let equal: ([Int], [Int]) -> Bool =
    fun p, xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => x == y && equal(xs, ys)
    | _ => false end
in

# Initialize a list with a given length using an initializer function #
let init: (Int, Int -> Int) -> [Int] =
    fun len, f ->
        let go: (Int, [Int]) -> [Int] =
        fun idx, xs ->
            if idx < len 
            then go(idx + 1, xs @ [f(idx)])   
            else xs
        in
        go(0, [])
in

# Reduce a list from the left. #
let fold_left: ((Int, Int) -> Int, Int, [Int]) -> Int =
  fun f, acc, xs ->
    case xs 
    | [] => acc
    | hd::tl => fold_left(f, f(acc, hd), tl) end in

# Reduce a list from the right. #
let fold_right: ((Int, Int) -> Int, [Int], Int) -> Int =
  fun f, xs, acc ->
    case xs
    | [] => acc
    | hd::tl => f(hd, fold_right(f, tl, acc)) end in


666
LSP: Prelude: String parsed successfully
LSP: Prelude: Info map generated successfully
Debug: true, Constrain: Types
LSP: Init: Recieved string: # Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)






















































LSP: Init: String parsed successfully
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: >( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {go: ((?, ?) -> [?]), filter: (((Int -> Bool), [Int]) -> [Int]), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: 
  LSP: Info: ALL errors:Error in term:
  p
Nature of error: Variable p is not bound    
Error in term:
  p
Nature of error: Variable p is not bound    
Error in term:
  p
Nature of error: type ((Int -> Bool), [Int]) is not consistent with arrow type
  LSP: Info: BidiCtx: Cls: Let expression
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent: Root
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: [?]
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: :: @
  LSP: Concave: Backpack: 
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new_tokens ::= whitespace | "," | "::" | "@"
root ::= new_tokens

Top 20 Logits:

:18.3514
#:15.5571
##:14.8445
let:14.1592
 :13.1065
    :12.825
in:12.7208
   :12.6301
################:12.5731
  :12.5373
####:12.4461
```:12.1942
/*:11.945
//:11.5338
########:11.5221
                :11.4401
        :11.4139
       :11.2678
[:11.2215
(*:11.1683
-:10.9788

================
# Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)
























































LSP: Prelude: Recieved string: ### List ###

# Add an element to the front of a list. #
let cons: (Int, [Int]) -> [Int] = fun x, xs -> x::xs in

# Determine the length of a list. #
let length: [Int] -> Int =
  fun xs ->
    case xs
    | [] => 0
    | _::xs => 1 + length(xs) end in

# Extract the first element of a list. #
let hd: [Int] -> Option =
  fun l ->
    case l
    | [] => None
    | x::xs => Some(x) end in

# Extract the rest of the list. #
let tl: [Int] -> [Int] =
  fun l ->
    case l
    | [] => []
    | x::xs => xs end in

# Determine if a list is empty. #
let is_empty: [Int] -> Bool =
  fun xs ->
    case xs
    | [] => true
    | _::_ => false end in

# Return the element at the index. #
let nth: ([Int], Int) -> Option =
  fun xs, n ->
    case xs, n
    | x::_, 0 => Some(x)
    | _::xs, n => nth(xs, n - 1)
    | [], _ => None end in

# Reverse a List. #
let rev: [Int] -> [Int] =
fun l -> 
let go: ([Int], [Int]) -> [Int] =
  fun xs, acc -> 
    case xs 
    | [] => acc 
    | x::xs => go(xs, x::acc) end in
go(l, []) in

# Check if two lists are equal #
let equal: ([Int], [Int]) -> Bool =
    fun p, xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => x == y && equal(xs, ys)
    | _ => false end
in

# Initialize a list with a given length using an initializer function #
let init: (Int, Int -> Int) -> [Int] =
    fun len, f ->
        let go: (Int, [Int]) -> [Int] =
        fun idx, xs ->
            if idx < len 
            then go(idx + 1, xs @ [f(idx)])   
            else xs
        in
        go(0, [])
in

# Reduce a list from the left. #
let fold_left: ((Int, Int) -> Int, Int, [Int]) -> Int =
  fun f, acc, xs ->
    case xs 
    | [] => acc
    | hd::tl => fold_left(f, f(acc, hd), tl) end in

# Reduce a list from the right. #
let fold_right: ((Int, Int) -> Int, [Int], Int) -> Int =
  fun f, xs, acc ->
    case xs
    | [] => acc
    | hd::tl => f(hd, fold_right(f, tl, acc)) end in


666
LSP: Prelude: String parsed successfully
LSP: Prelude: Info map generated successfully
Debug: true, Constrain: Types
LSP: Init: Recieved string: # Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)























































LSP: Init: String parsed successfully
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: >( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {go: ((?, ?) -> [?]), filter: (((Int -> Bool), [Int]) -> [Int]), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: 
  LSP: Info: ALL errors:Error in term:
  p
Nature of error: type ((Int -> Bool), [Int]) is not consistent with arrow type    
Error in term:
  p
Nature of error: Variable p is not bound    
Error in term:
  p
Nature of error: Variable p is not bound
  LSP: Info: BidiCtx: Cls: Let expression
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent: Root
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: [?]
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: :: @
  LSP: Concave: Backpack: 
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new_tokens ::= whitespace | "," | "::" | "@"
root ::= new_tokens

Top 20 Logits:

:18.3833
#:15.5598
##:14.8799
let:14.1654
 :13.1147
    :12.8215
in:12.7308
   :12.64
################:12.5915
  :12.5394
####:12.463
```:12.2285
/*:11.9389
########:11.5431
//:11.5327
                :11.4527
        :11.4247
       :11.2945
[:11.2355
(*:11.178
-:10.9904

================
# Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)

























































LSP: Prelude: Recieved string: ### List ###

# Add an element to the front of a list. #
let cons: (Int, [Int]) -> [Int] = fun x, xs -> x::xs in

# Determine the length of a list. #
let length: [Int] -> Int =
  fun xs ->
    case xs
    | [] => 0
    | _::xs => 1 + length(xs) end in

# Extract the first element of a list. #
let hd: [Int] -> Option =
  fun l ->
    case l
    | [] => None
    | x::xs => Some(x) end in

# Extract the rest of the list. #
let tl: [Int] -> [Int] =
  fun l ->
    case l
    | [] => []
    | x::xs => xs end in

# Determine if a list is empty. #
let is_empty: [Int] -> Bool =
  fun xs ->
    case xs
    | [] => true
    | _::_ => false end in

# Return the element at the index. #
let nth: ([Int], Int) -> Option =
  fun xs, n ->
    case xs, n
    | x::_, 0 => Some(x)
    | _::xs, n => nth(xs, n - 1)
    | [], _ => None end in

# Reverse a List. #
let rev: [Int] -> [Int] =
fun l -> 
let go: ([Int], [Int]) -> [Int] =
  fun xs, acc -> 
    case xs 
    | [] => acc 
    | x::xs => go(xs, x::acc) end in
go(l, []) in

# Check if two lists are equal #
let equal: ([Int], [Int]) -> Bool =
    fun p, xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => x == y && equal(xs, ys)
    | _ => false end
in

# Initialize a list with a given length using an initializer function #
let init: (Int, Int -> Int) -> [Int] =
    fun len, f ->
        let go: (Int, [Int]) -> [Int] =
        fun idx, xs ->
            if idx < len 
            then go(idx + 1, xs @ [f(idx)])   
            else xs
        in
        go(0, [])
in

# Reduce a list from the left. #
let fold_left: ((Int, Int) -> Int, Int, [Int]) -> Int =
  fun f, acc, xs ->
    case xs 
    | [] => acc
    | hd::tl => fold_left(f, f(acc, hd), tl) end in

# Reduce a list from the right. #
let fold_right: ((Int, Int) -> Int, [Int], Int) -> Int =
  fun f, xs, acc ->
    case xs
    | [] => acc
    | hd::tl => f(hd, fold_right(f, tl, acc)) end in


666
LSP: Prelude: String parsed successfully
LSP: Prelude: Info map generated successfully
Debug: true, Constrain: Types
LSP: Init: Recieved string: # Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)
























































LSP: Init: String parsed successfully
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: >( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {go: ((?, ?) -> [?]), filter: (((Int -> Bool), [Int]) -> [Int]), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: 
  LSP: Info: ALL errors:Error in term:
  p
Nature of error: type ((Int -> Bool), [Int]) is not consistent with arrow type    
Error in term:
  p
Nature of error: Variable p is not bound    
Error in term:
  p
Nature of error: Variable p is not bound
  LSP: Info: BidiCtx: Cls: Let expression
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent: Root
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: [?]
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: :: @
  LSP: Concave: Backpack: 
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new_tokens ::= whitespace | "," | "::" | "@"
root ::= new_tokens

Top 20 Logits:

:18.4111
#:15.5586
##:14.8988
let:14.1617
 :13.1205
    :12.8164
in:12.7794
   :12.646
################:12.6011
  :12.5442
####:12.4704
```:12.2497
/*:11.9322
########:11.5484
//:11.5279
                :11.4642
        :11.4347
       :11.316
[:11.2322
(*:11.1722
end:11.0015

================
# Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)


























































LSP: Prelude: Recieved string: ### List ###

# Add an element to the front of a list. #
let cons: (Int, [Int]) -> [Int] = fun x, xs -> x::xs in

# Determine the length of a list. #
let length: [Int] -> Int =
  fun xs ->
    case xs
    | [] => 0
    | _::xs => 1 + length(xs) end in

# Extract the first element of a list. #
let hd: [Int] -> Option =
  fun l ->
    case l
    | [] => None
    | x::xs => Some(x) end in

# Extract the rest of the list. #
let tl: [Int] -> [Int] =
  fun l ->
    case l
    | [] => []
    | x::xs => xs end in

# Determine if a list is empty. #
let is_empty: [Int] -> Bool =
  fun xs ->
    case xs
    | [] => true
    | _::_ => false end in

# Return the element at the index. #
let nth: ([Int], Int) -> Option =
  fun xs, n ->
    case xs, n
    | x::_, 0 => Some(x)
    | _::xs, n => nth(xs, n - 1)
    | [], _ => None end in

# Reverse a List. #
let rev: [Int] -> [Int] =
fun l -> 
let go: ([Int], [Int]) -> [Int] =
  fun xs, acc -> 
    case xs 
    | [] => acc 
    | x::xs => go(xs, x::acc) end in
go(l, []) in

# Check if two lists are equal #
let equal: ([Int], [Int]) -> Bool =
    fun p, xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => x == y && equal(xs, ys)
    | _ => false end
in

# Initialize a list with a given length using an initializer function #
let init: (Int, Int -> Int) -> [Int] =
    fun len, f ->
        let go: (Int, [Int]) -> [Int] =
        fun idx, xs ->
            if idx < len 
            then go(idx + 1, xs @ [f(idx)])   
            else xs
        in
        go(0, [])
in

# Reduce a list from the left. #
let fold_left: ((Int, Int) -> Int, Int, [Int]) -> Int =
  fun f, acc, xs ->
    case xs 
    | [] => acc
    | hd::tl => fold_left(f, f(acc, hd), tl) end in

# Reduce a list from the right. #
let fold_right: ((Int, Int) -> Int, [Int], Int) -> Int =
  fun f, xs, acc ->
    case xs
    | [] => acc
    | hd::tl => f(hd, fold_right(f, tl, acc)) end in


666
LSP: Prelude: String parsed successfully
LSP: Prelude: Info map generated successfully
Debug: true, Constrain: Types
LSP: Init: Recieved string: # Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)

























































LSP: Init: String parsed successfully
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: >( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {go: ((?, ?) -> [?]), filter: (((Int -> Bool), [Int]) -> [Int]), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: 
  LSP: Info: ALL errors:Error in term:
  p
Nature of error: type ((Int -> Bool), [Int]) is not consistent with arrow type    
Error in term:
  p
Nature of error: Variable p is not bound    
Error in term:
  p
Nature of error: Variable p is not bound
  LSP: Info: BidiCtx: Cls: Let expression
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent: Root
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: [?]
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: :: @
  LSP: Concave: Backpack: 
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new_tokens ::= whitespace | "," | "::" | "@"
root ::= new_tokens

Top 20 Logits:

:18.4321
#:15.5556
##:14.8997
let:14.1543
 :13.1245
in:12.8415
    :12.8143
   :12.6491
################:12.6035
  :12.5501
####:12.4649
```:12.2513
/*:11.9305
########:11.5427
//:11.5214
                :11.4719
        :11.4436
       :11.3292
[:11.2161
(*:11.1555
end:11.0401

================
# Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)



























































LSP: Prelude: Recieved string: ### List ###

# Add an element to the front of a list. #
let cons: (Int, [Int]) -> [Int] = fun x, xs -> x::xs in

# Determine the length of a list. #
let length: [Int] -> Int =
  fun xs ->
    case xs
    | [] => 0
    | _::xs => 1 + length(xs) end in

# Extract the first element of a list. #
let hd: [Int] -> Option =
  fun l ->
    case l
    | [] => None
    | x::xs => Some(x) end in

# Extract the rest of the list. #
let tl: [Int] -> [Int] =
  fun l ->
    case l
    | [] => []
    | x::xs => xs end in

# Determine if a list is empty. #
let is_empty: [Int] -> Bool =
  fun xs ->
    case xs
    | [] => true
    | _::_ => false end in

# Return the element at the index. #
let nth: ([Int], Int) -> Option =
  fun xs, n ->
    case xs, n
    | x::_, 0 => Some(x)
    | _::xs, n => nth(xs, n - 1)
    | [], _ => None end in

# Reverse a List. #
let rev: [Int] -> [Int] =
fun l -> 
let go: ([Int], [Int]) -> [Int] =
  fun xs, acc -> 
    case xs 
    | [] => acc 
    | x::xs => go(xs, x::acc) end in
go(l, []) in

# Check if two lists are equal #
let equal: ([Int], [Int]) -> Bool =
    fun p, xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => x == y && equal(xs, ys)
    | _ => false end
in

# Initialize a list with a given length using an initializer function #
let init: (Int, Int -> Int) -> [Int] =
    fun len, f ->
        let go: (Int, [Int]) -> [Int] =
        fun idx, xs ->
            if idx < len 
            then go(idx + 1, xs @ [f(idx)])   
            else xs
        in
        go(0, [])
in

# Reduce a list from the left. #
let fold_left: ((Int, Int) -> Int, Int, [Int]) -> Int =
  fun f, acc, xs ->
    case xs 
    | [] => acc
    | hd::tl => fold_left(f, f(acc, hd), tl) end in

# Reduce a list from the right. #
let fold_right: ((Int, Int) -> Int, [Int], Int) -> Int =
  fun f, xs, acc ->
    case xs
    | [] => acc
    | hd::tl => f(hd, fold_right(f, tl, acc)) end in


666
LSP: Prelude: String parsed successfully
LSP: Prelude: Info map generated successfully
Debug: true, Constrain: Types
LSP: Init: Recieved string: # Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)


























































LSP: Init: String parsed successfully
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: >( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {go: ((?, ?) -> [?]), filter: (((Int -> Bool), [Int]) -> [Int]), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: 
  LSP: Info: ALL errors:Error in term:
  p
Nature of error: Variable p is not bound    
Error in term:
  p
Nature of error: Variable p is not bound    
Error in term:
  p
Nature of error: type ((Int -> Bool), [Int]) is not consistent with arrow type
  LSP: Info: BidiCtx: Cls: Let expression
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent: Root
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: [?]
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: :: @
  LSP: Concave: Backpack: 
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new_tokens ::= whitespace | "," | "::" | "@"
root ::= new_tokens

Top 20 Logits:

:18.4494
#:15.5557
##:14.8924
let:14.1533
 :13.1297
in:12.8918
    :12.8174
   :12.6525
################:12.6047
  :12.5563
####:12.4513
```:12.2379
/*:11.9356
########:11.5374
//:11.5161
                :11.4775
        :11.453
       :11.3365
[:11.1979
(*:11.1407
end:11.0757

================
# Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)




























































LSP: Prelude: Recieved string: ### List ###

# Add an element to the front of a list. #
let cons: (Int, [Int]) -> [Int] = fun x, xs -> x::xs in

# Determine the length of a list. #
let length: [Int] -> Int =
  fun xs ->
    case xs
    | [] => 0
    | _::xs => 1 + length(xs) end in

# Extract the first element of a list. #
let hd: [Int] -> Option =
  fun l ->
    case l
    | [] => None
    | x::xs => Some(x) end in

# Extract the rest of the list. #
let tl: [Int] -> [Int] =
  fun l ->
    case l
    | [] => []
    | x::xs => xs end in

# Determine if a list is empty. #
let is_empty: [Int] -> Bool =
  fun xs ->
    case xs
    | [] => true
    | _::_ => false end in

# Return the element at the index. #
let nth: ([Int], Int) -> Option =
  fun xs, n ->
    case xs, n
    | x::_, 0 => Some(x)
    | _::xs, n => nth(xs, n - 1)
    | [], _ => None end in

# Reverse a List. #
let rev: [Int] -> [Int] =
fun l -> 
let go: ([Int], [Int]) -> [Int] =
  fun xs, acc -> 
    case xs 
    | [] => acc 
    | x::xs => go(xs, x::acc) end in
go(l, []) in

# Check if two lists are equal #
let equal: ([Int], [Int]) -> Bool =
    fun p, xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => x == y && equal(xs, ys)
    | _ => false end
in

# Initialize a list with a given length using an initializer function #
let init: (Int, Int -> Int) -> [Int] =
    fun len, f ->
        let go: (Int, [Int]) -> [Int] =
        fun idx, xs ->
            if idx < len 
            then go(idx + 1, xs @ [f(idx)])   
            else xs
        in
        go(0, [])
in

# Reduce a list from the left. #
let fold_left: ((Int, Int) -> Int, Int, [Int]) -> Int =
  fun f, acc, xs ->
    case xs 
    | [] => acc
    | hd::tl => fold_left(f, f(acc, hd), tl) end in

# Reduce a list from the right. #
let fold_right: ((Int, Int) -> Int, [Int], Int) -> Int =
  fun f, xs, acc ->
    case xs
    | [] => acc
    | hd::tl => f(hd, fold_right(f, tl, acc)) end in


666
LSP: Prelude: String parsed successfully
LSP: Prelude: Info map generated successfully
Debug: true, Constrain: Types
LSP: Init: Recieved string: # Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)



























































LSP: Init: String parsed successfully
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: >( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {go: ((?, ?) -> [?]), filter: (((Int -> Bool), [Int]) -> [Int]), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: 
  LSP: Info: ALL errors:Error in term:
  p
Nature of error: type ((Int -> Bool), [Int]) is not consistent with arrow type    
Error in term:
  p
Nature of error: Variable p is not bound    
Error in term:
  p
Nature of error: Variable p is not bound
  LSP: Info: BidiCtx: Cls: Let expression
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent: Root
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: [?]
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: :: @
  LSP: Concave: Backpack: 
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new_tokens ::= whitespace | "," | "::" | "@"
root ::= new_tokens

Top 20 Logits:

:18.4692
#:15.5631
##:14.888
let:14.1646
 :13.1388
in:12.9214
    :12.8235
   :12.6591
################:12.6119
  :12.5621
####:12.438
```:12.2226
/*:11.9459
########:11.5408
//:11.5152
                :11.485
        :11.463
       :11.3437
[:11.1868
(*:11.1385
end:11.1079

================
# Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)





























































LSP: Prelude: Recieved string: ### List ###

# Add an element to the front of a list. #
let cons: (Int, [Int]) -> [Int] = fun x, xs -> x::xs in

# Determine the length of a list. #
let length: [Int] -> Int =
  fun xs ->
    case xs
    | [] => 0
    | _::xs => 1 + length(xs) end in

# Extract the first element of a list. #
let hd: [Int] -> Option =
  fun l ->
    case l
    | [] => None
    | x::xs => Some(x) end in

# Extract the rest of the list. #
let tl: [Int] -> [Int] =
  fun l ->
    case l
    | [] => []
    | x::xs => xs end in

# Determine if a list is empty. #
let is_empty: [Int] -> Bool =
  fun xs ->
    case xs
    | [] => true
    | _::_ => false end in

# Return the element at the index. #
let nth: ([Int], Int) -> Option =
  fun xs, n ->
    case xs, n
    | x::_, 0 => Some(x)
    | _::xs, n => nth(xs, n - 1)
    | [], _ => None end in

# Reverse a List. #
let rev: [Int] -> [Int] =
fun l -> 
let go: ([Int], [Int]) -> [Int] =
  fun xs, acc -> 
    case xs 
    | [] => acc 
    | x::xs => go(xs, x::acc) end in
go(l, []) in

# Check if two lists are equal #
let equal: ([Int], [Int]) -> Bool =
    fun p, xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => x == y && equal(xs, ys)
    | _ => false end
in

# Initialize a list with a given length using an initializer function #
let init: (Int, Int -> Int) -> [Int] =
    fun len, f ->
        let go: (Int, [Int]) -> [Int] =
        fun idx, xs ->
            if idx < len 
            then go(idx + 1, xs @ [f(idx)])   
            else xs
        in
        go(0, [])
in

# Reduce a list from the left. #
let fold_left: ((Int, Int) -> Int, Int, [Int]) -> Int =
  fun f, acc, xs ->
    case xs 
    | [] => acc
    | hd::tl => fold_left(f, f(acc, hd), tl) end in

# Reduce a list from the right. #
let fold_right: ((Int, Int) -> Int, [Int], Int) -> Int =
  fun f, xs, acc ->
    case xs
    | [] => acc
    | hd::tl => f(hd, fold_right(f, tl, acc)) end in


666
LSP: Prelude: String parsed successfully
LSP: Prelude: Info map generated successfully
Debug: true, Constrain: Types
LSP: Init: Recieved string: # Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)




























































LSP: Init: String parsed successfully
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: >( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {go: ((?, ?) -> [?]), filter: (((Int -> Bool), [Int]) -> [Int]), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: 
  LSP: Info: ALL errors:Error in term:
  p
Nature of error: Variable p is not bound    
Error in term:
  p
Nature of error: Variable p is not bound    
Error in term:
  p
Nature of error: type ((Int -> Bool), [Int]) is not consistent with arrow type
  LSP: Info: BidiCtx: Cls: Let expression
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent: Root
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: [?]
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: :: @
  LSP: Concave: Backpack: 
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new_tokens ::= whitespace | "," | "::" | "@"
root ::= new_tokens

Top 20 Logits:

:18.4927
#:15.5791
##:14.89
let:14.1863
 :13.1496
in:12.9374
    :12.8268
   :12.6683
################:12.6264
  :12.5642
####:12.4303
```:12.2157
/*:11.9583
########:11.5521
//:11.5198
                :11.4937
        :11.4701
       :11.3526
[:11.1861
(*:11.1464
end:11.135

================
# Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)






























































LSP: Prelude: Recieved string: ### List ###

# Add an element to the front of a list. #
let cons: (Int, [Int]) -> [Int] = fun x, xs -> x::xs in

# Determine the length of a list. #
let length: [Int] -> Int =
  fun xs ->
    case xs
    | [] => 0
    | _::xs => 1 + length(xs) end in

# Extract the first element of a list. #
let hd: [Int] -> Option =
  fun l ->
    case l
    | [] => None
    | x::xs => Some(x) end in

# Extract the rest of the list. #
let tl: [Int] -> [Int] =
  fun l ->
    case l
    | [] => []
    | x::xs => xs end in

# Determine if a list is empty. #
let is_empty: [Int] -> Bool =
  fun xs ->
    case xs
    | [] => true
    | _::_ => false end in

# Return the element at the index. #
let nth: ([Int], Int) -> Option =
  fun xs, n ->
    case xs, n
    | x::_, 0 => Some(x)
    | _::xs, n => nth(xs, n - 1)
    | [], _ => None end in

# Reverse a List. #
let rev: [Int] -> [Int] =
fun l -> 
let go: ([Int], [Int]) -> [Int] =
  fun xs, acc -> 
    case xs 
    | [] => acc 
    | x::xs => go(xs, x::acc) end in
go(l, []) in

# Check if two lists are equal #
let equal: ([Int], [Int]) -> Bool =
    fun p, xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => x == y && equal(xs, ys)
    | _ => false end
in

# Initialize a list with a given length using an initializer function #
let init: (Int, Int -> Int) -> [Int] =
    fun len, f ->
        let go: (Int, [Int]) -> [Int] =
        fun idx, xs ->
            if idx < len 
            then go(idx + 1, xs @ [f(idx)])   
            else xs
        in
        go(0, [])
in

# Reduce a list from the left. #
let fold_left: ((Int, Int) -> Int, Int, [Int]) -> Int =
  fun f, acc, xs ->
    case xs 
    | [] => acc
    | hd::tl => fold_left(f, f(acc, hd), tl) end in

# Reduce a list from the right. #
let fold_right: ((Int, Int) -> Int, [Int], Int) -> Int =
  fun f, xs, acc ->
    case xs
    | [] => acc
    | hd::tl => f(hd, fold_right(f, tl, acc)) end in


666
LSP: Prelude: String parsed successfully
LSP: Prelude: Info map generated successfully
Debug: true, Constrain: Types
LSP: Init: Recieved string: # Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)





























































LSP: Init: String parsed successfully
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: >( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {go: ((?, ?) -> [?]), filter: (((Int -> Bool), [Int]) -> [Int]), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: 
  LSP: Info: ALL errors:Error in term:
  p
Nature of error: type ((Int -> Bool), [Int]) is not consistent with arrow type    
Error in term:
  p
Nature of error: Variable p is not bound    
Error in term:
  p
Nature of error: Variable p is not bound
  LSP: Info: BidiCtx: Cls: Let expression
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent: Root
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: [?]
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: :: @
  LSP: Concave: Backpack: 
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new_tokens ::= whitespace | "," | "::" | "@"
root ::= new_tokens

Top 20 Logits:

:18.517
#:15.6
##:14.8928
let:14.2102
 :13.1584
in:12.952
    :12.8244
   :12.6769
################:12.6443
  :12.5621
####:12.4274
```:12.2183
/*:11.9676
########:11.5633
//:11.5263
                :11.5018
        :11.4738
       :11.3621
[:11.1912
end:11.1567
(*:11.1545

================
# Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)































































LSP: Prelude: Recieved string: ### List ###

# Add an element to the front of a list. #
let cons: (Int, [Int]) -> [Int] = fun x, xs -> x::xs in

# Determine the length of a list. #
let length: [Int] -> Int =
  fun xs ->
    case xs
    | [] => 0
    | _::xs => 1 + length(xs) end in

# Extract the first element of a list. #
let hd: [Int] -> Option =
  fun l ->
    case l
    | [] => None
    | x::xs => Some(x) end in

# Extract the rest of the list. #
let tl: [Int] -> [Int] =
  fun l ->
    case l
    | [] => []
    | x::xs => xs end in

# Determine if a list is empty. #
let is_empty: [Int] -> Bool =
  fun xs ->
    case xs
    | [] => true
    | _::_ => false end in

# Return the element at the index. #
let nth: ([Int], Int) -> Option =
  fun xs, n ->
    case xs, n
    | x::_, 0 => Some(x)
    | _::xs, n => nth(xs, n - 1)
    | [], _ => None end in

# Reverse a List. #
let rev: [Int] -> [Int] =
fun l -> 
let go: ([Int], [Int]) -> [Int] =
  fun xs, acc -> 
    case xs 
    | [] => acc 
    | x::xs => go(xs, x::acc) end in
go(l, []) in

# Check if two lists are equal #
let equal: ([Int], [Int]) -> Bool =
    fun p, xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => x == y && equal(xs, ys)
    | _ => false end
in

# Initialize a list with a given length using an initializer function #
let init: (Int, Int -> Int) -> [Int] =
    fun len, f ->
        let go: (Int, [Int]) -> [Int] =
        fun idx, xs ->
            if idx < len 
            then go(idx + 1, xs @ [f(idx)])   
            else xs
        in
        go(0, [])
in

# Reduce a list from the left. #
let fold_left: ((Int, Int) -> Int, Int, [Int]) -> Int =
  fun f, acc, xs ->
    case xs 
    | [] => acc
    | hd::tl => fold_left(f, f(acc, hd), tl) end in

# Reduce a list from the right. #
let fold_right: ((Int, Int) -> Int, [Int], Int) -> Int =
  fun f, xs, acc ->
    case xs
    | [] => acc
    | hd::tl => f(hd, fold_right(f, tl, acc)) end in


666
LSP: Prelude: String parsed successfully
LSP: Prelude: Info map generated successfully
Debug: true, Constrain: Types
LSP: Init: Recieved string: # Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)






























































LSP: Init: String parsed successfully
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: >( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {go: ((?, ?) -> [?]), filter: (((Int -> Bool), [Int]) -> [Int]), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: 
  LSP: Info: ALL errors:Error in term:
  p
Nature of error: type ((Int -> Bool), [Int]) is not consistent with arrow type    
Error in term:
  p
Nature of error: Variable p is not bound    
Error in term:
  p
Nature of error: Variable p is not bound
  LSP: Info: BidiCtx: Cls: Let expression
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent: Root
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: [?]
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: :: @
  LSP: Concave: Backpack: 
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new_tokens ::= whitespace | "," | "::" | "@"
root ::= new_tokens

Top 20 Logits:

:18.5405
#:15.619
##:14.8884
let:14.2274
 :13.1661
in:12.9729
    :12.8207
   :12.6847
################:12.6622
  :12.562
####:12.4247
```:12.2246
/*:11.9718
########:11.5669
//:11.5298
                :11.5093
        :11.4774
       :11.3708
(:11.3473
[:11.1945
end:11.1785

================
# Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)
































































LSP: Prelude: Recieved string: ### List ###

# Add an element to the front of a list. #
let cons: (Int, [Int]) -> [Int] = fun x, xs -> x::xs in

# Determine the length of a list. #
let length: [Int] -> Int =
  fun xs ->
    case xs
    | [] => 0
    | _::xs => 1 + length(xs) end in

# Extract the first element of a list. #
let hd: [Int] -> Option =
  fun l ->
    case l
    | [] => None
    | x::xs => Some(x) end in

# Extract the rest of the list. #
let tl: [Int] -> [Int] =
  fun l ->
    case l
    | [] => []
    | x::xs => xs end in

# Determine if a list is empty. #
let is_empty: [Int] -> Bool =
  fun xs ->
    case xs
    | [] => true
    | _::_ => false end in

# Return the element at the index. #
let nth: ([Int], Int) -> Option =
  fun xs, n ->
    case xs, n
    | x::_, 0 => Some(x)
    | _::xs, n => nth(xs, n - 1)
    | [], _ => None end in

# Reverse a List. #
let rev: [Int] -> [Int] =
fun l -> 
let go: ([Int], [Int]) -> [Int] =
  fun xs, acc -> 
    case xs 
    | [] => acc 
    | x::xs => go(xs, x::acc) end in
go(l, []) in

# Check if two lists are equal #
let equal: ([Int], [Int]) -> Bool =
    fun p, xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => x == y && equal(xs, ys)
    | _ => false end
in

# Initialize a list with a given length using an initializer function #
let init: (Int, Int -> Int) -> [Int] =
    fun len, f ->
        let go: (Int, [Int]) -> [Int] =
        fun idx, xs ->
            if idx < len 
            then go(idx + 1, xs @ [f(idx)])   
            else xs
        in
        go(0, [])
in

# Reduce a list from the left. #
let fold_left: ((Int, Int) -> Int, Int, [Int]) -> Int =
  fun f, acc, xs ->
    case xs 
    | [] => acc
    | hd::tl => fold_left(f, f(acc, hd), tl) end in

# Reduce a list from the right. #
let fold_right: ((Int, Int) -> Int, [Int], Int) -> Int =
  fun f, xs, acc ->
    case xs
    | [] => acc
    | hd::tl => f(hd, fold_right(f, tl, acc)) end in


666
LSP: Prelude: String parsed successfully
LSP: Prelude: Info map generated successfully
Debug: true, Constrain: Types
LSP: Init: Recieved string: # Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)































































LSP: Init: String parsed successfully
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: >( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {go: ((?, ?) -> [?]), filter: (((Int -> Bool), [Int]) -> [Int]), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: 
  LSP: Info: ALL errors:Error in term:
  p
Nature of error: Variable p is not bound    
Error in term:
  p
Nature of error: Variable p is not bound    
Error in term:
  p
Nature of error: type ((Int -> Bool), [Int]) is not consistent with arrow type
  LSP: Info: BidiCtx: Cls: Let expression
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent: Root
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: [?]
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: :: @
  LSP: Concave: Backpack: 
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new_tokens ::= whitespace | "," | "::" | "@"
root ::= new_tokens

Top 20 Logits:

:18.5609
#:15.6297
##:14.8754
let:14.2341
 :13.1742
in:12.9928
    :12.8205
   :12.6918
################:12.6781
  :12.5683
####:12.4179
```:12.2246
/*:11.9749
########:11.5624
//:11.5296
                :11.5132
        :11.4814
       :11.3757
(:11.3337
end:11.1969
[:11.1922

================
# Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)

































































LSP: Prelude: Recieved string: ### List ###

# Add an element to the front of a list. #
let cons: (Int, [Int]) -> [Int] = fun x, xs -> x::xs in

# Determine the length of a list. #
let length: [Int] -> Int =
  fun xs ->
    case xs
    | [] => 0
    | _::xs => 1 + length(xs) end in

# Extract the first element of a list. #
let hd: [Int] -> Option =
  fun l ->
    case l
    | [] => None
    | x::xs => Some(x) end in

# Extract the rest of the list. #
let tl: [Int] -> [Int] =
  fun l ->
    case l
    | [] => []
    | x::xs => xs end in

# Determine if a list is empty. #
let is_empty: [Int] -> Bool =
  fun xs ->
    case xs
    | [] => true
    | _::_ => false end in

# Return the element at the index. #
let nth: ([Int], Int) -> Option =
  fun xs, n ->
    case xs, n
    | x::_, 0 => Some(x)
    | _::xs, n => nth(xs, n - 1)
    | [], _ => None end in

# Reverse a List. #
let rev: [Int] -> [Int] =
fun l -> 
let go: ([Int], [Int]) -> [Int] =
  fun xs, acc -> 
    case xs 
    | [] => acc 
    | x::xs => go(xs, x::acc) end in
go(l, []) in

# Check if two lists are equal #
let equal: ([Int], [Int]) -> Bool =
    fun p, xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => x == y && equal(xs, ys)
    | _ => false end
in

# Initialize a list with a given length using an initializer function #
let init: (Int, Int -> Int) -> [Int] =
    fun len, f ->
        let go: (Int, [Int]) -> [Int] =
        fun idx, xs ->
            if idx < len 
            then go(idx + 1, xs @ [f(idx)])   
            else xs
        in
        go(0, [])
in

# Reduce a list from the left. #
let fold_left: ((Int, Int) -> Int, Int, [Int]) -> Int =
  fun f, acc, xs ->
    case xs 
    | [] => acc
    | hd::tl => fold_left(f, f(acc, hd), tl) end in

# Reduce a list from the right. #
let fold_right: ((Int, Int) -> Int, [Int], Int) -> Int =
  fun f, xs, acc ->
    case xs
    | [] => acc
    | hd::tl => f(hd, fold_right(f, tl, acc)) end in


666
LSP: Prelude: String parsed successfully
LSP: Prelude: Info map generated successfully
Debug: true, Constrain: Types
LSP: Init: Recieved string: # Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)
































































LSP: Init: String parsed successfully
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: >( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {go: ((?, ?) -> [?]), filter: (((Int -> Bool), [Int]) -> [Int]), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: 
  LSP: Info: ALL errors:Error in term:
  p
Nature of error: Variable p is not bound    
Error in term:
  p
Nature of error: type ((Int -> Bool), [Int]) is not consistent with arrow type    
Error in term:
  p
Nature of error: Variable p is not bound
  LSP: Info: BidiCtx: Cls: Let expression
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent: Root
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: [?]
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: :: @
  LSP: Concave: Backpack: 
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new_tokens ::= whitespace | "," | "::" | "@"
root ::= new_tokens

Top 20 Logits:

:18.5767
#:15.632
##:14.8587
let:14.2345
 :13.1826
in:12.9984
    :12.8245
   :12.6978
################:12.6907
  :12.5799
####:12.4085
```:12.2124
/*:11.9801
########:11.5553
//:11.527
                :11.5116
        :11.484
       :11.3747
(:11.3259
end:11.1999
[:11.1857

================
# Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)


































































LSP: Prelude: Recieved string: ### List ###

# Add an element to the front of a list. #
let cons: (Int, [Int]) -> [Int] = fun x, xs -> x::xs in

# Determine the length of a list. #
let length: [Int] -> Int =
  fun xs ->
    case xs
    | [] => 0
    | _::xs => 1 + length(xs) end in

# Extract the first element of a list. #
let hd: [Int] -> Option =
  fun l ->
    case l
    | [] => None
    | x::xs => Some(x) end in

# Extract the rest of the list. #
let tl: [Int] -> [Int] =
  fun l ->
    case l
    | [] => []
    | x::xs => xs end in

# Determine if a list is empty. #
let is_empty: [Int] -> Bool =
  fun xs ->
    case xs
    | [] => true
    | _::_ => false end in

# Return the element at the index. #
let nth: ([Int], Int) -> Option =
  fun xs, n ->
    case xs, n
    | x::_, 0 => Some(x)
    | _::xs, n => nth(xs, n - 1)
    | [], _ => None end in

# Reverse a List. #
let rev: [Int] -> [Int] =
fun l -> 
let go: ([Int], [Int]) -> [Int] =
  fun xs, acc -> 
    case xs 
    | [] => acc 
    | x::xs => go(xs, x::acc) end in
go(l, []) in

# Check if two lists are equal #
let equal: ([Int], [Int]) -> Bool =
    fun p, xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => x == y && equal(xs, ys)
    | _ => false end
in

# Initialize a list with a given length using an initializer function #
let init: (Int, Int -> Int) -> [Int] =
    fun len, f ->
        let go: (Int, [Int]) -> [Int] =
        fun idx, xs ->
            if idx < len 
            then go(idx + 1, xs @ [f(idx)])   
            else xs
        in
        go(0, [])
in

# Reduce a list from the left. #
let fold_left: ((Int, Int) -> Int, Int, [Int]) -> Int =
  fun f, acc, xs ->
    case xs 
    | [] => acc
    | hd::tl => fold_left(f, f(acc, hd), tl) end in

# Reduce a list from the right. #
let fold_right: ((Int, Int) -> Int, [Int], Int) -> Int =
  fun f, xs, acc ->
    case xs
    | [] => acc
    | hd::tl => f(hd, fold_right(f, tl, acc)) end in


666
LSP: Prelude: String parsed successfully
LSP: Prelude: Info map generated successfully
Debug: true, Constrain: Types
LSP: Init: Recieved string: # Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)

































































LSP: Init: String parsed successfully
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: >( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {go: ((?, ?) -> [?]), filter: (((Int -> Bool), [Int]) -> [Int]), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: 
  LSP: Info: ALL errors:Error in term:
  p
Nature of error: Variable p is not bound    
Error in term:
  p
Nature of error: type ((Int -> Bool), [Int]) is not consistent with arrow type    
Error in term:
  p
Nature of error: Variable p is not bound
  LSP: Info: BidiCtx: Cls: Let expression
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent: Root
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: [?]
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: :: @
  LSP: Concave: Backpack: 
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new_tokens ::= whitespace | "," | "::" | "@"
root ::= new_tokens

Top 20 Logits:

:18.5896
#:15.6293
##:14.8422
let:14.2352
 :13.1909
in:12.988
    :12.8286
   :12.7011
################:12.6997
  :12.5939
####:12.4003
```:12.1971
/*:11.9849
########:11.5482
//:11.521
                :11.5061
        :11.4838
       :11.3683
(:11.3303
end:11.1843
[:11.1783

================
# Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)



































































LSP: Prelude: Recieved string: ### List ###

# Add an element to the front of a list. #
let cons: (Int, [Int]) -> [Int] = fun x, xs -> x::xs in

# Determine the length of a list. #
let length: [Int] -> Int =
  fun xs ->
    case xs
    | [] => 0
    | _::xs => 1 + length(xs) end in

# Extract the first element of a list. #
let hd: [Int] -> Option =
  fun l ->
    case l
    | [] => None
    | x::xs => Some(x) end in

# Extract the rest of the list. #
let tl: [Int] -> [Int] =
  fun l ->
    case l
    | [] => []
    | x::xs => xs end in

# Determine if a list is empty. #
let is_empty: [Int] -> Bool =
  fun xs ->
    case xs
    | [] => true
    | _::_ => false end in

# Return the element at the index. #
let nth: ([Int], Int) -> Option =
  fun xs, n ->
    case xs, n
    | x::_, 0 => Some(x)
    | _::xs, n => nth(xs, n - 1)
    | [], _ => None end in

# Reverse a List. #
let rev: [Int] -> [Int] =
fun l -> 
let go: ([Int], [Int]) -> [Int] =
  fun xs, acc -> 
    case xs 
    | [] => acc 
    | x::xs => go(xs, x::acc) end in
go(l, []) in

# Check if two lists are equal #
let equal: ([Int], [Int]) -> Bool =
    fun p, xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => x == y && equal(xs, ys)
    | _ => false end
in

# Initialize a list with a given length using an initializer function #
let init: (Int, Int -> Int) -> [Int] =
    fun len, f ->
        let go: (Int, [Int]) -> [Int] =
        fun idx, xs ->
            if idx < len 
            then go(idx + 1, xs @ [f(idx)])   
            else xs
        in
        go(0, [])
in

# Reduce a list from the left. #
let fold_left: ((Int, Int) -> Int, Int, [Int]) -> Int =
  fun f, acc, xs ->
    case xs 
    | [] => acc
    | hd::tl => fold_left(f, f(acc, hd), tl) end in

# Reduce a list from the right. #
let fold_right: ((Int, Int) -> Int, [Int], Int) -> Int =
  fun f, xs, acc ->
    case xs
    | [] => acc
    | hd::tl => f(hd, fold_right(f, tl, acc)) end in


666
LSP: Prelude: String parsed successfully
LSP: Prelude: Info map generated successfully
Debug: true, Constrain: Types
LSP: Init: Recieved string: # Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)


































































LSP: Init: String parsed successfully
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: >( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {go: ((?, ?) -> [?]), filter: (((Int -> Bool), [Int]) -> [Int]), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: 
  LSP: Info: ALL errors:Error in term:
  p
Nature of error: Variable p is not bound    
Error in term:
  p
Nature of error: type ((Int -> Bool), [Int]) is not consistent with arrow type    
Error in term:
  p
Nature of error: Variable p is not bound
  LSP: Info: BidiCtx: Cls: Let expression
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent: Root
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: [?]
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: :: @
  LSP: Concave: Backpack: 
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new_tokens ::= whitespace | "," | "::" | "@"
root ::= new_tokens

Top 20 Logits:

:18.6003
#:15.6267
##:14.8275
let:14.2421
 :13.1949
in:12.9709
    :12.8252
################:12.7066
   :12.6966
  :12.6042
####:12.394
```:12.1876
/*:11.9869
########:11.5407
//:11.5123
                :11.4976
        :11.4765
       :11.3547
(:11.3431
[:11.1739
end:11.1547

================
# Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)




































































LSP: Prelude: Recieved string: ### List ###

# Add an element to the front of a list. #
let cons: (Int, [Int]) -> [Int] = fun x, xs -> x::xs in

# Determine the length of a list. #
let length: [Int] -> Int =
  fun xs ->
    case xs
    | [] => 0
    | _::xs => 1 + length(xs) end in

# Extract the first element of a list. #
let hd: [Int] -> Option =
  fun l ->
    case l
    | [] => None
    | x::xs => Some(x) end in

# Extract the rest of the list. #
let tl: [Int] -> [Int] =
  fun l ->
    case l
    | [] => []
    | x::xs => xs end in

# Determine if a list is empty. #
let is_empty: [Int] -> Bool =
  fun xs ->
    case xs
    | [] => true
    | _::_ => false end in

# Return the element at the index. #
let nth: ([Int], Int) -> Option =
  fun xs, n ->
    case xs, n
    | x::_, 0 => Some(x)
    | _::xs, n => nth(xs, n - 1)
    | [], _ => None end in

# Reverse a List. #
let rev: [Int] -> [Int] =
fun l -> 
let go: ([Int], [Int]) -> [Int] =
  fun xs, acc -> 
    case xs 
    | [] => acc 
    | x::xs => go(xs, x::acc) end in
go(l, []) in

# Check if two lists are equal #
let equal: ([Int], [Int]) -> Bool =
    fun p, xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => x == y && equal(xs, ys)
    | _ => false end
in

# Initialize a list with a given length using an initializer function #
let init: (Int, Int -> Int) -> [Int] =
    fun len, f ->
        let go: (Int, [Int]) -> [Int] =
        fun idx, xs ->
            if idx < len 
            then go(idx + 1, xs @ [f(idx)])   
            else xs
        in
        go(0, [])
in

# Reduce a list from the left. #
let fold_left: ((Int, Int) -> Int, Int, [Int]) -> Int =
  fun f, acc, xs ->
    case xs 
    | [] => acc
    | hd::tl => fold_left(f, f(acc, hd), tl) end in

# Reduce a list from the right. #
let fold_right: ((Int, Int) -> Int, [Int], Int) -> Int =
  fun f, xs, acc ->
    case xs
    | [] => acc
    | hd::tl => f(hd, fold_right(f, tl, acc)) end in


666
LSP: Prelude: String parsed successfully
LSP: Prelude: Info map generated successfully
Debug: true, Constrain: Types
LSP: Init: Recieved string: # Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)



































































LSP: Init: String parsed successfully
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: >( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {go: ((?, ?) -> [?]), filter: (((Int -> Bool), [Int]) -> [Int]), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: 
  LSP: Info: ALL errors:Error in term:
  p
Nature of error: Variable p is not bound    
Error in term:
  p
Nature of error: Variable p is not bound    
Error in term:
  p
Nature of error: type ((Int -> Bool), [Int]) is not consistent with arrow type
  LSP: Info: BidiCtx: Cls: Let expression
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent: Root
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: [?]
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: :: @
  LSP: Concave: Backpack: 
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new_tokens ::= whitespace | "," | "::" | "@"
root ::= new_tokens

Top 20 Logits:

:18.608
#:15.6256
##:14.8135
let:14.2555
 :13.1901
in:12.9558
    :12.8102
################:12.7092
   :12.6815
  :12.6043
####:12.3853
```:12.1844
/*:11.9854
########:11.5281
//:11.5003
                :11.4864
        :11.4602
(:11.3544
       :11.3334
[:11.1734
end:11.1169

================
# Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)





































































LSP: Prelude: Recieved string: ### List ###

# Add an element to the front of a list. #
let cons: (Int, [Int]) -> [Int] = fun x, xs -> x::xs in

# Determine the length of a list. #
let length: [Int] -> Int =
  fun xs ->
    case xs
    | [] => 0
    | _::xs => 1 + length(xs) end in

# Extract the first element of a list. #
let hd: [Int] -> Option =
  fun l ->
    case l
    | [] => None
    | x::xs => Some(x) end in

# Extract the rest of the list. #
let tl: [Int] -> [Int] =
  fun l ->
    case l
    | [] => []
    | x::xs => xs end in

# Determine if a list is empty. #
let is_empty: [Int] -> Bool =
  fun xs ->
    case xs
    | [] => true
    | _::_ => false end in

# Return the element at the index. #
let nth: ([Int], Int) -> Option =
  fun xs, n ->
    case xs, n
    | x::_, 0 => Some(x)
    | _::xs, n => nth(xs, n - 1)
    | [], _ => None end in

# Reverse a List. #
let rev: [Int] -> [Int] =
fun l -> 
let go: ([Int], [Int]) -> [Int] =
  fun xs, acc -> 
    case xs 
    | [] => acc 
    | x::xs => go(xs, x::acc) end in
go(l, []) in

# Check if two lists are equal #
let equal: ([Int], [Int]) -> Bool =
    fun p, xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => x == y && equal(xs, ys)
    | _ => false end
in

# Initialize a list with a given length using an initializer function #
let init: (Int, Int -> Int) -> [Int] =
    fun len, f ->
        let go: (Int, [Int]) -> [Int] =
        fun idx, xs ->
            if idx < len 
            then go(idx + 1, xs @ [f(idx)])   
            else xs
        in
        go(0, [])
in

# Reduce a list from the left. #
let fold_left: ((Int, Int) -> Int, Int, [Int]) -> Int =
  fun f, acc, xs ->
    case xs 
    | [] => acc
    | hd::tl => fold_left(f, f(acc, hd), tl) end in

# Reduce a list from the right. #
let fold_right: ((Int, Int) -> Int, [Int], Int) -> Int =
  fun f, xs, acc ->
    case xs
    | [] => acc
    | hd::tl => f(hd, fold_right(f, tl, acc)) end in


666
LSP: Prelude: String parsed successfully
LSP: Prelude: Info map generated successfully
Debug: true, Constrain: Types
LSP: Init: Recieved string: # Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)




































































LSP: Init: String parsed successfully
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: >( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {go: ((?, ?) -> [?]), filter: (((Int -> Bool), [Int]) -> [Int]), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: 
  LSP: Info: ALL errors:Error in term:
  p
Nature of error: type ((Int -> Bool), [Int]) is not consistent with arrow type    
Error in term:
  p
Nature of error: Variable p is not bound    
Error in term:
  p
Nature of error: Variable p is not bound
  LSP: Info: BidiCtx: Cls: Let expression
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent: Root
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: [?]
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: :: @
  LSP: Concave: Backpack: 
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new_tokens ::= whitespace | "," | "::" | "@"
root ::= new_tokens

Top 20 Logits:

:18.6109
#:15.6217
##:14.7951
let:14.2692
 :13.1757
in:12.9446
    :12.7858
################:12.7033
   :12.6583
  :12.5925
####:12.3697
```:12.1787
/*:11.9783
########:11.5046
//:11.4813
                :11.4731
        :11.4374
(:11.3543
       :11.3069
[:11.1725
(*:11.0985

================
# Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)






































































LSP: Prelude: Recieved string: ### List ###

# Add an element to the front of a list. #
let cons: (Int, [Int]) -> [Int] = fun x, xs -> x::xs in

# Determine the length of a list. #
let length: [Int] -> Int =
  fun xs ->
    case xs
    | [] => 0
    | _::xs => 1 + length(xs) end in

# Extract the first element of a list. #
let hd: [Int] -> Option =
  fun l ->
    case l
    | [] => None
    | x::xs => Some(x) end in

# Extract the rest of the list. #
let tl: [Int] -> [Int] =
  fun l ->
    case l
    | [] => []
    | x::xs => xs end in

# Determine if a list is empty. #
let is_empty: [Int] -> Bool =
  fun xs ->
    case xs
    | [] => true
    | _::_ => false end in

# Return the element at the index. #
let nth: ([Int], Int) -> Option =
  fun xs, n ->
    case xs, n
    | x::_, 0 => Some(x)
    | _::xs, n => nth(xs, n - 1)
    | [], _ => None end in

# Reverse a List. #
let rev: [Int] -> [Int] =
fun l -> 
let go: ([Int], [Int]) -> [Int] =
  fun xs, acc -> 
    case xs 
    | [] => acc 
    | x::xs => go(xs, x::acc) end in
go(l, []) in

# Check if two lists are equal #
let equal: ([Int], [Int]) -> Bool =
    fun p, xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => x == y && equal(xs, ys)
    | _ => false end
in

# Initialize a list with a given length using an initializer function #
let init: (Int, Int -> Int) -> [Int] =
    fun len, f ->
        let go: (Int, [Int]) -> [Int] =
        fun idx, xs ->
            if idx < len 
            then go(idx + 1, xs @ [f(idx)])   
            else xs
        in
        go(0, [])
in

# Reduce a list from the left. #
let fold_left: ((Int, Int) -> Int, Int, [Int]) -> Int =
  fun f, acc, xs ->
    case xs 
    | [] => acc
    | hd::tl => fold_left(f, f(acc, hd), tl) end in

# Reduce a list from the right. #
let fold_right: ((Int, Int) -> Int, [Int], Int) -> Int =
  fun f, xs, acc ->
    case xs
    | [] => acc
    | hd::tl => f(hd, fold_right(f, tl, acc)) end in


666
LSP: Prelude: String parsed successfully
LSP: Prelude: Info map generated successfully
Debug: true, Constrain: Types
LSP: Init: Recieved string: # Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)





































































LSP: Init: String parsed successfully
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: >( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {go: ((?, ?) -> [?]), filter: (((Int -> Bool), [Int]) -> [Int]), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: 
  LSP: Info: ALL errors:Error in term:
  p
Nature of error: Variable p is not bound    
Error in term:
  p
Nature of error: type ((Int -> Bool), [Int]) is not consistent with arrow type    
Error in term:
  p
Nature of error: Variable p is not bound
  LSP: Info: BidiCtx: Cls: Let expression
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent: Root
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: [?]
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: :: @
  LSP: Concave: Backpack: 
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new_tokens ::= whitespace | "," | "::" | "@"
root ::= new_tokens

Top 20 Logits:

:18.6093
#:15.6107
##:14.772
let:14.2772
 :13.1579
in:12.9265
    :12.7599
################:12.6901
   :12.6359
  :12.5742
####:12.3474
```:12.1615
/*:11.9679
########:11.4731
                :11.4597
//:11.4556
        :11.4136
(:11.3399
       :11.2806
[:11.1662
(*:11.0765

================
# Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)







































































LSP: Prelude: Recieved string: ### List ###

# Add an element to the front of a list. #
let cons: (Int, [Int]) -> [Int] = fun x, xs -> x::xs in

# Determine the length of a list. #
let length: [Int] -> Int =
  fun xs ->
    case xs
    | [] => 0
    | _::xs => 1 + length(xs) end in

# Extract the first element of a list. #
let hd: [Int] -> Option =
  fun l ->
    case l
    | [] => None
    | x::xs => Some(x) end in

# Extract the rest of the list. #
let tl: [Int] -> [Int] =
  fun l ->
    case l
    | [] => []
    | x::xs => xs end in

# Determine if a list is empty. #
let is_empty: [Int] -> Bool =
  fun xs ->
    case xs
    | [] => true
    | _::_ => false end in

# Return the element at the index. #
let nth: ([Int], Int) -> Option =
  fun xs, n ->
    case xs, n
    | x::_, 0 => Some(x)
    | _::xs, n => nth(xs, n - 1)
    | [], _ => None end in

# Reverse a List. #
let rev: [Int] -> [Int] =
fun l -> 
let go: ([Int], [Int]) -> [Int] =
  fun xs, acc -> 
    case xs 
    | [] => acc 
    | x::xs => go(xs, x::acc) end in
go(l, []) in

# Check if two lists are equal #
let equal: ([Int], [Int]) -> Bool =
    fun p, xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => x == y && equal(xs, ys)
    | _ => false end
in

# Initialize a list with a given length using an initializer function #
let init: (Int, Int -> Int) -> [Int] =
    fun len, f ->
        let go: (Int, [Int]) -> [Int] =
        fun idx, xs ->
            if idx < len 
            then go(idx + 1, xs @ [f(idx)])   
            else xs
        in
        go(0, [])
in

# Reduce a list from the left. #
let fold_left: ((Int, Int) -> Int, Int, [Int]) -> Int =
  fun f, acc, xs ->
    case xs 
    | [] => acc
    | hd::tl => fold_left(f, f(acc, hd), tl) end in

# Reduce a list from the right. #
let fold_right: ((Int, Int) -> Int, [Int], Int) -> Int =
  fun f, xs, acc ->
    case xs
    | [] => acc
    | hd::tl => f(hd, fold_right(f, tl, acc)) end in


666
LSP: Prelude: String parsed successfully
LSP: Prelude: Info map generated successfully
Debug: true, Constrain: Types
LSP: Init: Recieved string: # Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)






































































LSP: Init: String parsed successfully
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: >( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {go: ((?, ?) -> [?]), filter: (((Int -> Bool), [Int]) -> [Int]), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: 
  LSP: Info: ALL errors:Error in term:
  p
Nature of error: type ((Int -> Bool), [Int]) is not consistent with arrow type    
Error in term:
  p
Nature of error: Variable p is not bound    
Error in term:
  p
Nature of error: Variable p is not bound
  LSP: Info: BidiCtx: Cls: Let expression
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent: Root
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: [?]
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: :: @
  LSP: Concave: Backpack: 
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new_tokens ::= whitespace | "," | "::" | "@"
root ::= new_tokens

Top 20 Logits:

:18.6057
#:15.594
##:14.751
let:14.2783
 :13.1458
in:12.8895
    :12.7411
################:12.6744
   :12.6255
  :12.5591
####:12.3241
```:12.1354
/*:11.9586
                :11.4485
########:11.4429
//:11.4298
        :11.3928
(:11.3199
       :11.2608
[:11.154
(*:11.0532

================
# Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)








































































LSP: Prelude: Recieved string: ### List ###

# Add an element to the front of a list. #
let cons: (Int, [Int]) -> [Int] = fun x, xs -> x::xs in

# Determine the length of a list. #
let length: [Int] -> Int =
  fun xs ->
    case xs
    | [] => 0
    | _::xs => 1 + length(xs) end in

# Extract the first element of a list. #
let hd: [Int] -> Option =
  fun l ->
    case l
    | [] => None
    | x::xs => Some(x) end in

# Extract the rest of the list. #
let tl: [Int] -> [Int] =
  fun l ->
    case l
    | [] => []
    | x::xs => xs end in

# Determine if a list is empty. #
let is_empty: [Int] -> Bool =
  fun xs ->
    case xs
    | [] => true
    | _::_ => false end in

# Return the element at the index. #
let nth: ([Int], Int) -> Option =
  fun xs, n ->
    case xs, n
    | x::_, 0 => Some(x)
    | _::xs, n => nth(xs, n - 1)
    | [], _ => None end in

# Reverse a List. #
let rev: [Int] -> [Int] =
fun l -> 
let go: ([Int], [Int]) -> [Int] =
  fun xs, acc -> 
    case xs 
    | [] => acc 
    | x::xs => go(xs, x::acc) end in
go(l, []) in

# Check if two lists are equal #
let equal: ([Int], [Int]) -> Bool =
    fun p, xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => x == y && equal(xs, ys)
    | _ => false end
in

# Initialize a list with a given length using an initializer function #
let init: (Int, Int -> Int) -> [Int] =
    fun len, f ->
        let go: (Int, [Int]) -> [Int] =
        fun idx, xs ->
            if idx < len 
            then go(idx + 1, xs @ [f(idx)])   
            else xs
        in
        go(0, [])
in

# Reduce a list from the left. #
let fold_left: ((Int, Int) -> Int, Int, [Int]) -> Int =
  fun f, acc, xs ->
    case xs 
    | [] => acc
    | hd::tl => fold_left(f, f(acc, hd), tl) end in

# Reduce a list from the right. #
let fold_right: ((Int, Int) -> Int, [Int], Int) -> Int =
  fun f, xs, acc ->
    case xs
    | [] => acc
    | hd::tl => f(hd, fold_right(f, tl, acc)) end in


666
LSP: Prelude: String parsed successfully
LSP: Prelude: Info map generated successfully
Debug: true, Constrain: Types
LSP: Init: Recieved string: # Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)







































































LSP: Init: String parsed successfully
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: >( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {go: ((?, ?) -> [?]), filter: (((Int -> Bool), [Int]) -> [Int]), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: 
  LSP: Info: ALL errors:Error in term:
  p
Nature of error: Variable p is not bound    
Error in term:
  p
Nature of error: Variable p is not bound    
Error in term:
  p
Nature of error: type ((Int -> Bool), [Int]) is not consistent with arrow type
  LSP: Info: BidiCtx: Cls: Let expression
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent: Root
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: [?]
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: :: @
  LSP: Concave: Backpack: 
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new_tokens ::= whitespace | "," | "::" | "@"
root ::= new_tokens

Top 20 Logits:

:18.6046
#:15.5783
##:14.7373
let:14.2751
 :13.1447
in:12.8435
    :12.7329
################:12.6611
   :12.6305
  :12.5532
####:12.3064
```:12.1101
/*:11.9523
                :11.441
########:11.4228
//:11.4098
        :11.3767
(:11.3087
       :11.2497
[:11.1382
end:11.0404

================
# Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)









































































LSP: Prelude: Recieved string: ### List ###

# Add an element to the front of a list. #
let cons: (Int, [Int]) -> [Int] = fun x, xs -> x::xs in

# Determine the length of a list. #
let length: [Int] -> Int =
  fun xs ->
    case xs
    | [] => 0
    | _::xs => 1 + length(xs) end in

# Extract the first element of a list. #
let hd: [Int] -> Option =
  fun l ->
    case l
    | [] => None
    | x::xs => Some(x) end in

# Extract the rest of the list. #
let tl: [Int] -> [Int] =
  fun l ->
    case l
    | [] => []
    | x::xs => xs end in

# Determine if a list is empty. #
let is_empty: [Int] -> Bool =
  fun xs ->
    case xs
    | [] => true
    | _::_ => false end in

# Return the element at the index. #
let nth: ([Int], Int) -> Option =
  fun xs, n ->
    case xs, n
    | x::_, 0 => Some(x)
    | _::xs, n => nth(xs, n - 1)
    | [], _ => None end in

# Reverse a List. #
let rev: [Int] -> [Int] =
fun l -> 
let go: ([Int], [Int]) -> [Int] =
  fun xs, acc -> 
    case xs 
    | [] => acc 
    | x::xs => go(xs, x::acc) end in
go(l, []) in

# Check if two lists are equal #
let equal: ([Int], [Int]) -> Bool =
    fun p, xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => x == y && equal(xs, ys)
    | _ => false end
in

# Initialize a list with a given length using an initializer function #
let init: (Int, Int -> Int) -> [Int] =
    fun len, f ->
        let go: (Int, [Int]) -> [Int] =
        fun idx, xs ->
            if idx < len 
            then go(idx + 1, xs @ [f(idx)])   
            else xs
        in
        go(0, [])
in

# Reduce a list from the left. #
let fold_left: ((Int, Int) -> Int, Int, [Int]) -> Int =
  fun f, acc, xs ->
    case xs 
    | [] => acc
    | hd::tl => fold_left(f, f(acc, hd), tl) end in

# Reduce a list from the right. #
let fold_right: ((Int, Int) -> Int, [Int], Int) -> Int =
  fun f, xs, acc ->
    case xs
    | [] => acc
    | hd::tl => f(hd, fold_right(f, tl, acc)) end in


666
LSP: Prelude: String parsed successfully
LSP: Prelude: Info map generated successfully
Debug: true, Constrain: Types
LSP: Init: Recieved string: # Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)








































































LSP: Init: String parsed successfully
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: >( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {go: ((?, ?) -> [?]), filter: (((Int -> Bool), [Int]) -> [Int]), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: 
  LSP: Info: ALL errors:Error in term:
  p
Nature of error: type ((Int -> Bool), [Int]) is not consistent with arrow type    
Error in term:
  p
Nature of error: Variable p is not bound    
Error in term:
  p
Nature of error: Variable p is not bound
  LSP: Info: BidiCtx: Cls: Let expression
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent: Root
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: [?]
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: :: @
  LSP: Concave: Backpack: 
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new_tokens ::= whitespace | "," | "::" | "@"
root ::= new_tokens

Top 20 Logits:

:18.6094
#:15.5711
##:14.729
let:14.273
 :13.1534
in:12.8115
    :12.7333
################:12.6517
   :12.6454
  :12.5586
####:12.2968
```:12.0968
/*:11.9487
                :11.4358
########:11.4139
//:11.3964
        :11.3659
(:11.3119
       :11.2446
[:11.1223
end:11.046

================
# Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)










































































LSP: Prelude: Recieved string: ### List ###

# Add an element to the front of a list. #
let cons: (Int, [Int]) -> [Int] = fun x, xs -> x::xs in

# Determine the length of a list. #
let length: [Int] -> Int =
  fun xs ->
    case xs
    | [] => 0
    | _::xs => 1 + length(xs) end in

# Extract the first element of a list. #
let hd: [Int] -> Option =
  fun l ->
    case l
    | [] => None
    | x::xs => Some(x) end in

# Extract the rest of the list. #
let tl: [Int] -> [Int] =
  fun l ->
    case l
    | [] => []
    | x::xs => xs end in

# Determine if a list is empty. #
let is_empty: [Int] -> Bool =
  fun xs ->
    case xs
    | [] => true
    | _::_ => false end in

# Return the element at the index. #
let nth: ([Int], Int) -> Option =
  fun xs, n ->
    case xs, n
    | x::_, 0 => Some(x)
    | _::xs, n => nth(xs, n - 1)
    | [], _ => None end in

# Reverse a List. #
let rev: [Int] -> [Int] =
fun l -> 
let go: ([Int], [Int]) -> [Int] =
  fun xs, acc -> 
    case xs 
    | [] => acc 
    | x::xs => go(xs, x::acc) end in
go(l, []) in

# Check if two lists are equal #
let equal: ([Int], [Int]) -> Bool =
    fun p, xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => x == y && equal(xs, ys)
    | _ => false end
in

# Initialize a list with a given length using an initializer function #
let init: (Int, Int -> Int) -> [Int] =
    fun len, f ->
        let go: (Int, [Int]) -> [Int] =
        fun idx, xs ->
            if idx < len 
            then go(idx + 1, xs @ [f(idx)])   
            else xs
        in
        go(0, [])
in

# Reduce a list from the left. #
let fold_left: ((Int, Int) -> Int, Int, [Int]) -> Int =
  fun f, acc, xs ->
    case xs 
    | [] => acc
    | hd::tl => fold_left(f, f(acc, hd), tl) end in

# Reduce a list from the right. #
let fold_right: ((Int, Int) -> Int, [Int], Int) -> Int =
  fun f, xs, acc ->
    case xs
    | [] => acc
    | hd::tl => f(hd, fold_right(f, tl, acc)) end in


666
LSP: Prelude: String parsed successfully
LSP: Prelude: Info map generated successfully
Debug: true, Constrain: Types
LSP: Init: Recieved string: # Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)









































































LSP: Init: String parsed successfully
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: >( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {go: ((?, ?) -> [?]), filter: (((Int -> Bool), [Int]) -> [Int]), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: 
  LSP: Info: ALL errors:Error in term:
  p
Nature of error: Variable p is not bound    
Error in term:
  p
Nature of error: type ((Int -> Bool), [Int]) is not consistent with arrow type    
Error in term:
  p
Nature of error: Variable p is not bound
  LSP: Info: BidiCtx: Cls: Let expression
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent: Root
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: [?]
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: :: @
  LSP: Concave: Backpack: 
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new_tokens ::= whitespace | "," | "::" | "@"
root ::= new_tokens

Top 20 Logits:

:18.6174
#:15.5733
##:14.7184
let:14.2761
 :13.1626
in:12.8076
    :12.7335
   :12.6574
################:12.6424
  :12.5675
####:12.2906
```:12.0966
/*:11.9464
                :11.43
########:11.4079
//:11.3878
        :11.3581
(:11.3218
       :11.2395
[:11.1067
end:11.0519

================
# Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)











































































LSP: Prelude: Recieved string: ### List ###

# Add an element to the front of a list. #
let cons: (Int, [Int]) -> [Int] = fun x, xs -> x::xs in

# Determine the length of a list. #
let length: [Int] -> Int =
  fun xs ->
    case xs
    | [] => 0
    | _::xs => 1 + length(xs) end in

# Extract the first element of a list. #
let hd: [Int] -> Option =
  fun l ->
    case l
    | [] => None
    | x::xs => Some(x) end in

# Extract the rest of the list. #
let tl: [Int] -> [Int] =
  fun l ->
    case l
    | [] => []
    | x::xs => xs end in

# Determine if a list is empty. #
let is_empty: [Int] -> Bool =
  fun xs ->
    case xs
    | [] => true
    | _::_ => false end in

# Return the element at the index. #
let nth: ([Int], Int) -> Option =
  fun xs, n ->
    case xs, n
    | x::_, 0 => Some(x)
    | _::xs, n => nth(xs, n - 1)
    | [], _ => None end in

# Reverse a List. #
let rev: [Int] -> [Int] =
fun l -> 
let go: ([Int], [Int]) -> [Int] =
  fun xs, acc -> 
    case xs 
    | [] => acc 
    | x::xs => go(xs, x::acc) end in
go(l, []) in

# Check if two lists are equal #
let equal: ([Int], [Int]) -> Bool =
    fun p, xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => x == y && equal(xs, ys)
    | _ => false end
in

# Initialize a list with a given length using an initializer function #
let init: (Int, Int -> Int) -> [Int] =
    fun len, f ->
        let go: (Int, [Int]) -> [Int] =
        fun idx, xs ->
            if idx < len 
            then go(idx + 1, xs @ [f(idx)])   
            else xs
        in
        go(0, [])
in

# Reduce a list from the left. #
let fold_left: ((Int, Int) -> Int, Int, [Int]) -> Int =
  fun f, acc, xs ->
    case xs 
    | [] => acc
    | hd::tl => fold_left(f, f(acc, hd), tl) end in

# Reduce a list from the right. #
let fold_right: ((Int, Int) -> Int, [Int], Int) -> Int =
  fun f, xs, acc ->
    case xs
    | [] => acc
    | hd::tl => f(hd, fold_right(f, tl, acc)) end in


666
LSP: Prelude: String parsed successfully
LSP: Prelude: Info map generated successfully
Debug: true, Constrain: Types
LSP: Init: Recieved string: # Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)










































































LSP: Init: String parsed successfully
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: >( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {go: ((?, ?) -> [?]), filter: (((Int -> Bool), [Int]) -> [Int]), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: 
  LSP: Info: ALL errors:Error in term:
  p
Nature of error: Variable p is not bound    
Error in term:
  p
Nature of error: type ((Int -> Bool), [Int]) is not consistent with arrow type    
Error in term:
  p
Nature of error: Variable p is not bound
  LSP: Info: BidiCtx: Cls: Let expression
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent: Root
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: [?]
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: :: @
  LSP: Concave: Backpack: 
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new_tokens ::= whitespace | "," | "::" | "@"
root ::= new_tokens

Top 20 Logits:

:18.6232
#:15.5784
##:14.6982
let:14.2815
 :13.1635
in:12.828
    :12.7262
   :12.6578
################:12.6282
  :12.5698
####:12.2817
```:12.1003
/*:11.943
                :11.4219
########:11.3938
//:11.3798
        :11.3485
(:11.3274
       :11.2291
[:11.0878
def:11.0567

================
# Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)












































































LSP: Prelude: Recieved string: ### List ###

# Add an element to the front of a list. #
let cons: (Int, [Int]) -> [Int] = fun x, xs -> x::xs in

# Determine the length of a list. #
let length: [Int] -> Int =
  fun xs ->
    case xs
    | [] => 0
    | _::xs => 1 + length(xs) end in

# Extract the first element of a list. #
let hd: [Int] -> Option =
  fun l ->
    case l
    | [] => None
    | x::xs => Some(x) end in

# Extract the rest of the list. #
let tl: [Int] -> [Int] =
  fun l ->
    case l
    | [] => []
    | x::xs => xs end in

# Determine if a list is empty. #
let is_empty: [Int] -> Bool =
  fun xs ->
    case xs
    | [] => true
    | _::_ => false end in

# Return the element at the index. #
let nth: ([Int], Int) -> Option =
  fun xs, n ->
    case xs, n
    | x::_, 0 => Some(x)
    | _::xs, n => nth(xs, n - 1)
    | [], _ => None end in

# Reverse a List. #
let rev: [Int] -> [Int] =
fun l -> 
let go: ([Int], [Int]) -> [Int] =
  fun xs, acc -> 
    case xs 
    | [] => acc 
    | x::xs => go(xs, x::acc) end in
go(l, []) in

# Check if two lists are equal #
let equal: ([Int], [Int]) -> Bool =
    fun p, xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => x == y && equal(xs, ys)
    | _ => false end
in

# Initialize a list with a given length using an initializer function #
let init: (Int, Int -> Int) -> [Int] =
    fun len, f ->
        let go: (Int, [Int]) -> [Int] =
        fun idx, xs ->
            if idx < len 
            then go(idx + 1, xs @ [f(idx)])   
            else xs
        in
        go(0, [])
in

# Reduce a list from the left. #
let fold_left: ((Int, Int) -> Int, Int, [Int]) -> Int =
  fun f, acc, xs ->
    case xs 
    | [] => acc
    | hd::tl => fold_left(f, f(acc, hd), tl) end in

# Reduce a list from the right. #
let fold_right: ((Int, Int) -> Int, [Int], Int) -> Int =
  fun f, xs, acc ->
    case xs
    | [] => acc
    | hd::tl => f(hd, fold_right(f, tl, acc)) end in


666
LSP: Prelude: String parsed successfully
LSP: Prelude: Info map generated successfully
Debug: true, Constrain: Types
LSP: Init: Recieved string: # Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)











































































LSP: Init: String parsed successfully
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: >( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {go: ((?, ?) -> [?]), filter: (((Int -> Bool), [Int]) -> [Int]), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: 
  LSP: Info: ALL errors:Error in term:
  p
Nature of error: type ((Int -> Bool), [Int]) is not consistent with arrow type    
Error in term:
  p
Nature of error: Variable p is not bound    
Error in term:
  p
Nature of error: Variable p is not bound
  LSP: Info: BidiCtx: Cls: Let expression
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent: Root
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: [?]
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: :: @
  LSP: Concave: Backpack: 
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new_tokens ::= whitespace | "," | "::" | "@"
root ::= new_tokens

Top 20 Logits:

:18.6229
#:15.5772
##:14.6699
let:14.2818
 :13.1546
in:12.8472
    :12.7118
   :12.6471
################:12.6084
  :12.5618
####:12.2661
```:12.0962
/*:11.9367
                :11.4084
########:11.3689
//:11.3672
        :11.3345
(:11.323
       :11.2114
[:11.0649
def:11.0534

================
# Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)













































































LSP: Prelude: Recieved string: ### List ###

# Add an element to the front of a list. #
let cons: (Int, [Int]) -> [Int] = fun x, xs -> x::xs in

# Determine the length of a list. #
let length: [Int] -> Int =
  fun xs ->
    case xs
    | [] => 0
    | _::xs => 1 + length(xs) end in

# Extract the first element of a list. #
let hd: [Int] -> Option =
  fun l ->
    case l
    | [] => None
    | x::xs => Some(x) end in

# Extract the rest of the list. #
let tl: [Int] -> [Int] =
  fun l ->
    case l
    | [] => []
    | x::xs => xs end in

# Determine if a list is empty. #
let is_empty: [Int] -> Bool =
  fun xs ->
    case xs
    | [] => true
    | _::_ => false end in

# Return the element at the index. #
let nth: ([Int], Int) -> Option =
  fun xs, n ->
    case xs, n
    | x::_, 0 => Some(x)
    | _::xs, n => nth(xs, n - 1)
    | [], _ => None end in

# Reverse a List. #
let rev: [Int] -> [Int] =
fun l -> 
let go: ([Int], [Int]) -> [Int] =
  fun xs, acc -> 
    case xs 
    | [] => acc 
    | x::xs => go(xs, x::acc) end in
go(l, []) in

# Check if two lists are equal #
let equal: ([Int], [Int]) -> Bool =
    fun p, xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => x == y && equal(xs, ys)
    | _ => false end
in

# Initialize a list with a given length using an initializer function #
let init: (Int, Int -> Int) -> [Int] =
    fun len, f ->
        let go: (Int, [Int]) -> [Int] =
        fun idx, xs ->
            if idx < len 
            then go(idx + 1, xs @ [f(idx)])   
            else xs
        in
        go(0, [])
in

# Reduce a list from the left. #
let fold_left: ((Int, Int) -> Int, Int, [Int]) -> Int =
  fun f, acc, xs ->
    case xs 
    | [] => acc
    | hd::tl => fold_left(f, f(acc, hd), tl) end in

# Reduce a list from the right. #
let fold_right: ((Int, Int) -> Int, [Int], Int) -> Int =
  fun f, xs, acc ->
    case xs
    | [] => acc
    | hd::tl => f(hd, fold_right(f, tl, acc)) end in


666
LSP: Prelude: String parsed successfully
LSP: Prelude: Info map generated successfully
Debug: true, Constrain: Types
LSP: Init: Recieved string: # Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)












































































LSP: Init: String parsed successfully
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: >( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {go: ((?, ?) -> [?]), filter: (((Int -> Bool), [Int]) -> [Int]), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: 
  LSP: Info: ALL errors:Error in term:
  p
Nature of error: type ((Int -> Bool), [Int]) is not consistent with arrow type    
Error in term:
  p
Nature of error: Variable p is not bound    
Error in term:
  p
Nature of error: Variable p is not bound
  LSP: Info: BidiCtx: Cls: Let expression
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent: Root
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: [?]
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: :: @
  LSP: Concave: Backpack: 
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new_tokens ::= whitespace | "," | "::" | "@"
root ::= new_tokens

Top 20 Logits:

:18.6171
#:15.5664
##:14.6461
let:14.2745
 :13.1428
in:12.8334
    :12.6981
   :12.6344
################:12.59
  :12.5496
####:12.248
```:12.0791
/*:11.9305
                :11.3895
//:11.3523
########:11.3457
        :11.3192
(:11.3116
       :11.1912
def:11.0488
end:11.0487

================
# Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)














































































LSP: Prelude: Recieved string: ### List ###

# Add an element to the front of a list. #
let cons: (Int, [Int]) -> [Int] = fun x, xs -> x::xs in

# Determine the length of a list. #
let length: [Int] -> Int =
  fun xs ->
    case xs
    | [] => 0
    | _::xs => 1 + length(xs) end in

# Extract the first element of a list. #
let hd: [Int] -> Option =
  fun l ->
    case l
    | [] => None
    | x::xs => Some(x) end in

# Extract the rest of the list. #
let tl: [Int] -> [Int] =
  fun l ->
    case l
    | [] => []
    | x::xs => xs end in

# Determine if a list is empty. #
let is_empty: [Int] -> Bool =
  fun xs ->
    case xs
    | [] => true
    | _::_ => false end in

# Return the element at the index. #
let nth: ([Int], Int) -> Option =
  fun xs, n ->
    case xs, n
    | x::_, 0 => Some(x)
    | _::xs, n => nth(xs, n - 1)
    | [], _ => None end in

# Reverse a List. #
let rev: [Int] -> [Int] =
fun l -> 
let go: ([Int], [Int]) -> [Int] =
  fun xs, acc -> 
    case xs 
    | [] => acc 
    | x::xs => go(xs, x::acc) end in
go(l, []) in

# Check if two lists are equal #
let equal: ([Int], [Int]) -> Bool =
    fun p, xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => x == y && equal(xs, ys)
    | _ => false end
in

# Initialize a list with a given length using an initializer function #
let init: (Int, Int -> Int) -> [Int] =
    fun len, f ->
        let go: (Int, [Int]) -> [Int] =
        fun idx, xs ->
            if idx < len 
            then go(idx + 1, xs @ [f(idx)])   
            else xs
        in
        go(0, [])
in

# Reduce a list from the left. #
let fold_left: ((Int, Int) -> Int, Int, [Int]) -> Int =
  fun f, acc, xs ->
    case xs 
    | [] => acc
    | hd::tl => fold_left(f, f(acc, hd), tl) end in

# Reduce a list from the right. #
let fold_right: ((Int, Int) -> Int, [Int], Int) -> Int =
  fun f, xs, acc ->
    case xs
    | [] => acc
    | hd::tl => f(hd, fold_right(f, tl, acc)) end in


666
LSP: Prelude: String parsed successfully
LSP: Prelude: Info map generated successfully
Debug: true, Constrain: Types
LSP: Init: Recieved string: # Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)













































































LSP: Init: String parsed successfully
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: >( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {go: ((?, ?) -> [?]), filter: (((Int -> Bool), [Int]) -> [Int]), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: 
  LSP: Info: ALL errors:Error in term:
  p
Nature of error: Variable p is not bound    
Error in term:
  p
Nature of error: Variable p is not bound    
Error in term:
  p
Nature of error: type ((Int -> Bool), [Int]) is not consistent with arrow type
  LSP: Info: BidiCtx: Cls: Let expression
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent: Root
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: [?]
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: :: @
  LSP: Concave: Backpack: 
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new_tokens ::= whitespace | "," | "::" | "@"
root ::= new_tokens

Top 20 Logits:

:18.6124
#:15.5495
##:14.6411
let:14.2632
 :13.1371
in:12.7816
    :12.6944
   :12.6306
################:12.5819
  :12.5436
####:12.2383
```:12.0571
/*:11.9249
                :11.372
//:11.3391
########:11.3379
        :11.3088
(:11.3023
       :11.1771
end:11.0547
def:11.0473

================
# Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)















































































LSP: Prelude: Recieved string: ### List ###

# Add an element to the front of a list. #
let cons: (Int, [Int]) -> [Int] = fun x, xs -> x::xs in

# Determine the length of a list. #
let length: [Int] -> Int =
  fun xs ->
    case xs
    | [] => 0
    | _::xs => 1 + length(xs) end in

# Extract the first element of a list. #
let hd: [Int] -> Option =
  fun l ->
    case l
    | [] => None
    | x::xs => Some(x) end in

# Extract the rest of the list. #
let tl: [Int] -> [Int] =
  fun l ->
    case l
    | [] => []
    | x::xs => xs end in

# Determine if a list is empty. #
let is_empty: [Int] -> Bool =
  fun xs ->
    case xs
    | [] => true
    | _::_ => false end in

# Return the element at the index. #
let nth: ([Int], Int) -> Option =
  fun xs, n ->
    case xs, n
    | x::_, 0 => Some(x)
    | _::xs, n => nth(xs, n - 1)
    | [], _ => None end in

# Reverse a List. #
let rev: [Int] -> [Int] =
fun l -> 
let go: ([Int], [Int]) -> [Int] =
  fun xs, acc -> 
    case xs 
    | [] => acc 
    | x::xs => go(xs, x::acc) end in
go(l, []) in

# Check if two lists are equal #
let equal: ([Int], [Int]) -> Bool =
    fun p, xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => x == y && equal(xs, ys)
    | _ => false end
in

# Initialize a list with a given length using an initializer function #
let init: (Int, Int -> Int) -> [Int] =
    fun len, f ->
        let go: (Int, [Int]) -> [Int] =
        fun idx, xs ->
            if idx < len 
            then go(idx + 1, xs @ [f(idx)])   
            else xs
        in
        go(0, [])
in

# Reduce a list from the left. #
let fold_left: ((Int, Int) -> Int, Int, [Int]) -> Int =
  fun f, acc, xs ->
    case xs 
    | [] => acc
    | hd::tl => fold_left(f, f(acc, hd), tl) end in

# Reduce a list from the right. #
let fold_right: ((Int, Int) -> Int, [Int], Int) -> Int =
  fun f, xs, acc ->
    case xs
    | [] => acc
    | hd::tl => f(hd, fold_right(f, tl, acc)) end in


666
LSP: Prelude: String parsed successfully
LSP: Prelude: Info map generated successfully
Debug: true, Constrain: Types
LSP: Init: Recieved string: # Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)














































































LSP: Init: String parsed successfully
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: >( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {go: ((?, ?) -> [?]), filter: (((Int -> Bool), [Int]) -> [Int]), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: 
  LSP: Info: ALL errors:Error in term:
  p
Nature of error: type ((Int -> Bool), [Int]) is not consistent with arrow type    
Error in term:
  p
Nature of error: Variable p is not bound    
Error in term:
  p
Nature of error: Variable p is not bound
  LSP: Info: BidiCtx: Cls: Let expression
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent: Root
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: [?]
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: :: @
  LSP: Concave: Backpack: 
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new_tokens ::= whitespace | "," | "::" | "@"
root ::= new_tokens

Top 20 Logits:

:18.6135
#:15.5328
##:14.6544
let:14.2526
 :13.1387
in:12.7187
    :12.6991
   :12.6366
################:12.5844
  :12.5467
####:12.2403
```:12.0462
/*:11.9157
                :11.361
########:11.345
//:11.3282
        :11.3045
(:11.3016
       :11.1711
end:11.0696
def:11.0497

================
# Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)
















































































LSP: Prelude: Recieved string: ### List ###

# Add an element to the front of a list. #
let cons: (Int, [Int]) -> [Int] = fun x, xs -> x::xs in

# Determine the length of a list. #
let length: [Int] -> Int =
  fun xs ->
    case xs
    | [] => 0
    | _::xs => 1 + length(xs) end in

# Extract the first element of a list. #
let hd: [Int] -> Option =
  fun l ->
    case l
    | [] => None
    | x::xs => Some(x) end in

# Extract the rest of the list. #
let tl: [Int] -> [Int] =
  fun l ->
    case l
    | [] => []
    | x::xs => xs end in

# Determine if a list is empty. #
let is_empty: [Int] -> Bool =
  fun xs ->
    case xs
    | [] => true
    | _::_ => false end in

# Return the element at the index. #
let nth: ([Int], Int) -> Option =
  fun xs, n ->
    case xs, n
    | x::_, 0 => Some(x)
    | _::xs, n => nth(xs, n - 1)
    | [], _ => None end in

# Reverse a List. #
let rev: [Int] -> [Int] =
fun l -> 
let go: ([Int], [Int]) -> [Int] =
  fun xs, acc -> 
    case xs 
    | [] => acc 
    | x::xs => go(xs, x::acc) end in
go(l, []) in

# Check if two lists are equal #
let equal: ([Int], [Int]) -> Bool =
    fun p, xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => x == y && equal(xs, ys)
    | _ => false end
in

# Initialize a list with a given length using an initializer function #
let init: (Int, Int -> Int) -> [Int] =
    fun len, f ->
        let go: (Int, [Int]) -> [Int] =
        fun idx, xs ->
            if idx < len 
            then go(idx + 1, xs @ [f(idx)])   
            else xs
        in
        go(0, [])
in

# Reduce a list from the left. #
let fold_left: ((Int, Int) -> Int, Int, [Int]) -> Int =
  fun f, acc, xs ->
    case xs 
    | [] => acc
    | hd::tl => fold_left(f, f(acc, hd), tl) end in

# Reduce a list from the right. #
let fold_right: ((Int, Int) -> Int, [Int], Int) -> Int =
  fun f, xs, acc ->
    case xs
    | [] => acc
    | hd::tl => f(hd, fold_right(f, tl, acc)) end in


666
LSP: Prelude: String parsed successfully
LSP: Prelude: Info map generated successfully
Debug: true, Constrain: Types
LSP: Init: Recieved string: # Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)















































































LSP: Init: String parsed successfully
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: >( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {go: ((?, ?) -> [?]), filter: (((Int -> Bool), [Int]) -> [Int]), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: 
  LSP: Info: ALL errors:Error in term:
  p
Nature of error: Variable p is not bound    
Error in term:
  p
Nature of error: type ((Int -> Bool), [Int]) is not consistent with arrow type    
Error in term:
  p
Nature of error: Variable p is not bound
  LSP: Info: BidiCtx: Cls: Let expression
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent: Root
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: [?]
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: :: @
  LSP: Concave: Backpack: 
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new_tokens ::= whitespace | "," | "::" | "@"
root ::= new_tokens

Top 20 Logits:

:18.619
#:15.5204
##:14.6698
let:14.2466
 :13.1412
    :12.7035
in:12.6791
   :12.6444
################:12.5877
  :12.5529
####:12.2451
```:12.0491
/*:11.9013
                :11.3543
########:11.3517
//:11.3174
(:11.307
        :11.3014
       :11.1682
end:11.0861
def:11.0536

================
# Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)

















































































LSP: Prelude: Recieved string: ### List ###

# Add an element to the front of a list. #
let cons: (Int, [Int]) -> [Int] = fun x, xs -> x::xs in

# Determine the length of a list. #
let length: [Int] -> Int =
  fun xs ->
    case xs
    | [] => 0
    | _::xs => 1 + length(xs) end in

# Extract the first element of a list. #
let hd: [Int] -> Option =
  fun l ->
    case l
    | [] => None
    | x::xs => Some(x) end in

# Extract the rest of the list. #
let tl: [Int] -> [Int] =
  fun l ->
    case l
    | [] => []
    | x::xs => xs end in

# Determine if a list is empty. #
let is_empty: [Int] -> Bool =
  fun xs ->
    case xs
    | [] => true
    | _::_ => false end in

# Return the element at the index. #
let nth: ([Int], Int) -> Option =
  fun xs, n ->
    case xs, n
    | x::_, 0 => Some(x)
    | _::xs, n => nth(xs, n - 1)
    | [], _ => None end in

# Reverse a List. #
let rev: [Int] -> [Int] =
fun l -> 
let go: ([Int], [Int]) -> [Int] =
  fun xs, acc -> 
    case xs 
    | [] => acc 
    | x::xs => go(xs, x::acc) end in
go(l, []) in

# Check if two lists are equal #
let equal: ([Int], [Int]) -> Bool =
    fun p, xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => x == y && equal(xs, ys)
    | _ => false end
in

# Initialize a list with a given length using an initializer function #
let init: (Int, Int -> Int) -> [Int] =
    fun len, f ->
        let go: (Int, [Int]) -> [Int] =
        fun idx, xs ->
            if idx < len 
            then go(idx + 1, xs @ [f(idx)])   
            else xs
        in
        go(0, [])
in

# Reduce a list from the left. #
let fold_left: ((Int, Int) -> Int, Int, [Int]) -> Int =
  fun f, acc, xs ->
    case xs 
    | [] => acc
    | hd::tl => fold_left(f, f(acc, hd), tl) end in

# Reduce a list from the right. #
let fold_right: ((Int, Int) -> Int, [Int], Int) -> Int =
  fun f, xs, acc ->
    case xs
    | [] => acc
    | hd::tl => f(hd, fold_right(f, tl, acc)) end in


666
LSP: Prelude: String parsed successfully
LSP: Prelude: Info map generated successfully
Debug: true, Constrain: Types
LSP: Init: Recieved string: # Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)
















































































LSP: Init: String parsed successfully
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: >( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {go: ((?, ?) -> [?]), filter: (((Int -> Bool), [Int]) -> [Int]), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: 
  LSP: Info: ALL errors:Error in term:
  p
Nature of error: Variable p is not bound    
Error in term:
  p
Nature of error: type ((Int -> Bool), [Int]) is not consistent with arrow type    
Error in term:
  p
Nature of error: Variable p is not bound
  LSP: Info: BidiCtx: Cls: Let expression
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent: Root
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: [?]
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: :: @
  LSP: Concave: Backpack: 
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new_tokens ::= whitespace | "," | "::" | "@"
root ::= new_tokens

Top 20 Logits:

:18.625
#:15.5121
##:14.6683
let:14.2453
 :13.1385
    :12.7003
in:12.6823
   :12.6469
################:12.5809
  :12.5553
####:12.2418
```:12.0567
/*:11.883
                :11.3505
########:11.3405
(:11.3105
//:11.3041
        :11.2953
       :11.1644
end:11.0998
def:11.0518

================
# Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)


















































































LSP: Prelude: Recieved string: ### List ###

# Add an element to the front of a list. #
let cons: (Int, [Int]) -> [Int] = fun x, xs -> x::xs in

# Determine the length of a list. #
let length: [Int] -> Int =
  fun xs ->
    case xs
    | [] => 0
    | _::xs => 1 + length(xs) end in

# Extract the first element of a list. #
let hd: [Int] -> Option =
  fun l ->
    case l
    | [] => None
    | x::xs => Some(x) end in

# Extract the rest of the list. #
let tl: [Int] -> [Int] =
  fun l ->
    case l
    | [] => []
    | x::xs => xs end in

# Determine if a list is empty. #
let is_empty: [Int] -> Bool =
  fun xs ->
    case xs
    | [] => true
    | _::_ => false end in

# Return the element at the index. #
let nth: ([Int], Int) -> Option =
  fun xs, n ->
    case xs, n
    | x::_, 0 => Some(x)
    | _::xs, n => nth(xs, n - 1)
    | [], _ => None end in

# Reverse a List. #
let rev: [Int] -> [Int] =
fun l -> 
let go: ([Int], [Int]) -> [Int] =
  fun xs, acc -> 
    case xs 
    | [] => acc 
    | x::xs => go(xs, x::acc) end in
go(l, []) in

# Check if two lists are equal #
let equal: ([Int], [Int]) -> Bool =
    fun p, xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => x == y && equal(xs, ys)
    | _ => false end
in

# Initialize a list with a given length using an initializer function #
let init: (Int, Int -> Int) -> [Int] =
    fun len, f ->
        let go: (Int, [Int]) -> [Int] =
        fun idx, xs ->
            if idx < len 
            then go(idx + 1, xs @ [f(idx)])   
            else xs
        in
        go(0, [])
in

# Reduce a list from the left. #
let fold_left: ((Int, Int) -> Int, Int, [Int]) -> Int =
  fun f, acc, xs ->
    case xs 
    | [] => acc
    | hd::tl => fold_left(f, f(acc, hd), tl) end in

# Reduce a list from the right. #
let fold_right: ((Int, Int) -> Int, [Int], Int) -> Int =
  fun f, xs, acc ->
    case xs
    | [] => acc
    | hd::tl => f(hd, fold_right(f, tl, acc)) end in


666
LSP: Prelude: String parsed successfully
LSP: Prelude: Info map generated successfully
Debug: true, Constrain: Types
LSP: Init: Recieved string: # Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)

















































































LSP: Init: String parsed successfully
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: >( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {go: ((?, ?) -> [?]), filter: (((Int -> Bool), [Int]) -> [Int]), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: 
  LSP: Info: ALL errors:Error in term:
  p
Nature of error: type ((Int -> Bool), [Int]) is not consistent with arrow type    
Error in term:
  p
Nature of error: Variable p is not bound    
Error in term:
  p
Nature of error: Variable p is not bound
  LSP: Info: BidiCtx: Cls: Let expression
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent: Root
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: [?]
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: :: @
  LSP: Concave: Backpack: 
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new_tokens ::= whitespace | "," | "::" | "@"
root ::= new_tokens

Top 20 Logits:

:18.6281
#:15.5024
##:14.6422
let:14.2443
 :13.1282
in:12.7124
    :12.6874
   :12.641
################:12.5607
  :12.5491
####:12.2254
```:12.0584
/*:11.8656
                :11.3473
(:11.3073
########:11.3058
//:11.2907
        :11.2837
       :11.1566
end:11.1078
def:11.0396

================
# Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)



















































































LSP: Prelude: Recieved string: ### List ###

# Add an element to the front of a list. #
let cons: (Int, [Int]) -> [Int] = fun x, xs -> x::xs in

# Determine the length of a list. #
let length: [Int] -> Int =
  fun xs ->
    case xs
    | [] => 0
    | _::xs => 1 + length(xs) end in

# Extract the first element of a list. #
let hd: [Int] -> Option =
  fun l ->
    case l
    | [] => None
    | x::xs => Some(x) end in

# Extract the rest of the list. #
let tl: [Int] -> [Int] =
  fun l ->
    case l
    | [] => []
    | x::xs => xs end in

# Determine if a list is empty. #
let is_empty: [Int] -> Bool =
  fun xs ->
    case xs
    | [] => true
    | _::_ => false end in

# Return the element at the index. #
let nth: ([Int], Int) -> Option =
  fun xs, n ->
    case xs, n
    | x::_, 0 => Some(x)
    | _::xs, n => nth(xs, n - 1)
    | [], _ => None end in

# Reverse a List. #
let rev: [Int] -> [Int] =
fun l -> 
let go: ([Int], [Int]) -> [Int] =
  fun xs, acc -> 
    case xs 
    | [] => acc 
    | x::xs => go(xs, x::acc) end in
go(l, []) in

# Check if two lists are equal #
let equal: ([Int], [Int]) -> Bool =
    fun p, xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => x == y && equal(xs, ys)
    | _ => false end
in

# Initialize a list with a given length using an initializer function #
let init: (Int, Int -> Int) -> [Int] =
    fun len, f ->
        let go: (Int, [Int]) -> [Int] =
        fun idx, xs ->
            if idx < len 
            then go(idx + 1, xs @ [f(idx)])   
            else xs
        in
        go(0, [])
in

# Reduce a list from the left. #
let fold_left: ((Int, Int) -> Int, Int, [Int]) -> Int =
  fun f, acc, xs ->
    case xs 
    | [] => acc
    | hd::tl => fold_left(f, f(acc, hd), tl) end in

# Reduce a list from the right. #
let fold_right: ((Int, Int) -> Int, [Int], Int) -> Int =
  fun f, xs, acc ->
    case xs
    | [] => acc
    | hd::tl => f(hd, fold_right(f, tl, acc)) end in


666
LSP: Prelude: String parsed successfully
LSP: Prelude: Info map generated successfully
Debug: true, Constrain: Types
LSP: Init: Recieved string: # Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)


















































































LSP: Init: String parsed successfully
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: >( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {go: ((?, ?) -> [?]), filter: (((Int -> Bool), [Int]) -> [Int]), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: 
  LSP: Info: ALL errors:Error in term:
  p
Nature of error: Variable p is not bound    
Error in term:
  p
Nature of error: type ((Int -> Bool), [Int]) is not consistent with arrow type    
Error in term:
  p
Nature of error: Variable p is not bound
  LSP: Info: BidiCtx: Cls: Let expression
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent: Root
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: [?]
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: :: @
  LSP: Concave: Backpack: 
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new_tokens ::= whitespace | "," | "::" | "@"
root ::= new_tokens

Top 20 Logits:

:18.6258
#:15.4871
##:14.6009
let:14.2407
 :13.1123
in:12.7246
    :12.6687
   :12.6291
  :12.5342
################:12.5314
####:12.1988
```:12.0477
/*:11.8556
                :11.3391
(:11.2986
//:11.2811
        :11.2666
########:11.2574
       :11.1433
end:11.1051
[:11.0313

================
# Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)




















































































LSP: Prelude: Recieved string: ### List ###

# Add an element to the front of a list. #
let cons: (Int, [Int]) -> [Int] = fun x, xs -> x::xs in

# Determine the length of a list. #
let length: [Int] -> Int =
  fun xs ->
    case xs
    | [] => 0
    | _::xs => 1 + length(xs) end in

# Extract the first element of a list. #
let hd: [Int] -> Option =
  fun l ->
    case l
    | [] => None
    | x::xs => Some(x) end in

# Extract the rest of the list. #
let tl: [Int] -> [Int] =
  fun l ->
    case l
    | [] => []
    | x::xs => xs end in

# Determine if a list is empty. #
let is_empty: [Int] -> Bool =
  fun xs ->
    case xs
    | [] => true
    | _::_ => false end in

# Return the element at the index. #
let nth: ([Int], Int) -> Option =
  fun xs, n ->
    case xs, n
    | x::_, 0 => Some(x)
    | _::xs, n => nth(xs, n - 1)
    | [], _ => None end in

# Reverse a List. #
let rev: [Int] -> [Int] =
fun l -> 
let go: ([Int], [Int]) -> [Int] =
  fun xs, acc -> 
    case xs 
    | [] => acc 
    | x::xs => go(xs, x::acc) end in
go(l, []) in

# Check if two lists are equal #
let equal: ([Int], [Int]) -> Bool =
    fun p, xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => x == y && equal(xs, ys)
    | _ => false end
in

# Initialize a list with a given length using an initializer function #
let init: (Int, Int -> Int) -> [Int] =
    fun len, f ->
        let go: (Int, [Int]) -> [Int] =
        fun idx, xs ->
            if idx < len 
            then go(idx + 1, xs @ [f(idx)])   
            else xs
        in
        go(0, [])
in

# Reduce a list from the left. #
let fold_left: ((Int, Int) -> Int, Int, [Int]) -> Int =
  fun f, acc, xs ->
    case xs 
    | [] => acc
    | hd::tl => fold_left(f, f(acc, hd), tl) end in

# Reduce a list from the right. #
let fold_right: ((Int, Int) -> Int, [Int], Int) -> Int =
  fun f, xs, acc ->
    case xs
    | [] => acc
    | hd::tl => f(hd, fold_right(f, tl, acc)) end in


666
LSP: Prelude: String parsed successfully
LSP: Prelude: Info map generated successfully
Debug: true, Constrain: Types
LSP: Init: Recieved string: # Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)



















































































LSP: Init: String parsed successfully
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: >( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {go: ((?, ?) -> [?]), filter: (((Int -> Bool), [Int]) -> [Int]), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: 
  LSP: Info: ALL errors:Error in term:
  p
Nature of error: Variable p is not bound    
Error in term:
  p
Nature of error: type ((Int -> Bool), [Int]) is not consistent with arrow type    
Error in term:
  p
Nature of error: Variable p is not bound
  LSP: Info: BidiCtx: Cls: Let expression
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent: Root
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: [?]
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: :: @
  LSP: Concave: Backpack: 
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new_tokens ::= whitespace | "," | "::" | "@"
root ::= new_tokens

Top 20 Logits:

:18.6212
#:15.4676
##:14.5656
let:14.2361
 :13.0973
in:12.6858
    :12.6516
   :12.6167
  :12.5173
################:12.5053
####:12.1742
```:12.0307
/*:11.8534
                :11.3257
(:11.2911
//:11.2761
        :11.2484
########:11.2167
       :11.1281
end:11.0872
[:11.0257

================
# Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)





















































































LSP: Prelude: Recieved string: ### List ###

# Add an element to the front of a list. #
let cons: (Int, [Int]) -> [Int] = fun x, xs -> x::xs in

# Determine the length of a list. #
let length: [Int] -> Int =
  fun xs ->
    case xs
    | [] => 0
    | _::xs => 1 + length(xs) end in

# Extract the first element of a list. #
let hd: [Int] -> Option =
  fun l ->
    case l
    | [] => None
    | x::xs => Some(x) end in

# Extract the rest of the list. #
let tl: [Int] -> [Int] =
  fun l ->
    case l
    | [] => []
    | x::xs => xs end in

# Determine if a list is empty. #
let is_empty: [Int] -> Bool =
  fun xs ->
    case xs
    | [] => true
    | _::_ => false end in

# Return the element at the index. #
let nth: ([Int], Int) -> Option =
  fun xs, n ->
    case xs, n
    | x::_, 0 => Some(x)
    | _::xs, n => nth(xs, n - 1)
    | [], _ => None end in

# Reverse a List. #
let rev: [Int] -> [Int] =
fun l -> 
let go: ([Int], [Int]) -> [Int] =
  fun xs, acc -> 
    case xs 
    | [] => acc 
    | x::xs => go(xs, x::acc) end in
go(l, []) in

# Check if two lists are equal #
let equal: ([Int], [Int]) -> Bool =
    fun p, xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => x == y && equal(xs, ys)
    | _ => false end
in

# Initialize a list with a given length using an initializer function #
let init: (Int, Int -> Int) -> [Int] =
    fun len, f ->
        let go: (Int, [Int]) -> [Int] =
        fun idx, xs ->
            if idx < len 
            then go(idx + 1, xs @ [f(idx)])   
            else xs
        in
        go(0, [])
in

# Reduce a list from the left. #
let fold_left: ((Int, Int) -> Int, Int, [Int]) -> Int =
  fun f, acc, xs ->
    case xs 
    | [] => acc
    | hd::tl => fold_left(f, f(acc, hd), tl) end in

# Reduce a list from the right. #
let fold_right: ((Int, Int) -> Int, [Int], Int) -> Int =
  fun f, xs, acc ->
    case xs
    | [] => acc
    | hd::tl => f(hd, fold_right(f, tl, acc)) end in


666
LSP: Prelude: String parsed successfully
LSP: Prelude: Info map generated successfully
Debug: true, Constrain: Types
LSP: Init: Recieved string: # Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)




















































































LSP: Init: String parsed successfully
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: >( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {go: ((?, ?) -> [?]), filter: (((Int -> Bool), [Int]) -> [Int]), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: 
  LSP: Info: ALL errors:Error in term:
  p
Nature of error: Variable p is not bound    
Error in term:
  p
Nature of error: Variable p is not bound    
Error in term:
  p
Nature of error: type ((Int -> Bool), [Int]) is not consistent with arrow type
  LSP: Info: BidiCtx: Cls: Let expression
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent: Root
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: [?]
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: :: @
  LSP: Concave: Backpack: 
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new_tokens ::= whitespace | "," | "::" | "@"
root ::= new_tokens

Top 20 Logits:

:18.6229
#:15.4495
##:14.5555
let:14.233
 :13.0908
    :12.6431
   :12.6095
in:12.6033
  :12.508
################:12.4939
####:12.1652
```:12.0229
/*:11.8548
                :11.3129
(:11.29
//:11.2752
        :11.2355
########:11.2016
       :11.118
end:11.0612
[:11.0237

================
# Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)






















































































LSP: Prelude: Recieved string: ### List ###

# Add an element to the front of a list. #
let cons: (Int, [Int]) -> [Int] = fun x, xs -> x::xs in

# Determine the length of a list. #
let length: [Int] -> Int =
  fun xs ->
    case xs
    | [] => 0
    | _::xs => 1 + length(xs) end in

# Extract the first element of a list. #
let hd: [Int] -> Option =
  fun l ->
    case l
    | [] => None
    | x::xs => Some(x) end in

# Extract the rest of the list. #
let tl: [Int] -> [Int] =
  fun l ->
    case l
    | [] => []
    | x::xs => xs end in

# Determine if a list is empty. #
let is_empty: [Int] -> Bool =
  fun xs ->
    case xs
    | [] => true
    | _::_ => false end in

# Return the element at the index. #
let nth: ([Int], Int) -> Option =
  fun xs, n ->
    case xs, n
    | x::_, 0 => Some(x)
    | _::xs, n => nth(xs, n - 1)
    | [], _ => None end in

# Reverse a List. #
let rev: [Int] -> [Int] =
fun l -> 
let go: ([Int], [Int]) -> [Int] =
  fun xs, acc -> 
    case xs 
    | [] => acc 
    | x::xs => go(xs, x::acc) end in
go(l, []) in

# Check if two lists are equal #
let equal: ([Int], [Int]) -> Bool =
    fun p, xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => x == y && equal(xs, ys)
    | _ => false end
in

# Initialize a list with a given length using an initializer function #
let init: (Int, Int -> Int) -> [Int] =
    fun len, f ->
        let go: (Int, [Int]) -> [Int] =
        fun idx, xs ->
            if idx < len 
            then go(idx + 1, xs @ [f(idx)])   
            else xs
        in
        go(0, [])
in

# Reduce a list from the left. #
let fold_left: ((Int, Int) -> Int, Int, [Int]) -> Int =
  fun f, acc, xs ->
    case xs 
    | [] => acc
    | hd::tl => fold_left(f, f(acc, hd), tl) end in

# Reduce a list from the right. #
let fold_right: ((Int, Int) -> Int, [Int], Int) -> Int =
  fun f, xs, acc ->
    case xs
    | [] => acc
    | hd::tl => f(hd, fold_right(f, tl, acc)) end in


666
LSP: Prelude: String parsed successfully
LSP: Prelude: Info map generated successfully
Debug: true, Constrain: Types
LSP: Init: Recieved string: # Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)





















































































LSP: Init: String parsed successfully
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: >( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {go: ((?, ?) -> [?]), filter: (((Int -> Bool), [Int]) -> [Int]), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: 
  LSP: Info: ALL errors:Error in term:
  p
Nature of error: Variable p is not bound    
Error in term:
  p
Nature of error: type ((Int -> Bool), [Int]) is not consistent with arrow type    
Error in term:
  p
Nature of error: Variable p is not bound
  LSP: Info: BidiCtx: Cls: Let expression
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent: Root
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: [?]
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: :: @
  LSP: Concave: Backpack: 
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new_tokens ::= whitespace | "," | "::" | "@"
root ::= new_tokens

Top 20 Logits:

:18.6337
#:15.4371
##:14.5712
let:14.2333
 :13.0926
    :12.6432
   :12.6078
in:12.5141
  :12.5079
################:12.4971
####:12.173
```:12.0313
/*:11.8558
                :11.3039
(:11.2938
//:11.2759
        :11.2305
########:11.2105
       :11.1158
end:11.0411
[:11.027

================
# Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)























































































LSP: Prelude: Recieved string: ### List ###

# Add an element to the front of a list. #
let cons: (Int, [Int]) -> [Int] = fun x, xs -> x::xs in

# Determine the length of a list. #
let length: [Int] -> Int =
  fun xs ->
    case xs
    | [] => 0
    | _::xs => 1 + length(xs) end in

# Extract the first element of a list. #
let hd: [Int] -> Option =
  fun l ->
    case l
    | [] => None
    | x::xs => Some(x) end in

# Extract the rest of the list. #
let tl: [Int] -> [Int] =
  fun l ->
    case l
    | [] => []
    | x::xs => xs end in

# Determine if a list is empty. #
let is_empty: [Int] -> Bool =
  fun xs ->
    case xs
    | [] => true
    | _::_ => false end in

# Return the element at the index. #
let nth: ([Int], Int) -> Option =
  fun xs, n ->
    case xs, n
    | x::_, 0 => Some(x)
    | _::xs, n => nth(xs, n - 1)
    | [], _ => None end in

# Reverse a List. #
let rev: [Int] -> [Int] =
fun l -> 
let go: ([Int], [Int]) -> [Int] =
  fun xs, acc -> 
    case xs 
    | [] => acc 
    | x::xs => go(xs, x::acc) end in
go(l, []) in

# Check if two lists are equal #
let equal: ([Int], [Int]) -> Bool =
    fun p, xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => x == y && equal(xs, ys)
    | _ => false end
in

# Initialize a list with a given length using an initializer function #
let init: (Int, Int -> Int) -> [Int] =
    fun len, f ->
        let go: (Int, [Int]) -> [Int] =
        fun idx, xs ->
            if idx < len 
            then go(idx + 1, xs @ [f(idx)])   
            else xs
        in
        go(0, [])
in

# Reduce a list from the left. #
let fold_left: ((Int, Int) -> Int, Int, [Int]) -> Int =
  fun f, acc, xs ->
    case xs 
    | [] => acc
    | hd::tl => fold_left(f, f(acc, hd), tl) end in

# Reduce a list from the right. #
let fold_right: ((Int, Int) -> Int, [Int], Int) -> Int =
  fun f, xs, acc ->
    case xs
    | [] => acc
    | hd::tl => f(hd, fold_right(f, tl, acc)) end in


666
LSP: Prelude: String parsed successfully
LSP: Prelude: Info map generated successfully
Debug: true, Constrain: Types
LSP: Init: Recieved string: # Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)






















































































LSP: Init: String parsed successfully
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: >( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {go: ((?, ?) -> [?]), filter: (((Int -> Bool), [Int]) -> [Int]), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: 
  LSP: Info: ALL errors:Error in term:
  p
Nature of error: type ((Int -> Bool), [Int]) is not consistent with arrow type    
Error in term:
  p
Nature of error: Variable p is not bound    
Error in term:
  p
Nature of error: Variable p is not bound
  LSP: Info: BidiCtx: Cls: Let expression
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent: Root
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: [?]
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: :: @
  LSP: Concave: Backpack: 
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new_tokens ::= whitespace | "," | "::" | "@"
root ::= new_tokens

Top 20 Logits:

:18.6488
#:15.4309
##:14.5947
let:14.2368
 :13.0966
    :12.6455
   :12.6068
  :12.5114
################:12.5051
in:12.4591
####:12.1859
```:12.0494
/*:11.8536
                :11.3
(:11.2955
//:11.2725
        :11.2318
########:11.2253
       :11.1189
end:11.0363
[:11.0325

================
# Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)
























































































LSP: Prelude: Recieved string: ### List ###

# Add an element to the front of a list. #
let cons: (Int, [Int]) -> [Int] = fun x, xs -> x::xs in

# Determine the length of a list. #
let length: [Int] -> Int =
  fun xs ->
    case xs
    | [] => 0
    | _::xs => 1 + length(xs) end in

# Extract the first element of a list. #
let hd: [Int] -> Option =
  fun l ->
    case l
    | [] => None
    | x::xs => Some(x) end in

# Extract the rest of the list. #
let tl: [Int] -> [Int] =
  fun l ->
    case l
    | [] => []
    | x::xs => xs end in

# Determine if a list is empty. #
let is_empty: [Int] -> Bool =
  fun xs ->
    case xs
    | [] => true
    | _::_ => false end in

# Return the element at the index. #
let nth: ([Int], Int) -> Option =
  fun xs, n ->
    case xs, n
    | x::_, 0 => Some(x)
    | _::xs, n => nth(xs, n - 1)
    | [], _ => None end in

# Reverse a List. #
let rev: [Int] -> [Int] =
fun l -> 
let go: ([Int], [Int]) -> [Int] =
  fun xs, acc -> 
    case xs 
    | [] => acc 
    | x::xs => go(xs, x::acc) end in
go(l, []) in

# Check if two lists are equal #
let equal: ([Int], [Int]) -> Bool =
    fun p, xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => x == y && equal(xs, ys)
    | _ => false end
in

# Initialize a list with a given length using an initializer function #
let init: (Int, Int -> Int) -> [Int] =
    fun len, f ->
        let go: (Int, [Int]) -> [Int] =
        fun idx, xs ->
            if idx < len 
            then go(idx + 1, xs @ [f(idx)])   
            else xs
        in
        go(0, [])
in

# Reduce a list from the left. #
let fold_left: ((Int, Int) -> Int, Int, [Int]) -> Int =
  fun f, acc, xs ->
    case xs 
    | [] => acc
    | hd::tl => fold_left(f, f(acc, hd), tl) end in

# Reduce a list from the right. #
let fold_right: ((Int, Int) -> Int, [Int], Int) -> Int =
  fun f, xs, acc ->
    case xs
    | [] => acc
    | hd::tl => f(hd, fold_right(f, tl, acc)) end in


666
LSP: Prelude: String parsed successfully
LSP: Prelude: Info map generated successfully
Debug: true, Constrain: Types
LSP: Init: Recieved string: # Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)























































































LSP: Init: String parsed successfully
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: >( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {go: ((?, ?) -> [?]), filter: (((Int -> Bool), [Int]) -> [Int]), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: 
  LSP: Info: ALL errors:Error in term:
  p
Nature of error: Variable p is not bound    
Error in term:
  p
Nature of error: type ((Int -> Bool), [Int]) is not consistent with arrow type    
Error in term:
  p
Nature of error: Variable p is not bound
  LSP: Info: BidiCtx: Cls: Let expression
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent: Root
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: [?]
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: :: @
  LSP: Concave: Backpack: 
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new_tokens ::= whitespace | "," | "::" | "@"
root ::= new_tokens

Top 20 Logits:

:18.6616
#:15.4272
##:14.6042
let:14.2386
 :13.0968
    :12.646
   :12.6022
  :12.5127
################:12.5073
in:12.4596
####:12.1892
```:12.0637
/*:11.8493
                :11.3013
(:11.289
//:11.2643
        :11.2363
########:11.2272
       :11.1233
end:11.0499
[:11.0328

================
# Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)

























































































LSP: Prelude: Recieved string: ### List ###

# Add an element to the front of a list. #
let cons: (Int, [Int]) -> [Int] = fun x, xs -> x::xs in

# Determine the length of a list. #
let length: [Int] -> Int =
  fun xs ->
    case xs
    | [] => 0
    | _::xs => 1 + length(xs) end in

# Extract the first element of a list. #
let hd: [Int] -> Option =
  fun l ->
    case l
    | [] => None
    | x::xs => Some(x) end in

# Extract the rest of the list. #
let tl: [Int] -> [Int] =
  fun l ->
    case l
    | [] => []
    | x::xs => xs end in

# Determine if a list is empty. #
let is_empty: [Int] -> Bool =
  fun xs ->
    case xs
    | [] => true
    | _::_ => false end in

# Return the element at the index. #
let nth: ([Int], Int) -> Option =
  fun xs, n ->
    case xs, n
    | x::_, 0 => Some(x)
    | _::xs, n => nth(xs, n - 1)
    | [], _ => None end in

# Reverse a List. #
let rev: [Int] -> [Int] =
fun l -> 
let go: ([Int], [Int]) -> [Int] =
  fun xs, acc -> 
    case xs 
    | [] => acc 
    | x::xs => go(xs, x::acc) end in
go(l, []) in

# Check if two lists are equal #
let equal: ([Int], [Int]) -> Bool =
    fun p, xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => x == y && equal(xs, ys)
    | _ => false end
in

# Initialize a list with a given length using an initializer function #
let init: (Int, Int -> Int) -> [Int] =
    fun len, f ->
        let go: (Int, [Int]) -> [Int] =
        fun idx, xs ->
            if idx < len 
            then go(idx + 1, xs @ [f(idx)])   
            else xs
        in
        go(0, [])
in

# Reduce a list from the left. #
let fold_left: ((Int, Int) -> Int, Int, [Int]) -> Int =
  fun f, acc, xs ->
    case xs 
    | [] => acc
    | hd::tl => fold_left(f, f(acc, hd), tl) end in

# Reduce a list from the right. #
let fold_right: ((Int, Int) -> Int, [Int], Int) -> Int =
  fun f, xs, acc ->
    case xs
    | [] => acc
    | hd::tl => f(hd, fold_right(f, tl, acc)) end in


666
LSP: Prelude: String parsed successfully
LSP: Prelude: Info map generated successfully
Debug: true, Constrain: Types
LSP: Init: Recieved string: # Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)
























































































LSP: Init: String parsed successfully
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: >( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {go: ((?, ?) -> [?]), filter: (((Int -> Bool), [Int]) -> [Int]), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: 
  LSP: Info: ALL errors:Error in term:
  p
Nature of error: Variable p is not bound    
Error in term:
  p
Nature of error: Variable p is not bound    
Error in term:
  p
Nature of error: type ((Int -> Bool), [Int]) is not consistent with arrow type
  LSP: Info: BidiCtx: Cls: Let expression
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent: Root
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: [?]
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: :: @
  LSP: Concave: Backpack: 
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new_tokens ::= whitespace | "," | "::" | "@"
root ::= new_tokens

Top 20 Logits:

:18.6676
#:15.4216
##:14.5894
let:14.2353
 :13.0915
    :12.6429
   :12.5931
  :12.5081
in:12.5046
################:12.4989
####:12.1762
```:12.0648
/*:11.846
                :11.3032
(:11.2764
//:11.2542
        :11.2391
########:11.2088
       :11.1237
end:11.0736
[:11.0247

================
# Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)


























































































LSP: Prelude: Recieved string: ### List ###

# Add an element to the front of a list. #
let cons: (Int, [Int]) -> [Int] = fun x, xs -> x::xs in

# Determine the length of a list. #
let length: [Int] -> Int =
  fun xs ->
    case xs
    | [] => 0
    | _::xs => 1 + length(xs) end in

# Extract the first element of a list. #
let hd: [Int] -> Option =
  fun l ->
    case l
    | [] => None
    | x::xs => Some(x) end in

# Extract the rest of the list. #
let tl: [Int] -> [Int] =
  fun l ->
    case l
    | [] => []
    | x::xs => xs end in

# Determine if a list is empty. #
let is_empty: [Int] -> Bool =
  fun xs ->
    case xs
    | [] => true
    | _::_ => false end in

# Return the element at the index. #
let nth: ([Int], Int) -> Option =
  fun xs, n ->
    case xs, n
    | x::_, 0 => Some(x)
    | _::xs, n => nth(xs, n - 1)
    | [], _ => None end in

# Reverse a List. #
let rev: [Int] -> [Int] =
fun l -> 
let go: ([Int], [Int]) -> [Int] =
  fun xs, acc -> 
    case xs 
    | [] => acc 
    | x::xs => go(xs, x::acc) end in
go(l, []) in

# Check if two lists are equal #
let equal: ([Int], [Int]) -> Bool =
    fun p, xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => x == y && equal(xs, ys)
    | _ => false end
in

# Initialize a list with a given length using an initializer function #
let init: (Int, Int -> Int) -> [Int] =
    fun len, f ->
        let go: (Int, [Int]) -> [Int] =
        fun idx, xs ->
            if idx < len 
            then go(idx + 1, xs @ [f(idx)])   
            else xs
        in
        go(0, [])
in

# Reduce a list from the left. #
let fold_left: ((Int, Int) -> Int, Int, [Int]) -> Int =
  fun f, acc, xs ->
    case xs 
    | [] => acc
    | hd::tl => fold_left(f, f(acc, hd), tl) end in

# Reduce a list from the right. #
let fold_right: ((Int, Int) -> Int, [Int], Int) -> Int =
  fun f, xs, acc ->
    case xs
    | [] => acc
    | hd::tl => f(hd, fold_right(f, tl, acc)) end in


666
LSP: Prelude: String parsed successfully
LSP: Prelude: Info map generated successfully
Debug: true, Constrain: Types
LSP: Init: Recieved string: # Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)

























































































LSP: Init: String parsed successfully
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: >( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {go: ((?, ?) -> [?]), filter: (((Int -> Bool), [Int]) -> [Int]), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: 
  LSP: Info: ALL errors:Error in term:
  p
Nature of error: Variable p is not bound    
Error in term:
  p
Nature of error: Variable p is not bound    
Error in term:
  p
Nature of error: type ((Int -> Bool), [Int]) is not consistent with arrow type
  LSP: Info: BidiCtx: Cls: Let expression
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent: Root
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: [?]
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: :: @
  LSP: Concave: Backpack: 
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new_tokens ::= whitespace | "," | "::" | "@"
root ::= new_tokens

Top 20 Logits:

:18.6681
#:15.4169
##:14.5591
let:14.2332
 :13.0861
    :12.6383
   :12.5851
in:12.5533
  :12.4997
################:12.4843
####:12.1521
```:12.0539
/*:11.8478
                :11.3024
(:11.269
//:11.247
        :11.2373
########:11.1781
       :11.1193
end:11.0936
def:11.0193

================
# Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)



























































































LSP: Prelude: Recieved string: ### List ###

# Add an element to the front of a list. #
let cons: (Int, [Int]) -> [Int] = fun x, xs -> x::xs in

# Determine the length of a list. #
let length: [Int] -> Int =
  fun xs ->
    case xs
    | [] => 0
    | _::xs => 1 + length(xs) end in

# Extract the first element of a list. #
let hd: [Int] -> Option =
  fun l ->
    case l
    | [] => None
    | x::xs => Some(x) end in

# Extract the rest of the list. #
let tl: [Int] -> [Int] =
  fun l ->
    case l
    | [] => []
    | x::xs => xs end in

# Determine if a list is empty. #
let is_empty: [Int] -> Bool =
  fun xs ->
    case xs
    | [] => true
    | _::_ => false end in

# Return the element at the index. #
let nth: ([Int], Int) -> Option =
  fun xs, n ->
    case xs, n
    | x::_, 0 => Some(x)
    | _::xs, n => nth(xs, n - 1)
    | [], _ => None end in

# Reverse a List. #
let rev: [Int] -> [Int] =
fun l -> 
let go: ([Int], [Int]) -> [Int] =
  fun xs, acc -> 
    case xs 
    | [] => acc 
    | x::xs => go(xs, x::acc) end in
go(l, []) in

# Check if two lists are equal #
let equal: ([Int], [Int]) -> Bool =
    fun p, xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => x == y && equal(xs, ys)
    | _ => false end
in

# Initialize a list with a given length using an initializer function #
let init: (Int, Int -> Int) -> [Int] =
    fun len, f ->
        let go: (Int, [Int]) -> [Int] =
        fun idx, xs ->
            if idx < len 
            then go(idx + 1, xs @ [f(idx)])   
            else xs
        in
        go(0, [])
in

# Reduce a list from the left. #
let fold_left: ((Int, Int) -> Int, Int, [Int]) -> Int =
  fun f, acc, xs ->
    case xs 
    | [] => acc
    | hd::tl => fold_left(f, f(acc, hd), tl) end in

# Reduce a list from the right. #
let fold_right: ((Int, Int) -> Int, [Int], Int) -> Int =
  fun f, xs, acc ->
    case xs
    | [] => acc
    | hd::tl => f(hd, fold_right(f, tl, acc)) end in


666
LSP: Prelude: String parsed successfully
LSP: Prelude: Info map generated successfully
Debug: true, Constrain: Types
LSP: Init: Recieved string: # Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)


























































































LSP: Init: String parsed successfully
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: >( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {go: ((?, ?) -> [?]), filter: (((Int -> Bool), [Int]) -> [Int]), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: 
  LSP: Info: ALL errors:Error in term:
  p
Nature of error: Variable p is not bound    
Error in term:
  p
Nature of error: type ((Int -> Bool), [Int]) is not consistent with arrow type    
Error in term:
  p
Nature of error: Variable p is not bound
  LSP: Info: BidiCtx: Cls: Let expression
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent: Root
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: [?]
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: :: @
  LSP: Concave: Backpack: 
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new_tokens ::= whitespace | "," | "::" | "@"
root ::= new_tokens

Top 20 Logits:

:18.6702
#:15.4194
##:14.5347
let:14.2414
 :13.0865
    :12.6363
   :12.5831
in:12.5706
  :12.4936
################:12.4747
####:12.1311
```:12.0459
/*:11.8567
                :11.302
(:11.2762
//:11.2476
        :11.2347
########:11.1537
       :11.1162
end:11.1011
[:11.0146

================
# Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)




























































































LSP: Prelude: Recieved string: ### List ###

# Add an element to the front of a list. #
let cons: (Int, [Int]) -> [Int] = fun x, xs -> x::xs in

# Determine the length of a list. #
let length: [Int] -> Int =
  fun xs ->
    case xs
    | [] => 0
    | _::xs => 1 + length(xs) end in

# Extract the first element of a list. #
let hd: [Int] -> Option =
  fun l ->
    case l
    | [] => None
    | x::xs => Some(x) end in

# Extract the rest of the list. #
let tl: [Int] -> [Int] =
  fun l ->
    case l
    | [] => []
    | x::xs => xs end in

# Determine if a list is empty. #
let is_empty: [Int] -> Bool =
  fun xs ->
    case xs
    | [] => true
    | _::_ => false end in

# Return the element at the index. #
let nth: ([Int], Int) -> Option =
  fun xs, n ->
    case xs, n
    | x::_, 0 => Some(x)
    | _::xs, n => nth(xs, n - 1)
    | [], _ => None end in

# Reverse a List. #
let rev: [Int] -> [Int] =
fun l -> 
let go: ([Int], [Int]) -> [Int] =
  fun xs, acc -> 
    case xs 
    | [] => acc 
    | x::xs => go(xs, x::acc) end in
go(l, []) in

# Check if two lists are equal #
let equal: ([Int], [Int]) -> Bool =
    fun p, xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => x == y && equal(xs, ys)
    | _ => false end
in

# Initialize a list with a given length using an initializer function #
let init: (Int, Int -> Int) -> [Int] =
    fun len, f ->
        let go: (Int, [Int]) -> [Int] =
        fun idx, xs ->
            if idx < len 
            then go(idx + 1, xs @ [f(idx)])   
            else xs
        in
        go(0, [])
in

# Reduce a list from the left. #
let fold_left: ((Int, Int) -> Int, Int, [Int]) -> Int =
  fun f, acc, xs ->
    case xs 
    | [] => acc
    | hd::tl => fold_left(f, f(acc, hd), tl) end in

# Reduce a list from the right. #
let fold_right: ((Int, Int) -> Int, [Int], Int) -> Int =
  fun f, xs, acc ->
    case xs
    | [] => acc
    | hd::tl => f(hd, fold_right(f, tl, acc)) end in


666
LSP: Prelude: String parsed successfully
LSP: Prelude: Info map generated successfully
Debug: true, Constrain: Types
LSP: Init: Recieved string: # Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)



























































































LSP: Init: String parsed successfully
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: >( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {go: ((?, ?) -> [?]), filter: (((Int -> Bool), [Int]) -> [Int]), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: 
  LSP: Info: ALL errors:Error in term:
  p
Nature of error: type ((Int -> Bool), [Int]) is not consistent with arrow type    
Error in term:
  p
Nature of error: Variable p is not bound    
Error in term:
  p
Nature of error: Variable p is not bound
  LSP: Info: BidiCtx: Cls: Let expression
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent: Root
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: [?]
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: :: @
  LSP: Concave: Backpack: 
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new_tokens ::= whitespace | "," | "::" | "@"
root ::= new_tokens

Top 20 Logits:

:18.6788
#:15.4302
##:14.5312
let:14.26
 :13.0919
    :12.6366
   :12.5855
in:12.5554
  :12.4915
################:12.4761
####:12.1246
```:12.0546
/*:11.8705
                :11.3036
(:11.2943
//:11.2569
        :11.2342
########:11.1468
       :11.119
end:11.0931
[:11.0287

================
# Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)





























































































LSP: Prelude: Recieved string: ### List ###

# Add an element to the front of a list. #
let cons: (Int, [Int]) -> [Int] = fun x, xs -> x::xs in

# Determine the length of a list. #
let length: [Int] -> Int =
  fun xs ->
    case xs
    | [] => 0
    | _::xs => 1 + length(xs) end in

# Extract the first element of a list. #
let hd: [Int] -> Option =
  fun l ->
    case l
    | [] => None
    | x::xs => Some(x) end in

# Extract the rest of the list. #
let tl: [Int] -> [Int] =
  fun l ->
    case l
    | [] => []
    | x::xs => xs end in

# Determine if a list is empty. #
let is_empty: [Int] -> Bool =
  fun xs ->
    case xs
    | [] => true
    | _::_ => false end in

# Return the element at the index. #
let nth: ([Int], Int) -> Option =
  fun xs, n ->
    case xs, n
    | x::_, 0 => Some(x)
    | _::xs, n => nth(xs, n - 1)
    | [], _ => None end in

# Reverse a List. #
let rev: [Int] -> [Int] =
fun l -> 
let go: ([Int], [Int]) -> [Int] =
  fun xs, acc -> 
    case xs 
    | [] => acc 
    | x::xs => go(xs, x::acc) end in
go(l, []) in

# Check if two lists are equal #
let equal: ([Int], [Int]) -> Bool =
    fun p, xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => x == y && equal(xs, ys)
    | _ => false end
in

# Initialize a list with a given length using an initializer function #
let init: (Int, Int -> Int) -> [Int] =
    fun len, f ->
        let go: (Int, [Int]) -> [Int] =
        fun idx, xs ->
            if idx < len 
            then go(idx + 1, xs @ [f(idx)])   
            else xs
        in
        go(0, [])
in

# Reduce a list from the left. #
let fold_left: ((Int, Int) -> Int, Int, [Int]) -> Int =
  fun f, acc, xs ->
    case xs 
    | [] => acc
    | hd::tl => fold_left(f, f(acc, hd), tl) end in

# Reduce a list from the right. #
let fold_right: ((Int, Int) -> Int, [Int], Int) -> Int =
  fun f, xs, acc ->
    case xs
    | [] => acc
    | hd::tl => f(hd, fold_right(f, tl, acc)) end in


666
LSP: Prelude: String parsed successfully
LSP: Prelude: Info map generated successfully
Debug: true, Constrain: Types
LSP: Init: Recieved string: # Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)




























































































LSP: Init: String parsed successfully
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: >( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {go: ((?, ?) -> [?]), filter: (((Int -> Bool), [Int]) -> [Int]), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: 
  LSP: Info: ALL errors:Error in term:
  p
Nature of error: Variable p is not bound    
Error in term:
  p
Nature of error: type ((Int -> Bool), [Int]) is not consistent with arrow type    
Error in term:
  p
Nature of error: Variable p is not bound
  LSP: Info: BidiCtx: Cls: Let expression
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent: Root
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: [?]
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: :: @
  LSP: Concave: Backpack: 
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new_tokens ::= whitespace | "," | "::" | "@"
root ::= new_tokens

Top 20 Logits:

:18.693
#:15.4436
##:14.5448
let:14.2806
 :13.0966
    :12.6342
   :12.586
in:12.532
  :12.4906
################:12.4842
####:12.1317
```:12.0771
/*:11.8829
(:11.3098
                :11.3066
//:11.2683
        :11.236
########:11.1518
       :11.1262
end:11.0751
[:11.0527

================
# Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)






























































































LSP: Prelude: Recieved string: ### List ###

# Add an element to the front of a list. #
let cons: (Int, [Int]) -> [Int] = fun x, xs -> x::xs in

# Determine the length of a list. #
let length: [Int] -> Int =
  fun xs ->
    case xs
    | [] => 0
    | _::xs => 1 + length(xs) end in

# Extract the first element of a list. #
let hd: [Int] -> Option =
  fun l ->
    case l
    | [] => None
    | x::xs => Some(x) end in

# Extract the rest of the list. #
let tl: [Int] -> [Int] =
  fun l ->
    case l
    | [] => []
    | x::xs => xs end in

# Determine if a list is empty. #
let is_empty: [Int] -> Bool =
  fun xs ->
    case xs
    | [] => true
    | _::_ => false end in

# Return the element at the index. #
let nth: ([Int], Int) -> Option =
  fun xs, n ->
    case xs, n
    | x::_, 0 => Some(x)
    | _::xs, n => nth(xs, n - 1)
    | [], _ => None end in

# Reverse a List. #
let rev: [Int] -> [Int] =
fun l -> 
let go: ([Int], [Int]) -> [Int] =
  fun xs, acc -> 
    case xs 
    | [] => acc 
    | x::xs => go(xs, x::acc) end in
go(l, []) in

# Check if two lists are equal #
let equal: ([Int], [Int]) -> Bool =
    fun p, xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => x == y && equal(xs, ys)
    | _ => false end
in

# Initialize a list with a given length using an initializer function #
let init: (Int, Int -> Int) -> [Int] =
    fun len, f ->
        let go: (Int, [Int]) -> [Int] =
        fun idx, xs ->
            if idx < len 
            then go(idx + 1, xs @ [f(idx)])   
            else xs
        in
        go(0, [])
in

# Reduce a list from the left. #
let fold_left: ((Int, Int) -> Int, Int, [Int]) -> Int =
  fun f, acc, xs ->
    case xs 
    | [] => acc
    | hd::tl => fold_left(f, f(acc, hd), tl) end in

# Reduce a list from the right. #
let fold_right: ((Int, Int) -> Int, [Int], Int) -> Int =
  fun f, xs, acc ->
    case xs
    | [] => acc
    | hd::tl => f(hd, fold_right(f, tl, acc)) end in


666
LSP: Prelude: String parsed successfully
LSP: Prelude: Info map generated successfully
Debug: true, Constrain: Types
LSP: Init: Recieved string: # Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)





























































































LSP: Init: String parsed successfully
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: >( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {go: ((?, ?) -> [?]), filter: (((Int -> Bool), [Int]) -> [Int]), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: 
  LSP: Info: ALL errors:Error in term:
  p
Nature of error: Variable p is not bound    
Error in term:
  p
Nature of error: Variable p is not bound    
Error in term:
  p
Nature of error: type ((Int -> Bool), [Int]) is not consistent with arrow type
  LSP: Info: BidiCtx: Cls: Let expression
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent: Root
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: [?]
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: :: @
  LSP: Concave: Backpack: 
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new_tokens ::= whitespace | "," | "::" | "@"
root ::= new_tokens

Top 20 Logits:

:18.709
#:15.4521
##:14.5603
let:14.2954
 :13.0978
    :12.6276
   :12.5817
in:12.527
################:12.4923
  :12.4905
####:12.1417
```:12.0996
/*:11.8909
(:11.313
                :11.3123
//:11.2758
        :11.2406
########:11.1562
       :11.1358
[:11.0731
end:11.0672

================
# Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)































































































LSP: Prelude: Recieved string: ### List ###

# Add an element to the front of a list. #
let cons: (Int, [Int]) -> [Int] = fun x, xs -> x::xs in

# Determine the length of a list. #
let length: [Int] -> Int =
  fun xs ->
    case xs
    | [] => 0
    | _::xs => 1 + length(xs) end in

# Extract the first element of a list. #
let hd: [Int] -> Option =
  fun l ->
    case l
    | [] => None
    | x::xs => Some(x) end in

# Extract the rest of the list. #
let tl: [Int] -> [Int] =
  fun l ->
    case l
    | [] => []
    | x::xs => xs end in

# Determine if a list is empty. #
let is_empty: [Int] -> Bool =
  fun xs ->
    case xs
    | [] => true
    | _::_ => false end in

# Return the element at the index. #
let nth: ([Int], Int) -> Option =
  fun xs, n ->
    case xs, n
    | x::_, 0 => Some(x)
    | _::xs, n => nth(xs, n - 1)
    | [], _ => None end in

# Reverse a List. #
let rev: [Int] -> [Int] =
fun l -> 
let go: ([Int], [Int]) -> [Int] =
  fun xs, acc -> 
    case xs 
    | [] => acc 
    | x::xs => go(xs, x::acc) end in
go(l, []) in

# Check if two lists are equal #
let equal: ([Int], [Int]) -> Bool =
    fun p, xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => x == y && equal(xs, ys)
    | _ => false end
in

# Initialize a list with a given length using an initializer function #
let init: (Int, Int -> Int) -> [Int] =
    fun len, f ->
        let go: (Int, [Int]) -> [Int] =
        fun idx, xs ->
            if idx < len 
            then go(idx + 1, xs @ [f(idx)])   
            else xs
        in
        go(0, [])
in

# Reduce a list from the left. #
let fold_left: ((Int, Int) -> Int, Int, [Int]) -> Int =
  fun f, acc, xs ->
    case xs 
    | [] => acc
    | hd::tl => fold_left(f, f(acc, hd), tl) end in

# Reduce a list from the right. #
let fold_right: ((Int, Int) -> Int, [Int], Int) -> Int =
  fun f, xs, acc ->
    case xs
    | [] => acc
    | hd::tl => f(hd, fold_right(f, tl, acc)) end in


666
LSP: Prelude: String parsed successfully
LSP: Prelude: Info map generated successfully
Debug: true, Constrain: Types
LSP: Init: Recieved string: # Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)






























































































LSP: Init: String parsed successfully
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: >( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {go: ((?, ?) -> [?]), filter: (((Int -> Bool), [Int]) -> [Int]), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: 
  LSP: Info: ALL errors:Error in term:
  p
Nature of error: Variable p is not bound    
Error in term:
  p
Nature of error: Variable p is not bound    
Error in term:
  p
Nature of error: type ((Int -> Bool), [Int]) is not consistent with arrow type
  LSP: Info: BidiCtx: Cls: Let expression
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent: Root
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: [?]
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: :: @
  LSP: Concave: Backpack: 
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new_tokens ::= whitespace | "," | "::" | "@"
root ::= new_tokens

Top 20 Logits:

:18.7229
#:15.4504
##:14.5656
let:14.2986
 :13.0972
    :12.6212
   :12.5758
in:12.5473
################:12.4965
  :12.4931
####:12.1449
```:12.1096
/*:11.8971
                :11.3187
(:11.303
//:11.2796
        :11.2481
########:11.1541
       :11.146
end:11.0828
[:11.0782

================
# Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)
































































































LSP: Prelude: Recieved string: ### List ###

# Add an element to the front of a list. #
let cons: (Int, [Int]) -> [Int] = fun x, xs -> x::xs in

# Determine the length of a list. #
let length: [Int] -> Int =
  fun xs ->
    case xs
    | [] => 0
    | _::xs => 1 + length(xs) end in

# Extract the first element of a list. #
let hd: [Int] -> Option =
  fun l ->
    case l
    | [] => None
    | x::xs => Some(x) end in

# Extract the rest of the list. #
let tl: [Int] -> [Int] =
  fun l ->
    case l
    | [] => []
    | x::xs => xs end in

# Determine if a list is empty. #
let is_empty: [Int] -> Bool =
  fun xs ->
    case xs
    | [] => true
    | _::_ => false end in

# Return the element at the index. #
let nth: ([Int], Int) -> Option =
  fun xs, n ->
    case xs, n
    | x::_, 0 => Some(x)
    | _::xs, n => nth(xs, n - 1)
    | [], _ => None end in

# Reverse a List. #
let rev: [Int] -> [Int] =
fun l -> 
let go: ([Int], [Int]) -> [Int] =
  fun xs, acc -> 
    case xs 
    | [] => acc 
    | x::xs => go(xs, x::acc) end in
go(l, []) in

# Check if two lists are equal #
let equal: ([Int], [Int]) -> Bool =
    fun p, xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => x == y && equal(xs, ys)
    | _ => false end
in

# Initialize a list with a given length using an initializer function #
let init: (Int, Int -> Int) -> [Int] =
    fun len, f ->
        let go: (Int, [Int]) -> [Int] =
        fun idx, xs ->
            if idx < len 
            then go(idx + 1, xs @ [f(idx)])   
            else xs
        in
        go(0, [])
in

# Reduce a list from the left. #
let fold_left: ((Int, Int) -> Int, Int, [Int]) -> Int =
  fun f, acc, xs ->
    case xs 
    | [] => acc
    | hd::tl => fold_left(f, f(acc, hd), tl) end in

# Reduce a list from the right. #
let fold_right: ((Int, Int) -> Int, [Int], Int) -> Int =
  fun f, xs, acc ->
    case xs
    | [] => acc
    | hd::tl => f(hd, fold_right(f, tl, acc)) end in


666
LSP: Prelude: String parsed successfully
LSP: Prelude: Info map generated successfully
Debug: true, Constrain: Types
LSP: Init: Recieved string: # Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)































































































LSP: Init: String parsed successfully
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: >( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {go: ((?, ?) -> [?]), filter: (((Int -> Bool), [Int]) -> [Int]), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: 
  LSP: Info: ALL errors:Error in term:
  p
Nature of error: Variable p is not bound    
Error in term:
  p
Nature of error: Variable p is not bound    
Error in term:
  p
Nature of error: type ((Int -> Bool), [Int]) is not consistent with arrow type
  LSP: Info: BidiCtx: Cls: Let expression
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent: Root
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: [?]
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: :: @
  LSP: Concave: Backpack: 
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new_tokens ::= whitespace | "," | "::" | "@"
root ::= new_tokens

Top 20 Logits:

:18.7311
#:15.4386
##:14.5579
let:14.2896
 :13.0969
    :12.6192
in:12.5788
   :12.571
  :12.4986
################:12.4933
####:12.1383
```:12.1025
/*:11.9055
                :11.3202
(:11.2874
//:11.2841
        :11.256
       :11.1532
########:11.1453
end:11.1135
[:11.0673

================
# Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)

































































































LSP: Prelude: Recieved string: ### List ###

# Add an element to the front of a list. #
let cons: (Int, [Int]) -> [Int] = fun x, xs -> x::xs in

# Determine the length of a list. #
let length: [Int] -> Int =
  fun xs ->
    case xs
    | [] => 0
    | _::xs => 1 + length(xs) end in

# Extract the first element of a list. #
let hd: [Int] -> Option =
  fun l ->
    case l
    | [] => None
    | x::xs => Some(x) end in

# Extract the rest of the list. #
let tl: [Int] -> [Int] =
  fun l ->
    case l
    | [] => []
    | x::xs => xs end in

# Determine if a list is empty. #
let is_empty: [Int] -> Bool =
  fun xs ->
    case xs
    | [] => true
    | _::_ => false end in

# Return the element at the index. #
let nth: ([Int], Int) -> Option =
  fun xs, n ->
    case xs, n
    | x::_, 0 => Some(x)
    | _::xs, n => nth(xs, n - 1)
    | [], _ => None end in

# Reverse a List. #
let rev: [Int] -> [Int] =
fun l -> 
let go: ([Int], [Int]) -> [Int] =
  fun xs, acc -> 
    case xs 
    | [] => acc 
    | x::xs => go(xs, x::acc) end in
go(l, []) in

# Check if two lists are equal #
let equal: ([Int], [Int]) -> Bool =
    fun p, xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => x == y && equal(xs, ys)
    | _ => false end
in

# Initialize a list with a given length using an initializer function #
let init: (Int, Int -> Int) -> [Int] =
    fun len, f ->
        let go: (Int, [Int]) -> [Int] =
        fun idx, xs ->
            if idx < len 
            then go(idx + 1, xs @ [f(idx)])   
            else xs
        in
        go(0, [])
in

# Reduce a list from the left. #
let fold_left: ((Int, Int) -> Int, Int, [Int]) -> Int =
  fun f, acc, xs ->
    case xs 
    | [] => acc
    | hd::tl => fold_left(f, f(acc, hd), tl) end in

# Reduce a list from the right. #
let fold_right: ((Int, Int) -> Int, [Int], Int) -> Int =
  fun f, xs, acc ->
    case xs
    | [] => acc
    | hd::tl => f(hd, fold_right(f, tl, acc)) end in


666
LSP: Prelude: String parsed successfully
LSP: Prelude: Info map generated successfully
Debug: true, Constrain: Types
LSP: Init: Recieved string: # Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)
































































































LSP: Init: String parsed successfully
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: >( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {go: ((?, ?) -> [?]), filter: (((Int -> Bool), [Int]) -> [Int]), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: 
  LSP: Info: ALL errors:Error in term:
  p
Nature of error: Variable p is not bound    
Error in term:
  p
Nature of error: Variable p is not bound    
Error in term:
  p
Nature of error: type ((Int -> Bool), [Int]) is not consistent with arrow type
  LSP: Info: BidiCtx: Cls: Let expression
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent: Root
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: [?]
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: :: @
  LSP: Concave: Backpack: 
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new_tokens ::= whitespace | "," | "::" | "@"
root ::= new_tokens

Top 20 Logits:

:18.7359
#:15.4228
##:14.5421
let:14.2756
 :13.0978
    :12.6224
in:12.6101
   :12.5669
  :12.5071
################:12.482
####:12.1257
```:12.0852
/*:11.9155
                :11.3167
//:11.2913
(:11.2781
        :11.2631
       :11.1553
end:11.1488
########:11.1335
[:11.0489

================
# Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)


































































































LSP: Prelude: Recieved string: ### List ###

# Add an element to the front of a list. #
let cons: (Int, [Int]) -> [Int] = fun x, xs -> x::xs in

# Determine the length of a list. #
let length: [Int] -> Int =
  fun xs ->
    case xs
    | [] => 0
    | _::xs => 1 + length(xs) end in

# Extract the first element of a list. #
let hd: [Int] -> Option =
  fun l ->
    case l
    | [] => None
    | x::xs => Some(x) end in

# Extract the rest of the list. #
let tl: [Int] -> [Int] =
  fun l ->
    case l
    | [] => []
    | x::xs => xs end in

# Determine if a list is empty. #
let is_empty: [Int] -> Bool =
  fun xs ->
    case xs
    | [] => true
    | _::_ => false end in

# Return the element at the index. #
let nth: ([Int], Int) -> Option =
  fun xs, n ->
    case xs, n
    | x::_, 0 => Some(x)
    | _::xs, n => nth(xs, n - 1)
    | [], _ => None end in

# Reverse a List. #
let rev: [Int] -> [Int] =
fun l -> 
let go: ([Int], [Int]) -> [Int] =
  fun xs, acc -> 
    case xs 
    | [] => acc 
    | x::xs => go(xs, x::acc) end in
go(l, []) in

# Check if two lists are equal #
let equal: ([Int], [Int]) -> Bool =
    fun p, xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => x == y && equal(xs, ys)
    | _ => false end
in

# Initialize a list with a given length using an initializer function #
let init: (Int, Int -> Int) -> [Int] =
    fun len, f ->
        let go: (Int, [Int]) -> [Int] =
        fun idx, xs ->
            if idx < len 
            then go(idx + 1, xs @ [f(idx)])   
            else xs
        in
        go(0, [])
in

# Reduce a list from the left. #
let fold_left: ((Int, Int) -> Int, Int, [Int]) -> Int =
  fun f, acc, xs ->
    case xs 
    | [] => acc
    | hd::tl => fold_left(f, f(acc, hd), tl) end in

# Reduce a list from the right. #
let fold_right: ((Int, Int) -> Int, [Int], Int) -> Int =
  fun f, xs, acc ->
    case xs
    | [] => acc
    | hd::tl => f(hd, fold_right(f, tl, acc)) end in


666
LSP: Prelude: String parsed successfully
LSP: Prelude: Info map generated successfully
Debug: true, Constrain: Types
LSP: Init: Recieved string: # Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)

































































































LSP: Init: String parsed successfully
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: >( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {go: ((?, ?) -> [?]), filter: (((Int -> Bool), [Int]) -> [Int]), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: 
  LSP: Info: ALL errors:Error in term:
  p
Nature of error: Variable p is not bound    
Error in term:
  p
Nature of error: Variable p is not bound    
Error in term:
  p
Nature of error: type ((Int -> Bool), [Int]) is not consistent with arrow type
  LSP: Info: BidiCtx: Cls: Let expression
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent: Root
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: [?]
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: :: @
  LSP: Concave: Backpack: 
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new_tokens ::= whitespace | "," | "::" | "@"
root ::= new_tokens

Top 20 Logits:

:18.7402
#:15.4105
##:14.5246
let:14.2655
 :13.0978
in:12.6367
    :12.6235
   :12.5597
  :12.5133
################:12.466
####:12.1125
```:12.0711
/*:11.9238
                :11.3109
//:11.3013
(:11.2794
        :11.2668
end:11.1775
       :11.1531
########:11.1219
[:11.0346

================
# Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)



































































































LSP: Prelude: Recieved string: ### List ###

# Add an element to the front of a list. #
let cons: (Int, [Int]) -> [Int] = fun x, xs -> x::xs in

# Determine the length of a list. #
let length: [Int] -> Int =
  fun xs ->
    case xs
    | [] => 0
    | _::xs => 1 + length(xs) end in

# Extract the first element of a list. #
let hd: [Int] -> Option =
  fun l ->
    case l
    | [] => None
    | x::xs => Some(x) end in

# Extract the rest of the list. #
let tl: [Int] -> [Int] =
  fun l ->
    case l
    | [] => []
    | x::xs => xs end in

# Determine if a list is empty. #
let is_empty: [Int] -> Bool =
  fun xs ->
    case xs
    | [] => true
    | _::_ => false end in

# Return the element at the index. #
let nth: ([Int], Int) -> Option =
  fun xs, n ->
    case xs, n
    | x::_, 0 => Some(x)
    | _::xs, n => nth(xs, n - 1)
    | [], _ => None end in

# Reverse a List. #
let rev: [Int] -> [Int] =
fun l -> 
let go: ([Int], [Int]) -> [Int] =
  fun xs, acc -> 
    case xs 
    | [] => acc 
    | x::xs => go(xs, x::acc) end in
go(l, []) in

# Check if two lists are equal #
let equal: ([Int], [Int]) -> Bool =
    fun p, xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => x == y && equal(xs, ys)
    | _ => false end
in

# Initialize a list with a given length using an initializer function #
let init: (Int, Int -> Int) -> [Int] =
    fun len, f ->
        let go: (Int, [Int]) -> [Int] =
        fun idx, xs ->
            if idx < len 
            then go(idx + 1, xs @ [f(idx)])   
            else xs
        in
        go(0, [])
in

# Reduce a list from the left. #
let fold_left: ((Int, Int) -> Int, Int, [Int]) -> Int =
  fun f, acc, xs ->
    case xs 
    | [] => acc
    | hd::tl => fold_left(f, f(acc, hd), tl) end in

# Reduce a list from the right. #
let fold_right: ((Int, Int) -> Int, [Int], Int) -> Int =
  fun f, xs, acc ->
    case xs
    | [] => acc
    | hd::tl => f(hd, fold_right(f, tl, acc)) end in


666
LSP: Prelude: String parsed successfully
LSP: Prelude: Info map generated successfully
Debug: true, Constrain: Types
LSP: Init: Recieved string: # Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)


































































































LSP: Init: String parsed successfully
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: >( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {go: ((?, ?) -> [?]), filter: (((Int -> Bool), [Int]) -> [Int]), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: 
  LSP: Info: ALL errors:Error in term:
  p
Nature of error: Variable p is not bound    
Error in term:
  p
Nature of error: type ((Int -> Bool), [Int]) is not consistent with arrow type    
Error in term:
  p
Nature of error: Variable p is not bound
  LSP: Info: BidiCtx: Cls: Let expression
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent: Root
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: [?]
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: :: @
  LSP: Concave: Backpack: 
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new_tokens ::= whitespace | "," | "::" | "@"
root ::= new_tokens

Top 20 Logits:

:18.7458
#:15.4065
##:14.5097
let:14.2663
 :13.0934
in:12.6558
    :12.6154
   :12.5467
  :12.5103
################:12.4503
####:12.102
```:12.0651
/*:11.9306
//:11.3127
                :11.3044
(:11.2864
        :11.2642
end:11.19
       :11.1481
########:11.1123
[:11.0319

================
# Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)




































































































LSP: Prelude: Recieved string: ### List ###

# Add an element to the front of a list. #
let cons: (Int, [Int]) -> [Int] = fun x, xs -> x::xs in

# Determine the length of a list. #
let length: [Int] -> Int =
  fun xs ->
    case xs
    | [] => 0
    | _::xs => 1 + length(xs) end in

# Extract the first element of a list. #
let hd: [Int] -> Option =
  fun l ->
    case l
    | [] => None
    | x::xs => Some(x) end in

# Extract the rest of the list. #
let tl: [Int] -> [Int] =
  fun l ->
    case l
    | [] => []
    | x::xs => xs end in

# Determine if a list is empty. #
let is_empty: [Int] -> Bool =
  fun xs ->
    case xs
    | [] => true
    | _::_ => false end in

# Return the element at the index. #
let nth: ([Int], Int) -> Option =
  fun xs, n ->
    case xs, n
    | x::_, 0 => Some(x)
    | _::xs, n => nth(xs, n - 1)
    | [], _ => None end in

# Reverse a List. #
let rev: [Int] -> [Int] =
fun l -> 
let go: ([Int], [Int]) -> [Int] =
  fun xs, acc -> 
    case xs 
    | [] => acc 
    | x::xs => go(xs, x::acc) end in
go(l, []) in

# Check if two lists are equal #
let equal: ([Int], [Int]) -> Bool =
    fun p, xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => x == y && equal(xs, ys)
    | _ => false end
in

# Initialize a list with a given length using an initializer function #
let init: (Int, Int -> Int) -> [Int] =
    fun len, f ->
        let go: (Int, [Int]) -> [Int] =
        fun idx, xs ->
            if idx < len 
            then go(idx + 1, xs @ [f(idx)])   
            else xs
        in
        go(0, [])
in

# Reduce a list from the left. #
let fold_left: ((Int, Int) -> Int, Int, [Int]) -> Int =
  fun f, acc, xs ->
    case xs 
    | [] => acc
    | hd::tl => fold_left(f, f(acc, hd), tl) end in

# Reduce a list from the right. #
let fold_right: ((Int, Int) -> Int, [Int], Int) -> Int =
  fun f, xs, acc ->
    case xs
    | [] => acc
    | hd::tl => f(hd, fold_right(f, tl, acc)) end in


666
LSP: Prelude: String parsed successfully
LSP: Prelude: Info map generated successfully
Debug: true, Constrain: Types
LSP: Init: Recieved string: # Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)



































































































LSP: Init: String parsed successfully
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: >( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {go: ((?, ?) -> [?]), filter: (((Int -> Bool), [Int]) -> [Int]), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: 
  LSP: Info: ALL errors:Error in term:
  p
Nature of error: Variable p is not bound    
Error in term:
  p
Nature of error: Variable p is not bound    
Error in term:
  p
Nature of error: type ((Int -> Bool), [Int]) is not consistent with arrow type
  LSP: Info: BidiCtx: Cls: Let expression
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent: Root
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: [?]
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: :: @
  LSP: Concave: Backpack: 
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new_tokens ::= whitespace | "," | "::" | "@"
root ::= new_tokens

Top 20 Logits:

:18.751
#:15.408
##:14.4962
let:14.2771
 :13.0819
in:12.6684
    :12.5956
   :12.5277
  :12.4963
################:12.4357
####:12.0923
```:12.0656
/*:11.9345
//:11.3207
                :11.2992
(:11.29
        :11.2536
end:11.1856
       :11.1413
########:11.1006
[:11.0393

================
# Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)





































































































LSP: Prelude: Recieved string: ### List ###

# Add an element to the front of a list. #
let cons: (Int, [Int]) -> [Int] = fun x, xs -> x::xs in

# Determine the length of a list. #
let length: [Int] -> Int =
  fun xs ->
    case xs
    | [] => 0
    | _::xs => 1 + length(xs) end in

# Extract the first element of a list. #
let hd: [Int] -> Option =
  fun l ->
    case l
    | [] => None
    | x::xs => Some(x) end in

# Extract the rest of the list. #
let tl: [Int] -> [Int] =
  fun l ->
    case l
    | [] => []
    | x::xs => xs end in

# Determine if a list is empty. #
let is_empty: [Int] -> Bool =
  fun xs ->
    case xs
    | [] => true
    | _::_ => false end in

# Return the element at the index. #
let nth: ([Int], Int) -> Option =
  fun xs, n ->
    case xs, n
    | x::_, 0 => Some(x)
    | _::xs, n => nth(xs, n - 1)
    | [], _ => None end in

# Reverse a List. #
let rev: [Int] -> [Int] =
fun l -> 
let go: ([Int], [Int]) -> [Int] =
  fun xs, acc -> 
    case xs 
    | [] => acc 
    | x::xs => go(xs, x::acc) end in
go(l, []) in

# Check if two lists are equal #
let equal: ([Int], [Int]) -> Bool =
    fun p, xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => x == y && equal(xs, ys)
    | _ => false end
in

# Initialize a list with a given length using an initializer function #
let init: (Int, Int -> Int) -> [Int] =
    fun len, f ->
        let go: (Int, [Int]) -> [Int] =
        fun idx, xs ->
            if idx < len 
            then go(idx + 1, xs @ [f(idx)])   
            else xs
        in
        go(0, [])
in

# Reduce a list from the left. #
let fold_left: ((Int, Int) -> Int, Int, [Int]) -> Int =
  fun f, acc, xs ->
    case xs 
    | [] => acc
    | hd::tl => fold_left(f, f(acc, hd), tl) end in

# Reduce a list from the right. #
let fold_right: ((Int, Int) -> Int, [Int], Int) -> Int =
  fun f, xs, acc ->
    case xs
    | [] => acc
    | hd::tl => f(hd, fold_right(f, tl, acc)) end in


666
LSP: Prelude: String parsed successfully
LSP: Prelude: Info map generated successfully
Debug: true, Constrain: Types
LSP: Init: Recieved string: # Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)




































































































LSP: Init: String parsed successfully
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: >( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {go: ((?, ?) -> [?]), filter: (((Int -> Bool), [Int]) -> [Int]), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: 
  LSP: Info: ALL errors:Error in term:
  p
Nature of error: Variable p is not bound    
Error in term:
  p
Nature of error: type ((Int -> Bool), [Int]) is not consistent with arrow type    
Error in term:
  p
Nature of error: Variable p is not bound
  LSP: Info: BidiCtx: Cls: Let expression
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent: Root
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: [?]
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: :: @
  LSP: Concave: Backpack: 
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new_tokens ::= whitespace | "," | "::" | "@"
root ::= new_tokens

Top 20 Logits:

:18.7555
#:15.4084
##:14.4844
let:14.2903
 :13.0679
in:12.6701
    :12.5715
   :12.5078
  :12.4789
################:12.4257
####:12.0827
```:12.0675
/*:11.9343
//:11.322
                :11.297
(:11.2856
        :11.2405
end:11.175
       :11.1357
########:11.0884
[:11.0517

================
# Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)






































































































LSP: Prelude: Recieved string: ### List ###

# Add an element to the front of a list. #
let cons: (Int, [Int]) -> [Int] = fun x, xs -> x::xs in

# Determine the length of a list. #
let length: [Int] -> Int =
  fun xs ->
    case xs
    | [] => 0
    | _::xs => 1 + length(xs) end in

# Extract the first element of a list. #
let hd: [Int] -> Option =
  fun l ->
    case l
    | [] => None
    | x::xs => Some(x) end in

# Extract the rest of the list. #
let tl: [Int] -> [Int] =
  fun l ->
    case l
    | [] => []
    | x::xs => xs end in

# Determine if a list is empty. #
let is_empty: [Int] -> Bool =
  fun xs ->
    case xs
    | [] => true
    | _::_ => false end in

# Return the element at the index. #
let nth: ([Int], Int) -> Option =
  fun xs, n ->
    case xs, n
    | x::_, 0 => Some(x)
    | _::xs, n => nth(xs, n - 1)
    | [], _ => None end in

# Reverse a List. #
let rev: [Int] -> [Int] =
fun l -> 
let go: ([Int], [Int]) -> [Int] =
  fun xs, acc -> 
    case xs 
    | [] => acc 
    | x::xs => go(xs, x::acc) end in
go(l, []) in

# Check if two lists are equal #
let equal: ([Int], [Int]) -> Bool =
    fun p, xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => x == y && equal(xs, ys)
    | _ => false end
in

# Initialize a list with a given length using an initializer function #
let init: (Int, Int -> Int) -> [Int] =
    fun len, f ->
        let go: (Int, [Int]) -> [Int] =
        fun idx, xs ->
            if idx < len 
            then go(idx + 1, xs @ [f(idx)])   
            else xs
        in
        go(0, [])
in

# Reduce a list from the left. #
let fold_left: ((Int, Int) -> Int, Int, [Int]) -> Int =
  fun f, acc, xs ->
    case xs 
    | [] => acc
    | hd::tl => fold_left(f, f(acc, hd), tl) end in

# Reduce a list from the right. #
let fold_right: ((Int, Int) -> Int, [Int], Int) -> Int =
  fun f, xs, acc ->
    case xs
    | [] => acc
    | hd::tl => f(hd, fold_right(f, tl, acc)) end in


666
LSP: Prelude: String parsed successfully
LSP: Prelude: Info map generated successfully
Debug: true, Constrain: Types
LSP: Init: Recieved string: # Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)





































































































LSP: Init: String parsed successfully
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: >( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {go: ((?, ?) -> [?]), filter: (((Int -> Bool), [Int]) -> [Int]), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: 
  LSP: Info: ALL errors:Error in term:
  p
Nature of error: type ((Int -> Bool), [Int]) is not consistent with arrow type    
Error in term:
  p
Nature of error: Variable p is not bound    
Error in term:
  p
Nature of error: Variable p is not bound
  LSP: Info: BidiCtx: Cls: Let expression
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent: Root
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: [?]
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: :: @
  LSP: Concave: Backpack: 
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new_tokens ::= whitespace | "," | "::" | "@"
root ::= new_tokens

Top 20 Logits:

:18.7606
#:15.4034
##:14.4799
let:14.2984
 :13.0592
in:12.6517
    :12.5556
   :12.4958
  :12.4677
################:12.4252
####:12.0769
```:12.0652
/*:11.9318
//:11.3176
                :11.298
(:11.2754
        :11.2327
end:11.1688
       :11.135
########:11.083
[:11.064

================
# Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)







































































































LSP: Prelude: Recieved string: ### List ###

# Add an element to the front of a list. #
let cons: (Int, [Int]) -> [Int] = fun x, xs -> x::xs in

# Determine the length of a list. #
let length: [Int] -> Int =
  fun xs ->
    case xs
    | [] => 0
    | _::xs => 1 + length(xs) end in

# Extract the first element of a list. #
let hd: [Int] -> Option =
  fun l ->
    case l
    | [] => None
    | x::xs => Some(x) end in

# Extract the rest of the list. #
let tl: [Int] -> [Int] =
  fun l ->
    case l
    | [] => []
    | x::xs => xs end in

# Determine if a list is empty. #
let is_empty: [Int] -> Bool =
  fun xs ->
    case xs
    | [] => true
    | _::_ => false end in

# Return the element at the index. #
let nth: ([Int], Int) -> Option =
  fun xs, n ->
    case xs, n
    | x::_, 0 => Some(x)
    | _::xs, n => nth(xs, n - 1)
    | [], _ => None end in

# Reverse a List. #
let rev: [Int] -> [Int] =
fun l -> 
let go: ([Int], [Int]) -> [Int] =
  fun xs, acc -> 
    case xs 
    | [] => acc 
    | x::xs => go(xs, x::acc) end in
go(l, []) in

# Check if two lists are equal #
let equal: ([Int], [Int]) -> Bool =
    fun p, xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => x == y && equal(xs, ys)
    | _ => false end
in

# Initialize a list with a given length using an initializer function #
let init: (Int, Int -> Int) -> [Int] =
    fun len, f ->
        let go: (Int, [Int]) -> [Int] =
        fun idx, xs ->
            if idx < len 
            then go(idx + 1, xs @ [f(idx)])   
            else xs
        in
        go(0, [])
in

# Reduce a list from the left. #
let fold_left: ((Int, Int) -> Int, Int, [Int]) -> Int =
  fun f, acc, xs ->
    case xs 
    | [] => acc
    | hd::tl => fold_left(f, f(acc, hd), tl) end in

# Reduce a list from the right. #
let fold_right: ((Int, Int) -> Int, [Int], Int) -> Int =
  fun f, xs, acc ->
    case xs
    | [] => acc
    | hd::tl => f(hd, fold_right(f, tl, acc)) end in


666
LSP: Prelude: String parsed successfully
LSP: Prelude: Info map generated successfully
Debug: true, Constrain: Types
LSP: Init: Recieved string: # Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)






































































































LSP: Init: String parsed successfully
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: >( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {go: ((?, ?) -> [?]), filter: (((Int -> Bool), [Int]) -> [Int]), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: 
  LSP: Info: ALL errors:Error in term:
  p
Nature of error: Variable p is not bound    
Error in term:
  p
Nature of error: type ((Int -> Bool), [Int]) is not consistent with arrow type    
Error in term:
  p
Nature of error: Variable p is not bound
  LSP: Info: BidiCtx: Cls: Let expression
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent: Root
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: [?]
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: :: @
  LSP: Concave: Backpack: 
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new_tokens ::= whitespace | "," | "::" | "@"
root ::= new_tokens

Top 20 Logits:

:18.7689
#:15.3939
##:14.4884
let:14.2999
 :13.0599
in:12.6132
    :12.5546
   :12.4954
  :12.4683
################:12.435
####:12.0799
```:12.0624
/*:11.9296
//:11.3131
                :11.3029
(:11.2691
        :11.2338
end:11.1673
       :11.1402
########:11.0912
[:11.0753

================
# Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)








































































































LSP: Prelude: Recieved string: ### List ###

# Add an element to the front of a list. #
let cons: (Int, [Int]) -> [Int] = fun x, xs -> x::xs in

# Determine the length of a list. #
let length: [Int] -> Int =
  fun xs ->
    case xs
    | [] => 0
    | _::xs => 1 + length(xs) end in

# Extract the first element of a list. #
let hd: [Int] -> Option =
  fun l ->
    case l
    | [] => None
    | x::xs => Some(x) end in

# Extract the rest of the list. #
let tl: [Int] -> [Int] =
  fun l ->
    case l
    | [] => []
    | x::xs => xs end in

# Determine if a list is empty. #
let is_empty: [Int] -> Bool =
  fun xs ->
    case xs
    | [] => true
    | _::_ => false end in

# Return the element at the index. #
let nth: ([Int], Int) -> Option =
  fun xs, n ->
    case xs, n
    | x::_, 0 => Some(x)
    | _::xs, n => nth(xs, n - 1)
    | [], _ => None end in

# Reverse a List. #
let rev: [Int] -> [Int] =
fun l -> 
let go: ([Int], [Int]) -> [Int] =
  fun xs, acc -> 
    case xs 
    | [] => acc 
    | x::xs => go(xs, x::acc) end in
go(l, []) in

# Check if two lists are equal #
let equal: ([Int], [Int]) -> Bool =
    fun p, xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => x == y && equal(xs, ys)
    | _ => false end
in

# Initialize a list with a given length using an initializer function #
let init: (Int, Int -> Int) -> [Int] =
    fun len, f ->
        let go: (Int, [Int]) -> [Int] =
        fun idx, xs ->
            if idx < len 
            then go(idx + 1, xs @ [f(idx)])   
            else xs
        in
        go(0, [])
in

# Reduce a list from the left. #
let fold_left: ((Int, Int) -> Int, Int, [Int]) -> Int =
  fun f, acc, xs ->
    case xs 
    | [] => acc
    | hd::tl => fold_left(f, f(acc, hd), tl) end in

# Reduce a list from the right. #
let fold_right: ((Int, Int) -> Int, [Int], Int) -> Int =
  fun f, xs, acc ->
    case xs
    | [] => acc
    | hd::tl => f(hd, fold_right(f, tl, acc)) end in


666
LSP: Prelude: String parsed successfully
LSP: Prelude: Info map generated successfully
Debug: true, Constrain: Types
LSP: Init: Recieved string: # Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)







































































































LSP: Init: String parsed successfully
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: >( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {go: ((?, ?) -> [?]), filter: (((Int -> Bool), [Int]) -> [Int]), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: 
  LSP: Info: ALL errors:Error in term:
  p
Nature of error: Variable p is not bound    
Error in term:
  p
Nature of error: type ((Int -> Bool), [Int]) is not consistent with arrow type    
Error in term:
  p
Nature of error: Variable p is not bound
  LSP: Info: BidiCtx: Cls: Let expression
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent: Root
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: [?]
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: :: @
  LSP: Concave: Backpack: 
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new_tokens ::= whitespace | "," | "::" | "@"
root ::= new_tokens

Top 20 Logits:

:18.7819
#:15.3839
##:14.5084
let:14.2982
 :13.0687
in:12.5726
    :12.5642
   :12.5035
  :12.48
################:12.4512
####:12.0941
```:12.0673
/*:11.928
//:11.3118
                :11.3115
(:11.2731
        :11.2424
end:11.1668
       :11.1503
########:11.1106
[:11.0861

================
# Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)









































































































LSP: Prelude: Recieved string: ### List ###

# Add an element to the front of a list. #
let cons: (Int, [Int]) -> [Int] = fun x, xs -> x::xs in

# Determine the length of a list. #
let length: [Int] -> Int =
  fun xs ->
    case xs
    | [] => 0
    | _::xs => 1 + length(xs) end in

# Extract the first element of a list. #
let hd: [Int] -> Option =
  fun l ->
    case l
    | [] => None
    | x::xs => Some(x) end in

# Extract the rest of the list. #
let tl: [Int] -> [Int] =
  fun l ->
    case l
    | [] => []
    | x::xs => xs end in

# Determine if a list is empty. #
let is_empty: [Int] -> Bool =
  fun xs ->
    case xs
    | [] => true
    | _::_ => false end in

# Return the element at the index. #
let nth: ([Int], Int) -> Option =
  fun xs, n ->
    case xs, n
    | x::_, 0 => Some(x)
    | _::xs, n => nth(xs, n - 1)
    | [], _ => None end in

# Reverse a List. #
let rev: [Int] -> [Int] =
fun l -> 
let go: ([Int], [Int]) -> [Int] =
  fun xs, acc -> 
    case xs 
    | [] => acc 
    | x::xs => go(xs, x::acc) end in
go(l, []) in

# Check if two lists are equal #
let equal: ([Int], [Int]) -> Bool =
    fun p, xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => x == y && equal(xs, ys)
    | _ => false end
in

# Initialize a list with a given length using an initializer function #
let init: (Int, Int -> Int) -> [Int] =
    fun len, f ->
        let go: (Int, [Int]) -> [Int] =
        fun idx, xs ->
            if idx < len 
            then go(idx + 1, xs @ [f(idx)])   
            else xs
        in
        go(0, [])
in

# Reduce a list from the left. #
let fold_left: ((Int, Int) -> Int, Int, [Int]) -> Int =
  fun f, acc, xs ->
    case xs 
    | [] => acc
    | hd::tl => fold_left(f, f(acc, hd), tl) end in

# Reduce a list from the right. #
let fold_right: ((Int, Int) -> Int, [Int], Int) -> Int =
  fun f, xs, acc ->
    case xs
    | [] => acc
    | hd::tl => f(hd, fold_right(f, tl, acc)) end in


666
LSP: Prelude: String parsed successfully
LSP: Prelude: Info map generated successfully
Debug: true, Constrain: Types
LSP: Init: Recieved string: # Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)








































































































LSP: Init: String parsed successfully
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: >( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {go: ((?, ?) -> [?]), filter: (((Int -> Bool), [Int]) -> [Int]), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: 
  LSP: Info: ALL errors:Error in term:
  p
Nature of error: Variable p is not bound    
Error in term:
  p
Nature of error: Variable p is not bound    
Error in term:
  p
Nature of error: type ((Int -> Bool), [Int]) is not consistent with arrow type
  LSP: Info: BidiCtx: Cls: Let expression
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent: Root
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: [?]
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: :: @
  LSP: Concave: Backpack: 
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new_tokens ::= whitespace | "," | "::" | "@"
root ::= new_tokens

Top 20 Logits:

:18.798
#:15.3757
##:14.5299
let:14.2998
 :13.0786
    :12.5734
in:12.5504
   :12.5102
  :12.496
################:12.4668
####:12.1124
```:12.0793
/*:11.9278
                :11.3213
//:11.313
(:11.2849
        :11.2525
end:11.165
       :11.1598
########:11.1307
[:11.0957

================
# Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)










































































































LSP: Prelude: Recieved string: ### List ###

# Add an element to the front of a list. #
let cons: (Int, [Int]) -> [Int] = fun x, xs -> x::xs in

# Determine the length of a list. #
let length: [Int] -> Int =
  fun xs ->
    case xs
    | [] => 0
    | _::xs => 1 + length(xs) end in

# Extract the first element of a list. #
let hd: [Int] -> Option =
  fun l ->
    case l
    | [] => None
    | x::xs => Some(x) end in

# Extract the rest of the list. #
let tl: [Int] -> [Int] =
  fun l ->
    case l
    | [] => []
    | x::xs => xs end in

# Determine if a list is empty. #
let is_empty: [Int] -> Bool =
  fun xs ->
    case xs
    | [] => true
    | _::_ => false end in

# Return the element at the index. #
let nth: ([Int], Int) -> Option =
  fun xs, n ->
    case xs, n
    | x::_, 0 => Some(x)
    | _::xs, n => nth(xs, n - 1)
    | [], _ => None end in

# Reverse a List. #
let rev: [Int] -> [Int] =
fun l -> 
let go: ([Int], [Int]) -> [Int] =
  fun xs, acc -> 
    case xs 
    | [] => acc 
    | x::xs => go(xs, x::acc) end in
go(l, []) in

# Check if two lists are equal #
let equal: ([Int], [Int]) -> Bool =
    fun p, xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => x == y && equal(xs, ys)
    | _ => false end
in

# Initialize a list with a given length using an initializer function #
let init: (Int, Int -> Int) -> [Int] =
    fun len, f ->
        let go: (Int, [Int]) -> [Int] =
        fun idx, xs ->
            if idx < len 
            then go(idx + 1, xs @ [f(idx)])   
            else xs
        in
        go(0, [])
in

# Reduce a list from the left. #
let fold_left: ((Int, Int) -> Int, Int, [Int]) -> Int =
  fun f, acc, xs ->
    case xs 
    | [] => acc
    | hd::tl => fold_left(f, f(acc, hd), tl) end in

# Reduce a list from the right. #
let fold_right: ((Int, Int) -> Int, [Int], Int) -> Int =
  fun f, xs, acc ->
    case xs
    | [] => acc
    | hd::tl => f(hd, fold_right(f, tl, acc)) end in


666
LSP: Prelude: String parsed successfully
LSP: Prelude: Info map generated successfully
Debug: true, Constrain: Types
LSP: Init: Recieved string: # Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)









































































































LSP: Init: String parsed successfully
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: >( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {go: ((?, ?) -> [?]), filter: (((Int -> Bool), [Int]) -> [Int]), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: 
  LSP: Info: ALL errors:Error in term:
  p
Nature of error: type ((Int -> Bool), [Int]) is not consistent with arrow type    
Error in term:
  p
Nature of error: Variable p is not bound    
Error in term:
  p
Nature of error: Variable p is not bound
  LSP: Info: BidiCtx: Cls: Let expression
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent: Root
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: [?]
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: :: @
  LSP: Concave: Backpack: 
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new_tokens ::= whitespace | "," | "::" | "@"
root ::= new_tokens

Top 20 Logits:

:18.8134
#:15.3692
##:14.5405
let:14.3064
 :13.0827
    :12.575
in:12.5614
   :12.5083
  :12.5071
################:12.4746
####:12.1243
```:12.0912
/*:11.9289
                :11.3295
//:11.3154
(:11.2961
        :11.2578
end:11.1644
       :11.1633
########:11.1388
[:11.1024

================
# Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)











































































































LSP: Prelude: Recieved string: ### List ###

# Add an element to the front of a list. #
let cons: (Int, [Int]) -> [Int] = fun x, xs -> x::xs in

# Determine the length of a list. #
let length: [Int] -> Int =
  fun xs ->
    case xs
    | [] => 0
    | _::xs => 1 + length(xs) end in

# Extract the first element of a list. #
let hd: [Int] -> Option =
  fun l ->
    case l
    | [] => None
    | x::xs => Some(x) end in

# Extract the rest of the list. #
let tl: [Int] -> [Int] =
  fun l ->
    case l
    | [] => []
    | x::xs => xs end in

# Determine if a list is empty. #
let is_empty: [Int] -> Bool =
  fun xs ->
    case xs
    | [] => true
    | _::_ => false end in

# Return the element at the index. #
let nth: ([Int], Int) -> Option =
  fun xs, n ->
    case xs, n
    | x::_, 0 => Some(x)
    | _::xs, n => nth(xs, n - 1)
    | [], _ => None end in

# Reverse a List. #
let rev: [Int] -> [Int] =
fun l -> 
let go: ([Int], [Int]) -> [Int] =
  fun xs, acc -> 
    case xs 
    | [] => acc 
    | x::xs => go(xs, x::acc) end in
go(l, []) in

# Check if two lists are equal #
let equal: ([Int], [Int]) -> Bool =
    fun p, xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => x == y && equal(xs, ys)
    | _ => false end
in

# Initialize a list with a given length using an initializer function #
let init: (Int, Int -> Int) -> [Int] =
    fun len, f ->
        let go: (Int, [Int]) -> [Int] =
        fun idx, xs ->
            if idx < len 
            then go(idx + 1, xs @ [f(idx)])   
            else xs
        in
        go(0, [])
in

# Reduce a list from the left. #
let fold_left: ((Int, Int) -> Int, Int, [Int]) -> Int =
  fun f, acc, xs ->
    case xs 
    | [] => acc
    | hd::tl => fold_left(f, f(acc, hd), tl) end in

# Reduce a list from the right. #
let fold_right: ((Int, Int) -> Int, [Int], Int) -> Int =
  fun f, xs, acc ->
    case xs
    | [] => acc
    | hd::tl => f(hd, fold_right(f, tl, acc)) end in


666
LSP: Prelude: String parsed successfully
LSP: Prelude: Info map generated successfully
Debug: true, Constrain: Types
LSP: Init: Recieved string: # Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)










































































































LSP: Init: String parsed successfully
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: >( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {go: ((?, ?) -> [?]), filter: (((Int -> Bool), [Int]) -> [Int]), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: 
  LSP: Info: ALL errors:Error in term:
  p
Nature of error: Variable p is not bound    
Error in term:
  p
Nature of error: type ((Int -> Bool), [Int]) is not consistent with arrow type    
Error in term:
  p
Nature of error: Variable p is not bound
  LSP: Info: BidiCtx: Cls: Let expression
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent: Root
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: [?]
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: :: @
  LSP: Concave: Backpack: 
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new_tokens ::= whitespace | "," | "::" | "@"
root ::= new_tokens

Top 20 Logits:

:18.8256
#:15.3629
##:14.534
let:14.3135
 :13.0787
in:12.6071
    :12.5714
  :12.5083
   :12.498
################:12.4719
####:12.1234
```:12.0945
/*:11.9311
                :11.3344
//:11.3181
(:11.2981
        :11.2578
end:11.1725
       :11.1595
########:11.1301
[:11.103

================
# Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)












































































































LSP: Prelude: Recieved string: ### List ###

# Add an element to the front of a list. #
let cons: (Int, [Int]) -> [Int] = fun x, xs -> x::xs in

# Determine the length of a list. #
let length: [Int] -> Int =
  fun xs ->
    case xs
    | [] => 0
    | _::xs => 1 + length(xs) end in

# Extract the first element of a list. #
let hd: [Int] -> Option =
  fun l ->
    case l
    | [] => None
    | x::xs => Some(x) end in

# Extract the rest of the list. #
let tl: [Int] -> [Int] =
  fun l ->
    case l
    | [] => []
    | x::xs => xs end in

# Determine if a list is empty. #
let is_empty: [Int] -> Bool =
  fun xs ->
    case xs
    | [] => true
    | _::_ => false end in

# Return the element at the index. #
let nth: ([Int], Int) -> Option =
  fun xs, n ->
    case xs, n
    | x::_, 0 => Some(x)
    | _::xs, n => nth(xs, n - 1)
    | [], _ => None end in

# Reverse a List. #
let rev: [Int] -> [Int] =
fun l -> 
let go: ([Int], [Int]) -> [Int] =
  fun xs, acc -> 
    case xs 
    | [] => acc 
    | x::xs => go(xs, x::acc) end in
go(l, []) in

# Check if two lists are equal #
let equal: ([Int], [Int]) -> Bool =
    fun p, xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => x == y && equal(xs, ys)
    | _ => false end
in

# Initialize a list with a given length using an initializer function #
let init: (Int, Int -> Int) -> [Int] =
    fun len, f ->
        let go: (Int, [Int]) -> [Int] =
        fun idx, xs ->
            if idx < len 
            then go(idx + 1, xs @ [f(idx)])   
            else xs
        in
        go(0, [])
in

# Reduce a list from the left. #
let fold_left: ((Int, Int) -> Int, Int, [Int]) -> Int =
  fun f, acc, xs ->
    case xs 
    | [] => acc
    | hd::tl => fold_left(f, f(acc, hd), tl) end in

# Reduce a list from the right. #
let fold_right: ((Int, Int) -> Int, [Int], Int) -> Int =
  fun f, xs, acc ->
    case xs
    | [] => acc
    | hd::tl => f(hd, fold_right(f, tl, acc)) end in


666
LSP: Prelude: String parsed successfully
LSP: Prelude: Info map generated successfully
Debug: true, Constrain: Types
LSP: Init: Recieved string: # Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)











































































































LSP: Init: String parsed successfully
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: >( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {go: ((?, ?) -> [?]), filter: (((Int -> Bool), [Int]) -> [Int]), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: 
  LSP: Info: ALL errors:Error in term:
  p
Nature of error: Variable p is not bound    
Error in term:
  p
Nature of error: Variable p is not bound    
Error in term:
  p
Nature of error: type ((Int -> Bool), [Int]) is not consistent with arrow type
  LSP: Info: BidiCtx: Cls: Let expression
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent: Root
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: [?]
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: :: @
  LSP: Concave: Backpack: 
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new_tokens ::= whitespace | "," | "::" | "@"
root ::= new_tokens

Top 20 Logits:

:18.8342
#:15.3551
##:14.515
let:14.3177
 :13.0707
in:12.664
    :12.5697
  :12.5015
   :12.486
################:12.4628
####:12.112
```:12.0851
/*:11.9355
                :11.3344
//:11.3221
(:11.2872
        :11.2556
end:11.1918
       :11.1513
########:11.1103
[:11.0973

================
# Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)













































































































LSP: Prelude: Recieved string: ### List ###

# Add an element to the front of a list. #
let cons: (Int, [Int]) -> [Int] = fun x, xs -> x::xs in

# Determine the length of a list. #
let length: [Int] -> Int =
  fun xs ->
    case xs
    | [] => 0
    | _::xs => 1 + length(xs) end in

# Extract the first element of a list. #
let hd: [Int] -> Option =
  fun l ->
    case l
    | [] => None
    | x::xs => Some(x) end in

# Extract the rest of the list. #
let tl: [Int] -> [Int] =
  fun l ->
    case l
    | [] => []
    | x::xs => xs end in

# Determine if a list is empty. #
let is_empty: [Int] -> Bool =
  fun xs ->
    case xs
    | [] => true
    | _::_ => false end in

# Return the element at the index. #
let nth: ([Int], Int) -> Option =
  fun xs, n ->
    case xs, n
    | x::_, 0 => Some(x)
    | _::xs, n => nth(xs, n - 1)
    | [], _ => None end in

# Reverse a List. #
let rev: [Int] -> [Int] =
fun l -> 
let go: ([Int], [Int]) -> [Int] =
  fun xs, acc -> 
    case xs 
    | [] => acc 
    | x::xs => go(xs, x::acc) end in
go(l, []) in

# Check if two lists are equal #
let equal: ([Int], [Int]) -> Bool =
    fun p, xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => x == y && equal(xs, ys)
    | _ => false end
in

# Initialize a list with a given length using an initializer function #
let init: (Int, Int -> Int) -> [Int] =
    fun len, f ->
        let go: (Int, [Int]) -> [Int] =
        fun idx, xs ->
            if idx < len 
            then go(idx + 1, xs @ [f(idx)])   
            else xs
        in
        go(0, [])
in

# Reduce a list from the left. #
let fold_left: ((Int, Int) -> Int, Int, [Int]) -> Int =
  fun f, acc, xs ->
    case xs 
    | [] => acc
    | hd::tl => fold_left(f, f(acc, hd), tl) end in

# Reduce a list from the right. #
let fold_right: ((Int, Int) -> Int, [Int], Int) -> Int =
  fun f, xs, acc ->
    case xs
    | [] => acc
    | hd::tl => f(hd, fold_right(f, tl, acc)) end in


666
LSP: Prelude: String parsed successfully
LSP: Prelude: Info map generated successfully
Debug: true, Constrain: Types
LSP: Init: Recieved string: # Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)












































































































LSP: Init: String parsed successfully
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: >( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {go: ((?, ?) -> [?]), filter: (((Int -> Bool), [Int]) -> [Int]), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: 
  LSP: Info: ALL errors:Error in term:
  p
Nature of error: Variable p is not bound    
Error in term:
  p
Nature of error: type ((Int -> Bool), [Int]) is not consistent with arrow type    
Error in term:
  p
Nature of error: Variable p is not bound
  LSP: Info: BidiCtx: Cls: Let expression
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent: Root
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: [?]
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: :: @
  LSP: Concave: Backpack: 
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new_tokens ::= whitespace | "," | "::" | "@"
root ::= new_tokens

Top 20 Logits:

:18.8428
#:15.3491
##:14.4982
let:14.3207
 :13.0673
in:12.6998
    :12.5777
  :12.4953
   :12.4837
################:12.4559
####:12.0998
```:12.0683
/*:11.9435
                :11.3324
//:11.3311
(:11.2698
        :11.2559
end:11.2201
       :11.1465
########:11.0927
[:11.0921

================
# Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)














































































































LSP: Prelude: Recieved string: ### List ###

# Add an element to the front of a list. #
let cons: (Int, [Int]) -> [Int] = fun x, xs -> x::xs in

# Determine the length of a list. #
let length: [Int] -> Int =
  fun xs ->
    case xs
    | [] => 0
    | _::xs => 1 + length(xs) end in

# Extract the first element of a list. #
let hd: [Int] -> Option =
  fun l ->
    case l
    | [] => None
    | x::xs => Some(x) end in

# Extract the rest of the list. #
let tl: [Int] -> [Int] =
  fun l ->
    case l
    | [] => []
    | x::xs => xs end in

# Determine if a list is empty. #
let is_empty: [Int] -> Bool =
  fun xs ->
    case xs
    | [] => true
    | _::_ => false end in

# Return the element at the index. #
let nth: ([Int], Int) -> Option =
  fun xs, n ->
    case xs, n
    | x::_, 0 => Some(x)
    | _::xs, n => nth(xs, n - 1)
    | [], _ => None end in

# Reverse a List. #
let rev: [Int] -> [Int] =
fun l -> 
let go: ([Int], [Int]) -> [Int] =
  fun xs, acc -> 
    case xs 
    | [] => acc 
    | x::xs => go(xs, x::acc) end in
go(l, []) in

# Check if two lists are equal #
let equal: ([Int], [Int]) -> Bool =
    fun p, xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => x == y && equal(xs, ys)
    | _ => false end
in

# Initialize a list with a given length using an initializer function #
let init: (Int, Int -> Int) -> [Int] =
    fun len, f ->
        let go: (Int, [Int]) -> [Int] =
        fun idx, xs ->
            if idx < len 
            then go(idx + 1, xs @ [f(idx)])   
            else xs
        in
        go(0, [])
in

# Reduce a list from the left. #
let fold_left: ((Int, Int) -> Int, Int, [Int]) -> Int =
  fun f, acc, xs ->
    case xs 
    | [] => acc
    | hd::tl => fold_left(f, f(acc, hd), tl) end in

# Reduce a list from the right. #
let fold_right: ((Int, Int) -> Int, [Int], Int) -> Int =
  fun f, xs, acc ->
    case xs
    | [] => acc
    | hd::tl => f(hd, fold_right(f, tl, acc)) end in


666
LSP: Prelude: String parsed successfully
LSP: Prelude: Info map generated successfully
Debug: true, Constrain: Types
LSP: Init: Recieved string: # Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)













































































































LSP: Init: String parsed successfully
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: >( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {go: ((?, ?) -> [?]), filter: (((Int -> Bool), [Int]) -> [Int]), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: 
  LSP: Info: ALL errors:Error in term:
  p
Nature of error: Variable p is not bound    
Error in term:
  p
Nature of error: type ((Int -> Bool), [Int]) is not consistent with arrow type    
Error in term:
  p
Nature of error: Variable p is not bound
  LSP: Info: BidiCtx: Cls: Let expression
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent: Root
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: [?]
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: :: @
  LSP: Concave: Backpack: 
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new_tokens ::= whitespace | "," | "::" | "@"
root ::= new_tokens

Top 20 Logits:

:18.8557
#:15.3496
##:14.495
let:14.324
 :13.0721
in:12.7051
    :12.5947
  :12.4955
   :12.4939
################:12.4567
####:12.0963
```:12.055
/*:11.954
//:11.3472
                :11.3325
        :11.26
(:11.2566
end:11.2495
       :11.1498
[:11.0936
########:11.0883

================
# Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)















































































































LSP: Prelude: Recieved string: ### List ###

# Add an element to the front of a list. #
let cons: (Int, [Int]) -> [Int] = fun x, xs -> x::xs in

# Determine the length of a list. #
let length: [Int] -> Int =
  fun xs ->
    case xs
    | [] => 0
    | _::xs => 1 + length(xs) end in

# Extract the first element of a list. #
let hd: [Int] -> Option =
  fun l ->
    case l
    | [] => None
    | x::xs => Some(x) end in

# Extract the rest of the list. #
let tl: [Int] -> [Int] =
  fun l ->
    case l
    | [] => []
    | x::xs => xs end in

# Determine if a list is empty. #
let is_empty: [Int] -> Bool =
  fun xs ->
    case xs
    | [] => true
    | _::_ => false end in

# Return the element at the index. #
let nth: ([Int], Int) -> Option =
  fun xs, n ->
    case xs, n
    | x::_, 0 => Some(x)
    | _::xs, n => nth(xs, n - 1)
    | [], _ => None end in

# Reverse a List. #
let rev: [Int] -> [Int] =
fun l -> 
let go: ([Int], [Int]) -> [Int] =
  fun xs, acc -> 
    case xs 
    | [] => acc 
    | x::xs => go(xs, x::acc) end in
go(l, []) in

# Check if two lists are equal #
let equal: ([Int], [Int]) -> Bool =
    fun p, xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => x == y && equal(xs, ys)
    | _ => false end
in

# Initialize a list with a given length using an initializer function #
let init: (Int, Int -> Int) -> [Int] =
    fun len, f ->
        let go: (Int, [Int]) -> [Int] =
        fun idx, xs ->
            if idx < len 
            then go(idx + 1, xs @ [f(idx)])   
            else xs
        in
        go(0, [])
in

# Reduce a list from the left. #
let fold_left: ((Int, Int) -> Int, Int, [Int]) -> Int =
  fun f, acc, xs ->
    case xs 
    | [] => acc
    | hd::tl => fold_left(f, f(acc, hd), tl) end in

# Reduce a list from the right. #
let fold_right: ((Int, Int) -> Int, [Int], Int) -> Int =
  fun f, xs, acc ->
    case xs
    | [] => acc
    | hd::tl => f(hd, fold_right(f, tl, acc)) end in


666
LSP: Prelude: String parsed successfully
LSP: Prelude: Info map generated successfully
Debug: true, Constrain: Types
LSP: Init: Recieved string: # Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)














































































































LSP: Init: String parsed successfully
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: >( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {go: ((?, ?) -> [?]), filter: (((Int -> Bool), [Int]) -> [Int]), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: 
  LSP: Info: ALL errors:Error in term:
  p
Nature of error: Variable p is not bound    
Error in term:
  p
Nature of error: Variable p is not bound    
Error in term:
  p
Nature of error: type ((Int -> Bool), [Int]) is not consistent with arrow type
  LSP: Info: BidiCtx: Cls: Let expression
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent: Root
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: [?]
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: :: @
  LSP: Concave: Backpack: 
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new_tokens ::= whitespace | "," | "::" | "@"
root ::= new_tokens

Top 20 Logits:

:18.8727
#:15.3558
##:14.5009
let:14.3278
 :13.0815
in:12.6992
    :12.6105
   :12.5091
  :12.5007
################:12.4611
####:12.1012
```:12.0526
/*:11.9648
//:11.3673
                :11.3339
end:11.2721
        :11.265
(:11.2497
       :11.1586
[:11.1017
########:11.0925

================
# Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)
















































































































LSP: Prelude: Recieved string: ### List ###

# Add an element to the front of a list. #
let cons: (Int, [Int]) -> [Int] = fun x, xs -> x::xs in

# Determine the length of a list. #
let length: [Int] -> Int =
  fun xs ->
    case xs
    | [] => 0
    | _::xs => 1 + length(xs) end in

# Extract the first element of a list. #
let hd: [Int] -> Option =
  fun l ->
    case l
    | [] => None
    | x::xs => Some(x) end in

# Extract the rest of the list. #
let tl: [Int] -> [Int] =
  fun l ->
    case l
    | [] => []
    | x::xs => xs end in

# Determine if a list is empty. #
let is_empty: [Int] -> Bool =
  fun xs ->
    case xs
    | [] => true
    | _::_ => false end in

# Return the element at the index. #
let nth: ([Int], Int) -> Option =
  fun xs, n ->
    case xs, n
    | x::_, 0 => Some(x)
    | _::xs, n => nth(xs, n - 1)
    | [], _ => None end in

# Reverse a List. #
let rev: [Int] -> [Int] =
fun l -> 
let go: ([Int], [Int]) -> [Int] =
  fun xs, acc -> 
    case xs 
    | [] => acc 
    | x::xs => go(xs, x::acc) end in
go(l, []) in

# Check if two lists are equal #
let equal: ([Int], [Int]) -> Bool =
    fun p, xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => x == y && equal(xs, ys)
    | _ => false end
in

# Initialize a list with a given length using an initializer function #
let init: (Int, Int -> Int) -> [Int] =
    fun len, f ->
        let go: (Int, [Int]) -> [Int] =
        fun idx, xs ->
            if idx < len 
            then go(idx + 1, xs @ [f(idx)])   
            else xs
        in
        go(0, [])
in

# Reduce a list from the left. #
let fold_left: ((Int, Int) -> Int, Int, [Int]) -> Int =
  fun f, acc, xs ->
    case xs 
    | [] => acc
    | hd::tl => fold_left(f, f(acc, hd), tl) end in

# Reduce a list from the right. #
let fold_right: ((Int, Int) -> Int, [Int], Int) -> Int =
  fun f, xs, acc ->
    case xs
    | [] => acc
    | hd::tl => f(hd, fold_right(f, tl, acc)) end in


666
LSP: Prelude: String parsed successfully
LSP: Prelude: Info map generated successfully
Debug: true, Constrain: Types
LSP: Init: Recieved string: # Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)















































































































LSP: Init: String parsed successfully
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: >( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {go: ((?, ?) -> [?]), filter: (((Int -> Bool), [Int]) -> [Int]), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: 
  LSP: Info: ALL errors:Error in term:
  p
Nature of error: Variable p is not bound    
Error in term:
  p
Nature of error: Variable p is not bound    
Error in term:
  p
Nature of error: type ((Int -> Bool), [Int]) is not consistent with arrow type
  LSP: Info: BidiCtx: Cls: Let expression
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent: Root
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: [?]
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: :: @
  LSP: Concave: Backpack: 
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new_tokens ::= whitespace | "," | "::" | "@"
root ::= new_tokens

Top 20 Logits:

:18.8911
#:15.3639
##:14.5009
let:14.3331
 :13.0888
in:12.7163
    :12.617
   :12.5194
  :12.5065
################:12.4618
####:12.1056
```:12.0575
/*:11.9736
//:11.3862
                :11.3354
end:11.2869
        :11.2677
(:11.2451
       :11.1664
[:11.1102
########:11.0916

================
# Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)

















































































































LSP: Prelude: Recieved string: ### List ###

# Add an element to the front of a list. #
let cons: (Int, [Int]) -> [Int] = fun x, xs -> x::xs in

# Determine the length of a list. #
let length: [Int] -> Int =
  fun xs ->
    case xs
    | [] => 0
    | _::xs => 1 + length(xs) end in

# Extract the first element of a list. #
let hd: [Int] -> Option =
  fun l ->
    case l
    | [] => None
    | x::xs => Some(x) end in

# Extract the rest of the list. #
let tl: [Int] -> [Int] =
  fun l ->
    case l
    | [] => []
    | x::xs => xs end in

# Determine if a list is empty. #
let is_empty: [Int] -> Bool =
  fun xs ->
    case xs
    | [] => true
    | _::_ => false end in

# Return the element at the index. #
let nth: ([Int], Int) -> Option =
  fun xs, n ->
    case xs, n
    | x::_, 0 => Some(x)
    | _::xs, n => nth(xs, n - 1)
    | [], _ => None end in

# Reverse a List. #
let rev: [Int] -> [Int] =
fun l -> 
let go: ([Int], [Int]) -> [Int] =
  fun xs, acc -> 
    case xs 
    | [] => acc 
    | x::xs => go(xs, x::acc) end in
go(l, []) in

# Check if two lists are equal #
let equal: ([Int], [Int]) -> Bool =
    fun p, xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => x == y && equal(xs, ys)
    | _ => false end
in

# Initialize a list with a given length using an initializer function #
let init: (Int, Int -> Int) -> [Int] =
    fun len, f ->
        let go: (Int, [Int]) -> [Int] =
        fun idx, xs ->
            if idx < len 
            then go(idx + 1, xs @ [f(idx)])   
            else xs
        in
        go(0, [])
in

# Reduce a list from the left. #
let fold_left: ((Int, Int) -> Int, Int, [Int]) -> Int =
  fun f, acc, xs ->
    case xs 
    | [] => acc
    | hd::tl => fold_left(f, f(acc, hd), tl) end in

# Reduce a list from the right. #
let fold_right: ((Int, Int) -> Int, [Int], Int) -> Int =
  fun f, xs, acc ->
    case xs
    | [] => acc
    | hd::tl => f(hd, fold_right(f, tl, acc)) end in


666
LSP: Prelude: String parsed successfully
LSP: Prelude: Info map generated successfully
Debug: true, Constrain: Types
LSP: Init: Recieved string: # Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)
















































































































LSP: Init: String parsed successfully
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: >( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {go: ((?, ?) -> [?]), filter: (((Int -> Bool), [Int]) -> [Int]), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: 
  LSP: Info: ALL errors:Error in term:
  p
Nature of error: type ((Int -> Bool), [Int]) is not consistent with arrow type    
Error in term:
  p
Nature of error: Variable p is not bound    
Error in term:
  p
Nature of error: Variable p is not bound
  LSP: Info: BidiCtx: Cls: Let expression
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent: Root
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: [?]
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: :: @
  LSP: Concave: Backpack: 
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new_tokens ::= whitespace | "," | "::" | "@"
root ::= new_tokens

Top 20 Logits:

:18.9063
#:15.3667
##:14.4817
let:14.3359
 :13.0883
in:12.7714
    :12.6126
   :12.518
  :12.5078
################:12.4521
####:12.0987
```:12.0607
/*:11.9791
//:11.3999
                :11.3345
end:11.2976
        :11.2642
(:11.2376
       :11.1662
[:11.1106
########:11.0739

================
# Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)


















































































































LSP: Prelude: Recieved string: ### List ###

# Add an element to the front of a list. #
let cons: (Int, [Int]) -> [Int] = fun x, xs -> x::xs in

# Determine the length of a list. #
let length: [Int] -> Int =
  fun xs ->
    case xs
    | [] => 0
    | _::xs => 1 + length(xs) end in

# Extract the first element of a list. #
let hd: [Int] -> Option =
  fun l ->
    case l
    | [] => None
    | x::xs => Some(x) end in

# Extract the rest of the list. #
let tl: [Int] -> [Int] =
  fun l ->
    case l
    | [] => []
    | x::xs => xs end in

# Determine if a list is empty. #
let is_empty: [Int] -> Bool =
  fun xs ->
    case xs
    | [] => true
    | _::_ => false end in

# Return the element at the index. #
let nth: ([Int], Int) -> Option =
  fun xs, n ->
    case xs, n
    | x::_, 0 => Some(x)
    | _::xs, n => nth(xs, n - 1)
    | [], _ => None end in

# Reverse a List. #
let rev: [Int] -> [Int] =
fun l -> 
let go: ([Int], [Int]) -> [Int] =
  fun xs, acc -> 
    case xs 
    | [] => acc 
    | x::xs => go(xs, x::acc) end in
go(l, []) in

# Check if two lists are equal #
let equal: ([Int], [Int]) -> Bool =
    fun p, xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => x == y && equal(xs, ys)
    | _ => false end
in

# Initialize a list with a given length using an initializer function #
let init: (Int, Int -> Int) -> [Int] =
    fun len, f ->
        let go: (Int, [Int]) -> [Int] =
        fun idx, xs ->
            if idx < len 
            then go(idx + 1, xs @ [f(idx)])   
            else xs
        in
        go(0, [])
in

# Reduce a list from the left. #
let fold_left: ((Int, Int) -> Int, Int, [Int]) -> Int =
  fun f, acc, xs ->
    case xs 
    | [] => acc
    | hd::tl => fold_left(f, f(acc, hd), tl) end in

# Reduce a list from the right. #
let fold_right: ((Int, Int) -> Int, [Int], Int) -> Int =
  fun f, xs, acc ->
    case xs
    | [] => acc
    | hd::tl => f(hd, fold_right(f, tl, acc)) end in


666
LSP: Prelude: String parsed successfully
LSP: Prelude: Info map generated successfully
Debug: true, Constrain: Types
LSP: Init: Recieved string: # Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)

















































































































LSP: Init: String parsed successfully
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: >( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {go: ((?, ?) -> [?]), filter: (((Int -> Bool), [Int]) -> [Int]), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: 
  LSP: Info: ALL errors:Error in term:
  p
Nature of error: type ((Int -> Bool), [Int]) is not consistent with arrow type    
Error in term:
  p
Nature of error: Variable p is not bound    
Error in term:
  p
Nature of error: Variable p is not bound
  LSP: Info: BidiCtx: Cls: Let expression
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent: Root
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: [?]
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: :: @
  LSP: Concave: Backpack: 
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new_tokens ::= whitespace | "," | "::" | "@"
root ::= new_tokens

Top 20 Logits:

:18.9132
#:15.3589
##:14.4436
let:14.3305
 :13.0779
in:12.837
    :12.6018
   :12.5048
  :12.5004
################:12.4304
####:12.0777
```:12.0531
/*:11.9821
//:11.4065
                :11.3268
end:11.3055
        :11.2538
(:11.2235
       :11.1556
[:11.0998
def:11.0668

================
# Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)



















































































































LSP: Prelude: Recieved string: ### List ###

# Add an element to the front of a list. #
let cons: (Int, [Int]) -> [Int] = fun x, xs -> x::xs in

# Determine the length of a list. #
let length: [Int] -> Int =
  fun xs ->
    case xs
    | [] => 0
    | _::xs => 1 + length(xs) end in

# Extract the first element of a list. #
let hd: [Int] -> Option =
  fun l ->
    case l
    | [] => None
    | x::xs => Some(x) end in

# Extract the rest of the list. #
let tl: [Int] -> [Int] =
  fun l ->
    case l
    | [] => []
    | x::xs => xs end in

# Determine if a list is empty. #
let is_empty: [Int] -> Bool =
  fun xs ->
    case xs
    | [] => true
    | _::_ => false end in

# Return the element at the index. #
let nth: ([Int], Int) -> Option =
  fun xs, n ->
    case xs, n
    | x::_, 0 => Some(x)
    | _::xs, n => nth(xs, n - 1)
    | [], _ => None end in

# Reverse a List. #
let rev: [Int] -> [Int] =
fun l -> 
let go: ([Int], [Int]) -> [Int] =
  fun xs, acc -> 
    case xs 
    | [] => acc 
    | x::xs => go(xs, x::acc) end in
go(l, []) in

# Check if two lists are equal #
let equal: ([Int], [Int]) -> Bool =
    fun p, xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => x == y && equal(xs, ys)
    | _ => false end
in

# Initialize a list with a given length using an initializer function #
let init: (Int, Int -> Int) -> [Int] =
    fun len, f ->
        let go: (Int, [Int]) -> [Int] =
        fun idx, xs ->
            if idx < len 
            then go(idx + 1, xs @ [f(idx)])   
            else xs
        in
        go(0, [])
in

# Reduce a list from the left. #
let fold_left: ((Int, Int) -> Int, Int, [Int]) -> Int =
  fun f, acc, xs ->
    case xs 
    | [] => acc
    | hd::tl => fold_left(f, f(acc, hd), tl) end in

# Reduce a list from the right. #
let fold_right: ((Int, Int) -> Int, [Int], Int) -> Int =
  fun f, xs, acc ->
    case xs
    | [] => acc
    | hd::tl => f(hd, fold_right(f, tl, acc)) end in


666
LSP: Prelude: String parsed successfully
LSP: Prelude: Info map generated successfully
Debug: true, Constrain: Types
LSP: Init: Recieved string: # Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)


















































































































LSP: Init: String parsed successfully
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: >( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {go: ((?, ?) -> [?]), filter: (((Int -> Bool), [Int]) -> [Int]), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: 
  LSP: Info: ALL errors:Error in term:
  p
Nature of error: Variable p is not bound    
Error in term:
  p
Nature of error: type ((Int -> Bool), [Int]) is not consistent with arrow type    
Error in term:
  p
Nature of error: Variable p is not bound
  LSP: Info: BidiCtx: Cls: Let expression
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent: Root
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: [?]
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: :: @
  LSP: Concave: Backpack: 
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new_tokens ::= whitespace | "," | "::" | "@"
root ::= new_tokens

Top 20 Logits:

:18.9138
#:15.3447
##:14.4055
let:14.3192
 :13.0638
in:12.8644
    :12.5939
   :12.4877
  :12.4874
################:12.4067
####:12.0528
```:12.0327
/*:11.9855
//:11.4091
                :11.3137
end:11.3066
        :11.2425
(:11.2059
       :11.1404
[:11.0845
def:11.0654

================
# Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)




















































































































LSP: Prelude: Recieved string: ### List ###

# Add an element to the front of a list. #
let cons: (Int, [Int]) -> [Int] = fun x, xs -> x::xs in

# Determine the length of a list. #
let length: [Int] -> Int =
  fun xs ->
    case xs
    | [] => 0
    | _::xs => 1 + length(xs) end in

# Extract the first element of a list. #
let hd: [Int] -> Option =
  fun l ->
    case l
    | [] => None
    | x::xs => Some(x) end in

# Extract the rest of the list. #
let tl: [Int] -> [Int] =
  fun l ->
    case l
    | [] => []
    | x::xs => xs end in

# Determine if a list is empty. #
let is_empty: [Int] -> Bool =
  fun xs ->
    case xs
    | [] => true
    | _::_ => false end in

# Return the element at the index. #
let nth: ([Int], Int) -> Option =
  fun xs, n ->
    case xs, n
    | x::_, 0 => Some(x)
    | _::xs, n => nth(xs, n - 1)
    | [], _ => None end in

# Reverse a List. #
let rev: [Int] -> [Int] =
fun l -> 
let go: ([Int], [Int]) -> [Int] =
  fun xs, acc -> 
    case xs 
    | [] => acc 
    | x::xs => go(xs, x::acc) end in
go(l, []) in

# Check if two lists are equal #
let equal: ([Int], [Int]) -> Bool =
    fun p, xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => x == y && equal(xs, ys)
    | _ => false end
in

# Initialize a list with a given length using an initializer function #
let init: (Int, Int -> Int) -> [Int] =
    fun len, f ->
        let go: (Int, [Int]) -> [Int] =
        fun idx, xs ->
            if idx < len 
            then go(idx + 1, xs @ [f(idx)])   
            else xs
        in
        go(0, [])
in

# Reduce a list from the left. #
let fold_left: ((Int, Int) -> Int, Int, [Int]) -> Int =
  fun f, acc, xs ->
    case xs 
    | [] => acc
    | hd::tl => fold_left(f, f(acc, hd), tl) end in

# Reduce a list from the right. #
let fold_right: ((Int, Int) -> Int, [Int], Int) -> Int =
  fun f, xs, acc ->
    case xs
    | [] => acc
    | hd::tl => f(hd, fold_right(f, tl, acc)) end in


666
LSP: Prelude: String parsed successfully
LSP: Prelude: Info map generated successfully
Debug: true, Constrain: Types
LSP: Init: Recieved string: # Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)



















































































































LSP: Init: String parsed successfully
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: >( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {go: ((?, ?) -> [?]), filter: (((Int -> Bool), [Int]) -> [Int]), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: 
  LSP: Info: ALL errors:Error in term:
  p
Nature of error: type ((Int -> Bool), [Int]) is not consistent with arrow type    
Error in term:
  p
Nature of error: Variable p is not bound    
Error in term:
  p
Nature of error: Variable p is not bound
  LSP: Info: BidiCtx: Cls: Let expression
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent: Root
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: [?]
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: :: @
  LSP: Concave: Backpack: 
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new_tokens ::= whitespace | "," | "::" | "@"
root ::= new_tokens

Top 20 Logits:

:18.9172
#:15.3323
##:14.3916
let:14.3094
 :13.0554
in:12.8324
    :12.593
  :12.4775
   :12.4748
################:12.3963
####:12.0411
```:12.0123
/*:11.9892
//:11.413
                :11.3047
end:11.2998
        :11.2364
(:11.1915
       :11.13
[:11.0759
def:11.0667

================
# Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)





















































































































LSP: Prelude: Recieved string: ### List ###

# Add an element to the front of a list. #
let cons: (Int, [Int]) -> [Int] = fun x, xs -> x::xs in

# Determine the length of a list. #
let length: [Int] -> Int =
  fun xs ->
    case xs
    | [] => 0
    | _::xs => 1 + length(xs) end in

# Extract the first element of a list. #
let hd: [Int] -> Option =
  fun l ->
    case l
    | [] => None
    | x::xs => Some(x) end in

# Extract the rest of the list. #
let tl: [Int] -> [Int] =
  fun l ->
    case l
    | [] => []
    | x::xs => xs end in

# Determine if a list is empty. #
let is_empty: [Int] -> Bool =
  fun xs ->
    case xs
    | [] => true
    | _::_ => false end in

# Return the element at the index. #
let nth: ([Int], Int) -> Option =
  fun xs, n ->
    case xs, n
    | x::_, 0 => Some(x)
    | _::xs, n => nth(xs, n - 1)
    | [], _ => None end in

# Reverse a List. #
let rev: [Int] -> [Int] =
fun l -> 
let go: ([Int], [Int]) -> [Int] =
  fun xs, acc -> 
    case xs 
    | [] => acc 
    | x::xs => go(xs, x::acc) end in
go(l, []) in

# Check if two lists are equal #
let equal: ([Int], [Int]) -> Bool =
    fun p, xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => x == y && equal(xs, ys)
    | _ => false end
in

# Initialize a list with a given length using an initializer function #
let init: (Int, Int -> Int) -> [Int] =
    fun len, f ->
        let go: (Int, [Int]) -> [Int] =
        fun idx, xs ->
            if idx < len 
            then go(idx + 1, xs @ [f(idx)])   
            else xs
        in
        go(0, [])
in

# Reduce a list from the left. #
let fold_left: ((Int, Int) -> Int, Int, [Int]) -> Int =
  fun f, acc, xs ->
    case xs 
    | [] => acc
    | hd::tl => fold_left(f, f(acc, hd), tl) end in

# Reduce a list from the right. #
let fold_right: ((Int, Int) -> Int, [Int], Int) -> Int =
  fun f, xs, acc ->
    case xs
    | [] => acc
    | hd::tl => f(hd, fold_right(f, tl, acc)) end in


666
LSP: Prelude: String parsed successfully
LSP: Prelude: Info map generated successfully
Debug: true, Constrain: Types
LSP: Init: Recieved string: # Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)




















































































































LSP: Init: String parsed successfully
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: >( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {go: ((?, ?) -> [?]), filter: (((Int -> Bool), [Int]) -> [Int]), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: 
  LSP: Info: ALL errors:Error in term:
  p
Nature of error: Variable p is not bound    
Error in term:
  p
Nature of error: type ((Int -> Bool), [Int]) is not consistent with arrow type    
Error in term:
  p
Nature of error: Variable p is not bound
  LSP: Info: BidiCtx: Cls: Let expression
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent: Root
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: [?]
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: :: @
  LSP: Concave: Backpack: 
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new_tokens ::= whitespace | "," | "::" | "@"
root ::= new_tokens

Top 20 Logits:

:18.9271
#:15.3228
##:14.4069
let:14.3035
 :13.0549
in:12.7613
    :12.5926
  :12.4735
   :12.4673
################:12.4022
####:12.0471
```:12.004
/*:11.9905
//:11.4198
                :11.3036
end:11.2904
        :11.233
(:11.183
       :11.1265
[:11.0774
def:11.0735

================
# Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)






















































































































LSP: Prelude: Recieved string: ### List ###

# Add an element to the front of a list. #
let cons: (Int, [Int]) -> [Int] = fun x, xs -> x::xs in

# Determine the length of a list. #
let length: [Int] -> Int =
  fun xs ->
    case xs
    | [] => 0
    | _::xs => 1 + length(xs) end in

# Extract the first element of a list. #
let hd: [Int] -> Option =
  fun l ->
    case l
    | [] => None
    | x::xs => Some(x) end in

# Extract the rest of the list. #
let tl: [Int] -> [Int] =
  fun l ->
    case l
    | [] => []
    | x::xs => xs end in

# Determine if a list is empty. #
let is_empty: [Int] -> Bool =
  fun xs ->
    case xs
    | [] => true
    | _::_ => false end in

# Return the element at the index. #
let nth: ([Int], Int) -> Option =
  fun xs, n ->
    case xs, n
    | x::_, 0 => Some(x)
    | _::xs, n => nth(xs, n - 1)
    | [], _ => None end in

# Reverse a List. #
let rev: [Int] -> [Int] =
fun l -> 
let go: ([Int], [Int]) -> [Int] =
  fun xs, acc -> 
    case xs 
    | [] => acc 
    | x::xs => go(xs, x::acc) end in
go(l, []) in

# Check if two lists are equal #
let equal: ([Int], [Int]) -> Bool =
    fun p, xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => x == y && equal(xs, ys)
    | _ => false end
in

# Initialize a list with a given length using an initializer function #
let init: (Int, Int -> Int) -> [Int] =
    fun len, f ->
        let go: (Int, [Int]) -> [Int] =
        fun idx, xs ->
            if idx < len 
            then go(idx + 1, xs @ [f(idx)])   
            else xs
        in
        go(0, [])
in

# Reduce a list from the left. #
let fold_left: ((Int, Int) -> Int, Int, [Int]) -> Int =
  fun f, acc, xs ->
    case xs 
    | [] => acc
    | hd::tl => fold_left(f, f(acc, hd), tl) end in

# Reduce a list from the right. #
let fold_right: ((Int, Int) -> Int, [Int], Int) -> Int =
  fun f, xs, acc ->
    case xs
    | [] => acc
    | hd::tl => f(hd, fold_right(f, tl, acc)) end in


666
LSP: Prelude: String parsed successfully
LSP: Prelude: Info map generated successfully
Debug: true, Constrain: Types
LSP: Init: Recieved string: # Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)





















































































































LSP: Init: String parsed successfully
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: >( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {go: ((?, ?) -> [?]), filter: (((Int -> Bool), [Int]) -> [Int]), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: 
  LSP: Info: ALL errors:Error in term:
  p
Nature of error: Variable p is not bound    
Error in term:
  p
Nature of error: Variable p is not bound    
Error in term:
  p
Nature of error: type ((Int -> Bool), [Int]) is not consistent with arrow type
  LSP: Info: BidiCtx: Cls: Let expression
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent: Root
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: [?]
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: :: @
  LSP: Concave: Backpack: 
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new_tokens ::= whitespace | "," | "::" | "@"
root ::= new_tokens

Top 20 Logits:

:18.9408
#:15.3154
##:14.4338
let:14.3003
 :13.0581
in:12.6971
    :12.5863
  :12.4733
   :12.4633
################:12.4136
####:12.06
```:12.0077
/*:11.9868
//:11.424
                :11.3086
end:11.2883
        :11.2294
(:11.1787
       :11.1265
[:11.0859
def:11.0859

================
# Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)























































































































LSP: Prelude: Recieved string: ### List ###

# Add an element to the front of a list. #
let cons: (Int, [Int]) -> [Int] = fun x, xs -> x::xs in

# Determine the length of a list. #
let length: [Int] -> Int =
  fun xs ->
    case xs
    | [] => 0
    | _::xs => 1 + length(xs) end in

# Extract the first element of a list. #
let hd: [Int] -> Option =
  fun l ->
    case l
    | [] => None
    | x::xs => Some(x) end in

# Extract the rest of the list. #
let tl: [Int] -> [Int] =
  fun l ->
    case l
    | [] => []
    | x::xs => xs end in

# Determine if a list is empty. #
let is_empty: [Int] -> Bool =
  fun xs ->
    case xs
    | [] => true
    | _::_ => false end in

# Return the element at the index. #
let nth: ([Int], Int) -> Option =
  fun xs, n ->
    case xs, n
    | x::_, 0 => Some(x)
    | _::xs, n => nth(xs, n - 1)
    | [], _ => None end in

# Reverse a List. #
let rev: [Int] -> [Int] =
fun l -> 
let go: ([Int], [Int]) -> [Int] =
  fun xs, acc -> 
    case xs 
    | [] => acc 
    | x::xs => go(xs, x::acc) end in
go(l, []) in

# Check if two lists are equal #
let equal: ([Int], [Int]) -> Bool =
    fun p, xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => x == y && equal(xs, ys)
    | _ => false end
in

# Initialize a list with a given length using an initializer function #
let init: (Int, Int -> Int) -> [Int] =
    fun len, f ->
        let go: (Int, [Int]) -> [Int] =
        fun idx, xs ->
            if idx < len 
            then go(idx + 1, xs @ [f(idx)])   
            else xs
        in
        go(0, [])
in

# Reduce a list from the left. #
let fold_left: ((Int, Int) -> Int, Int, [Int]) -> Int =
  fun f, acc, xs ->
    case xs 
    | [] => acc
    | hd::tl => fold_left(f, f(acc, hd), tl) end in

# Reduce a list from the right. #
let fold_right: ((Int, Int) -> Int, [Int], Int) -> Int =
  fun f, xs, acc ->
    case xs
    | [] => acc
    | hd::tl => f(hd, fold_right(f, tl, acc)) end in


666
LSP: Prelude: String parsed successfully
LSP: Prelude: Info map generated successfully
Debug: true, Constrain: Types
LSP: Init: Recieved string: # Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)






















































































































LSP: Init: String parsed successfully
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: >( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {go: ((?, ?) -> [?]), filter: (((Int -> Bool), [Int]) -> [Int]), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: 
  LSP: Info: ALL errors:Error in term:
  p
Nature of error: Variable p is not bound    
Error in term:
  p
Nature of error: Variable p is not bound    
Error in term:
  p
Nature of error: type ((Int -> Bool), [Int]) is not consistent with arrow type
  LSP: Info: BidiCtx: Cls: Let expression
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent: Root
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: [?]
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: :: @
  LSP: Concave: Backpack: 
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new_tokens ::= whitespace | "," | "::" | "@"
root ::= new_tokens

Top 20 Logits:

:18.9551
#:15.3106
##:14.4493
let:14.2977
 :13.0608
in:12.6816
    :12.5756
  :12.4764
   :12.4605
################:12.4194
####:12.0662
```:12.0144
/*:11.9785
//:11.4208
                :11.3179
end:11.3037
        :11.2256
(:11.174
       :11.1267
def:11.1005
[:11.0952

================
# Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)
























































































































LSP: Prelude: Recieved string: ### List ###

# Add an element to the front of a list. #
let cons: (Int, [Int]) -> [Int] = fun x, xs -> x::xs in

# Determine the length of a list. #
let length: [Int] -> Int =
  fun xs ->
    case xs
    | [] => 0
    | _::xs => 1 + length(xs) end in

# Extract the first element of a list. #
let hd: [Int] -> Option =
  fun l ->
    case l
    | [] => None
    | x::xs => Some(x) end in

# Extract the rest of the list. #
let tl: [Int] -> [Int] =
  fun l ->
    case l
    | [] => []
    | x::xs => xs end in

# Determine if a list is empty. #
let is_empty: [Int] -> Bool =
  fun xs ->
    case xs
    | [] => true
    | _::_ => false end in

# Return the element at the index. #
let nth: ([Int], Int) -> Option =
  fun xs, n ->
    case xs, n
    | x::_, 0 => Some(x)
    | _::xs, n => nth(xs, n - 1)
    | [], _ => None end in

# Reverse a List. #
let rev: [Int] -> [Int] =
fun l -> 
let go: ([Int], [Int]) -> [Int] =
  fun xs, acc -> 
    case xs 
    | [] => acc 
    | x::xs => go(xs, x::acc) end in
go(l, []) in

# Check if two lists are equal #
let equal: ([Int], [Int]) -> Bool =
    fun p, xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => x == y && equal(xs, ys)
    | _ => false end
in

# Initialize a list with a given length using an initializer function #
let init: (Int, Int -> Int) -> [Int] =
    fun len, f ->
        let go: (Int, [Int]) -> [Int] =
        fun idx, xs ->
            if idx < len 
            then go(idx + 1, xs @ [f(idx)])   
            else xs
        in
        go(0, [])
in

# Reduce a list from the left. #
let fold_left: ((Int, Int) -> Int, Int, [Int]) -> Int =
  fun f, acc, xs ->
    case xs 
    | [] => acc
    | hd::tl => fold_left(f, f(acc, hd), tl) end in

# Reduce a list from the right. #
let fold_right: ((Int, Int) -> Int, [Int], Int) -> Int =
  fun f, xs, acc ->
    case xs
    | [] => acc
    | hd::tl => f(hd, fold_right(f, tl, acc)) end in


666
LSP: Prelude: String parsed successfully
LSP: Prelude: Info map generated successfully
Debug: true, Constrain: Types
LSP: Init: Recieved string: # Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)























































































































LSP: Init: String parsed successfully
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: >( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {go: ((?, ?) -> [?]), filter: (((Int -> Bool), [Int]) -> [Int]), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: 
  LSP: Info: ALL errors:Error in term:
  p
Nature of error: Variable p is not bound    
Error in term:
  p
Nature of error: Variable p is not bound    
Error in term:
  p
Nature of error: type ((Int -> Bool), [Int]) is not consistent with arrow type
  LSP: Info: BidiCtx: Cls: Let expression
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent: Root
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: [?]
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: :: @
  LSP: Concave: Backpack: 
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new_tokens ::= whitespace | "," | "::" | "@"
root ::= new_tokens

Top 20 Logits:

:18.9663
#:15.3046
##:14.4395
let:14.2921
 :13.0606
in:12.7192
    :12.5648
  :12.4791
   :12.4558
################:12.4146
####:12.0587
```:12.0147
/*:11.9689
//:11.413
end:11.3354
                :11.3271
        :11.22
(:11.1651
       :11.1237
def:11.1131
[:11.0979

================
# Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)

























































































































LSP: Prelude: Recieved string: ### List ###

# Add an element to the front of a list. #
let cons: (Int, [Int]) -> [Int] = fun x, xs -> x::xs in

# Determine the length of a list. #
let length: [Int] -> Int =
  fun xs ->
    case xs
    | [] => 0
    | _::xs => 1 + length(xs) end in

# Extract the first element of a list. #
let hd: [Int] -> Option =
  fun l ->
    case l
    | [] => None
    | x::xs => Some(x) end in

# Extract the rest of the list. #
let tl: [Int] -> [Int] =
  fun l ->
    case l
    | [] => []
    | x::xs => xs end in

# Determine if a list is empty. #
let is_empty: [Int] -> Bool =
  fun xs ->
    case xs
    | [] => true
    | _::_ => false end in

# Return the element at the index. #
let nth: ([Int], Int) -> Option =
  fun xs, n ->
    case xs, n
    | x::_, 0 => Some(x)
    | _::xs, n => nth(xs, n - 1)
    | [], _ => None end in

# Reverse a List. #
let rev: [Int] -> [Int] =
fun l -> 
let go: ([Int], [Int]) -> [Int] =
  fun xs, acc -> 
    case xs 
    | [] => acc 
    | x::xs => go(xs, x::acc) end in
go(l, []) in

# Check if two lists are equal #
let equal: ([Int], [Int]) -> Bool =
    fun p, xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => x == y && equal(xs, ys)
    | _ => false end
in

# Initialize a list with a given length using an initializer function #
let init: (Int, Int -> Int) -> [Int] =
    fun len, f ->
        let go: (Int, [Int]) -> [Int] =
        fun idx, xs ->
            if idx < len 
            then go(idx + 1, xs @ [f(idx)])   
            else xs
        in
        go(0, [])
in

# Reduce a list from the left. #
let fold_left: ((Int, Int) -> Int, Int, [Int]) -> Int =
  fun f, acc, xs ->
    case xs 
    | [] => acc
    | hd::tl => fold_left(f, f(acc, hd), tl) end in

# Reduce a list from the right. #
let fold_right: ((Int, Int) -> Int, [Int], Int) -> Int =
  fun f, xs, acc ->
    case xs
    | [] => acc
    | hd::tl => f(hd, fold_right(f, tl, acc)) end in


666
LSP: Prelude: String parsed successfully
LSP: Prelude: Info map generated successfully
Debug: true, Constrain: Types
LSP: Init: Recieved string: # Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)
























































































































LSP: Init: String parsed successfully
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: >( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {go: ((?, ?) -> [?]), filter: (((Int -> Bool), [Int]) -> [Int]), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: 
  LSP: Info: ALL errors:Error in term:
  p
Nature of error: Variable p is not bound    
Error in term:
  p
Nature of error: Variable p is not bound    
Error in term:
  p
Nature of error: type ((Int -> Bool), [Int]) is not consistent with arrow type
  LSP: Info: BidiCtx: Cls: Let expression
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent: Root
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: [?]
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: :: @
  LSP: Concave: Backpack: 
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new_tokens ::= whitespace | "," | "::" | "@"
root ::= new_tokens

Top 20 Logits:

:18.9736
#:15.2956
##:14.4102
let:14.2843
 :13.0595
in:12.7694
    :12.5583
  :12.48
   :12.4514
################:12.4018
####:12.0413
```:12.004
/*:11.9632
//:11.4072
end:11.3685
                :11.3317
        :11.213
(:11.1544
def:11.1209
       :11.117
[:11.0937

================
# Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)


























































































































LSP: Prelude: Recieved string: ### List ###

# Add an element to the front of a list. #
let cons: (Int, [Int]) -> [Int] = fun x, xs -> x::xs in

# Determine the length of a list. #
let length: [Int] -> Int =
  fun xs ->
    case xs
    | [] => 0
    | _::xs => 1 + length(xs) end in

# Extract the first element of a list. #
let hd: [Int] -> Option =
  fun l ->
    case l
    | [] => None
    | x::xs => Some(x) end in

# Extract the rest of the list. #
let tl: [Int] -> [Int] =
  fun l ->
    case l
    | [] => []
    | x::xs => xs end in

# Determine if a list is empty. #
let is_empty: [Int] -> Bool =
  fun xs ->
    case xs
    | [] => true
    | _::_ => false end in

# Return the element at the index. #
let nth: ([Int], Int) -> Option =
  fun xs, n ->
    case xs, n
    | x::_, 0 => Some(x)
    | _::xs, n => nth(xs, n - 1)
    | [], _ => None end in

# Reverse a List. #
let rev: [Int] -> [Int] =
fun l -> 
let go: ([Int], [Int]) -> [Int] =
  fun xs, acc -> 
    case xs 
    | [] => acc 
    | x::xs => go(xs, x::acc) end in
go(l, []) in

# Check if two lists are equal #
let equal: ([Int], [Int]) -> Bool =
    fun p, xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => x == y && equal(xs, ys)
    | _ => false end
in

# Initialize a list with a given length using an initializer function #
let init: (Int, Int -> Int) -> [Int] =
    fun len, f ->
        let go: (Int, [Int]) -> [Int] =
        fun idx, xs ->
            if idx < len 
            then go(idx + 1, xs @ [f(idx)])   
            else xs
        in
        go(0, [])
in

# Reduce a list from the left. #
let fold_left: ((Int, Int) -> Int, Int, [Int]) -> Int =
  fun f, acc, xs ->
    case xs 
    | [] => acc
    | hd::tl => fold_left(f, f(acc, hd), tl) end in

# Reduce a list from the right. #
let fold_right: ((Int, Int) -> Int, [Int], Int) -> Int =
  fun f, xs, acc ->
    case xs
    | [] => acc
    | hd::tl => f(hd, fold_right(f, tl, acc)) end in


666
LSP: Prelude: String parsed successfully
LSP: Prelude: Info map generated successfully
Debug: true, Constrain: Types
LSP: Init: Recieved string: # Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)

























































































































LSP: Init: String parsed successfully
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: >( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {go: ((?, ?) -> [?]), filter: (((Int -> Bool), [Int]) -> [Int]), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: 
  LSP: Info: ALL errors:Error in term:
  p
Nature of error: Variable p is not bound    
Error in term:
  p
Nature of error: type ((Int -> Bool), [Int]) is not consistent with arrow type    
Error in term:
  p
Nature of error: Variable p is not bound
  LSP: Info: BidiCtx: Cls: Let expression
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent: Root
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: [?]
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: :: @
  LSP: Concave: Backpack: 
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new_tokens ::= whitespace | "," | "::" | "@"
root ::= new_tokens

Top 20 Logits:

:18.9815
#:15.2886
##:14.3828
let:14.2804
 :13.0625
in:12.783
    :12.559
  :12.4814
   :12.4509
################:12.3911
####:12.0282
```:11.9883
/*:11.9651
//:11.4077
end:11.3833
                :11.3322
        :11.2083
(:11.151
def:11.1227
       :11.1107
[:11.0899

================
# Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)



























































































































LSP: Prelude: Recieved string: ### List ###

# Add an element to the front of a list. #
let cons: (Int, [Int]) -> [Int] = fun x, xs -> x::xs in

# Determine the length of a list. #
let length: [Int] -> Int =
  fun xs ->
    case xs
    | [] => 0
    | _::xs => 1 + length(xs) end in

# Extract the first element of a list. #
let hd: [Int] -> Option =
  fun l ->
    case l
    | [] => None
    | x::xs => Some(x) end in

# Extract the rest of the list. #
let tl: [Int] -> [Int] =
  fun l ->
    case l
    | [] => []
    | x::xs => xs end in

# Determine if a list is empty. #
let is_empty: [Int] -> Bool =
  fun xs ->
    case xs
    | [] => true
    | _::_ => false end in

# Return the element at the index. #
let nth: ([Int], Int) -> Option =
  fun xs, n ->
    case xs, n
    | x::_, 0 => Some(x)
    | _::xs, n => nth(xs, n - 1)
    | [], _ => None end in

# Reverse a List. #
let rev: [Int] -> [Int] =
fun l -> 
let go: ([Int], [Int]) -> [Int] =
  fun xs, acc -> 
    case xs 
    | [] => acc 
    | x::xs => go(xs, x::acc) end in
go(l, []) in

# Check if two lists are equal #
let equal: ([Int], [Int]) -> Bool =
    fun p, xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => x == y && equal(xs, ys)
    | _ => false end
in

# Initialize a list with a given length using an initializer function #
let init: (Int, Int -> Int) -> [Int] =
    fun len, f ->
        let go: (Int, [Int]) -> [Int] =
        fun idx, xs ->
            if idx < len 
            then go(idx + 1, xs @ [f(idx)])   
            else xs
        in
        go(0, [])
in

# Reduce a list from the left. #
let fold_left: ((Int, Int) -> Int, Int, [Int]) -> Int =
  fun f, acc, xs ->
    case xs 
    | [] => acc
    | hd::tl => fold_left(f, f(acc, hd), tl) end in

# Reduce a list from the right. #
let fold_right: ((Int, Int) -> Int, [Int], Int) -> Int =
  fun f, xs, acc ->
    case xs
    | [] => acc
    | hd::tl => f(hd, fold_right(f, tl, acc)) end in


666
LSP: Prelude: String parsed successfully
LSP: Prelude: Info map generated successfully
Debug: true, Constrain: Types
LSP: Init: Recieved string: # Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)


























































































































LSP: Init: String parsed successfully
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: >( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {go: ((?, ?) -> [?]), filter: (((Int -> Bool), [Int]) -> [Int]), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: 
  LSP: Info: ALL errors:Error in term:
  p
Nature of error: Variable p is not bound    
Error in term:
  p
Nature of error: type ((Int -> Bool), [Int]) is not consistent with arrow type    
Error in term:
  p
Nature of error: Variable p is not bound
  LSP: Info: BidiCtx: Cls: Let expression
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent: Root
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: [?]
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: :: @
  LSP: Concave: Backpack: 
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new_tokens ::= whitespace | "," | "::" | "@"
root ::= new_tokens

Top 20 Logits:

:18.9942
#:15.2877
##:14.3769
let:14.2832
 :13.0701
in:12.7384
    :12.5635
  :12.4846
   :12.4528
################:12.3925
####:12.0318
```:11.9827
/*:11.9714
//:11.4136
end:11.3677
                :11.331
        :11.2082
(:11.1575
def:11.121
       :11.1093
[:11.0933

================
# Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)




























































































































LSP: Prelude: Recieved string: ### List ###

# Add an element to the front of a list. #
let cons: (Int, [Int]) -> [Int] = fun x, xs -> x::xs in

# Determine the length of a list. #
let length: [Int] -> Int =
  fun xs ->
    case xs
    | [] => 0
    | _::xs => 1 + length(xs) end in

# Extract the first element of a list. #
let hd: [Int] -> Option =
  fun l ->
    case l
    | [] => None
    | x::xs => Some(x) end in

# Extract the rest of the list. #
let tl: [Int] -> [Int] =
  fun l ->
    case l
    | [] => []
    | x::xs => xs end in

# Determine if a list is empty. #
let is_empty: [Int] -> Bool =
  fun xs ->
    case xs
    | [] => true
    | _::_ => false end in

# Return the element at the index. #
let nth: ([Int], Int) -> Option =
  fun xs, n ->
    case xs, n
    | x::_, 0 => Some(x)
    | _::xs, n => nth(xs, n - 1)
    | [], _ => None end in

# Reverse a List. #
let rev: [Int] -> [Int] =
fun l -> 
let go: ([Int], [Int]) -> [Int] =
  fun xs, acc -> 
    case xs 
    | [] => acc 
    | x::xs => go(xs, x::acc) end in
go(l, []) in

# Check if two lists are equal #
let equal: ([Int], [Int]) -> Bool =
    fun p, xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => x == y && equal(xs, ys)
    | _ => false end
in

# Initialize a list with a given length using an initializer function #
let init: (Int, Int -> Int) -> [Int] =
    fun len, f ->
        let go: (Int, [Int]) -> [Int] =
        fun idx, xs ->
            if idx < len 
            then go(idx + 1, xs @ [f(idx)])   
            else xs
        in
        go(0, [])
in

# Reduce a list from the left. #
let fold_left: ((Int, Int) -> Int, Int, [Int]) -> Int =
  fun f, acc, xs ->
    case xs 
    | [] => acc
    | hd::tl => fold_left(f, f(acc, hd), tl) end in

# Reduce a list from the right. #
let fold_right: ((Int, Int) -> Int, [Int], Int) -> Int =
  fun f, xs, acc ->
    case xs
    | [] => acc
    | hd::tl => f(hd, fold_right(f, tl, acc)) end in


666
LSP: Prelude: String parsed successfully
LSP: Prelude: Info map generated successfully
Debug: true, Constrain: Types
LSP: Init: Recieved string: # Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)



























































































































LSP: Init: String parsed successfully
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: >( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {go: ((?, ?) -> [?]), filter: (((Int -> Bool), [Int]) -> [Int]), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: 
  LSP: Info: ALL errors:Error in term:
  p
Nature of error: Variable p is not bound    
Error in term:
  p
Nature of error: type ((Int -> Bool), [Int]) is not consistent with arrow type    
Error in term:
  p
Nature of error: Variable p is not bound
  LSP: Info: BidiCtx: Cls: Let expression
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent: Root
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: [?]
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: :: @
  LSP: Concave: Backpack: 
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new_tokens ::= whitespace | "," | "::" | "@"
root ::= new_tokens

Top 20 Logits:

:19.0125
#:15.2921
##:14.3992
let:14.2915
 :13.0794
in:12.6557
    :12.5675
  :12.4898
   :12.4538
################:12.4092
####:12.0519
```:11.9928
/*:11.975
//:11.4197
end:11.3303
                :11.33
        :11.2127
(:11.1672
def:11.1217
       :11.1126
[:11.1052

================
# Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)





























































































































LSP: Prelude: Recieved string: ### List ###

# Add an element to the front of a list. #
let cons: (Int, [Int]) -> [Int] = fun x, xs -> x::xs in

# Determine the length of a list. #
let length: [Int] -> Int =
  fun xs ->
    case xs
    | [] => 0
    | _::xs => 1 + length(xs) end in

# Extract the first element of a list. #
let hd: [Int] -> Option =
  fun l ->
    case l
    | [] => None
    | x::xs => Some(x) end in

# Extract the rest of the list. #
let tl: [Int] -> [Int] =
  fun l ->
    case l
    | [] => []
    | x::xs => xs end in

# Determine if a list is empty. #
let is_empty: [Int] -> Bool =
  fun xs ->
    case xs
    | [] => true
    | _::_ => false end in

# Return the element at the index. #
let nth: ([Int], Int) -> Option =
  fun xs, n ->
    case xs, n
    | x::_, 0 => Some(x)
    | _::xs, n => nth(xs, n - 1)
    | [], _ => None end in

# Reverse a List. #
let rev: [Int] -> [Int] =
fun l -> 
let go: ([Int], [Int]) -> [Int] =
  fun xs, acc -> 
    case xs 
    | [] => acc 
    | x::xs => go(xs, x::acc) end in
go(l, []) in

# Check if two lists are equal #
let equal: ([Int], [Int]) -> Bool =
    fun p, xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => x == y && equal(xs, ys)
    | _ => false end
in

# Initialize a list with a given length using an initializer function #
let init: (Int, Int -> Int) -> [Int] =
    fun len, f ->
        let go: (Int, [Int]) -> [Int] =
        fun idx, xs ->
            if idx < len 
            then go(idx + 1, xs @ [f(idx)])   
            else xs
        in
        go(0, [])
in

# Reduce a list from the left. #
let fold_left: ((Int, Int) -> Int, Int, [Int]) -> Int =
  fun f, acc, xs ->
    case xs 
    | [] => acc
    | hd::tl => fold_left(f, f(acc, hd), tl) end in

# Reduce a list from the right. #
let fold_right: ((Int, Int) -> Int, [Int], Int) -> Int =
  fun f, xs, acc ->
    case xs
    | [] => acc
    | hd::tl => f(hd, fold_right(f, tl, acc)) end in


666
LSP: Prelude: String parsed successfully
LSP: Prelude: Info map generated successfully
Debug: true, Constrain: Types
LSP: Init: Recieved string: # Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)




























































































































LSP: Init: String parsed successfully
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: >( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {go: ((?, ?) -> [?]), filter: (((Int -> Bool), [Int]) -> [Int]), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: 
  LSP: Info: ALL errors:Error in term:
  p
Nature of error: Variable p is not bound    
Error in term:
  p
Nature of error: type ((Int -> Bool), [Int]) is not consistent with arrow type    
Error in term:
  p
Nature of error: Variable p is not bound
  LSP: Info: BidiCtx: Cls: Let expression
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent: Root
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: [?]
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: :: @
  LSP: Concave: Backpack: 
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new_tokens ::= whitespace | "," | "::" | "@"
root ::= new_tokens

Top 20 Logits:

:19.0341
#:15.2967
##:14.4363
let:14.3003
 :13.0866
in:12.5815
    :12.5694
  :12.4966
   :12.4522
################:12.4336
####:12.0765
```:12.0116
/*:11.9709
//:11.4187
                :11.3312
end:11.2974
        :11.2197
(:11.1721
def:11.1285
[:11.1212
       :11.117

================
# Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)






























































































































LSP: Prelude: Recieved string: ### List ###

# Add an element to the front of a list. #
let cons: (Int, [Int]) -> [Int] = fun x, xs -> x::xs in

# Determine the length of a list. #
let length: [Int] -> Int =
  fun xs ->
    case xs
    | [] => 0
    | _::xs => 1 + length(xs) end in

# Extract the first element of a list. #
let hd: [Int] -> Option =
  fun l ->
    case l
    | [] => None
    | x::xs => Some(x) end in

# Extract the rest of the list. #
let tl: [Int] -> [Int] =
  fun l ->
    case l
    | [] => []
    | x::xs => xs end in

# Determine if a list is empty. #
let is_empty: [Int] -> Bool =
  fun xs ->
    case xs
    | [] => true
    | _::_ => false end in

# Return the element at the index. #
let nth: ([Int], Int) -> Option =
  fun xs, n ->
    case xs, n
    | x::_, 0 => Some(x)
    | _::xs, n => nth(xs, n - 1)
    | [], _ => None end in

# Reverse a List. #
let rev: [Int] -> [Int] =
fun l -> 
let go: ([Int], [Int]) -> [Int] =
  fun xs, acc -> 
    case xs 
    | [] => acc 
    | x::xs => go(xs, x::acc) end in
go(l, []) in

# Check if two lists are equal #
let equal: ([Int], [Int]) -> Bool =
    fun p, xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => x == y && equal(xs, ys)
    | _ => false end
in

# Initialize a list with a given length using an initializer function #
let init: (Int, Int -> Int) -> [Int] =
    fun len, f ->
        let go: (Int, [Int]) -> [Int] =
        fun idx, xs ->
            if idx < len 
            then go(idx + 1, xs @ [f(idx)])   
            else xs
        in
        go(0, [])
in

# Reduce a list from the left. #
let fold_left: ((Int, Int) -> Int, Int, [Int]) -> Int =
  fun f, acc, xs ->
    case xs 
    | [] => acc
    | hd::tl => fold_left(f, f(acc, hd), tl) end in

# Reduce a list from the right. #
let fold_right: ((Int, Int) -> Int, [Int], Int) -> Int =
  fun f, xs, acc ->
    case xs
    | [] => acc
    | hd::tl => f(hd, fold_right(f, tl, acc)) end in


666
LSP: Prelude: String parsed successfully
LSP: Prelude: Info map generated successfully
Debug: true, Constrain: Types
LSP: Init: Recieved string: # Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)





























































































































LSP: Init: String parsed successfully
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: >( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {go: ((?, ?) -> [?]), filter: (((Int -> Bool), [Int]) -> [Int]), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: 
  LSP: Info: ALL errors:Error in term:
  p
Nature of error: Variable p is not bound    
Error in term:
  p
Nature of error: type ((Int -> Bool), [Int]) is not consistent with arrow type    
Error in term:
  p
Nature of error: Variable p is not bound
  LSP: Info: BidiCtx: Cls: Let expression
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent: Root
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: [?]
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: :: @
  LSP: Concave: Backpack: 
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new_tokens ::= whitespace | "," | "::" | "@"
root ::= new_tokens

Top 20 Logits:

:19.0552
#:15.2954
##:14.466
let:14.3026
 :13.0895
    :12.5709
in:12.5527
  :12.5021
################:12.4541
   :12.4488
####:12.0917
```:12.0258
/*:11.9608
//:11.4078
                :11.3353
end:11.2895
        :11.2272
(:11.1684
def:11.141
[:11.1316
       :11.1196

================
# Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)































































































































LSP: Prelude: Recieved string: ### List ###

# Add an element to the front of a list. #
let cons: (Int, [Int]) -> [Int] = fun x, xs -> x::xs in

# Determine the length of a list. #
let length: [Int] -> Int =
  fun xs ->
    case xs
    | [] => 0
    | _::xs => 1 + length(xs) end in

# Extract the first element of a list. #
let hd: [Int] -> Option =
  fun l ->
    case l
    | [] => None
    | x::xs => Some(x) end in

# Extract the rest of the list. #
let tl: [Int] -> [Int] =
  fun l ->
    case l
    | [] => []
    | x::xs => xs end in

# Determine if a list is empty. #
let is_empty: [Int] -> Bool =
  fun xs ->
    case xs
    | [] => true
    | _::_ => false end in

# Return the element at the index. #
let nth: ([Int], Int) -> Option =
  fun xs, n ->
    case xs, n
    | x::_, 0 => Some(x)
    | _::xs, n => nth(xs, n - 1)
    | [], _ => None end in

# Reverse a List. #
let rev: [Int] -> [Int] =
fun l -> 
let go: ([Int], [Int]) -> [Int] =
  fun xs, acc -> 
    case xs 
    | [] => acc 
    | x::xs => go(xs, x::acc) end in
go(l, []) in

# Check if two lists are equal #
let equal: ([Int], [Int]) -> Bool =
    fun p, xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => x == y && equal(xs, ys)
    | _ => false end
in

# Initialize a list with a given length using an initializer function #
let init: (Int, Int -> Int) -> [Int] =
    fun len, f ->
        let go: (Int, [Int]) -> [Int] =
        fun idx, xs ->
            if idx < len 
            then go(idx + 1, xs @ [f(idx)])   
            else xs
        in
        go(0, [])
in

# Reduce a list from the left. #
let fold_left: ((Int, Int) -> Int, Int, [Int]) -> Int =
  fun f, acc, xs ->
    case xs 
    | [] => acc
    | hd::tl => fold_left(f, f(acc, hd), tl) end in

# Reduce a list from the right. #
let fold_right: ((Int, Int) -> Int, [Int], Int) -> Int =
  fun f, xs, acc ->
    case xs
    | [] => acc
    | hd::tl => f(hd, fold_right(f, tl, acc)) end in


666
LSP: Prelude: String parsed successfully
LSP: Prelude: Info map generated successfully
Debug: true, Constrain: Types
LSP: Init: Recieved string: # Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)






























































































































LSP: Init: String parsed successfully
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: >( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {go: ((?, ?) -> [?]), filter: (((Int -> Bool), [Int]) -> [Int]), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: 
  LSP: Info: ALL errors:Error in term:
  p
Nature of error: type ((Int -> Bool), [Int]) is not consistent with arrow type    
Error in term:
  p
Nature of error: Variable p is not bound    
Error in term:
  p
Nature of error: Variable p is not bound
  LSP: Info: BidiCtx: Cls: Let expression
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent: Root
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: [?]
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: :: @
  LSP: Concave: Backpack: 
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new_tokens ::= whitespace | "," | "::" | "@"
root ::= new_tokens

Top 20 Logits:

:19.0706
#:15.2869
##:14.476
let:14.2968
 :13.0883
    :12.5735
in:12.566
  :12.5031
################:12.4623
   :12.4458
####:12.0925
```:12.0256
/*:11.9511
//:11.3928
                :11.3396
end:11.3022
        :11.2322
(:11.1582
def:11.154
[:11.1315
       :11.1195

================
# Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)
































































































































LSP: Prelude: Recieved string: ### List ###

# Add an element to the front of a list. #
let cons: (Int, [Int]) -> [Int] = fun x, xs -> x::xs in

# Determine the length of a list. #
let length: [Int] -> Int =
  fun xs ->
    case xs
    | [] => 0
    | _::xs => 1 + length(xs) end in

# Extract the first element of a list. #
let hd: [Int] -> Option =
  fun l ->
    case l
    | [] => None
    | x::xs => Some(x) end in

# Extract the rest of the list. #
let tl: [Int] -> [Int] =
  fun l ->
    case l
    | [] => []
    | x::xs => xs end in

# Determine if a list is empty. #
let is_empty: [Int] -> Bool =
  fun xs ->
    case xs
    | [] => true
    | _::_ => false end in

# Return the element at the index. #
let nth: ([Int], Int) -> Option =
  fun xs, n ->
    case xs, n
    | x::_, 0 => Some(x)
    | _::xs, n => nth(xs, n - 1)
    | [], _ => None end in

# Reverse a List. #
let rev: [Int] -> [Int] =
fun l -> 
let go: ([Int], [Int]) -> [Int] =
  fun xs, acc -> 
    case xs 
    | [] => acc 
    | x::xs => go(xs, x::acc) end in
go(l, []) in

# Check if two lists are equal #
let equal: ([Int], [Int]) -> Bool =
    fun p, xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => x == y && equal(xs, ys)
    | _ => false end
in

# Initialize a list with a given length using an initializer function #
let init: (Int, Int -> Int) -> [Int] =
    fun len, f ->
        let go: (Int, [Int]) -> [Int] =
        fun idx, xs ->
            if idx < len 
            then go(idx + 1, xs @ [f(idx)])   
            else xs
        in
        go(0, [])
in

# Reduce a list from the left. #
let fold_left: ((Int, Int) -> Int, Int, [Int]) -> Int =
  fun f, acc, xs ->
    case xs 
    | [] => acc
    | hd::tl => fold_left(f, f(acc, hd), tl) end in

# Reduce a list from the right. #
let fold_right: ((Int, Int) -> Int, [Int], Int) -> Int =
  fun f, xs, acc ->
    case xs
    | [] => acc
    | hd::tl => f(hd, fold_right(f, tl, acc)) end in


666
LSP: Prelude: String parsed successfully
LSP: Prelude: Info map generated successfully
Debug: true, Constrain: Types
LSP: Init: Recieved string: # Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)































































































































LSP: Init: String parsed successfully
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: >( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {go: ((?, ?) -> [?]), filter: (((Int -> Bool), [Int]) -> [Int]), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: 
  LSP: Info: ALL errors:Error in term:
  p
Nature of error: Variable p is not bound    
Error in term:
  p
Nature of error: Variable p is not bound    
Error in term:
  p
Nature of error: type ((Int -> Bool), [Int]) is not consistent with arrow type
  LSP: Info: BidiCtx: Cls: Let expression
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent: Root
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: [?]
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: :: @
  LSP: Concave: Backpack: 
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new_tokens ::= whitespace | "," | "::" | "@"
root ::= new_tokens

Top 20 Logits:

:19.0796
#:15.2767
##:14.4683
let:14.2903
 :13.0863
in:12.5893
    :12.5774
  :12.5004
################:12.4585
   :12.4465
####:12.0821
```:12.013
/*:11.9462
//:11.3811
                :11.3419
end:11.3194
        :11.2331
def:11.1619
(:11.1505
[:11.1255
       :11.1173

================
# Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)

































































































































LSP: Prelude: Recieved string: ### List ###

# Add an element to the front of a list. #
let cons: (Int, [Int]) -> [Int] = fun x, xs -> x::xs in

# Determine the length of a list. #
let length: [Int] -> Int =
  fun xs ->
    case xs
    | [] => 0
    | _::xs => 1 + length(xs) end in

# Extract the first element of a list. #
let hd: [Int] -> Option =
  fun l ->
    case l
    | [] => None
    | x::xs => Some(x) end in

# Extract the rest of the list. #
let tl: [Int] -> [Int] =
  fun l ->
    case l
    | [] => []
    | x::xs => xs end in

# Determine if a list is empty. #
let is_empty: [Int] -> Bool =
  fun xs ->
    case xs
    | [] => true
    | _::_ => false end in

# Return the element at the index. #
let nth: ([Int], Int) -> Option =
  fun xs, n ->
    case xs, n
    | x::_, 0 => Some(x)
    | _::xs, n => nth(xs, n - 1)
    | [], _ => None end in

# Reverse a List. #
let rev: [Int] -> [Int] =
fun l -> 
let go: ([Int], [Int]) -> [Int] =
  fun xs, acc -> 
    case xs 
    | [] => acc 
    | x::xs => go(xs, x::acc) end in
go(l, []) in

# Check if two lists are equal #
let equal: ([Int], [Int]) -> Bool =
    fun p, xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => x == y && equal(xs, ys)
    | _ => false end
in

# Initialize a list with a given length using an initializer function #
let init: (Int, Int -> Int) -> [Int] =
    fun len, f ->
        let go: (Int, [Int]) -> [Int] =
        fun idx, xs ->
            if idx < len 
            then go(idx + 1, xs @ [f(idx)])   
            else xs
        in
        go(0, [])
in

# Reduce a list from the left. #
let fold_left: ((Int, Int) -> Int, Int, [Int]) -> Int =
  fun f, acc, xs ->
    case xs 
    | [] => acc
    | hd::tl => fold_left(f, f(acc, hd), tl) end in

# Reduce a list from the right. #
let fold_right: ((Int, Int) -> Int, [Int], Int) -> Int =
  fun f, xs, acc ->
    case xs
    | [] => acc
    | hd::tl => f(hd, fold_right(f, tl, acc)) end in


666
LSP: Prelude: String parsed successfully
LSP: Prelude: Info map generated successfully
Debug: true, Constrain: Types
LSP: Init: Recieved string: # Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)
































































































































LSP: Init: String parsed successfully
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: >( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {go: ((?, ?) -> [?]), filter: (((Int -> Bool), [Int]) -> [Int]), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: 
  LSP: Info: ALL errors:Error in term:
  p
Nature of error: Variable p is not bound    
Error in term:
  p
Nature of error: type ((Int -> Bool), [Int]) is not consistent with arrow type    
Error in term:
  p
Nature of error: Variable p is not bound
  LSP: Info: BidiCtx: Cls: Let expression
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent: Root
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: [?]
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: :: @
  LSP: Concave: Backpack: 
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new_tokens ::= whitespace | "," | "::" | "@"
root ::= new_tokens

Top 20 Logits:

:19.0859
#:15.2729
##:14.4529
let:14.2906
 :13.0862
in:12.5968
    :12.5791
  :12.4948
   :12.4498
################:12.4484
####:12.0695
```:12.0007
/*:11.9462
//:11.3766
                :11.3435
end:11.3274
        :11.2302
def:11.1631
(:11.1539
[:11.1217
       :11.1152

================
# Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)


































































































































LSP: Prelude: Recieved string: ### List ###

# Add an element to the front of a list. #
let cons: (Int, [Int]) -> [Int] = fun x, xs -> x::xs in

# Determine the length of a list. #
let length: [Int] -> Int =
  fun xs ->
    case xs
    | [] => 0
    | _::xs => 1 + length(xs) end in

# Extract the first element of a list. #
let hd: [Int] -> Option =
  fun l ->
    case l
    | [] => None
    | x::xs => Some(x) end in

# Extract the rest of the list. #
let tl: [Int] -> [Int] =
  fun l ->
    case l
    | [] => []
    | x::xs => xs end in

# Determine if a list is empty. #
let is_empty: [Int] -> Bool =
  fun xs ->
    case xs
    | [] => true
    | _::_ => false end in

# Return the element at the index. #
let nth: ([Int], Int) -> Option =
  fun xs, n ->
    case xs, n
    | x::_, 0 => Some(x)
    | _::xs, n => nth(xs, n - 1)
    | [], _ => None end in

# Reverse a List. #
let rev: [Int] -> [Int] =
fun l -> 
let go: ([Int], [Int]) -> [Int] =
  fun xs, acc -> 
    case xs 
    | [] => acc 
    | x::xs => go(xs, x::acc) end in
go(l, []) in

# Check if two lists are equal #
let equal: ([Int], [Int]) -> Bool =
    fun p, xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => x == y && equal(xs, ys)
    | _ => false end
in

# Initialize a list with a given length using an initializer function #
let init: (Int, Int -> Int) -> [Int] =
    fun len, f ->
        let go: (Int, [Int]) -> [Int] =
        fun idx, xs ->
            if idx < len 
            then go(idx + 1, xs @ [f(idx)])   
            else xs
        in
        go(0, [])
in

# Reduce a list from the left. #
let fold_left: ((Int, Int) -> Int, Int, [Int]) -> Int =
  fun f, acc, xs ->
    case xs 
    | [] => acc
    | hd::tl => fold_left(f, f(acc, hd), tl) end in

# Reduce a list from the right. #
let fold_right: ((Int, Int) -> Int, [Int], Int) -> Int =
  fun f, xs, acc ->
    case xs
    | [] => acc
    | hd::tl => f(hd, fold_right(f, tl, acc)) end in


666
LSP: Prelude: String parsed successfully
LSP: Prelude: Info map generated successfully
Debug: true, Constrain: Types
LSP: Init: Recieved string: # Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)

































































































































LSP: Init: String parsed successfully
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: >( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {go: ((?, ?) -> [?]), filter: (((Int -> Bool), [Int]) -> [Int]), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: 
  LSP: Info: ALL errors:Error in term:
  p
Nature of error: Variable p is not bound    
Error in term:
  p
Nature of error: Variable p is not bound    
Error in term:
  p
Nature of error: type ((Int -> Bool), [Int]) is not consistent with arrow type
  LSP: Info: BidiCtx: Cls: Let expression
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent: Root
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: [?]
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: :: @
  LSP: Concave: Backpack: 
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new_tokens ::= whitespace | "," | "::" | "@"
root ::= new_tokens

Top 20 Logits:

:19.0941
#:15.2778
##:14.441
let:14.2991
 :13.088
in:12.5803
    :12.5759
  :12.4868
   :12.4529
################:12.4385
####:12.0608
```:11.9974
/*:11.9493
//:11.3782
                :11.3448
end:11.3209
        :11.2255
(:11.1659
def:11.1597
[:11.1263
       :11.1149

================
# Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)



































































































































LSP: Prelude: Recieved string: ### List ###

# Add an element to the front of a list. #
let cons: (Int, [Int]) -> [Int] = fun x, xs -> x::xs in

# Determine the length of a list. #
let length: [Int] -> Int =
  fun xs ->
    case xs
    | [] => 0
    | _::xs => 1 + length(xs) end in

# Extract the first element of a list. #
let hd: [Int] -> Option =
  fun l ->
    case l
    | [] => None
    | x::xs => Some(x) end in

# Extract the rest of the list. #
let tl: [Int] -> [Int] =
  fun l ->
    case l
    | [] => []
    | x::xs => xs end in

# Determine if a list is empty. #
let is_empty: [Int] -> Bool =
  fun xs ->
    case xs
    | [] => true
    | _::_ => false end in

# Return the element at the index. #
let nth: ([Int], Int) -> Option =
  fun xs, n ->
    case xs, n
    | x::_, 0 => Some(x)
    | _::xs, n => nth(xs, n - 1)
    | [], _ => None end in

# Reverse a List. #
let rev: [Int] -> [Int] =
fun l -> 
let go: ([Int], [Int]) -> [Int] =
  fun xs, acc -> 
    case xs 
    | [] => acc 
    | x::xs => go(xs, x::acc) end in
go(l, []) in

# Check if two lists are equal #
let equal: ([Int], [Int]) -> Bool =
    fun p, xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => x == y && equal(xs, ys)
    | _ => false end
in

# Initialize a list with a given length using an initializer function #
let init: (Int, Int -> Int) -> [Int] =
    fun len, f ->
        let go: (Int, [Int]) -> [Int] =
        fun idx, xs ->
            if idx < len 
            then go(idx + 1, xs @ [f(idx)])   
            else xs
        in
        go(0, [])
in

# Reduce a list from the left. #
let fold_left: ((Int, Int) -> Int, Int, [Int]) -> Int =
  fun f, acc, xs ->
    case xs 
    | [] => acc
    | hd::tl => fold_left(f, f(acc, hd), tl) end in

# Reduce a list from the right. #
let fold_right: ((Int, Int) -> Int, [Int], Int) -> Int =
  fun f, xs, acc ->
    case xs
    | [] => acc
    | hd::tl => f(hd, fold_right(f, tl, acc)) end in


666
LSP: Prelude: String parsed successfully
LSP: Prelude: Info map generated successfully
Debug: true, Constrain: Types
LSP: Init: Recieved string: # Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)


































































































































LSP: Init: String parsed successfully
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: >( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {go: ((?, ?) -> [?]), filter: (((Int -> Bool), [Int]) -> [Int]), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: 
  LSP: Info: ALL errors:Error in term:
  p
Nature of error: Variable p is not bound    
Error in term:
  p
Nature of error: Variable p is not bound    
Error in term:
  p
Nature of error: type ((Int -> Bool), [Int]) is not consistent with arrow type
  LSP: Info: BidiCtx: Cls: Let expression
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent: Root
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: [?]
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: :: @
  LSP: Concave: Backpack: 
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new_tokens ::= whitespace | "," | "::" | "@"
root ::= new_tokens

Top 20 Logits:

:19.1055
#:15.2884
##:14.4371
let:14.3114
 :13.0898
    :12.5684
in:12.5527
  :12.4771
   :12.4541
################:12.4321
####:12.0577
```:12.0021
/*:11.9521
//:11.3823
                :11.3463
end:11.3046
        :11.2207
(:11.1758
def:11.1551
[:11.1376
       :11.1163

================
# Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)




































































































































LSP: Prelude: Recieved string: ### List ###

# Add an element to the front of a list. #
let cons: (Int, [Int]) -> [Int] = fun x, xs -> x::xs in

# Determine the length of a list. #
let length: [Int] -> Int =
  fun xs ->
    case xs
    | [] => 0
    | _::xs => 1 + length(xs) end in

# Extract the first element of a list. #
let hd: [Int] -> Option =
  fun l ->
    case l
    | [] => None
    | x::xs => Some(x) end in

# Extract the rest of the list. #
let tl: [Int] -> [Int] =
  fun l ->
    case l
    | [] => []
    | x::xs => xs end in

# Determine if a list is empty. #
let is_empty: [Int] -> Bool =
  fun xs ->
    case xs
    | [] => true
    | _::_ => false end in

# Return the element at the index. #
let nth: ([Int], Int) -> Option =
  fun xs, n ->
    case xs, n
    | x::_, 0 => Some(x)
    | _::xs, n => nth(xs, n - 1)
    | [], _ => None end in

# Reverse a List. #
let rev: [Int] -> [Int] =
fun l -> 
let go: ([Int], [Int]) -> [Int] =
  fun xs, acc -> 
    case xs 
    | [] => acc 
    | x::xs => go(xs, x::acc) end in
go(l, []) in

# Check if two lists are equal #
let equal: ([Int], [Int]) -> Bool =
    fun p, xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => x == y && equal(xs, ys)
    | _ => false end
in

# Initialize a list with a given length using an initializer function #
let init: (Int, Int -> Int) -> [Int] =
    fun len, f ->
        let go: (Int, [Int]) -> [Int] =
        fun idx, xs ->
            if idx < len 
            then go(idx + 1, xs @ [f(idx)])   
            else xs
        in
        go(0, [])
in

# Reduce a list from the left. #
let fold_left: ((Int, Int) -> Int, Int, [Int]) -> Int =
  fun f, acc, xs ->
    case xs 
    | [] => acc
    | hd::tl => fold_left(f, f(acc, hd), tl) end in

# Reduce a list from the right. #
let fold_right: ((Int, Int) -> Int, [Int], Int) -> Int =
  fun f, xs, acc ->
    case xs
    | [] => acc
    | hd::tl => f(hd, fold_right(f, tl, acc)) end in


666
LSP: Prelude: String parsed successfully
LSP: Prelude: Info map generated successfully
Debug: true, Constrain: Types
LSP: Init: Recieved string: # Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)



































































































































LSP: Init: String parsed successfully
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: >( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {go: ((?, ?) -> [?]), filter: (((Int -> Bool), [Int]) -> [Int]), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: 
  LSP: Info: ALL errors:Error in term:
  p
Nature of error: Variable p is not bound    
Error in term:
  p
Nature of error: Variable p is not bound    
Error in term:
  p
Nature of error: type ((Int -> Bool), [Int]) is not consistent with arrow type
  LSP: Info: BidiCtx: Cls: Let expression
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent: Root
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: [?]
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: :: @
  LSP: Concave: Backpack: 
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new_tokens ::= whitespace | "," | "::" | "@"
root ::= new_tokens

Top 20 Logits:

:19.1189
#:15.2962
##:14.4382
let:14.3196
 :13.0897
    :12.559
in:12.5315
  :12.4673
   :12.4524
################:12.43
####:12.0565
```:12.0054
/*:11.9529
//:11.3841
                :11.349
end:11.2939
        :11.2173
(:11.1729
def:11.1545
[:11.1446
       :11.1174

================
# Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)





































































































































LSP: Prelude: Recieved string: ### List ###

# Add an element to the front of a list. #
let cons: (Int, [Int]) -> [Int] = fun x, xs -> x::xs in

# Determine the length of a list. #
let length: [Int] -> Int =
  fun xs ->
    case xs
    | [] => 0
    | _::xs => 1 + length(xs) end in

# Extract the first element of a list. #
let hd: [Int] -> Option =
  fun l ->
    case l
    | [] => None
    | x::xs => Some(x) end in

# Extract the rest of the list. #
let tl: [Int] -> [Int] =
  fun l ->
    case l
    | [] => []
    | x::xs => xs end in

# Determine if a list is empty. #
let is_empty: [Int] -> Bool =
  fun xs ->
    case xs
    | [] => true
    | _::_ => false end in

# Return the element at the index. #
let nth: ([Int], Int) -> Option =
  fun xs, n ->
    case xs, n
    | x::_, 0 => Some(x)
    | _::xs, n => nth(xs, n - 1)
    | [], _ => None end in

# Reverse a List. #
let rev: [Int] -> [Int] =
fun l -> 
let go: ([Int], [Int]) -> [Int] =
  fun xs, acc -> 
    case xs 
    | [] => acc 
    | x::xs => go(xs, x::acc) end in
go(l, []) in

# Check if two lists are equal #
let equal: ([Int], [Int]) -> Bool =
    fun p, xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => x == y && equal(xs, ys)
    | _ => false end
in

# Initialize a list with a given length using an initializer function #
let init: (Int, Int -> Int) -> [Int] =
    fun len, f ->
        let go: (Int, [Int]) -> [Int] =
        fun idx, xs ->
            if idx < len 
            then go(idx + 1, xs @ [f(idx)])   
            else xs
        in
        go(0, [])
in

# Reduce a list from the left. #
let fold_left: ((Int, Int) -> Int, Int, [Int]) -> Int =
  fun f, acc, xs ->
    case xs 
    | [] => acc
    | hd::tl => fold_left(f, f(acc, hd), tl) end in

# Reduce a list from the right. #
let fold_right: ((Int, Int) -> Int, [Int], Int) -> Int =
  fun f, xs, acc ->
    case xs
    | [] => acc
    | hd::tl => f(hd, fold_right(f, tl, acc)) end in


666
LSP: Prelude: String parsed successfully
LSP: Prelude: Info map generated successfully
Debug: true, Constrain: Types
LSP: Init: Recieved string: # Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)




































































































































LSP: Init: String parsed successfully
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: >( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {go: ((?, ?) -> [?]), filter: (((Int -> Bool), [Int]) -> [Int]), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: 
  LSP: Info: ALL errors:Error in term:
  p
Nature of error: Variable p is not bound    
Error in term:
  p
Nature of error: Variable p is not bound    
Error in term:
  p
Nature of error: type ((Int -> Bool), [Int]) is not consistent with arrow type
  LSP: Info: BidiCtx: Cls: Let expression
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent: Root
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: [?]
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: :: @
  LSP: Concave: Backpack: 
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new_tokens ::= whitespace | "," | "::" | "@"
root ::= new_tokens

Top 20 Logits:

:19.1322
#:15.294
##:14.4401
let:14.3171
 :13.0892
    :12.5528
in:12.5171
  :12.4596
   :12.4499
################:12.4317
####:12.0534
```:11.9991
/*:11.9534
//:11.3826
                :11.3515
end:11.2995
        :11.2165
def:11.1647
(:11.1551
[:11.1384
       :11.1174

================
# Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)






































































































































LSP: Prelude: Recieved string: ### List ###

# Add an element to the front of a list. #
let cons: (Int, [Int]) -> [Int] = fun x, xs -> x::xs in

# Determine the length of a list. #
let length: [Int] -> Int =
  fun xs ->
    case xs
    | [] => 0
    | _::xs => 1 + length(xs) end in

# Extract the first element of a list. #
let hd: [Int] -> Option =
  fun l ->
    case l
    | [] => None
    | x::xs => Some(x) end in

# Extract the rest of the list. #
let tl: [Int] -> [Int] =
  fun l ->
    case l
    | [] => []
    | x::xs => xs end in

# Determine if a list is empty. #
let is_empty: [Int] -> Bool =
  fun xs ->
    case xs
    | [] => true
    | _::_ => false end in

# Return the element at the index. #
let nth: ([Int], Int) -> Option =
  fun xs, n ->
    case xs, n
    | x::_, 0 => Some(x)
    | _::xs, n => nth(xs, n - 1)
    | [], _ => None end in

# Reverse a List. #
let rev: [Int] -> [Int] =
fun l -> 
let go: ([Int], [Int]) -> [Int] =
  fun xs, acc -> 
    case xs 
    | [] => acc 
    | x::xs => go(xs, x::acc) end in
go(l, []) in

# Check if two lists are equal #
let equal: ([Int], [Int]) -> Bool =
    fun p, xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => x == y && equal(xs, ys)
    | _ => false end
in

# Initialize a list with a given length using an initializer function #
let init: (Int, Int -> Int) -> [Int] =
    fun len, f ->
        let go: (Int, [Int]) -> [Int] =
        fun idx, xs ->
            if idx < len 
            then go(idx + 1, xs @ [f(idx)])   
            else xs
        in
        go(0, [])
in

# Reduce a list from the left. #
let fold_left: ((Int, Int) -> Int, Int, [Int]) -> Int =
  fun f, acc, xs ->
    case xs 
    | [] => acc
    | hd::tl => fold_left(f, f(acc, hd), tl) end in

# Reduce a list from the right. #
let fold_right: ((Int, Int) -> Int, [Int], Int) -> Int =
  fun f, xs, acc ->
    case xs
    | [] => acc
    | hd::tl => f(hd, fold_right(f, tl, acc)) end in


666
LSP: Prelude: String parsed successfully
LSP: Prelude: Info map generated successfully
Debug: true, Constrain: Types
LSP: Init: Recieved string: # Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)





































































































































LSP: Init: String parsed successfully
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: >( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {go: ((?, ?) -> [?]), filter: (((Int -> Bool), [Int]) -> [Int]), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: 
  LSP: Info: ALL errors:Error in term:
  p
Nature of error: type ((Int -> Bool), [Int]) is not consistent with arrow type    
Error in term:
  p
Nature of error: Variable p is not bound    
Error in term:
  p
Nature of error: Variable p is not bound
  LSP: Info: BidiCtx: Cls: Let expression
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent: Root
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: [?]
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: :: @
  LSP: Concave: Backpack: 
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new_tokens ::= whitespace | "," | "::" | "@"
root ::= new_tokens

Top 20 Logits:

:19.1441
#:15.2831
##:14.4425
let:14.3032
 :13.0913
    :12.5543
in:12.5029
  :12.4565
   :12.4505
################:12.4344
####:12.0496
```:11.9823
/*:11.9566
//:11.3813
                :11.3508
end:11.3182
        :11.2179
def:11.1823
(:11.131
[:11.121
       :11.1173

================
# Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)







































































































































LSP: Prelude: Recieved string: ### List ###

# Add an element to the front of a list. #
let cons: (Int, [Int]) -> [Int] = fun x, xs -> x::xs in

# Determine the length of a list. #
let length: [Int] -> Int =
  fun xs ->
    case xs
    | [] => 0
    | _::xs => 1 + length(xs) end in

# Extract the first element of a list. #
let hd: [Int] -> Option =
  fun l ->
    case l
    | [] => None
    | x::xs => Some(x) end in

# Extract the rest of the list. #
let tl: [Int] -> [Int] =
  fun l ->
    case l
    | [] => []
    | x::xs => xs end in

# Determine if a list is empty. #
let is_empty: [Int] -> Bool =
  fun xs ->
    case xs
    | [] => true
    | _::_ => false end in

# Return the element at the index. #
let nth: ([Int], Int) -> Option =
  fun xs, n ->
    case xs, n
    | x::_, 0 => Some(x)
    | _::xs, n => nth(xs, n - 1)
    | [], _ => None end in

# Reverse a List. #
let rev: [Int] -> [Int] =
fun l -> 
let go: ([Int], [Int]) -> [Int] =
  fun xs, acc -> 
    case xs 
    | [] => acc 
    | x::xs => go(xs, x::acc) end in
go(l, []) in

# Check if two lists are equal #
let equal: ([Int], [Int]) -> Bool =
    fun p, xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => x == y && equal(xs, ys)
    | _ => false end
in

# Initialize a list with a given length using an initializer function #
let init: (Int, Int -> Int) -> [Int] =
    fun len, f ->
        let go: (Int, [Int]) -> [Int] =
        fun idx, xs ->
            if idx < len 
            then go(idx + 1, xs @ [f(idx)])   
            else xs
        in
        go(0, [])
in

# Reduce a list from the left. #
let fold_left: ((Int, Int) -> Int, Int, [Int]) -> Int =
  fun f, acc, xs ->
    case xs 
    | [] => acc
    | hd::tl => fold_left(f, f(acc, hd), tl) end in

# Reduce a list from the right. #
let fold_right: ((Int, Int) -> Int, [Int], Int) -> Int =
  fun f, xs, acc ->
    case xs
    | [] => acc
    | hd::tl => f(hd, fold_right(f, tl, acc)) end in


666
LSP: Prelude: String parsed successfully
LSP: Prelude: Info map generated successfully
Debug: true, Constrain: Types
LSP: Init: Recieved string: # Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)






































































































































LSP: Init: String parsed successfully
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: >( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {go: ((?, ?) -> [?]), filter: (((Int -> Bool), [Int]) -> [Int]), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: 
  LSP: Info: ALL errors:Error in term:
  p
Nature of error: type ((Int -> Bool), [Int]) is not consistent with arrow type    
Error in term:
  p
Nature of error: Variable p is not bound    
Error in term:
  p
Nature of error: Variable p is not bound
  LSP: Info: BidiCtx: Cls: Let expression
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent: Root
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: [?]
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: :: @
  LSP: Concave: Backpack: 
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new_tokens ::= whitespace | "," | "::" | "@"
root ::= new_tokens

Top 20 Logits:

:19.1571
#:15.2715
##:14.4462
let:14.2851
 :13.0991
    :12.5635
in:12.4929
  :12.4605
   :12.4556
################:12.4378
####:12.0486
```:11.9652
/*:11.9613
//:11.3812
                :11.3496
end:11.3438
        :11.2229
def:11.1994
       :11.118
(:11.1157
[:11.1022

================
# Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)








































































































































LSP: Prelude: Recieved string: ### List ###

# Add an element to the front of a list. #
let cons: (Int, [Int]) -> [Int] = fun x, xs -> x::xs in

# Determine the length of a list. #
let length: [Int] -> Int =
  fun xs ->
    case xs
    | [] => 0
    | _::xs => 1 + length(xs) end in

# Extract the first element of a list. #
let hd: [Int] -> Option =
  fun l ->
    case l
    | [] => None
    | x::xs => Some(x) end in

# Extract the rest of the list. #
let tl: [Int] -> [Int] =
  fun l ->
    case l
    | [] => []
    | x::xs => xs end in

# Determine if a list is empty. #
let is_empty: [Int] -> Bool =
  fun xs ->
    case xs
    | [] => true
    | _::_ => false end in

# Return the element at the index. #
let nth: ([Int], Int) -> Option =
  fun xs, n ->
    case xs, n
    | x::_, 0 => Some(x)
    | _::xs, n => nth(xs, n - 1)
    | [], _ => None end in

# Reverse a List. #
let rev: [Int] -> [Int] =
fun l -> 
let go: ([Int], [Int]) -> [Int] =
  fun xs, acc -> 
    case xs 
    | [] => acc 
    | x::xs => go(xs, x::acc) end in
go(l, []) in

# Check if two lists are equal #
let equal: ([Int], [Int]) -> Bool =
    fun p, xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => x == y && equal(xs, ys)
    | _ => false end
in

# Initialize a list with a given length using an initializer function #
let init: (Int, Int -> Int) -> [Int] =
    fun len, f ->
        let go: (Int, [Int]) -> [Int] =
        fun idx, xs ->
            if idx < len 
            then go(idx + 1, xs @ [f(idx)])   
            else xs
        in
        go(0, [])
in

# Reduce a list from the left. #
let fold_left: ((Int, Int) -> Int, Int, [Int]) -> Int =
  fun f, acc, xs ->
    case xs 
    | [] => acc
    | hd::tl => fold_left(f, f(acc, hd), tl) end in

# Reduce a list from the right. #
let fold_right: ((Int, Int) -> Int, [Int], Int) -> Int =
  fun f, xs, acc ->
    case xs
    | [] => acc
    | hd::tl => f(hd, fold_right(f, tl, acc)) end in


666
LSP: Prelude: String parsed successfully
LSP: Prelude: Info map generated successfully
Debug: true, Constrain: Types
LSP: Init: Recieved string: # Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)







































































































































LSP: Init: String parsed successfully
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: >( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {go: ((?, ?) -> [?]), filter: (((Int -> Bool), [Int]) -> [Int]), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: 
  LSP: Info: ALL errors:Error in term:
  p
Nature of error: Variable p is not bound    
Error in term:
  p
Nature of error: Variable p is not bound    
Error in term:
  p
Nature of error: type ((Int -> Bool), [Int]) is not consistent with arrow type
  LSP: Info: BidiCtx: Cls: Let expression
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent: Root
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: [?]
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: :: @
  LSP: Concave: Backpack: 
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new_tokens ::= whitespace | "," | "::" | "@"
root ::= new_tokens

Top 20 Logits:

:19.1719
#:15.2658
##:14.4488
let:14.2718
 :13.11
    :12.5733
in:12.4906
  :12.4675
   :12.4603
################:12.4407
####:12.0495
/*:11.9643
```:11.9567
//:11.3824
end:11.3677
                :11.3497
        :11.2293
def:11.2112
       :11.1187
(:11.1164
[:11.0918

================
# Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)









































































































































LSP: Prelude: Recieved string: ### List ###

# Add an element to the front of a list. #
let cons: (Int, [Int]) -> [Int] = fun x, xs -> x::xs in

# Determine the length of a list. #
let length: [Int] -> Int =
  fun xs ->
    case xs
    | [] => 0
    | _::xs => 1 + length(xs) end in

# Extract the first element of a list. #
let hd: [Int] -> Option =
  fun l ->
    case l
    | [] => None
    | x::xs => Some(x) end in

# Extract the rest of the list. #
let tl: [Int] -> [Int] =
  fun l ->
    case l
    | [] => []
    | x::xs => xs end in

# Determine if a list is empty. #
let is_empty: [Int] -> Bool =
  fun xs ->
    case xs
    | [] => true
    | _::_ => false end in

# Return the element at the index. #
let nth: ([Int], Int) -> Option =
  fun xs, n ->
    case xs, n
    | x::_, 0 => Some(x)
    | _::xs, n => nth(xs, n - 1)
    | [], _ => None end in

# Reverse a List. #
let rev: [Int] -> [Int] =
fun l -> 
let go: ([Int], [Int]) -> [Int] =
  fun xs, acc -> 
    case xs 
    | [] => acc 
    | x::xs => go(xs, x::acc) end in
go(l, []) in

# Check if two lists are equal #
let equal: ([Int], [Int]) -> Bool =
    fun p, xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => x == y && equal(xs, ys)
    | _ => false end
in

# Initialize a list with a given length using an initializer function #
let init: (Int, Int -> Int) -> [Int] =
    fun len, f ->
        let go: (Int, [Int]) -> [Int] =
        fun idx, xs ->
            if idx < len 
            then go(idx + 1, xs @ [f(idx)])   
            else xs
        in
        go(0, [])
in

# Reduce a list from the left. #
let fold_left: ((Int, Int) -> Int, Int, [Int]) -> Int =
  fun f, acc, xs ->
    case xs 
    | [] => acc
    | hd::tl => fold_left(f, f(acc, hd), tl) end in

# Reduce a list from the right. #
let fold_right: ((Int, Int) -> Int, [Int], Int) -> Int =
  fun f, xs, acc ->
    case xs
    | [] => acc
    | hd::tl => f(hd, fold_right(f, tl, acc)) end in


666
LSP: Prelude: String parsed successfully
LSP: Prelude: Info map generated successfully
Debug: true, Constrain: Types
LSP: Init: Recieved string: # Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)








































































































































LSP: Init: String parsed successfully
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: >( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {go: ((?, ?) -> [?]), filter: (((Int -> Bool), [Int]) -> [Int]), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: 
  LSP: Info: ALL errors:Error in term:
  p
Nature of error: type ((Int -> Bool), [Int]) is not consistent with arrow type    
Error in term:
  p
Nature of error: Variable p is not bound    
Error in term:
  p
Nature of error: Variable p is not bound
  LSP: Info: BidiCtx: Cls: Let expression
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent: Root
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: [?]
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: :: @
  LSP: Concave: Backpack: 
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new_tokens ::= whitespace | "," | "::" | "@"
root ::= new_tokens

Top 20 Logits:

:19.1884
#:15.2685
##:14.4482
let:14.2703
 :13.1193
    :12.5792
in:12.4975
  :12.4731
   :12.462
################:12.442
####:12.0492
/*:11.9653
```:11.9569
end:11.3843
//:11.3841
                :11.3518
        :11.2348
def:11.2172
(:11.1273
       :11.1187
[:11.0942

================
# Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)










































































































































LSP: Prelude: Recieved string: ### List ###

# Add an element to the front of a list. #
let cons: (Int, [Int]) -> [Int] = fun x, xs -> x::xs in

# Determine the length of a list. #
let length: [Int] -> Int =
  fun xs ->
    case xs
    | [] => 0
    | _::xs => 1 + length(xs) end in

# Extract the first element of a list. #
let hd: [Int] -> Option =
  fun l ->
    case l
    | [] => None
    | x::xs => Some(x) end in

# Extract the rest of the list. #
let tl: [Int] -> [Int] =
  fun l ->
    case l
    | [] => []
    | x::xs => xs end in

# Determine if a list is empty. #
let is_empty: [Int] -> Bool =
  fun xs ->
    case xs
    | [] => true
    | _::_ => false end in

# Return the element at the index. #
let nth: ([Int], Int) -> Option =
  fun xs, n ->
    case xs, n
    | x::_, 0 => Some(x)
    | _::xs, n => nth(xs, n - 1)
    | [], _ => None end in

# Reverse a List. #
let rev: [Int] -> [Int] =
fun l -> 
let go: ([Int], [Int]) -> [Int] =
  fun xs, acc -> 
    case xs 
    | [] => acc 
    | x::xs => go(xs, x::acc) end in
go(l, []) in

# Check if two lists are equal #
let equal: ([Int], [Int]) -> Bool =
    fun p, xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => x == y && equal(xs, ys)
    | _ => false end
in

# Initialize a list with a given length using an initializer function #
let init: (Int, Int -> Int) -> [Int] =
    fun len, f ->
        let go: (Int, [Int]) -> [Int] =
        fun idx, xs ->
            if idx < len 
            then go(idx + 1, xs @ [f(idx)])   
            else xs
        in
        go(0, [])
in

# Reduce a list from the left. #
let fold_left: ((Int, Int) -> Int, Int, [Int]) -> Int =
  fun f, acc, xs ->
    case xs 
    | [] => acc
    | hd::tl => fold_left(f, f(acc, hd), tl) end in

# Reduce a list from the right. #
let fold_right: ((Int, Int) -> Int, [Int], Int) -> Int =
  fun f, xs, acc ->
    case xs
    | [] => acc
    | hd::tl => f(hd, fold_right(f, tl, acc)) end in


666
LSP: Prelude: String parsed successfully
LSP: Prelude: Info map generated successfully
Debug: true, Constrain: Types
LSP: Init: Recieved string: # Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)









































































































































LSP: Init: String parsed successfully
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: >( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {go: ((?, ?) -> [?]), filter: (((Int -> Bool), [Int]) -> [Int]), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: 
  LSP: Info: ALL errors:Error in term:
  p
Nature of error: Variable p is not bound    
Error in term:
  p
Nature of error: type ((Int -> Bool), [Int]) is not consistent with arrow type    
Error in term:
  p
Nature of error: Variable p is not bound
  LSP: Info: BidiCtx: Cls: Let expression
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent: Root
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: [?]
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: :: @
  LSP: Concave: Backpack: 
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new_tokens ::= whitespace | "," | "::" | "@"
root ::= new_tokens

Top 20 Logits:

:19.205
#:15.2763
##:14.4419
let:14.2776
 :13.1234
    :12.5787
in:12.5163
  :12.4739
   :12.4586
################:12.4405
####:12.0449
/*:11.9637
```:11.9614
end:11.3914
//:11.384
                :11.3554
        :11.2369
def:11.2163
(:11.1371
       :11.1167
[:11.1051

================
# Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)











































































































































LSP: Prelude: Recieved string: ### List ###

# Add an element to the front of a list. #
let cons: (Int, [Int]) -> [Int] = fun x, xs -> x::xs in

# Determine the length of a list. #
let length: [Int] -> Int =
  fun xs ->
    case xs
    | [] => 0
    | _::xs => 1 + length(xs) end in

# Extract the first element of a list. #
let hd: [Int] -> Option =
  fun l ->
    case l
    | [] => None
    | x::xs => Some(x) end in

# Extract the rest of the list. #
let tl: [Int] -> [Int] =
  fun l ->
    case l
    | [] => []
    | x::xs => xs end in

# Determine if a list is empty. #
let is_empty: [Int] -> Bool =
  fun xs ->
    case xs
    | [] => true
    | _::_ => false end in

# Return the element at the index. #
let nth: ([Int], Int) -> Option =
  fun xs, n ->
    case xs, n
    | x::_, 0 => Some(x)
    | _::xs, n => nth(xs, n - 1)
    | [], _ => None end in

# Reverse a List. #
let rev: [Int] -> [Int] =
fun l -> 
let go: ([Int], [Int]) -> [Int] =
  fun xs, acc -> 
    case xs 
    | [] => acc 
    | x::xs => go(xs, x::acc) end in
go(l, []) in

# Check if two lists are equal #
let equal: ([Int], [Int]) -> Bool =
    fun p, xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => x == y && equal(xs, ys)
    | _ => false end
in

# Initialize a list with a given length using an initializer function #
let init: (Int, Int -> Int) -> [Int] =
    fun len, f ->
        let go: (Int, [Int]) -> [Int] =
        fun idx, xs ->
            if idx < len 
            then go(idx + 1, xs @ [f(idx)])   
            else xs
        in
        go(0, [])
in

# Reduce a list from the left. #
let fold_left: ((Int, Int) -> Int, Int, [Int]) -> Int =
  fun f, acc, xs ->
    case xs 
    | [] => acc
    | hd::tl => fold_left(f, f(acc, hd), tl) end in

# Reduce a list from the right. #
let fold_right: ((Int, Int) -> Int, [Int], Int) -> Int =
  fun f, xs, acc ->
    case xs
    | [] => acc
    | hd::tl => f(hd, fold_right(f, tl, acc)) end in


666
LSP: Prelude: String parsed successfully
LSP: Prelude: Info map generated successfully
Debug: true, Constrain: Types
LSP: Init: Recieved string: # Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)










































































































































LSP: Init: String parsed successfully
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: >( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {go: ((?, ?) -> [?]), filter: (((Int -> Bool), [Int]) -> [Int]), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: 
  LSP: Info: ALL errors:Error in term:
  p
Nature of error: Variable p is not bound    
Error in term:
  p
Nature of error: type ((Int -> Bool), [Int]) is not consistent with arrow type    
Error in term:
  p
Nature of error: Variable p is not bound
  LSP: Info: BidiCtx: Cls: Let expression
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent: Root
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: [?]
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: :: @
  LSP: Concave: Backpack: 
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new_tokens ::= whitespace | "," | "::" | "@"
root ::= new_tokens

Top 20 Logits:

:19.2182
#:15.2808
##:14.4296
let:14.2861
 :13.1205
    :12.5714
in:12.5332
  :12.4672
   :12.449
################:12.4367
####:12.0355
/*:11.9605
```:11.9602
end:11.3871
//:11.3806
                :11.3564
        :11.2329
def:11.2105
(:11.1384
[:11.1173
       :11.1104

================
# Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)












































































































































LSP: Prelude: Recieved string: ### List ###

# Add an element to the front of a list. #
let cons: (Int, [Int]) -> [Int] = fun x, xs -> x::xs in

# Determine the length of a list. #
let length: [Int] -> Int =
  fun xs ->
    case xs
    | [] => 0
    | _::xs => 1 + length(xs) end in

# Extract the first element of a list. #
let hd: [Int] -> Option =
  fun l ->
    case l
    | [] => None
    | x::xs => Some(x) end in

# Extract the rest of the list. #
let tl: [Int] -> [Int] =
  fun l ->
    case l
    | [] => []
    | x::xs => xs end in

# Determine if a list is empty. #
let is_empty: [Int] -> Bool =
  fun xs ->
    case xs
    | [] => true
    | _::_ => false end in

# Return the element at the index. #
let nth: ([Int], Int) -> Option =
  fun xs, n ->
    case xs, n
    | x::_, 0 => Some(x)
    | _::xs, n => nth(xs, n - 1)
    | [], _ => None end in

# Reverse a List. #
let rev: [Int] -> [Int] =
fun l -> 
let go: ([Int], [Int]) -> [Int] =
  fun xs, acc -> 
    case xs 
    | [] => acc 
    | x::xs => go(xs, x::acc) end in
go(l, []) in

# Check if two lists are equal #
let equal: ([Int], [Int]) -> Bool =
    fun p, xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => x == y && equal(xs, ys)
    | _ => false end
in

# Initialize a list with a given length using an initializer function #
let init: (Int, Int -> Int) -> [Int] =
    fun len, f ->
        let go: (Int, [Int]) -> [Int] =
        fun idx, xs ->
            if idx < len 
            then go(idx + 1, xs @ [f(idx)])   
            else xs
        in
        go(0, [])
in

# Reduce a list from the left. #
let fold_left: ((Int, Int) -> Int, Int, [Int]) -> Int =
  fun f, acc, xs ->
    case xs 
    | [] => acc
    | hd::tl => fold_left(f, f(acc, hd), tl) end in

# Reduce a list from the right. #
let fold_right: ((Int, Int) -> Int, [Int], Int) -> Int =
  fun f, xs, acc ->
    case xs
    | [] => acc
    | hd::tl => f(hd, fold_right(f, tl, acc)) end in


666
LSP: Prelude: String parsed successfully
LSP: Prelude: Info map generated successfully
Debug: true, Constrain: Types
LSP: Init: Recieved string: # Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)











































































































































LSP: Init: String parsed successfully
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: >( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {go: ((?, ?) -> [?]), filter: (((Int -> Bool), [Int]) -> [Int]), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: 
  LSP: Info: ALL errors:Error in term:
  p
Nature of error: Variable p is not bound    
Error in term:
  p
Nature of error: type ((Int -> Bool), [Int]) is not consistent with arrow type    
Error in term:
  p
Nature of error: Variable p is not bound
  LSP: Info: BidiCtx: Cls: Let expression
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent: Root
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: [?]
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: :: @
  LSP: Concave: Backpack: 
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new_tokens ::= whitespace | "," | "::" | "@"
root ::= new_tokens

Top 20 Logits:

:19.2276
#:15.2788
##:14.421
let:14.2934
 :13.1151
    :12.5629
in:12.5197
  :12.4572
   :12.4391
################:12.4356
####:12.0271
/*:11.9581
```:11.95
//:11.3756
end:11.3708
                :11.3531
        :11.2243
def:11.2044
(:11.1319
[:11.1293
       :11.1012

================
# Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)













































































































































LSP: Prelude: Recieved string: ### List ###

# Add an element to the front of a list. #
let cons: (Int, [Int]) -> [Int] = fun x, xs -> x::xs in

# Determine the length of a list. #
let length: [Int] -> Int =
  fun xs ->
    case xs
    | [] => 0
    | _::xs => 1 + length(xs) end in

# Extract the first element of a list. #
let hd: [Int] -> Option =
  fun l ->
    case l
    | [] => None
    | x::xs => Some(x) end in

# Extract the rest of the list. #
let tl: [Int] -> [Int] =
  fun l ->
    case l
    | [] => []
    | x::xs => xs end in

# Determine if a list is empty. #
let is_empty: [Int] -> Bool =
  fun xs ->
    case xs
    | [] => true
    | _::_ => false end in

# Return the element at the index. #
let nth: ([Int], Int) -> Option =
  fun xs, n ->
    case xs, n
    | x::_, 0 => Some(x)
    | _::xs, n => nth(xs, n - 1)
    | [], _ => None end in

# Reverse a List. #
let rev: [Int] -> [Int] =
fun l -> 
let go: ([Int], [Int]) -> [Int] =
  fun xs, acc -> 
    case xs 
    | [] => acc 
    | x::xs => go(xs, x::acc) end in
go(l, []) in

# Check if two lists are equal #
let equal: ([Int], [Int]) -> Bool =
    fun p, xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => x == y && equal(xs, ys)
    | _ => false end
in

# Initialize a list with a given length using an initializer function #
let init: (Int, Int -> Int) -> [Int] =
    fun len, f ->
        let go: (Int, [Int]) -> [Int] =
        fun idx, xs ->
            if idx < len 
            then go(idx + 1, xs @ [f(idx)])   
            else xs
        in
        go(0, [])
in

# Reduce a list from the left. #
let fold_left: ((Int, Int) -> Int, Int, [Int]) -> Int =
  fun f, acc, xs ->
    case xs 
    | [] => acc
    | hd::tl => fold_left(f, f(acc, hd), tl) end in

# Reduce a list from the right. #
let fold_right: ((Int, Int) -> Int, [Int], Int) -> Int =
  fun f, xs, acc ->
    case xs
    | [] => acc
    | hd::tl => f(hd, fold_right(f, tl, acc)) end in


666
LSP: Prelude: String parsed successfully
LSP: Prelude: Info map generated successfully
Debug: true, Constrain: Types
LSP: Init: Recieved string: # Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)












































































































































LSP: Init: String parsed successfully
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: >( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {go: ((?, ?) -> [?]), filter: (((Int -> Bool), [Int]) -> [Int]), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: 
  LSP: Info: ALL errors:Error in term:
  p
Nature of error: type ((Int -> Bool), [Int]) is not consistent with arrow type    
Error in term:
  p
Nature of error: Variable p is not bound    
Error in term:
  p
Nature of error: Variable p is not bound
  LSP: Info: BidiCtx: Cls: Let expression
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent: Root
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: [?]
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: :: @
  LSP: Concave: Backpack: 
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new_tokens ::= whitespace | "," | "::" | "@"
root ::= new_tokens

Top 20 Logits:

:19.2377
#:15.2744
##:14.4271
let:14.2999
 :13.1147
    :12.5596
in:12.4659
  :12.4508
################:12.4419
   :12.4367
####:12.0299
/*:11.9564
```:11.9427
//:11.3717
                :11.3494
end:11.3456
        :11.2168
def:11.1992
[:11.144
(:11.1276
       :11.0957

================
# Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)














































































































































LSP: Prelude: Recieved string: ### List ###

# Add an element to the front of a list. #
let cons: (Int, [Int]) -> [Int] = fun x, xs -> x::xs in

# Determine the length of a list. #
let length: [Int] -> Int =
  fun xs ->
    case xs
    | [] => 0
    | _::xs => 1 + length(xs) end in

# Extract the first element of a list. #
let hd: [Int] -> Option =
  fun l ->
    case l
    | [] => None
    | x::xs => Some(x) end in

# Extract the rest of the list. #
let tl: [Int] -> [Int] =
  fun l ->
    case l
    | [] => []
    | x::xs => xs end in

# Determine if a list is empty. #
let is_empty: [Int] -> Bool =
  fun xs ->
    case xs
    | [] => true
    | _::_ => false end in

# Return the element at the index. #
let nth: ([Int], Int) -> Option =
  fun xs, n ->
    case xs, n
    | x::_, 0 => Some(x)
    | _::xs, n => nth(xs, n - 1)
    | [], _ => None end in

# Reverse a List. #
let rev: [Int] -> [Int] =
fun l -> 
let go: ([Int], [Int]) -> [Int] =
  fun xs, acc -> 
    case xs 
    | [] => acc 
    | x::xs => go(xs, x::acc) end in
go(l, []) in

# Check if two lists are equal #
let equal: ([Int], [Int]) -> Bool =
    fun p, xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => x == y && equal(xs, ys)
    | _ => false end
in

# Initialize a list with a given length using an initializer function #
let init: (Int, Int -> Int) -> [Int] =
    fun len, f ->
        let go: (Int, [Int]) -> [Int] =
        fun idx, xs ->
            if idx < len 
            then go(idx + 1, xs @ [f(idx)])   
            else xs
        in
        go(0, [])
in

# Reduce a list from the left. #
let fold_left: ((Int, Int) -> Int, Int, [Int]) -> Int =
  fun f, acc, xs ->
    case xs 
    | [] => acc
    | hd::tl => fold_left(f, f(acc, hd), tl) end in

# Reduce a list from the right. #
let fold_right: ((Int, Int) -> Int, [Int], Int) -> Int =
  fun f, xs, acc ->
    case xs
    | [] => acc
    | hd::tl => f(hd, fold_right(f, tl, acc)) end in


666
LSP: Prelude: String parsed successfully
LSP: Prelude: Info map generated successfully
Debug: true, Constrain: Types
LSP: Init: Recieved string: # Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)













































































































































LSP: Init: String parsed successfully
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: >( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {go: ((?, ?) -> [?]), filter: (((Int -> Bool), [Int]) -> [Int]), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: 
  LSP: Info: ALL errors:Error in term:
  p
Nature of error: Variable p is not bound    
Error in term:
  p
Nature of error: type ((Int -> Bool), [Int]) is not consistent with arrow type    
Error in term:
  p
Nature of error: Variable p is not bound
  LSP: Info: BidiCtx: Cls: Let expression
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent: Root
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: [?]
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: :: @
  LSP: Concave: Backpack: 
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new_tokens ::= whitespace | "," | "::" | "@"
root ::= new_tokens

Top 20 Logits:

:19.2512
#:15.2714
##:14.4476
let:14.3041
 :13.1193
    :12.5607
################:12.4543
  :12.4506
   :12.4403
in:12.3917
####:12.0446
/*:11.9532
```:11.9466
//:11.3683
                :11.347
end:11.3151
        :11.2139
def:11.1959
[:11.1619
(:11.1318
       :11.0963

================
# Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)















































































































































LSP: Prelude: Recieved string: ### List ###

# Add an element to the front of a list. #
let cons: (Int, [Int]) -> [Int] = fun x, xs -> x::xs in

# Determine the length of a list. #
let length: [Int] -> Int =
  fun xs ->
    case xs
    | [] => 0
    | _::xs => 1 + length(xs) end in

# Extract the first element of a list. #
let hd: [Int] -> Option =
  fun l ->
    case l
    | [] => None
    | x::xs => Some(x) end in

# Extract the rest of the list. #
let tl: [Int] -> [Int] =
  fun l ->
    case l
    | [] => []
    | x::xs => xs end in

# Determine if a list is empty. #
let is_empty: [Int] -> Bool =
  fun xs ->
    case xs
    | [] => true
    | _::_ => false end in

# Return the element at the index. #
let nth: ([Int], Int) -> Option =
  fun xs, n ->
    case xs, n
    | x::_, 0 => Some(x)
    | _::xs, n => nth(xs, n - 1)
    | [], _ => None end in

# Reverse a List. #
let rev: [Int] -> [Int] =
fun l -> 
let go: ([Int], [Int]) -> [Int] =
  fun xs, acc -> 
    case xs 
    | [] => acc 
    | x::xs => go(xs, x::acc) end in
go(l, []) in

# Check if two lists are equal #
let equal: ([Int], [Int]) -> Bool =
    fun p, xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => x == y && equal(xs, ys)
    | _ => false end
in

# Initialize a list with a given length using an initializer function #
let init: (Int, Int -> Int) -> [Int] =
    fun len, f ->
        let go: (Int, [Int]) -> [Int] =
        fun idx, xs ->
            if idx < len 
            then go(idx + 1, xs @ [f(idx)])   
            else xs
        in
        go(0, [])
in

# Reduce a list from the left. #
let fold_left: ((Int, Int) -> Int, Int, [Int]) -> Int =
  fun f, acc, xs ->
    case xs 
    | [] => acc
    | hd::tl => fold_left(f, f(acc, hd), tl) end in

# Reduce a list from the right. #
let fold_right: ((Int, Int) -> Int, [Int], Int) -> Int =
  fun f, xs, acc ->
    case xs
    | [] => acc
    | hd::tl => f(hd, fold_right(f, tl, acc)) end in


666
LSP: Prelude: String parsed successfully
LSP: Prelude: Info map generated successfully
Debug: true, Constrain: Types
LSP: Init: Recieved string: # Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)














































































































































LSP: Init: String parsed successfully
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: >( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {go: ((?, ?) -> [?]), filter: (((Int -> Bool), [Int]) -> [Int]), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: 
  LSP: Info: ALL errors:Error in term:
  p
Nature of error: Variable p is not bound    
Error in term:
  p
Nature of error: type ((Int -> Bool), [Int]) is not consistent with arrow type    
Error in term:
  p
Nature of error: Variable p is not bound
  LSP: Info: BidiCtx: Cls: Let expression
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent: Root
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: [?]
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: :: @
  LSP: Concave: Backpack: 
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new_tokens ::= whitespace | "," | "::" | "@"
root ::= new_tokens

Top 20 Logits:

:19.2671
#:15.2707
##:14.4715
let:14.3072
 :13.1239
    :12.5615
################:12.467
  :12.4549
   :12.4428
in:12.3347
####:12.0631
```:11.9584
/*:11.9497
//:11.3659
                :11.3462
end:11.2852
        :11.2151
def:11.196
[:11.18
(:11.1417
       :11.1002

================
# Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)
















































































































































LSP: Prelude: Recieved string: ### List ###

# Add an element to the front of a list. #
let cons: (Int, [Int]) -> [Int] = fun x, xs -> x::xs in

# Determine the length of a list. #
let length: [Int] -> Int =
  fun xs ->
    case xs
    | [] => 0
    | _::xs => 1 + length(xs) end in

# Extract the first element of a list. #
let hd: [Int] -> Option =
  fun l ->
    case l
    | [] => None
    | x::xs => Some(x) end in

# Extract the rest of the list. #
let tl: [Int] -> [Int] =
  fun l ->
    case l
    | [] => []
    | x::xs => xs end in

# Determine if a list is empty. #
let is_empty: [Int] -> Bool =
  fun xs ->
    case xs
    | [] => true
    | _::_ => false end in

# Return the element at the index. #
let nth: ([Int], Int) -> Option =
  fun xs, n ->
    case xs, n
    | x::_, 0 => Some(x)
    | _::xs, n => nth(xs, n - 1)
    | [], _ => None end in

# Reverse a List. #
let rev: [Int] -> [Int] =
fun l -> 
let go: ([Int], [Int]) -> [Int] =
  fun xs, acc -> 
    case xs 
    | [] => acc 
    | x::xs => go(xs, x::acc) end in
go(l, []) in

# Check if two lists are equal #
let equal: ([Int], [Int]) -> Bool =
    fun p, xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => x == y && equal(xs, ys)
    | _ => false end
in

# Initialize a list with a given length using an initializer function #
let init: (Int, Int -> Int) -> [Int] =
    fun len, f ->
        let go: (Int, [Int]) -> [Int] =
        fun idx, xs ->
            if idx < len 
            then go(idx + 1, xs @ [f(idx)])   
            else xs
        in
        go(0, [])
in

# Reduce a list from the left. #
let fold_left: ((Int, Int) -> Int, Int, [Int]) -> Int =
  fun f, acc, xs ->
    case xs 
    | [] => acc
    | hd::tl => fold_left(f, f(acc, hd), tl) end in

# Reduce a list from the right. #
let fold_right: ((Int, Int) -> Int, [Int], Int) -> Int =
  fun f, xs, acc ->
    case xs
    | [] => acc
    | hd::tl => f(hd, fold_right(f, tl, acc)) end in


666
LSP: Prelude: String parsed successfully
LSP: Prelude: Info map generated successfully
Debug: true, Constrain: Types
LSP: Init: Recieved string: # Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)















































































































































LSP: Init: String parsed successfully
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: >( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {go: ((?, ?) -> [?]), filter: (((Int -> Bool), [Int]) -> [Int]), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: 
  LSP: Info: ALL errors:Error in term:
  p
Nature of error: Variable p is not bound    
Error in term:
  p
Nature of error: type ((Int -> Bool), [Int]) is not consistent with arrow type    
Error in term:
  p
Nature of error: Variable p is not bound
  LSP: Info: BidiCtx: Cls: Let expression
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent: Root
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: [?]
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: :: @
  LSP: Concave: Backpack: 
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new_tokens ::= whitespace | "," | "::" | "@"
root ::= new_tokens

Top 20 Logits:

:19.283
#:15.2702
##:14.4856
let:14.3109
 :13.1251
    :12.5587
################:12.4736
  :12.4603
   :12.4399
in:12.3242
####:12.0748
```:11.9691
/*:11.9482
//:11.3655
                :11.3471
end:11.2672
        :11.2175
def:11.1995
[:11.1917
(:11.1487
       :11.1029

================
# Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)

















































































































































LSP: Prelude: Recieved string: ### List ###

# Add an element to the front of a list. #
let cons: (Int, [Int]) -> [Int] = fun x, xs -> x::xs in

# Determine the length of a list. #
let length: [Int] -> Int =
  fun xs ->
    case xs
    | [] => 0
    | _::xs => 1 + length(xs) end in

# Extract the first element of a list. #
let hd: [Int] -> Option =
  fun l ->
    case l
    | [] => None
    | x::xs => Some(x) end in

# Extract the rest of the list. #
let tl: [Int] -> [Int] =
  fun l ->
    case l
    | [] => []
    | x::xs => xs end in

# Determine if a list is empty. #
let is_empty: [Int] -> Bool =
  fun xs ->
    case xs
    | [] => true
    | _::_ => false end in

# Return the element at the index. #
let nth: ([Int], Int) -> Option =
  fun xs, n ->
    case xs, n
    | x::_, 0 => Some(x)
    | _::xs, n => nth(xs, n - 1)
    | [], _ => None end in

# Reverse a List. #
let rev: [Int] -> [Int] =
fun l -> 
let go: ([Int], [Int]) -> [Int] =
  fun xs, acc -> 
    case xs 
    | [] => acc 
    | x::xs => go(xs, x::acc) end in
go(l, []) in

# Check if two lists are equal #
let equal: ([Int], [Int]) -> Bool =
    fun p, xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => x == y && equal(xs, ys)
    | _ => false end
in

# Initialize a list with a given length using an initializer function #
let init: (Int, Int -> Int) -> [Int] =
    fun len, f ->
        let go: (Int, [Int]) -> [Int] =
        fun idx, xs ->
            if idx < len 
            then go(idx + 1, xs @ [f(idx)])   
            else xs
        in
        go(0, [])
in

# Reduce a list from the left. #
let fold_left: ((Int, Int) -> Int, Int, [Int]) -> Int =
  fun f, acc, xs ->
    case xs 
    | [] => acc
    | hd::tl => fold_left(f, f(acc, hd), tl) end in

# Reduce a list from the right. #
let fold_right: ((Int, Int) -> Int, [Int], Int) -> Int =
  fun f, xs, acc ->
    case xs
    | [] => acc
    | hd::tl => f(hd, fold_right(f, tl, acc)) end in


666
LSP: Prelude: String parsed successfully
LSP: Prelude: Info map generated successfully
Debug: true, Constrain: Types
LSP: Init: Recieved string: # Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)
















































































































































LSP: Init: String parsed successfully
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: >( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {go: ((?, ?) -> [?]), filter: (((Int -> Bool), [Int]) -> [Int]), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: 
  LSP: Info: ALL errors:Error in term:
  p
Nature of error: Variable p is not bound    
Error in term:
  p
Nature of error: type ((Int -> Bool), [Int]) is not consistent with arrow type    
Error in term:
  p
Nature of error: Variable p is not bound
  LSP: Info: BidiCtx: Cls: Let expression
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent: Root
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: [?]
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: :: @
  LSP: Concave: Backpack: 
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new_tokens ::= whitespace | "," | "::" | "@"
root ::= new_tokens

Top 20 Logits:

:19.2953
#:15.2664
##:14.4811
let:14.3139
 :13.1215
    :12.5524
################:12.4701
  :12.4618
   :12.4302
in:12.3593
####:12.0727
```:11.9703
/*:11.9495
//:11.3665
                :11.3471
end:11.265
        :11.2178
def:11.2048
[:11.1896
(:11.147
       :11.1004

================
# Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)


















































































































































LSP: Prelude: Recieved string: ### List ###

# Add an element to the front of a list. #
let cons: (Int, [Int]) -> [Int] = fun x, xs -> x::xs in

# Determine the length of a list. #
let length: [Int] -> Int =
  fun xs ->
    case xs
    | [] => 0
    | _::xs => 1 + length(xs) end in

# Extract the first element of a list. #
let hd: [Int] -> Option =
  fun l ->
    case l
    | [] => None
    | x::xs => Some(x) end in

# Extract the rest of the list. #
let tl: [Int] -> [Int] =
  fun l ->
    case l
    | [] => []
    | x::xs => xs end in

# Determine if a list is empty. #
let is_empty: [Int] -> Bool =
  fun xs ->
    case xs
    | [] => true
    | _::_ => false end in

# Return the element at the index. #
let nth: ([Int], Int) -> Option =
  fun xs, n ->
    case xs, n
    | x::_, 0 => Some(x)
    | _::xs, n => nth(xs, n - 1)
    | [], _ => None end in

# Reverse a List. #
let rev: [Int] -> [Int] =
fun l -> 
let go: ([Int], [Int]) -> [Int] =
  fun xs, acc -> 
    case xs 
    | [] => acc 
    | x::xs => go(xs, x::acc) end in
go(l, []) in

# Check if two lists are equal #
let equal: ([Int], [Int]) -> Bool =
    fun p, xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => x == y && equal(xs, ys)
    | _ => false end
in

# Initialize a list with a given length using an initializer function #
let init: (Int, Int -> Int) -> [Int] =
    fun len, f ->
        let go: (Int, [Int]) -> [Int] =
        fun idx, xs ->
            if idx < len 
            then go(idx + 1, xs @ [f(idx)])   
            else xs
        in
        go(0, [])
in

# Reduce a list from the left. #
let fold_left: ((Int, Int) -> Int, Int, [Int]) -> Int =
  fun f, acc, xs ->
    case xs 
    | [] => acc
    | hd::tl => fold_left(f, f(acc, hd), tl) end in

# Reduce a list from the right. #
let fold_right: ((Int, Int) -> Int, [Int], Int) -> Int =
  fun f, xs, acc ->
    case xs
    | [] => acc
    | hd::tl => f(hd, fold_right(f, tl, acc)) end in


666
LSP: Prelude: String parsed successfully
LSP: Prelude: Info map generated successfully
Debug: true, Constrain: Types
LSP: Init: Recieved string: # Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)

















































































































































LSP: Init: String parsed successfully
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: >( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {go: ((?, ?) -> [?]), filter: (((Int -> Bool), [Int]) -> [Int]), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: 
  LSP: Info: ALL errors:Error in term:
  p
Nature of error: Variable p is not bound    
Error in term:
  p
Nature of error: type ((Int -> Bool), [Int]) is not consistent with arrow type    
Error in term:
  p
Nature of error: Variable p is not bound
  LSP: Info: BidiCtx: Cls: Let expression
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent: Root
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: [?]
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: :: @
  LSP: Concave: Backpack: 
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new_tokens ::= whitespace | "," | "::" | "@"
root ::= new_tokens

Top 20 Logits:

:19.3014
#:15.2579
##:14.4615
let:14.3157
 :13.1145
    :12.5447
################:12.4572
  :12.4558
   :12.4164
in:12.4111
####:12.0583
```:11.9568
/*:11.9538
//:11.3672
                :11.3416
end:11.2707
        :11.2131
def:11.2109
[:11.1752
(:11.1376
       :11.0905

================
# Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)



















































































































































LSP: Prelude: Recieved string: ### List ###

# Add an element to the front of a list. #
let cons: (Int, [Int]) -> [Int] = fun x, xs -> x::xs in

# Determine the length of a list. #
let length: [Int] -> Int =
  fun xs ->
    case xs
    | [] => 0
    | _::xs => 1 + length(xs) end in

# Extract the first element of a list. #
let hd: [Int] -> Option =
  fun l ->
    case l
    | [] => None
    | x::xs => Some(x) end in

# Extract the rest of the list. #
let tl: [Int] -> [Int] =
  fun l ->
    case l
    | [] => []
    | x::xs => xs end in

# Determine if a list is empty. #
let is_empty: [Int] -> Bool =
  fun xs ->
    case xs
    | [] => true
    | _::_ => false end in

# Return the element at the index. #
let nth: ([Int], Int) -> Option =
  fun xs, n ->
    case xs, n
    | x::_, 0 => Some(x)
    | _::xs, n => nth(xs, n - 1)
    | [], _ => None end in

# Reverse a List. #
let rev: [Int] -> [Int] =
fun l -> 
let go: ([Int], [Int]) -> [Int] =
  fun xs, acc -> 
    case xs 
    | [] => acc 
    | x::xs => go(xs, x::acc) end in
go(l, []) in

# Check if two lists are equal #
let equal: ([Int], [Int]) -> Bool =
    fun p, xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => x == y && equal(xs, ys)
    | _ => false end
in

# Initialize a list with a given length using an initializer function #
let init: (Int, Int -> Int) -> [Int] =
    fun len, f ->
        let go: (Int, [Int]) -> [Int] =
        fun idx, xs ->
            if idx < len 
            then go(idx + 1, xs @ [f(idx)])   
            else xs
        in
        go(0, [])
in

# Reduce a list from the left. #
let fold_left: ((Int, Int) -> Int, Int, [Int]) -> Int =
  fun f, acc, xs ->
    case xs 
    | [] => acc
    | hd::tl => fold_left(f, f(acc, hd), tl) end in

# Reduce a list from the right. #
let fold_right: ((Int, Int) -> Int, [Int], Int) -> Int =
  fun f, xs, acc ->
    case xs
    | [] => acc
    | hd::tl => f(hd, fold_right(f, tl, acc)) end in


666
LSP: Prelude: String parsed successfully
LSP: Prelude: Info map generated successfully
Debug: true, Constrain: Types
LSP: Init: Recieved string: # Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)


















































































































































LSP: Init: String parsed successfully
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: >( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {go: ((?, ?) -> [?]), filter: (((Int -> Bool), [Int]) -> [Int]), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: 
  LSP: Info: ALL errors:Error in term:
  p
Nature of error: Variable p is not bound    
Error in term:
  p
Nature of error: Variable p is not bound    
Error in term:
  p
Nature of error: type ((Int -> Bool), [Int]) is not consistent with arrow type
  LSP: Info: BidiCtx: Cls: Let expression
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent: Root
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: [?]
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: :: @
  LSP: Concave: Backpack: 
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new_tokens ::= whitespace | "," | "::" | "@"
root ::= new_tokens

Top 20 Logits:

:19.3038
#:15.2503
##:14.4429
let:14.3188
 :13.1084
    :12.5396
in:12.446
  :12.4447
################:12.4432
   :12.4048
####:12.0429
/*:11.9592
```:11.9358
//:11.368
                :11.3315
end:11.2766
def:11.2148
        :11.2048
[:11.161
(:11.1285
       :11.0772

================
# Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)




















































































































































LSP: Prelude: Recieved string: ### List ###

# Add an element to the front of a list. #
let cons: (Int, [Int]) -> [Int] = fun x, xs -> x::xs in

# Determine the length of a list. #
let length: [Int] -> Int =
  fun xs ->
    case xs
    | [] => 0
    | _::xs => 1 + length(xs) end in

# Extract the first element of a list. #
let hd: [Int] -> Option =
  fun l ->
    case l
    | [] => None
    | x::xs => Some(x) end in

# Extract the rest of the list. #
let tl: [Int] -> [Int] =
  fun l ->
    case l
    | [] => []
    | x::xs => xs end in

# Determine if a list is empty. #
let is_empty: [Int] -> Bool =
  fun xs ->
    case xs
    | [] => true
    | _::_ => false end in

# Return the element at the index. #
let nth: ([Int], Int) -> Option =
  fun xs, n ->
    case xs, n
    | x::_, 0 => Some(x)
    | _::xs, n => nth(xs, n - 1)
    | [], _ => None end in

# Reverse a List. #
let rev: [Int] -> [Int] =
fun l -> 
let go: ([Int], [Int]) -> [Int] =
  fun xs, acc -> 
    case xs 
    | [] => acc 
    | x::xs => go(xs, x::acc) end in
go(l, []) in

# Check if two lists are equal #
let equal: ([Int], [Int]) -> Bool =
    fun p, xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => x == y && equal(xs, ys)
    | _ => false end
in

# Initialize a list with a given length using an initializer function #
let init: (Int, Int -> Int) -> [Int] =
    fun len, f ->
        let go: (Int, [Int]) -> [Int] =
        fun idx, xs ->
            if idx < len 
            then go(idx + 1, xs @ [f(idx)])   
            else xs
        in
        go(0, [])
in

# Reduce a list from the left. #
let fold_left: ((Int, Int) -> Int, Int, [Int]) -> Int =
  fun f, acc, xs ->
    case xs 
    | [] => acc
    | hd::tl => fold_left(f, f(acc, hd), tl) end in

# Reduce a list from the right. #
let fold_right: ((Int, Int) -> Int, [Int], Int) -> Int =
  fun f, xs, acc ->
    case xs
    | [] => acc
    | hd::tl => f(hd, fold_right(f, tl, acc)) end in


666
LSP: Prelude: String parsed successfully
LSP: Prelude: Info map generated successfully
Debug: true, Constrain: Types
LSP: Init: Recieved string: # Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)



















































































































































LSP: Init: String parsed successfully
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: >( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {go: ((?, ?) -> [?]), filter: (((Int -> Bool), [Int]) -> [Int]), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: 
  LSP: Info: ALL errors:Error in term:
  p
Nature of error: type ((Int -> Bool), [Int]) is not consistent with arrow type    
Error in term:
  p
Nature of error: Variable p is not bound    
Error in term:
  p
Nature of error: Variable p is not bound
  LSP: Info: BidiCtx: Cls: Let expression
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent: Root
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: [?]
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: :: @
  LSP: Concave: Backpack: 
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new_tokens ::= whitespace | "," | "::" | "@"
root ::= new_tokens

Top 20 Logits:

:19.3087
#:15.2498
##:14.441
let:14.3238
 :13.1065
    :12.5381
in:12.4511
################:12.4396
  :12.4325
   :12.4002
####:12.0386
/*:11.9618
```:11.9221
//:11.3697
                :11.3222
end:11.2806
def:11.2159
        :11.1975
[:11.1587
(:11.1272
       :11.0681

================
# Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)





















































































































































LSP: Prelude: Recieved string: ### List ###

# Add an element to the front of a list. #
let cons: (Int, [Int]) -> [Int] = fun x, xs -> x::xs in

# Determine the length of a list. #
let length: [Int] -> Int =
  fun xs ->
    case xs
    | [] => 0
    | _::xs => 1 + length(xs) end in

# Extract the first element of a list. #
let hd: [Int] -> Option =
  fun l ->
    case l
    | [] => None
    | x::xs => Some(x) end in

# Extract the rest of the list. #
let tl: [Int] -> [Int] =
  fun l ->
    case l
    | [] => []
    | x::xs => xs end in

# Determine if a list is empty. #
let is_empty: [Int] -> Bool =
  fun xs ->
    case xs
    | [] => true
    | _::_ => false end in

# Return the element at the index. #
let nth: ([Int], Int) -> Option =
  fun xs, n ->
    case xs, n
    | x::_, 0 => Some(x)
    | _::xs, n => nth(xs, n - 1)
    | [], _ => None end in

# Reverse a List. #
let rev: [Int] -> [Int] =
fun l -> 
let go: ([Int], [Int]) -> [Int] =
  fun xs, acc -> 
    case xs 
    | [] => acc 
    | x::xs => go(xs, x::acc) end in
go(l, []) in

# Check if two lists are equal #
let equal: ([Int], [Int]) -> Bool =
    fun p, xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => x == y && equal(xs, ys)
    | _ => false end
in

# Initialize a list with a given length using an initializer function #
let init: (Int, Int -> Int) -> [Int] =
    fun len, f ->
        let go: (Int, [Int]) -> [Int] =
        fun idx, xs ->
            if idx < len 
            then go(idx + 1, xs @ [f(idx)])   
            else xs
        in
        go(0, [])
in

# Reduce a list from the left. #
let fold_left: ((Int, Int) -> Int, Int, [Int]) -> Int =
  fun f, acc, xs ->
    case xs 
    | [] => acc
    | hd::tl => fold_left(f, f(acc, hd), tl) end in

# Reduce a list from the right. #
let fold_right: ((Int, Int) -> Int, [Int], Int) -> Int =
  fun f, xs, acc ->
    case xs
    | [] => acc
    | hd::tl => f(hd, fold_right(f, tl, acc)) end in


666
LSP: Prelude: String parsed successfully
LSP: Prelude: Info map generated successfully
Debug: true, Constrain: Types
LSP: Init: Recieved string: # Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)




















































































































































LSP: Init: String parsed successfully
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: >( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {go: ((?, ?) -> [?]), filter: (((Int -> Bool), [Int]) -> [Int]), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: 
  LSP: Info: ALL errors:Error in term:
  p
Nature of error: type ((Int -> Bool), [Int]) is not consistent with arrow type    
Error in term:
  p
Nature of error: Variable p is not bound    
Error in term:
  p
Nature of error: Variable p is not bound
  LSP: Info: BidiCtx: Cls: Let expression
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent: Root
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: [?]
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: :: @
  LSP: Concave: Backpack: 
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new_tokens ::= whitespace | "," | "::" | "@"
root ::= new_tokens

Top 20 Logits:

:19.3181
#:15.2574
##:14.4564
let:14.3296
 :13.1075
    :12.5359
################:12.4475
in:12.4382
  :12.4212
   :12.4018
####:12.0462
/*:11.9602
```:11.9238
//:11.3711
                :11.3162
end:11.2803
def:11.2152
        :11.1927
[:11.1712
(:11.1339
       :11.0663

================
# Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)






















































































































































LSP: Prelude: Recieved string: ### List ###

# Add an element to the front of a list. #
let cons: (Int, [Int]) -> [Int] = fun x, xs -> x::xs in

# Determine the length of a list. #
let length: [Int] -> Int =
  fun xs ->
    case xs
    | [] => 0
    | _::xs => 1 + length(xs) end in

# Extract the first element of a list. #
let hd: [Int] -> Option =
  fun l ->
    case l
    | [] => None
    | x::xs => Some(x) end in

# Extract the rest of the list. #
let tl: [Int] -> [Int] =
  fun l ->
    case l
    | [] => []
    | x::xs => xs end in

# Determine if a list is empty. #
let is_empty: [Int] -> Bool =
  fun xs ->
    case xs
    | [] => true
    | _::_ => false end in

# Return the element at the index. #
let nth: ([Int], Int) -> Option =
  fun xs, n ->
    case xs, n
    | x::_, 0 => Some(x)
    | _::xs, n => nth(xs, n - 1)
    | [], _ => None end in

# Reverse a List. #
let rev: [Int] -> [Int] =
fun l -> 
let go: ([Int], [Int]) -> [Int] =
  fun xs, acc -> 
    case xs 
    | [] => acc 
    | x::xs => go(xs, x::acc) end in
go(l, []) in

# Check if two lists are equal #
let equal: ([Int], [Int]) -> Bool =
    fun p, xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => x == y && equal(xs, ys)
    | _ => false end
in

# Initialize a list with a given length using an initializer function #
let init: (Int, Int -> Int) -> [Int] =
    fun len, f ->
        let go: (Int, [Int]) -> [Int] =
        fun idx, xs ->
            if idx < len 
            then go(idx + 1, xs @ [f(idx)])   
            else xs
        in
        go(0, [])
in

# Reduce a list from the left. #
let fold_left: ((Int, Int) -> Int, Int, [Int]) -> Int =
  fun f, acc, xs ->
    case xs 
    | [] => acc
    | hd::tl => fold_left(f, f(acc, hd), tl) end in

# Reduce a list from the right. #
let fold_right: ((Int, Int) -> Int, [Int], Int) -> Int =
  fun f, xs, acc ->
    case xs
    | [] => acc
    | hd::tl => f(hd, fold_right(f, tl, acc)) end in


666
LSP: Prelude: String parsed successfully
LSP: Prelude: Info map generated successfully
Debug: true, Constrain: Types
LSP: Init: Recieved string: # Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)





















































































































































LSP: Init: String parsed successfully
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: >( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {go: ((?, ?) -> [?]), filter: (((Int -> Bool), [Int]) -> [Int]), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: 
  LSP: Info: ALL errors:Error in term:
  p
Nature of error: Variable p is not bound    
Error in term:
  p
Nature of error: type ((Int -> Bool), [Int]) is not consistent with arrow type    
Error in term:
  p
Nature of error: Variable p is not bound
  LSP: Info: BidiCtx: Cls: Let expression
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent: Root
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: [?]
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: :: @
  LSP: Concave: Backpack: 
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new_tokens ::= whitespace | "," | "::" | "@"
root ::= new_tokens

Top 20 Logits:

:19.3314
#:15.2704
##:14.4772
let:14.3364
 :13.1104
    :12.5309
################:12.4591
in:12.4358
  :12.4139
   :12.4075
####:12.0576
/*:11.9547
```:11.9359
//:11.3691
                :11.3155
end:11.2808
def:11.2139
[:11.1915
        :11.1908
(:11.1423
       :11.0702

================
# Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)























































































































































LSP: Prelude: Recieved string: ### List ###

# Add an element to the front of a list. #
let cons: (Int, [Int]) -> [Int] = fun x, xs -> x::xs in

# Determine the length of a list. #
let length: [Int] -> Int =
  fun xs ->
    case xs
    | [] => 0
    | _::xs => 1 + length(xs) end in

# Extract the first element of a list. #
let hd: [Int] -> Option =
  fun l ->
    case l
    | [] => None
    | x::xs => Some(x) end in

# Extract the rest of the list. #
let tl: [Int] -> [Int] =
  fun l ->
    case l
    | [] => []
    | x::xs => xs end in

# Determine if a list is empty. #
let is_empty: [Int] -> Bool =
  fun xs ->
    case xs
    | [] => true
    | _::_ => false end in

# Return the element at the index. #
let nth: ([Int], Int) -> Option =
  fun xs, n ->
    case xs, n
    | x::_, 0 => Some(x)
    | _::xs, n => nth(xs, n - 1)
    | [], _ => None end in

# Reverse a List. #
let rev: [Int] -> [Int] =
fun l -> 
let go: ([Int], [Int]) -> [Int] =
  fun xs, acc -> 
    case xs 
    | [] => acc 
    | x::xs => go(xs, x::acc) end in
go(l, []) in

# Check if two lists are equal #
let equal: ([Int], [Int]) -> Bool =
    fun p, xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => x == y && equal(xs, ys)
    | _ => false end
in

# Initialize a list with a given length using an initializer function #
let init: (Int, Int -> Int) -> [Int] =
    fun len, f ->
        let go: (Int, [Int]) -> [Int] =
        fun idx, xs ->
            if idx < len 
            then go(idx + 1, xs @ [f(idx)])   
            else xs
        in
        go(0, [])
in

# Reduce a list from the left. #
let fold_left: ((Int, Int) -> Int, Int, [Int]) -> Int =
  fun f, acc, xs ->
    case xs 
    | [] => acc
    | hd::tl => fold_left(f, f(acc, hd), tl) end in

# Reduce a list from the right. #
let fold_right: ((Int, Int) -> Int, [Int], Int) -> Int =
  fun f, xs, acc ->
    case xs
    | [] => acc
    | hd::tl => f(hd, fold_right(f, tl, acc)) end in


666
LSP: Prelude: String parsed successfully
LSP: Prelude: Info map generated successfully
Debug: true, Constrain: Types
LSP: Init: Recieved string: # Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)






















































































































































LSP: Init: String parsed successfully
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: >( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {go: ((?, ?) -> [?]), filter: (((Int -> Bool), [Int]) -> [Int]), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: 
  LSP: Info: ALL errors:Error in term:
  p
Nature of error: Variable p is not bound    
Error in term:
  p
Nature of error: Variable p is not bound    
Error in term:
  p
Nature of error: type ((Int -> Bool), [Int]) is not consistent with arrow type
  LSP: Info: BidiCtx: Cls: Let expression
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent: Root
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: [?]
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: :: @
  LSP: Concave: Backpack: 
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new_tokens ::= whitespace | "," | "::" | "@"
root ::= new_tokens

Top 20 Logits:

:19.3452
#:15.2821
##:14.4867
let:14.3434
 :13.1135
    :12.5242
################:12.4674
in:12.4663
  :12.4132
   :12.4126
####:12.0621
```:11.9472
/*:11.9471
//:11.3637
                :11.3193
end:11.2883
def:11.212
[:11.2055
        :11.1908
(:11.1466
       :11.0751

================
# Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)
























































































































































LSP: Prelude: Recieved string: ### List ###

# Add an element to the front of a list. #
let cons: (Int, [Int]) -> [Int] = fun x, xs -> x::xs in

# Determine the length of a list. #
let length: [Int] -> Int =
  fun xs ->
    case xs
    | [] => 0
    | _::xs => 1 + length(xs) end in

# Extract the first element of a list. #
let hd: [Int] -> Option =
  fun l ->
    case l
    | [] => None
    | x::xs => Some(x) end in

# Extract the rest of the list. #
let tl: [Int] -> [Int] =
  fun l ->
    case l
    | [] => []
    | x::xs => xs end in

# Determine if a list is empty. #
let is_empty: [Int] -> Bool =
  fun xs ->
    case xs
    | [] => true
    | _::_ => false end in

# Return the element at the index. #
let nth: ([Int], Int) -> Option =
  fun xs, n ->
    case xs, n
    | x::_, 0 => Some(x)
    | _::xs, n => nth(xs, n - 1)
    | [], _ => None end in

# Reverse a List. #
let rev: [Int] -> [Int] =
fun l -> 
let go: ([Int], [Int]) -> [Int] =
  fun xs, acc -> 
    case xs 
    | [] => acc 
    | x::xs => go(xs, x::acc) end in
go(l, []) in

# Check if two lists are equal #
let equal: ([Int], [Int]) -> Bool =
    fun p, xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => x == y && equal(xs, ys)
    | _ => false end
in

# Initialize a list with a given length using an initializer function #
let init: (Int, Int -> Int) -> [Int] =
    fun len, f ->
        let go: (Int, [Int]) -> [Int] =
        fun idx, xs ->
            if idx < len 
            then go(idx + 1, xs @ [f(idx)])   
            else xs
        in
        go(0, [])
in

# Reduce a list from the left. #
let fold_left: ((Int, Int) -> Int, Int, [Int]) -> Int =
  fun f, acc, xs ->
    case xs 
    | [] => acc
    | hd::tl => fold_left(f, f(acc, hd), tl) end in

# Reduce a list from the right. #
let fold_right: ((Int, Int) -> Int, [Int], Int) -> Int =
  fun f, xs, acc ->
    case xs
    | [] => acc
    | hd::tl => f(hd, fold_right(f, tl, acc)) end in


666
LSP: Prelude: String parsed successfully
LSP: Prelude: Info map generated successfully
Debug: true, Constrain: Types
LSP: Init: Recieved string: # Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)























































































































































LSP: Init: String parsed successfully
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: >( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {go: ((?, ?) -> [?]), filter: (((Int -> Bool), [Int]) -> [Int]), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: 
  LSP: Info: ALL errors:Error in term:
  p
Nature of error: Variable p is not bound    
Error in term:
  p
Nature of error: Variable p is not bound    
Error in term:
  p
Nature of error: type ((Int -> Bool), [Int]) is not consistent with arrow type
  LSP: Info: BidiCtx: Cls: Let expression
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent: Root
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: [?]
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: :: @
  LSP: Concave: Backpack: 
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new_tokens ::= whitespace | "," | "::" | "@"
root ::= new_tokens

Top 20 Logits:

:19.354
#:15.2851
##:14.477
let:14.3482
 :13.1139
in:12.5196
    :12.5189
################:12.4687
  :12.4164
   :12.4128
####:12.0549
```:11.9471
/*:11.9425
//:11.3585
                :11.3213
end:11.2992
def:11.2083
[:11.2048
        :11.19
(:11.1452
       :11.0754

================
# Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)

























































































































































LSP: Prelude: Recieved string: ### List ###

# Add an element to the front of a list. #
let cons: (Int, [Int]) -> [Int] = fun x, xs -> x::xs in

# Determine the length of a list. #
let length: [Int] -> Int =
  fun xs ->
    case xs
    | [] => 0
    | _::xs => 1 + length(xs) end in

# Extract the first element of a list. #
let hd: [Int] -> Option =
  fun l ->
    case l
    | [] => None
    | x::xs => Some(x) end in

# Extract the rest of the list. #
let tl: [Int] -> [Int] =
  fun l ->
    case l
    | [] => []
    | x::xs => xs end in

# Determine if a list is empty. #
let is_empty: [Int] -> Bool =
  fun xs ->
    case xs
    | [] => true
    | _::_ => false end in

# Return the element at the index. #
let nth: ([Int], Int) -> Option =
  fun xs, n ->
    case xs, n
    | x::_, 0 => Some(x)
    | _::xs, n => nth(xs, n - 1)
    | [], _ => None end in

# Reverse a List. #
let rev: [Int] -> [Int] =
fun l -> 
let go: ([Int], [Int]) -> [Int] =
  fun xs, acc -> 
    case xs 
    | [] => acc 
    | x::xs => go(xs, x::acc) end in
go(l, []) in

# Check if two lists are equal #
let equal: ([Int], [Int]) -> Bool =
    fun p, xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => x == y && equal(xs, ys)
    | _ => false end
in

# Initialize a list with a given length using an initializer function #
let init: (Int, Int -> Int) -> [Int] =
    fun len, f ->
        let go: (Int, [Int]) -> [Int] =
        fun idx, xs ->
            if idx < len 
            then go(idx + 1, xs @ [f(idx)])   
            else xs
        in
        go(0, [])
in

# Reduce a list from the left. #
let fold_left: ((Int, Int) -> Int, Int, [Int]) -> Int =
  fun f, acc, xs ->
    case xs 
    | [] => acc
    | hd::tl => fold_left(f, f(acc, hd), tl) end in

# Reduce a list from the right. #
let fold_right: ((Int, Int) -> Int, [Int], Int) -> Int =
  fun f, xs, acc ->
    case xs
    | [] => acc
    | hd::tl => f(hd, fold_right(f, tl, acc)) end in


666
LSP: Prelude: String parsed successfully
LSP: Prelude: Info map generated successfully
Debug: true, Constrain: Types
LSP: Init: Recieved string: # Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)
























































































































































LSP: Init: String parsed successfully
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: >( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {go: ((?, ?) -> [?]), filter: (((Int -> Bool), [Int]) -> [Int]), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: 
  LSP: Info: ALL errors:Error in term:
  p
Nature of error: Variable p is not bound    
Error in term:
  p
Nature of error: type ((Int -> Bool), [Int]) is not consistent with arrow type    
Error in term:
  p
Nature of error: Variable p is not bound
  LSP: Info: BidiCtx: Cls: Let expression
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent: Root
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: [?]
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: :: @
  LSP: Concave: Backpack: 
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new_tokens ::= whitespace | "," | "::" | "@"
root ::= new_tokens

Top 20 Logits:

:19.3569
#:15.2799
##:14.4576
let:14.3504
 :13.1111
in:12.562
    :12.5179
################:12.4633
  :12.4197
   :12.4081
####:12.0422
/*:11.9438
```:11.9344
//:11.3573
                :11.3176
end:11.3041
def:11.2006
[:11.1946
        :11.1881
(:11.1414
       :11.069

================
# Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)


























































































































































LSP: Prelude: Recieved string: ### List ###

# Add an element to the front of a list. #
let cons: (Int, [Int]) -> [Int] = fun x, xs -> x::xs in

# Determine the length of a list. #
let length: [Int] -> Int =
  fun xs ->
    case xs
    | [] => 0
    | _::xs => 1 + length(xs) end in

# Extract the first element of a list. #
let hd: [Int] -> Option =
  fun l ->
    case l
    | [] => None
    | x::xs => Some(x) end in

# Extract the rest of the list. #
let tl: [Int] -> [Int] =
  fun l ->
    case l
    | [] => []
    | x::xs => xs end in

# Determine if a list is empty. #
let is_empty: [Int] -> Bool =
  fun xs ->
    case xs
    | [] => true
    | _::_ => false end in

# Return the element at the index. #
let nth: ([Int], Int) -> Option =
  fun xs, n ->
    case xs, n
    | x::_, 0 => Some(x)
    | _::xs, n => nth(xs, n - 1)
    | [], _ => None end in

# Reverse a List. #
let rev: [Int] -> [Int] =
fun l -> 
let go: ([Int], [Int]) -> [Int] =
  fun xs, acc -> 
    case xs 
    | [] => acc 
    | x::xs => go(xs, x::acc) end in
go(l, []) in

# Check if two lists are equal #
let equal: ([Int], [Int]) -> Bool =
    fun p, xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => x == y && equal(xs, ys)
    | _ => false end
in

# Initialize a list with a given length using an initializer function #
let init: (Int, Int -> Int) -> [Int] =
    fun len, f ->
        let go: (Int, [Int]) -> [Int] =
        fun idx, xs ->
            if idx < len 
            then go(idx + 1, xs @ [f(idx)])   
            else xs
        in
        go(0, [])
in

# Reduce a list from the left. #
let fold_left: ((Int, Int) -> Int, Int, [Int]) -> Int =
  fun f, acc, xs ->
    case xs 
    | [] => acc
    | hd::tl => fold_left(f, f(acc, hd), tl) end in

# Reduce a list from the right. #
let fold_right: ((Int, Int) -> Int, [Int], Int) -> Int =
  fun f, xs, acc ->
    case xs
    | [] => acc
    | hd::tl => f(hd, fold_right(f, tl, acc)) end in


666
LSP: Prelude: String parsed successfully
LSP: Prelude: Info map generated successfully
Debug: true, Constrain: Types
LSP: Init: Recieved string: # Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)

























































































































































LSP: Init: String parsed successfully
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: >( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {go: ((?, ?) -> [?]), filter: (((Int -> Bool), [Int]) -> [Int]), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: 
  LSP: Info: ALL errors:Error in term:
  p
Nature of error: Variable p is not bound    
Error in term:
  p
Nature of error: Variable p is not bound    
Error in term:
  p
Nature of error: type ((Int -> Bool), [Int]) is not consistent with arrow type
  LSP: Info: BidiCtx: Cls: Let expression
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent: Root
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: [?]
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: :: @
  LSP: Concave: Backpack: 
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new_tokens ::= whitespace | "," | "::" | "@"
root ::= new_tokens

Top 20 Logits:

:19.3592
#:15.2734
##:14.4455
let:14.3507
 :13.1081
in:12.5715
    :12.5198
################:12.4589
  :12.4223
   :12.4
####:12.0365
/*:11.9489
```:11.92
//:11.362
                :11.311
end:11.2953
[:11.1874
def:11.1867
        :11.1864
(:11.1409
       :11.0598

================
# Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)



























































































































































LSP: Prelude: Recieved string: ### List ###

# Add an element to the front of a list. #
let cons: (Int, [Int]) -> [Int] = fun x, xs -> x::xs in

# Determine the length of a list. #
let length: [Int] -> Int =
  fun xs ->
    case xs
    | [] => 0
    | _::xs => 1 + length(xs) end in

# Extract the first element of a list. #
let hd: [Int] -> Option =
  fun l ->
    case l
    | [] => None
    | x::xs => Some(x) end in

# Extract the rest of the list. #
let tl: [Int] -> [Int] =
  fun l ->
    case l
    | [] => []
    | x::xs => xs end in

# Determine if a list is empty. #
let is_empty: [Int] -> Bool =
  fun xs ->
    case xs
    | [] => true
    | _::_ => false end in

# Return the element at the index. #
let nth: ([Int], Int) -> Option =
  fun xs, n ->
    case xs, n
    | x::_, 0 => Some(x)
    | _::xs, n => nth(xs, n - 1)
    | [], _ => None end in

# Reverse a List. #
let rev: [Int] -> [Int] =
fun l -> 
let go: ([Int], [Int]) -> [Int] =
  fun xs, acc -> 
    case xs 
    | [] => acc 
    | x::xs => go(xs, x::acc) end in
go(l, []) in

# Check if two lists are equal #
let equal: ([Int], [Int]) -> Bool =
    fun p, xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => x == y && equal(xs, ys)
    | _ => false end
in

# Initialize a list with a given length using an initializer function #
let init: (Int, Int -> Int) -> [Int] =
    fun len, f ->
        let go: (Int, [Int]) -> [Int] =
        fun idx, xs ->
            if idx < len 
            then go(idx + 1, xs @ [f(idx)])   
            else xs
        in
        go(0, [])
in

# Reduce a list from the left. #
let fold_left: ((Int, Int) -> Int, Int, [Int]) -> Int =
  fun f, acc, xs ->
    case xs 
    | [] => acc
    | hd::tl => fold_left(f, f(acc, hd), tl) end in

# Reduce a list from the right. #
let fold_right: ((Int, Int) -> Int, [Int], Int) -> Int =
  fun f, xs, acc ->
    case xs
    | [] => acc
    | hd::tl => f(hd, fold_right(f, tl, acc)) end in


666
LSP: Prelude: String parsed successfully
LSP: Prelude: Info map generated successfully
Debug: true, Constrain: Types
LSP: Init: Recieved string: # Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)


























































































































































LSP: Init: String parsed successfully
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: >( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {go: ((?, ?) -> [?]), filter: (((Int -> Bool), [Int]) -> [Int]), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: 
  LSP: Info: ALL errors:Error in term:
  p
Nature of error: Variable p is not bound    
Error in term:
  p
Nature of error: Variable p is not bound    
Error in term:
  p
Nature of error: type ((Int -> Bool), [Int]) is not consistent with arrow type
  LSP: Info: BidiCtx: Cls: Let expression
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent: Root
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: [?]
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: :: @
  LSP: Concave: Backpack: 
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new_tokens ::= whitespace | "," | "::" | "@"
root ::= new_tokens

Top 20 Logits:

:19.366
#:15.2674
##:14.4498
let:14.3495
 :13.1058
in:12.5516
    :12.5204
################:12.4617
  :12.4238
   :12.3909
####:12.0422
/*:11.955
```:11.912
//:11.3719
                :11.3037
end:11.2739
[:11.1897
        :11.1837
def:11.1698
(:11.1433
       :11.052

================
# Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)




























































































































































LSP: Prelude: Recieved string: ### List ###

# Add an element to the front of a list. #
let cons: (Int, [Int]) -> [Int] = fun x, xs -> x::xs in

# Determine the length of a list. #
let length: [Int] -> Int =
  fun xs ->
    case xs
    | [] => 0
    | _::xs => 1 + length(xs) end in

# Extract the first element of a list. #
let hd: [Int] -> Option =
  fun l ->
    case l
    | [] => None
    | x::xs => Some(x) end in

# Extract the rest of the list. #
let tl: [Int] -> [Int] =
  fun l ->
    case l
    | [] => []
    | x::xs => xs end in

# Determine if a list is empty. #
let is_empty: [Int] -> Bool =
  fun xs ->
    case xs
    | [] => true
    | _::_ => false end in

# Return the element at the index. #
let nth: ([Int], Int) -> Option =
  fun xs, n ->
    case xs, n
    | x::_, 0 => Some(x)
    | _::xs, n => nth(xs, n - 1)
    | [], _ => None end in

# Reverse a List. #
let rev: [Int] -> [Int] =
fun l -> 
let go: ([Int], [Int]) -> [Int] =
  fun xs, acc -> 
    case xs 
    | [] => acc 
    | x::xs => go(xs, x::acc) end in
go(l, []) in

# Check if two lists are equal #
let equal: ([Int], [Int]) -> Bool =
    fun p, xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => x == y && equal(xs, ys)
    | _ => false end
in

# Initialize a list with a given length using an initializer function #
let init: (Int, Int -> Int) -> [Int] =
    fun len, f ->
        let go: (Int, [Int]) -> [Int] =
        fun idx, xs ->
            if idx < len 
            then go(idx + 1, xs @ [f(idx)])   
            else xs
        in
        go(0, [])
in

# Reduce a list from the left. #
let fold_left: ((Int, Int) -> Int, Int, [Int]) -> Int =
  fun f, acc, xs ->
    case xs 
    | [] => acc
    | hd::tl => fold_left(f, f(acc, hd), tl) end in

# Reduce a list from the right. #
let fold_right: ((Int, Int) -> Int, [Int], Int) -> Int =
  fun f, xs, acc ->
    case xs
    | [] => acc
    | hd::tl => f(hd, fold_right(f, tl, acc)) end in


666
LSP: Prelude: String parsed successfully
LSP: Prelude: Info map generated successfully
Debug: true, Constrain: Types
LSP: Init: Recieved string: # Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)



























































































































































LSP: Init: String parsed successfully
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: >( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {go: ((?, ?) -> [?]), filter: (((Int -> Bool), [Int]) -> [Int]), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: 
  LSP: Info: ALL errors:Error in term:
  p
Nature of error: Variable p is not bound    
Error in term:
  p
Nature of error: type ((Int -> Bool), [Int]) is not consistent with arrow type    
Error in term:
  p
Nature of error: Variable p is not bound
  LSP: Info: BidiCtx: Cls: Let expression
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent: Root
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: [?]
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: :: @
  LSP: Concave: Backpack: 
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new_tokens ::= whitespace | "," | "::" | "@"
root ::= new_tokens

Top 20 Logits:

:19.3777
#:15.2615
##:14.4647
let:14.3479
 :13.1037
in:12.5286
    :12.5177
################:12.4682
  :12.4243
   :12.3834
####:12.053
/*:11.9592
```:11.9112
//:11.3824
                :11.2982
end:11.2545
[:11.1993
        :11.1792
def:11.156
(:11.1433
       :11.0468

================
# Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)





























































































































































LSP: Prelude: Recieved string: ### List ###

# Add an element to the front of a list. #
let cons: (Int, [Int]) -> [Int] = fun x, xs -> x::xs in

# Determine the length of a list. #
let length: [Int] -> Int =
  fun xs ->
    case xs
    | [] => 0
    | _::xs => 1 + length(xs) end in

# Extract the first element of a list. #
let hd: [Int] -> Option =
  fun l ->
    case l
    | [] => None
    | x::xs => Some(x) end in

# Extract the rest of the list. #
let tl: [Int] -> [Int] =
  fun l ->
    case l
    | [] => []
    | x::xs => xs end in

# Determine if a list is empty. #
let is_empty: [Int] -> Bool =
  fun xs ->
    case xs
    | [] => true
    | _::_ => false end in

# Return the element at the index. #
let nth: ([Int], Int) -> Option =
  fun xs, n ->
    case xs, n
    | x::_, 0 => Some(x)
    | _::xs, n => nth(xs, n - 1)
    | [], _ => None end in

# Reverse a List. #
let rev: [Int] -> [Int] =
fun l -> 
let go: ([Int], [Int]) -> [Int] =
  fun xs, acc -> 
    case xs 
    | [] => acc 
    | x::xs => go(xs, x::acc) end in
go(l, []) in

# Check if two lists are equal #
let equal: ([Int], [Int]) -> Bool =
    fun p, xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => x == y && equal(xs, ys)
    | _ => false end
in

# Initialize a list with a given length using an initializer function #
let init: (Int, Int -> Int) -> [Int] =
    fun len, f ->
        let go: (Int, [Int]) -> [Int] =
        fun idx, xs ->
            if idx < len 
            then go(idx + 1, xs @ [f(idx)])   
            else xs
        in
        go(0, [])
in

# Reduce a list from the left. #
let fold_left: ((Int, Int) -> Int, Int, [Int]) -> Int =
  fun f, acc, xs ->
    case xs 
    | [] => acc
    | hd::tl => fold_left(f, f(acc, hd), tl) end in

# Reduce a list from the right. #
let fold_right: ((Int, Int) -> Int, [Int], Int) -> Int =
  fun f, xs, acc ->
    case xs
    | [] => acc
    | hd::tl => f(hd, fold_right(f, tl, acc)) end in


666
LSP: Prelude: String parsed successfully
LSP: Prelude: Info map generated successfully
Debug: true, Constrain: Types
LSP: Init: Recieved string: # Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)




























































































































































LSP: Init: String parsed successfully
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: >( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {go: ((?, ?) -> [?]), filter: (((Int -> Bool), [Int]) -> [Int]), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: 
  LSP: Info: ALL errors:Error in term:
  p
Nature of error: Variable p is not bound    
Error in term:
  p
Nature of error: type ((Int -> Bool), [Int]) is not consistent with arrow type    
Error in term:
  p
Nature of error: Variable p is not bound
  LSP: Info: BidiCtx: Cls: Let expression
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent: Root
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: [?]
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: :: @
  LSP: Concave: Backpack: 
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new_tokens ::= whitespace | "," | "::" | "@"
root ::= new_tokens

Top 20 Logits:

:19.3915
#:15.2544
##:14.4738
let:14.3454
 :13.1009
in:12.5341
    :12.5128
################:12.4719
  :12.4256
   :12.3773
####:12.0572
/*:11.9588
```:11.9125
//:11.3872
                :11.2968
end:11.256
[:11.2087
        :11.1746
def:11.1486
(:11.1359
       :11.0434

================
# Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)






























































































































































LSP: Prelude: Recieved string: ### List ###

# Add an element to the front of a list. #
let cons: (Int, [Int]) -> [Int] = fun x, xs -> x::xs in

# Determine the length of a list. #
let length: [Int] -> Int =
  fun xs ->
    case xs
    | [] => 0
    | _::xs => 1 + length(xs) end in

# Extract the first element of a list. #
let hd: [Int] -> Option =
  fun l ->
    case l
    | [] => None
    | x::xs => Some(x) end in

# Extract the rest of the list. #
let tl: [Int] -> [Int] =
  fun l ->
    case l
    | [] => []
    | x::xs => xs end in

# Determine if a list is empty. #
let is_empty: [Int] -> Bool =
  fun xs ->
    case xs
    | [] => true
    | _::_ => false end in

# Return the element at the index. #
let nth: ([Int], Int) -> Option =
  fun xs, n ->
    case xs, n
    | x::_, 0 => Some(x)
    | _::xs, n => nth(xs, n - 1)
    | [], _ => None end in

# Reverse a List. #
let rev: [Int] -> [Int] =
fun l -> 
let go: ([Int], [Int]) -> [Int] =
  fun xs, acc -> 
    case xs 
    | [] => acc 
    | x::xs => go(xs, x::acc) end in
go(l, []) in

# Check if two lists are equal #
let equal: ([Int], [Int]) -> Bool =
    fun p, xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => x == y && equal(xs, ys)
    | _ => false end
in

# Initialize a list with a given length using an initializer function #
let init: (Int, Int -> Int) -> [Int] =
    fun len, f ->
        let go: (Int, [Int]) -> [Int] =
        fun idx, xs ->
            if idx < len 
            then go(idx + 1, xs @ [f(idx)])   
            else xs
        in
        go(0, [])
in

# Reduce a list from the left. #
let fold_left: ((Int, Int) -> Int, Int, [Int]) -> Int =
  fun f, acc, xs ->
    case xs 
    | [] => acc
    | hd::tl => fold_left(f, f(acc, hd), tl) end in

# Reduce a list from the right. #
let fold_right: ((Int, Int) -> Int, [Int], Int) -> Int =
  fun f, xs, acc ->
    case xs
    | [] => acc
    | hd::tl => f(hd, fold_right(f, tl, acc)) end in


666
LSP: Prelude: String parsed successfully
LSP: Prelude: Info map generated successfully
Debug: true, Constrain: Types
LSP: Init: Recieved string: # Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)





























































































































































LSP: Init: String parsed successfully
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: >( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {go: ((?, ?) -> [?]), filter: (((Int -> Bool), [Int]) -> [Int]), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: 
  LSP: Info: ALL errors:Error in term:
  p
Nature of error: Variable p is not bound    
Error in term:
  p
Nature of error: Variable p is not bound    
Error in term:
  p
Nature of error: type ((Int -> Bool), [Int]) is not consistent with arrow type
  LSP: Info: BidiCtx: Cls: Let expression
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent: Root
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: [?]
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: :: @
  LSP: Concave: Backpack: 
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new_tokens ::= whitespace | "," | "::" | "@"
root ::= new_tokens

Top 20 Logits:

:19.4021
#:15.2439
##:14.4631
let:14.3404
 :13.0961
in:12.5771
    :12.5068
################:12.4672
  :12.4268
   :12.3702
####:12.0471
/*:11.9553
```:11.9077
//:11.3865
                :11.2963
end:11.2784
[:11.2111
        :11.1683
def:11.1453
(:11.121
       :11.0391

================
# Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)































































































































































LSP: Prelude: Recieved string: ### List ###

# Add an element to the front of a list. #
let cons: (Int, [Int]) -> [Int] = fun x, xs -> x::xs in

# Determine the length of a list. #
let length: [Int] -> Int =
  fun xs ->
    case xs
    | [] => 0
    | _::xs => 1 + length(xs) end in

# Extract the first element of a list. #
let hd: [Int] -> Option =
  fun l ->
    case l
    | [] => None
    | x::xs => Some(x) end in

# Extract the rest of the list. #
let tl: [Int] -> [Int] =
  fun l ->
    case l
    | [] => []
    | x::xs => xs end in

# Determine if a list is empty. #
let is_empty: [Int] -> Bool =
  fun xs ->
    case xs
    | [] => true
    | _::_ => false end in

# Return the element at the index. #
let nth: ([Int], Int) -> Option =
  fun xs, n ->
    case xs, n
    | x::_, 0 => Some(x)
    | _::xs, n => nth(xs, n - 1)
    | [], _ => None end in

# Reverse a List. #
let rev: [Int] -> [Int] =
fun l -> 
let go: ([Int], [Int]) -> [Int] =
  fun xs, acc -> 
    case xs 
    | [] => acc 
    | x::xs => go(xs, x::acc) end in
go(l, []) in

# Check if two lists are equal #
let equal: ([Int], [Int]) -> Bool =
    fun p, xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => x == y && equal(xs, ys)
    | _ => false end
in

# Initialize a list with a given length using an initializer function #
let init: (Int, Int -> Int) -> [Int] =
    fun len, f ->
        let go: (Int, [Int]) -> [Int] =
        fun idx, xs ->
            if idx < len 
            then go(idx + 1, xs @ [f(idx)])   
            else xs
        in
        go(0, [])
in

# Reduce a list from the left. #
let fold_left: ((Int, Int) -> Int, Int, [Int]) -> Int =
  fun f, acc, xs ->
    case xs 
    | [] => acc
    | hd::tl => fold_left(f, f(acc, hd), tl) end in

# Reduce a list from the right. #
let fold_right: ((Int, Int) -> Int, [Int], Int) -> Int =
  fun f, xs, acc ->
    case xs
    | [] => acc
    | hd::tl => f(hd, fold_right(f, tl, acc)) end in


666
LSP: Prelude: String parsed successfully
LSP: Prelude: Info map generated successfully
Debug: true, Constrain: Types
LSP: Init: Recieved string: # Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)






























































































































































LSP: Init: String parsed successfully
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: >( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {go: ((?, ?) -> [?]), filter: (((Int -> Bool), [Int]) -> [Int]), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: 
  LSP: Info: ALL errors:Error in term:
  p
Nature of error: Variable p is not bound    
Error in term:
  p
Nature of error: type ((Int -> Bool), [Int]) is not consistent with arrow type    
Error in term:
  p
Nature of error: Variable p is not bound
  LSP: Info: BidiCtx: Cls: Let expression
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent: Root
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: [?]
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: :: @
  LSP: Concave: Backpack: 
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new_tokens ::= whitespace | "," | "::" | "@"
root ::= new_tokens

Top 20 Logits:

:19.4067
#:15.2314
##:14.4319
let:14.3356
 :13.0906
in:12.6367
    :12.5004
################:12.4529
  :12.4258
   :12.363
####:12.0248
/*:11.952
```:11.8928
//:11.3845
end:11.3038
                :11.2922
[:11.207
        :11.1569
def:11.1406
(:11.1068
       :11.0309

================
# Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)
































































































































































LSP: Prelude: Recieved string: ### List ###

# Add an element to the front of a list. #
let cons: (Int, [Int]) -> [Int] = fun x, xs -> x::xs in

# Determine the length of a list. #
let length: [Int] -> Int =
  fun xs ->
    case xs
    | [] => 0
    | _::xs => 1 + length(xs) end in

# Extract the first element of a list. #
let hd: [Int] -> Option =
  fun l ->
    case l
    | [] => None
    | x::xs => Some(x) end in

# Extract the rest of the list. #
let tl: [Int] -> [Int] =
  fun l ->
    case l
    | [] => []
    | x::xs => xs end in

# Determine if a list is empty. #
let is_empty: [Int] -> Bool =
  fun xs ->
    case xs
    | [] => true
    | _::_ => false end in

# Return the element at the index. #
let nth: ([Int], Int) -> Option =
  fun xs, n ->
    case xs, n
    | x::_, 0 => Some(x)
    | _::xs, n => nth(xs, n - 1)
    | [], _ => None end in

# Reverse a List. #
let rev: [Int] -> [Int] =
fun l -> 
let go: ([Int], [Int]) -> [Int] =
  fun xs, acc -> 
    case xs 
    | [] => acc 
    | x::xs => go(xs, x::acc) end in
go(l, []) in

# Check if two lists are equal #
let equal: ([Int], [Int]) -> Bool =
    fun p, xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => x == y && equal(xs, ys)
    | _ => false end
in

# Initialize a list with a given length using an initializer function #
let init: (Int, Int -> Int) -> [Int] =
    fun len, f ->
        let go: (Int, [Int]) -> [Int] =
        fun idx, xs ->
            if idx < len 
            then go(idx + 1, xs @ [f(idx)])   
            else xs
        in
        go(0, [])
in

# Reduce a list from the left. #
let fold_left: ((Int, Int) -> Int, Int, [Int]) -> Int =
  fun f, acc, xs ->
    case xs 
    | [] => acc
    | hd::tl => fold_left(f, f(acc, hd), tl) end in

# Reduce a list from the right. #
let fold_right: ((Int, Int) -> Int, [Int], Int) -> Int =
  fun f, xs, acc ->
    case xs
    | [] => acc
    | hd::tl => f(hd, fold_right(f, tl, acc)) end in


666
LSP: Prelude: String parsed successfully
LSP: Prelude: Info map generated successfully
Debug: true, Constrain: Types
LSP: Init: Recieved string: # Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)































































































































































LSP: Init: String parsed successfully
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: >( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {go: ((?, ?) -> [?]), filter: (((Int -> Bool), [Int]) -> [Int]), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: 
  LSP: Info: ALL errors:Error in term:
  p
Nature of error: Variable p is not bound    
Error in term:
  p
Nature of error: type ((Int -> Bool), [Int]) is not consistent with arrow type    
Error in term:
  p
Nature of error: Variable p is not bound
  LSP: Info: BidiCtx: Cls: Let expression
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent: Root
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: [?]
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: :: @
  LSP: Concave: Backpack: 
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new_tokens ::= whitespace | "," | "::" | "@"
root ::= new_tokens

Top 20 Logits:

:19.408
#:15.2238
##:14.3958
let:14.3347
 :13.0873
in:12.6795
    :12.495
################:12.4362
  :12.4232
   :12.3577
####:12.0034
/*:11.9498
```:11.8753
//:11.3836
end:11.3118
                :11.2851
[:11.2025
        :11.1436
def:11.1312
(:11.1023
       :11.0213

================
# Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)

































































































































































LSP: Prelude: Recieved string: ### List ###

# Add an element to the front of a list. #
let cons: (Int, [Int]) -> [Int] = fun x, xs -> x::xs in

# Determine the length of a list. #
let length: [Int] -> Int =
  fun xs ->
    case xs
    | [] => 0
    | _::xs => 1 + length(xs) end in

# Extract the first element of a list. #
let hd: [Int] -> Option =
  fun l ->
    case l
    | [] => None
    | x::xs => Some(x) end in

# Extract the rest of the list. #
let tl: [Int] -> [Int] =
  fun l ->
    case l
    | [] => []
    | x::xs => xs end in

# Determine if a list is empty. #
let is_empty: [Int] -> Bool =
  fun xs ->
    case xs
    | [] => true
    | _::_ => false end in

# Return the element at the index. #
let nth: ([Int], Int) -> Option =
  fun xs, n ->
    case xs, n
    | x::_, 0 => Some(x)
    | _::xs, n => nth(xs, n - 1)
    | [], _ => None end in

# Reverse a List. #
let rev: [Int] -> [Int] =
fun l -> 
let go: ([Int], [Int]) -> [Int] =
  fun xs, acc -> 
    case xs 
    | [] => acc 
    | x::xs => go(xs, x::acc) end in
go(l, []) in

# Check if two lists are equal #
let equal: ([Int], [Int]) -> Bool =
    fun p, xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => x == y && equal(xs, ys)
    | _ => false end
in

# Initialize a list with a given length using an initializer function #
let init: (Int, Int -> Int) -> [Int] =
    fun len, f ->
        let go: (Int, [Int]) -> [Int] =
        fun idx, xs ->
            if idx < len 
            then go(idx + 1, xs @ [f(idx)])   
            else xs
        in
        go(0, [])
in

# Reduce a list from the left. #
let fold_left: ((Int, Int) -> Int, Int, [Int]) -> Int =
  fun f, acc, xs ->
    case xs 
    | [] => acc
    | hd::tl => fold_left(f, f(acc, hd), tl) end in

# Reduce a list from the right. #
let fold_right: ((Int, Int) -> Int, [Int], Int) -> Int =
  fun f, xs, acc ->
    case xs
    | [] => acc
    | hd::tl => f(hd, fold_right(f, tl, acc)) end in


666
LSP: Prelude: String parsed successfully
LSP: Prelude: Info map generated successfully
Debug: true, Constrain: Types
LSP: Init: Recieved string: # Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)
































































































































































LSP: Init: String parsed successfully
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: >( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {go: ((?, ?) -> [?]), filter: (((Int -> Bool), [Int]) -> [Int]), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: 
  LSP: Info: ALL errors:Error in term:
  p
Nature of error: Variable p is not bound    
Error in term:
  p
Nature of error: Variable p is not bound    
Error in term:
  p
Nature of error: type ((Int -> Bool), [Int]) is not consistent with arrow type
  LSP: Info: BidiCtx: Cls: Let expression
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent: Root
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: [?]
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: :: @
  LSP: Concave: Backpack: 
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new_tokens ::= whitespace | "," | "::" | "@"
root ::= new_tokens

Top 20 Logits:

:19.4118
#:15.2246
##:14.3741
let:14.339
 :13.0869
in:12.6806
    :12.4915
################:12.4279
  :12.4199
   :12.3535
####:11.9954
/*:11.9489
```:11.8673
//:11.3841
end:11.2896
                :11.2777
[:11.2032
        :11.134
def:11.1189
(:11.1085
       :11.0149

================
# Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)


































































































































































LSP: Prelude: Recieved string: ### List ###

# Add an element to the front of a list. #
let cons: (Int, [Int]) -> [Int] = fun x, xs -> x::xs in

# Determine the length of a list. #
let length: [Int] -> Int =
  fun xs ->
    case xs
    | [] => 0
    | _::xs => 1 + length(xs) end in

# Extract the first element of a list. #
let hd: [Int] -> Option =
  fun l ->
    case l
    | [] => None
    | x::xs => Some(x) end in

# Extract the rest of the list. #
let tl: [Int] -> [Int] =
  fun l ->
    case l
    | [] => []
    | x::xs => xs end in

# Determine if a list is empty. #
let is_empty: [Int] -> Bool =
  fun xs ->
    case xs
    | [] => true
    | _::_ => false end in

# Return the element at the index. #
let nth: ([Int], Int) -> Option =
  fun xs, n ->
    case xs, n
    | x::_, 0 => Some(x)
    | _::xs, n => nth(xs, n - 1)
    | [], _ => None end in

# Reverse a List. #
let rev: [Int] -> [Int] =
fun l -> 
let go: ([Int], [Int]) -> [Int] =
  fun xs, acc -> 
    case xs 
    | [] => acc 
    | x::xs => go(xs, x::acc) end in
go(l, []) in

# Check if two lists are equal #
let equal: ([Int], [Int]) -> Bool =
    fun p, xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => x == y && equal(xs, ys)
    | _ => false end
in

# Initialize a list with a given length using an initializer function #
let init: (Int, Int -> Int) -> [Int] =
    fun len, f ->
        let go: (Int, [Int]) -> [Int] =
        fun idx, xs ->
            if idx < len 
            then go(idx + 1, xs @ [f(idx)])   
            else xs
        in
        go(0, [])
in

# Reduce a list from the left. #
let fold_left: ((Int, Int) -> Int, Int, [Int]) -> Int =
  fun f, acc, xs ->
    case xs 
    | [] => acc
    | hd::tl => fold_left(f, f(acc, hd), tl) end in

# Reduce a list from the right. #
let fold_right: ((Int, Int) -> Int, [Int], Int) -> Int =
  fun f, xs, acc ->
    case xs
    | [] => acc
    | hd::tl => f(hd, fold_right(f, tl, acc)) end in


666
LSP: Prelude: String parsed successfully
LSP: Prelude: Info map generated successfully
Debug: true, Constrain: Types
LSP: Init: Recieved string: # Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)

































































































































































LSP: Init: String parsed successfully
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: >( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {go: ((?, ?) -> [?]), filter: (((Int -> Bool), [Int]) -> [Int]), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: 
  LSP: Info: ALL errors:Error in term:
  p
Nature of error: type ((Int -> Bool), [Int]) is not consistent with arrow type    
Error in term:
  p
Nature of error: Variable p is not bound    
Error in term:
  p
Nature of error: Variable p is not bound
  LSP: Info: BidiCtx: Cls: Let expression
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent: Root
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: [?]
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: :: @
  LSP: Concave: Backpack: 
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new_tokens ::= whitespace | "," | "::" | "@"
root ::= new_tokens

Top 20 Logits:

:19.4208
#:15.2298
##:14.377
let:14.349
 :13.0877
in:12.6423
    :12.4872
################:12.4334
  :12.4163
   :12.3489
####:12.0032
/*:11.949
```:11.8741
//:11.3865
                :11.2717
end:11.2408
[:11.2119
        :11.1281
(:11.1198
def:11.1078
       :11.0124

================
# Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)



































































































































































LSP: Prelude: Recieved string: ### List ###

# Add an element to the front of a list. #
let cons: (Int, [Int]) -> [Int] = fun x, xs -> x::xs in

# Determine the length of a list. #
let length: [Int] -> Int =
  fun xs ->
    case xs
    | [] => 0
    | _::xs => 1 + length(xs) end in

# Extract the first element of a list. #
let hd: [Int] -> Option =
  fun l ->
    case l
    | [] => None
    | x::xs => Some(x) end in

# Extract the rest of the list. #
let tl: [Int] -> [Int] =
  fun l ->
    case l
    | [] => []
    | x::xs => xs end in

# Determine if a list is empty. #
let is_empty: [Int] -> Bool =
  fun xs ->
    case xs
    | [] => true
    | _::_ => false end in

# Return the element at the index. #
let nth: ([Int], Int) -> Option =
  fun xs, n ->
    case xs, n
    | x::_, 0 => Some(x)
    | _::xs, n => nth(xs, n - 1)
    | [], _ => None end in

# Reverse a List. #
let rev: [Int] -> [Int] =
fun l -> 
let go: ([Int], [Int]) -> [Int] =
  fun xs, acc -> 
    case xs 
    | [] => acc 
    | x::xs => go(xs, x::acc) end in
go(l, []) in

# Check if two lists are equal #
let equal: ([Int], [Int]) -> Bool =
    fun p, xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => x == y && equal(xs, ys)
    | _ => false end
in

# Initialize a list with a given length using an initializer function #
let init: (Int, Int -> Int) -> [Int] =
    fun len, f ->
        let go: (Int, [Int]) -> [Int] =
        fun idx, xs ->
            if idx < len 
            then go(idx + 1, xs @ [f(idx)])   
            else xs
        in
        go(0, [])
in

# Reduce a list from the left. #
let fold_left: ((Int, Int) -> Int, Int, [Int]) -> Int =
  fun f, acc, xs ->
    case xs 
    | [] => acc
    | hd::tl => fold_left(f, f(acc, hd), tl) end in

# Reduce a list from the right. #
let fold_right: ((Int, Int) -> Int, [Int], Int) -> Int =
  fun f, xs, acc ->
    case xs
    | [] => acc
    | hd::tl => f(hd, fold_right(f, tl, acc)) end in


666
LSP: Prelude: String parsed successfully
LSP: Prelude: Info map generated successfully
Debug: true, Constrain: Types
LSP: Init: Recieved string: # Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)


































































































































































LSP: Init: String parsed successfully
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: >( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {go: ((?, ?) -> [?]), filter: (((Int -> Bool), [Int]) -> [Int]), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: 
  LSP: Info: ALL errors:Error in term:
  p
Nature of error: Variable p is not bound    
Error in term:
  p
Nature of error: type ((Int -> Bool), [Int]) is not consistent with arrow type    
Error in term:
  p
Nature of error: Variable p is not bound
  LSP: Info: BidiCtx: Cls: Let expression
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent: Root
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: [?]
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: :: @
  LSP: Concave: Backpack: 
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new_tokens ::= whitespace | "," | "::" | "@"
root ::= new_tokens

Top 20 Logits:

:19.4328
#:15.2321
##:14.399
let:14.3602
 :13.0884
in:12.5949
    :12.4816
################:12.4485
  :12.4143
   :12.3443
####:12.0193
/*:11.9472
```:11.8903
//:11.3881
                :11.268
[:11.2228
end:11.1922
(:11.1245
        :11.1241
def:11.1024
       :11.0108

================
# Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)




































































































































































LSP: Prelude: Recieved string: ### List ###

# Add an element to the front of a list. #
let cons: (Int, [Int]) -> [Int] = fun x, xs -> x::xs in

# Determine the length of a list. #
let length: [Int] -> Int =
  fun xs ->
    case xs
    | [] => 0
    | _::xs => 1 + length(xs) end in

# Extract the first element of a list. #
let hd: [Int] -> Option =
  fun l ->
    case l
    | [] => None
    | x::xs => Some(x) end in

# Extract the rest of the list. #
let tl: [Int] -> [Int] =
  fun l ->
    case l
    | [] => []
    | x::xs => xs end in

# Determine if a list is empty. #
let is_empty: [Int] -> Bool =
  fun xs ->
    case xs
    | [] => true
    | _::_ => false end in

# Return the element at the index. #
let nth: ([Int], Int) -> Option =
  fun xs, n ->
    case xs, n
    | x::_, 0 => Some(x)
    | _::xs, n => nth(xs, n - 1)
    | [], _ => None end in

# Reverse a List. #
let rev: [Int] -> [Int] =
fun l -> 
let go: ([Int], [Int]) -> [Int] =
  fun xs, acc -> 
    case xs 
    | [] => acc 
    | x::xs => go(xs, x::acc) end in
go(l, []) in

# Check if two lists are equal #
let equal: ([Int], [Int]) -> Bool =
    fun p, xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => x == y && equal(xs, ys)
    | _ => false end
in

# Initialize a list with a given length using an initializer function #
let init: (Int, Int -> Int) -> [Int] =
    fun len, f ->
        let go: (Int, [Int]) -> [Int] =
        fun idx, xs ->
            if idx < len 
            then go(idx + 1, xs @ [f(idx)])   
            else xs
        in
        go(0, [])
in

# Reduce a list from the left. #
let fold_left: ((Int, Int) -> Int, Int, [Int]) -> Int =
  fun f, acc, xs ->
    case xs 
    | [] => acc
    | hd::tl => fold_left(f, f(acc, hd), tl) end in

# Reduce a list from the right. #
let fold_right: ((Int, Int) -> Int, [Int], Int) -> Int =
  fun f, xs, acc ->
    case xs
    | [] => acc
    | hd::tl => f(hd, fold_right(f, tl, acc)) end in


666
LSP: Prelude: String parsed successfully
LSP: Prelude: Info map generated successfully
Debug: true, Constrain: Types
LSP: Init: Recieved string: # Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)



































































































































































LSP: Init: String parsed successfully
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: >( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {go: ((?, ?) -> [?]), filter: (((Int -> Bool), [Int]) -> [Int]), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: 
  LSP: Info: ALL errors:Error in term:
  p
Nature of error: Variable p is not bound    
Error in term:
  p
Nature of error: type ((Int -> Bool), [Int]) is not consistent with arrow type    
Error in term:
  p
Nature of error: Variable p is not bound
  LSP: Info: BidiCtx: Cls: Let expression
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent: Root
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: [?]
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: :: @
  LSP: Concave: Backpack: 
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new_tokens ::= whitespace | "," | "::" | "@"
root ::= new_tokens

Top 20 Logits:

:19.4442
#:15.2259
##:14.4244
let:14.3656
 :13.0884
in:12.5678
    :12.4782
################:12.4651
  :12.415
   :12.3404
####:12.0337
/*:11.9426
```:11.9039
//:11.3862
                :11.2666
[:11.2268
end:11.1679
        :11.1212
(:11.1154
def:11.109
########:11.019

================
# Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)





































































































































































LSP: Prelude: Recieved string: ### List ###

# Add an element to the front of a list. #
let cons: (Int, [Int]) -> [Int] = fun x, xs -> x::xs in

# Determine the length of a list. #
let length: [Int] -> Int =
  fun xs ->
    case xs
    | [] => 0
    | _::xs => 1 + length(xs) end in

# Extract the first element of a list. #
let hd: [Int] -> Option =
  fun l ->
    case l
    | [] => None
    | x::xs => Some(x) end in

# Extract the rest of the list. #
let tl: [Int] -> [Int] =
  fun l ->
    case l
    | [] => []
    | x::xs => xs end in

# Determine if a list is empty. #
let is_empty: [Int] -> Bool =
  fun xs ->
    case xs
    | [] => true
    | _::_ => false end in

# Return the element at the index. #
let nth: ([Int], Int) -> Option =
  fun xs, n ->
    case xs, n
    | x::_, 0 => Some(x)
    | _::xs, n => nth(xs, n - 1)
    | [], _ => None end in

# Reverse a List. #
let rev: [Int] -> [Int] =
fun l -> 
let go: ([Int], [Int]) -> [Int] =
  fun xs, acc -> 
    case xs 
    | [] => acc 
    | x::xs => go(xs, x::acc) end in
go(l, []) in

# Check if two lists are equal #
let equal: ([Int], [Int]) -> Bool =
    fun p, xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => x == y && equal(xs, ys)
    | _ => false end
in

# Initialize a list with a given length using an initializer function #
let init: (Int, Int -> Int) -> [Int] =
    fun len, f ->
        let go: (Int, [Int]) -> [Int] =
        fun idx, xs ->
            if idx < len 
            then go(idx + 1, xs @ [f(idx)])   
            else xs
        in
        go(0, [])
in

# Reduce a list from the left. #
let fold_left: ((Int, Int) -> Int, Int, [Int]) -> Int =
  fun f, acc, xs ->
    case xs 
    | [] => acc
    | hd::tl => fold_left(f, f(acc, hd), tl) end in

# Reduce a list from the right. #
let fold_right: ((Int, Int) -> Int, [Int], Int) -> Int =
  fun f, xs, acc ->
    case xs
    | [] => acc
    | hd::tl => f(hd, fold_right(f, tl, acc)) end in


666
LSP: Prelude: String parsed successfully
LSP: Prelude: Info map generated successfully
Debug: true, Constrain: Types
LSP: Init: Recieved string: # Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)




































































































































































LSP: Init: String parsed successfully
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: >( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {go: ((?, ?) -> [?]), filter: (((Int -> Bool), [Int]) -> [Int]), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: 
  LSP: Info: ALL errors:Error in term:
  p
Nature of error: type ((Int -> Bool), [Int]) is not consistent with arrow type    
Error in term:
  p
Nature of error: Variable p is not bound    
Error in term:
  p
Nature of error: Variable p is not bound
  LSP: Info: BidiCtx: Cls: Let expression
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent: Root
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: [?]
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: :: @
  LSP: Concave: Backpack: 
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new_tokens ::= whitespace | "," | "::" | "@"
root ::= new_tokens

Top 20 Logits:

:19.4531
#:15.212
##:14.4413
let:14.3617
 :13.0888
in:12.5716
    :12.4817
################:12.4764
  :12.4183
   :12.3403
####:12.0414
/*:11.9374
```:11.9065
//:11.3825
                :11.2668
[:11.2211
end:11.1753
def:11.1264
        :11.1198
(:11.0973
########:11.0317

================
# Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)






































































































































































LSP: Prelude: Recieved string: ### List ###

# Add an element to the front of a list. #
let cons: (Int, [Int]) -> [Int] = fun x, xs -> x::xs in

# Determine the length of a list. #
let length: [Int] -> Int =
  fun xs ->
    case xs
    | [] => 0
    | _::xs => 1 + length(xs) end in

# Extract the first element of a list. #
let hd: [Int] -> Option =
  fun l ->
    case l
    | [] => None
    | x::xs => Some(x) end in

# Extract the rest of the list. #
let tl: [Int] -> [Int] =
  fun l ->
    case l
    | [] => []
    | x::xs => xs end in

# Determine if a list is empty. #
let is_empty: [Int] -> Bool =
  fun xs ->
    case xs
    | [] => true
    | _::_ => false end in

# Return the element at the index. #
let nth: ([Int], Int) -> Option =
  fun xs, n ->
    case xs, n
    | x::_, 0 => Some(x)
    | _::xs, n => nth(xs, n - 1)
    | [], _ => None end in

# Reverse a List. #
let rev: [Int] -> [Int] =
fun l -> 
let go: ([Int], [Int]) -> [Int] =
  fun xs, acc -> 
    case xs 
    | [] => acc 
    | x::xs => go(xs, x::acc) end in
go(l, []) in

# Check if two lists are equal #
let equal: ([Int], [Int]) -> Bool =
    fun p, xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => x == y && equal(xs, ys)
    | _ => false end
in

# Initialize a list with a given length using an initializer function #
let init: (Int, Int -> Int) -> [Int] =
    fun len, f ->
        let go: (Int, [Int]) -> [Int] =
        fun idx, xs ->
            if idx < len 
            then go(idx + 1, xs @ [f(idx)])   
            else xs
        in
        go(0, [])
in

# Reduce a list from the left. #
let fold_left: ((Int, Int) -> Int, Int, [Int]) -> Int =
  fun f, acc, xs ->
    case xs 
    | [] => acc
    | hd::tl => fold_left(f, f(acc, hd), tl) end in

# Reduce a list from the right. #
let fold_right: ((Int, Int) -> Int, [Int], Int) -> Int =
  fun f, xs, acc ->
    case xs
    | [] => acc
    | hd::tl => f(hd, fold_right(f, tl, acc)) end in


666
LSP: Prelude: String parsed successfully
LSP: Prelude: Info map generated successfully
Debug: true, Constrain: Types
LSP: Init: Recieved string: # Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)





































































































































































LSP: Init: String parsed successfully
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: >( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {go: ((?, ?) -> [?]), filter: (((Int -> Bool), [Int]) -> [Int]), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: 
  LSP: Info: ALL errors:Error in term:
  p
Nature of error: Variable p is not bound    
Error in term:
  p
Nature of error: Variable p is not bound    
Error in term:
  p
Nature of error: type ((Int -> Bool), [Int]) is not consistent with arrow type
  LSP: Info: BidiCtx: Cls: Let expression
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent: Root
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: [?]
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: :: @
  LSP: Concave: Backpack: 
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new_tokens ::= whitespace | "," | "::" | "@"
root ::= new_tokens

Top 20 Logits:

:19.4592
#:15.1989
##:14.4464
let:14.3512
 :13.0909
in:12.602
    :12.4914
################:12.4805
  :12.4228
   :12.3439
####:12.0431
/*:11.9319
```:11.8995
//:11.3789
                :11.2684
[:11.2112
end:11.2057
def:11.1439
        :11.1206
(:11.0822
########:11.0347

================
# Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)







































































































































































LSP: Prelude: Recieved string: ### List ###

# Add an element to the front of a list. #
let cons: (Int, [Int]) -> [Int] = fun x, xs -> x::xs in

# Determine the length of a list. #
let length: [Int] -> Int =
  fun xs ->
    case xs
    | [] => 0
    | _::xs => 1 + length(xs) end in

# Extract the first element of a list. #
let hd: [Int] -> Option =
  fun l ->
    case l
    | [] => None
    | x::xs => Some(x) end in

# Extract the rest of the list. #
let tl: [Int] -> [Int] =
  fun l ->
    case l
    | [] => []
    | x::xs => xs end in

# Determine if a list is empty. #
let is_empty: [Int] -> Bool =
  fun xs ->
    case xs
    | [] => true
    | _::_ => false end in

# Return the element at the index. #
let nth: ([Int], Int) -> Option =
  fun xs, n ->
    case xs, n
    | x::_, 0 => Some(x)
    | _::xs, n => nth(xs, n - 1)
    | [], _ => None end in

# Reverse a List. #
let rev: [Int] -> [Int] =
fun l -> 
let go: ([Int], [Int]) -> [Int] =
  fun xs, acc -> 
    case xs 
    | [] => acc 
    | x::xs => go(xs, x::acc) end in
go(l, []) in

# Check if two lists are equal #
let equal: ([Int], [Int]) -> Bool =
    fun p, xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => x == y && equal(xs, ys)
    | _ => false end
in

# Initialize a list with a given length using an initializer function #
let init: (Int, Int -> Int) -> [Int] =
    fun len, f ->
        let go: (Int, [Int]) -> [Int] =
        fun idx, xs ->
            if idx < len 
            then go(idx + 1, xs @ [f(idx)])   
            else xs
        in
        go(0, [])
in

# Reduce a list from the left. #
let fold_left: ((Int, Int) -> Int, Int, [Int]) -> Int =
  fun f, acc, xs ->
    case xs 
    | [] => acc
    | hd::tl => fold_left(f, f(acc, hd), tl) end in

# Reduce a list from the right. #
let fold_right: ((Int, Int) -> Int, [Int], Int) -> Int =
  fun f, xs, acc ->
    case xs
    | [] => acc
    | hd::tl => f(hd, fold_right(f, tl, acc)) end in


666
LSP: Prelude: String parsed successfully
LSP: Prelude: Info map generated successfully
Debug: true, Constrain: Types
LSP: Init: Recieved string: # Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)






































































































































































LSP: Init: String parsed successfully
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: >( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {go: ((?, ?) -> [?]), filter: (((Int -> Bool), [Int]) -> [Int]), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: 
  LSP: Info: ALL errors:Error in term:
  p
Nature of error: type ((Int -> Bool), [Int]) is not consistent with arrow type    
Error in term:
  p
Nature of error: Variable p is not bound    
Error in term:
  p
Nature of error: Variable p is not bound
  LSP: Info: BidiCtx: Cls: Let expression
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent: Root
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: [?]
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: :: @
  LSP: Concave: Backpack: 
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new_tokens ::= whitespace | "," | "::" | "@"
root ::= new_tokens

Top 20 Logits:

:19.4639
#:15.1937
##:14.4405
let:14.3397
 :13.0943
in:12.6455
    :12.5005
################:12.4775
  :12.4258
   :12.347
####:12.0416
/*:11.9265
```:11.8901
//:11.3771
                :11.2702
end:11.2416
[:11.2034
def:11.1539
        :11.1225
(:11.078
########:11.0309

================
# Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)








































































































































































LSP: Prelude: Recieved string: ### List ###

# Add an element to the front of a list. #
let cons: (Int, [Int]) -> [Int] = fun x, xs -> x::xs in

# Determine the length of a list. #
let length: [Int] -> Int =
  fun xs ->
    case xs
    | [] => 0
    | _::xs => 1 + length(xs) end in

# Extract the first element of a list. #
let hd: [Int] -> Option =
  fun l ->
    case l
    | [] => None
    | x::xs => Some(x) end in

# Extract the rest of the list. #
let tl: [Int] -> [Int] =
  fun l ->
    case l
    | [] => []
    | x::xs => xs end in

# Determine if a list is empty. #
let is_empty: [Int] -> Bool =
  fun xs ->
    case xs
    | [] => true
    | _::_ => false end in

# Return the element at the index. #
let nth: ([Int], Int) -> Option =
  fun xs, n ->
    case xs, n
    | x::_, 0 => Some(x)
    | _::xs, n => nth(xs, n - 1)
    | [], _ => None end in

# Reverse a List. #
let rev: [Int] -> [Int] =
fun l -> 
let go: ([Int], [Int]) -> [Int] =
  fun xs, acc -> 
    case xs 
    | [] => acc 
    | x::xs => go(xs, x::acc) end in
go(l, []) in

# Check if two lists are equal #
let equal: ([Int], [Int]) -> Bool =
    fun p, xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => x == y && equal(xs, ys)
    | _ => false end
in

# Initialize a list with a given length using an initializer function #
let init: (Int, Int -> Int) -> [Int] =
    fun len, f ->
        let go: (Int, [Int]) -> [Int] =
        fun idx, xs ->
            if idx < len 
            then go(idx + 1, xs @ [f(idx)])   
            else xs
        in
        go(0, [])
in

# Reduce a list from the left. #
let fold_left: ((Int, Int) -> Int, Int, [Int]) -> Int =
  fun f, acc, xs ->
    case xs 
    | [] => acc
    | hd::tl => fold_left(f, f(acc, hd), tl) end in

# Reduce a list from the right. #
let fold_right: ((Int, Int) -> Int, [Int], Int) -> Int =
  fun f, xs, acc ->
    case xs
    | [] => acc
    | hd::tl => f(hd, fold_right(f, tl, acc)) end in


666
LSP: Prelude: String parsed successfully
LSP: Prelude: Info map generated successfully
Debug: true, Constrain: Types
LSP: Init: Recieved string: # Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)







































































































































































LSP: Init: String parsed successfully
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: >( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {go: ((?, ?) -> [?]), filter: (((Int -> Bool), [Int]) -> [Int]), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: 
  LSP: Info: ALL errors:Error in term:
  p
Nature of error: Variable p is not bound    
Error in term:
  p
Nature of error: Variable p is not bound    
Error in term:
  p
Nature of error: type ((Int -> Bool), [Int]) is not consistent with arrow type
  LSP: Info: BidiCtx: Cls: Let expression
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent: Root
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: [?]
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: :: @
  LSP: Concave: Backpack: 
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new_tokens ::= whitespace | "," | "::" | "@"
root ::= new_tokens

Top 20 Logits:

:19.4705
#:15.1971
##:14.4271
let:14.3353
 :13.0984
in:12.6859
    :12.5039
################:12.4686
  :12.4262
   :12.3492
####:12.0384
/*:11.9239
```:11.8844
//:11.3796
                :11.2709
end:11.2682
[:11.2019
def:11.1562
        :11.1233
(:11.0827
########:11.0229

================
# Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)









































































































































































LSP: Prelude: Recieved string: ### List ###

# Add an element to the front of a list. #
let cons: (Int, [Int]) -> [Int] = fun x, xs -> x::xs in

# Determine the length of a list. #
let length: [Int] -> Int =
  fun xs ->
    case xs
    | [] => 0
    | _::xs => 1 + length(xs) end in

# Extract the first element of a list. #
let hd: [Int] -> Option =
  fun l ->
    case l
    | [] => None
    | x::xs => Some(x) end in

# Extract the rest of the list. #
let tl: [Int] -> [Int] =
  fun l ->
    case l
    | [] => []
    | x::xs => xs end in

# Determine if a list is empty. #
let is_empty: [Int] -> Bool =
  fun xs ->
    case xs
    | [] => true
    | _::_ => false end in

# Return the element at the index. #
let nth: ([Int], Int) -> Option =
  fun xs, n ->
    case xs, n
    | x::_, 0 => Some(x)
    | _::xs, n => nth(xs, n - 1)
    | [], _ => None end in

# Reverse a List. #
let rev: [Int] -> [Int] =
fun l -> 
let go: ([Int], [Int]) -> [Int] =
  fun xs, acc -> 
    case xs 
    | [] => acc 
    | x::xs => go(xs, x::acc) end in
go(l, []) in

# Check if two lists are equal #
let equal: ([Int], [Int]) -> Bool =
    fun p, xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => x == y && equal(xs, ys)
    | _ => false end
in

# Initialize a list with a given length using an initializer function #
let init: (Int, Int -> Int) -> [Int] =
    fun len, f ->
        let go: (Int, [Int]) -> [Int] =
        fun idx, xs ->
            if idx < len 
            then go(idx + 1, xs @ [f(idx)])   
            else xs
        in
        go(0, [])
in

# Reduce a list from the left. #
let fold_left: ((Int, Int) -> Int, Int, [Int]) -> Int =
  fun f, acc, xs ->
    case xs 
    | [] => acc
    | hd::tl => fold_left(f, f(acc, hd), tl) end in

# Reduce a list from the right. #
let fold_right: ((Int, Int) -> Int, [Int], Int) -> Int =
  fun f, xs, acc ->
    case xs
    | [] => acc
    | hd::tl => f(hd, fold_right(f, tl, acc)) end in


666
LSP: Prelude: String parsed successfully
LSP: Prelude: Info map generated successfully
Debug: true, Constrain: Types
LSP: Init: Recieved string: # Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)








































































































































































LSP: Init: String parsed successfully
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: >( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {go: ((?, ?) -> [?]), filter: (((Int -> Bool), [Int]) -> [Int]), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: 
  LSP: Info: ALL errors:Error in term:
  p
Nature of error: type ((Int -> Bool), [Int]) is not consistent with arrow type    
Error in term:
  p
Nature of error: Variable p is not bound    
Error in term:
  p
Nature of error: Variable p is not bound
  LSP: Info: BidiCtx: Cls: Let expression
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent: Root
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: [?]
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: :: @
  LSP: Concave: Backpack: 
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new_tokens ::= whitespace | "," | "::" | "@"
root ::= new_tokens

Top 20 Logits:

:19.4796
#:15.2057
##:14.4101
let:14.3404
 :13.1018
in:12.7172
    :12.501
################:12.4566
  :12.4235
   :12.3505
####:12.0342
/*:11.9242
```:11.8836
//:11.3875
end:11.2781
                :11.2713
[:11.2055
def:11.1538
        :11.1211
(:11.0868
########:11.0129

================
# Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)










































































































































































LSP: Prelude: Recieved string: ### List ###

# Add an element to the front of a list. #
let cons: (Int, [Int]) -> [Int] = fun x, xs -> x::xs in

# Determine the length of a list. #
let length: [Int] -> Int =
  fun xs ->
    case xs
    | [] => 0
    | _::xs => 1 + length(xs) end in

# Extract the first element of a list. #
let hd: [Int] -> Option =
  fun l ->
    case l
    | [] => None
    | x::xs => Some(x) end in

# Extract the rest of the list. #
let tl: [Int] -> [Int] =
  fun l ->
    case l
    | [] => []
    | x::xs => xs end in

# Determine if a list is empty. #
let is_empty: [Int] -> Bool =
  fun xs ->
    case xs
    | [] => true
    | _::_ => false end in

# Return the element at the index. #
let nth: ([Int], Int) -> Option =
  fun xs, n ->
    case xs, n
    | x::_, 0 => Some(x)
    | _::xs, n => nth(xs, n - 1)
    | [], _ => None end in

# Reverse a List. #
let rev: [Int] -> [Int] =
fun l -> 
let go: ([Int], [Int]) -> [Int] =
  fun xs, acc -> 
    case xs 
    | [] => acc 
    | x::xs => go(xs, x::acc) end in
go(l, []) in

# Check if two lists are equal #
let equal: ([Int], [Int]) -> Bool =
    fun p, xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => x == y && equal(xs, ys)
    | _ => false end
in

# Initialize a list with a given length using an initializer function #
let init: (Int, Int -> Int) -> [Int] =
    fun len, f ->
        let go: (Int, [Int]) -> [Int] =
        fun idx, xs ->
            if idx < len 
            then go(idx + 1, xs @ [f(idx)])   
            else xs
        in
        go(0, [])
in

# Reduce a list from the left. #
let fold_left: ((Int, Int) -> Int, Int, [Int]) -> Int =
  fun f, acc, xs ->
    case xs 
    | [] => acc
    | hd::tl => fold_left(f, f(acc, hd), tl) end in

# Reduce a list from the right. #
let fold_right: ((Int, Int) -> Int, [Int], Int) -> Int =
  fun f, xs, acc ->
    case xs
    | [] => acc
    | hd::tl => f(hd, fold_right(f, tl, acc)) end in


666
LSP: Prelude: String parsed successfully
LSP: Prelude: Info map generated successfully
Debug: true, Constrain: Types
LSP: Init: Recieved string: # Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)









































































































































































LSP: Init: String parsed successfully
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: >( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {go: ((?, ?) -> [?]), filter: (((Int -> Bool), [Int]) -> [Int]), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: 
  LSP: Info: ALL errors:Error in term:
  p
Nature of error: type ((Int -> Bool), [Int]) is not consistent with arrow type    
Error in term:
  p
Nature of error: Variable p is not bound    
Error in term:
  p
Nature of error: Variable p is not bound
  LSP: Info: BidiCtx: Cls: Let expression
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent: Root
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: [?]
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: :: @
  LSP: Concave: Backpack: 
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new_tokens ::= whitespace | "," | "::" | "@"
root ::= new_tokens

Top 20 Logits:

:19.4886
#:15.2118
##:14.3915
let:14.3489
 :13.1021
in:12.7383
    :12.4944
################:12.4451
  :12.4182
   :12.3494
####:12.0279
/*:11.9237
```:11.8827
//:11.3964
end:11.2774
                :11.2703
[:11.2068
def:11.1505
        :11.1155
(:11.0806
########:11.0022

================
# Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)











































































































































































LSP: Prelude: Recieved string: ### List ###

# Add an element to the front of a list. #
let cons: (Int, [Int]) -> [Int] = fun x, xs -> x::xs in

# Determine the length of a list. #
let length: [Int] -> Int =
  fun xs ->
    case xs
    | [] => 0
    | _::xs => 1 + length(xs) end in

# Extract the first element of a list. #
let hd: [Int] -> Option =
  fun l ->
    case l
    | [] => None
    | x::xs => Some(x) end in

# Extract the rest of the list. #
let tl: [Int] -> [Int] =
  fun l ->
    case l
    | [] => []
    | x::xs => xs end in

# Determine if a list is empty. #
let is_empty: [Int] -> Bool =
  fun xs ->
    case xs
    | [] => true
    | _::_ => false end in

# Return the element at the index. #
let nth: ([Int], Int) -> Option =
  fun xs, n ->
    case xs, n
    | x::_, 0 => Some(x)
    | _::xs, n => nth(xs, n - 1)
    | [], _ => None end in

# Reverse a List. #
let rev: [Int] -> [Int] =
fun l -> 
let go: ([Int], [Int]) -> [Int] =
  fun xs, acc -> 
    case xs 
    | [] => acc 
    | x::xs => go(xs, x::acc) end in
go(l, []) in

# Check if two lists are equal #
let equal: ([Int], [Int]) -> Bool =
    fun p, xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => x == y && equal(xs, ys)
    | _ => false end
in

# Initialize a list with a given length using an initializer function #
let init: (Int, Int -> Int) -> [Int] =
    fun len, f ->
        let go: (Int, [Int]) -> [Int] =
        fun idx, xs ->
            if idx < len 
            then go(idx + 1, xs @ [f(idx)])   
            else xs
        in
        go(0, [])
in

# Reduce a list from the left. #
let fold_left: ((Int, Int) -> Int, Int, [Int]) -> Int =
  fun f, acc, xs ->
    case xs 
    | [] => acc
    | hd::tl => fold_left(f, f(acc, hd), tl) end in

# Reduce a list from the right. #
let fold_right: ((Int, Int) -> Int, [Int], Int) -> Int =
  fun f, xs, acc ->
    case xs
    | [] => acc
    | hd::tl => f(hd, fold_right(f, tl, acc)) end in


666
LSP: Prelude: String parsed successfully
LSP: Prelude: Info map generated successfully
Debug: true, Constrain: Types
LSP: Init: Recieved string: # Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)










































































































































































LSP: Init: String parsed successfully
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: >( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {go: ((?, ?) -> [?]), filter: (((Int -> Bool), [Int]) -> [Int]), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: 
  LSP: Info: ALL errors:Error in term:
  p
Nature of error: Variable p is not bound    
Error in term:
  p
Nature of error: Variable p is not bound    
Error in term:
  p
Nature of error: type ((Int -> Bool), [Int]) is not consistent with arrow type
  LSP: Info: BidiCtx: Cls: Let expression
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent: Root
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: [?]
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: :: @
  LSP: Concave: Backpack: 
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new_tokens ::= whitespace | "," | "::" | "@"
root ::= new_tokens

Top 20 Logits:

:19.4952
#:15.2091
##:14.3764
let:14.3529
 :13.0993
in:12.7358
    :12.4887
################:12.4372
  :12.4115
   :12.3463
####:12.0216
/*:11.9219
```:11.8746
//:11.4022
end:11.2731
                :11.2648
[:11.2025
def:11.1509
        :11.108
(:11.0637
########:10.9939

================
# Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)












































































































































































LSP: Prelude: Recieved string: ### List ###

# Add an element to the front of a list. #
let cons: (Int, [Int]) -> [Int] = fun x, xs -> x::xs in

# Determine the length of a list. #
let length: [Int] -> Int =
  fun xs ->
    case xs
    | [] => 0
    | _::xs => 1 + length(xs) end in

# Extract the first element of a list. #
let hd: [Int] -> Option =
  fun l ->
    case l
    | [] => None
    | x::xs => Some(x) end in

# Extract the rest of the list. #
let tl: [Int] -> [Int] =
  fun l ->
    case l
    | [] => []
    | x::xs => xs end in

# Determine if a list is empty. #
let is_empty: [Int] -> Bool =
  fun xs ->
    case xs
    | [] => true
    | _::_ => false end in

# Return the element at the index. #
let nth: ([Int], Int) -> Option =
  fun xs, n ->
    case xs, n
    | x::_, 0 => Some(x)
    | _::xs, n => nth(xs, n - 1)
    | [], _ => None end in

# Reverse a List. #
let rev: [Int] -> [Int] =
fun l -> 
let go: ([Int], [Int]) -> [Int] =
  fun xs, acc -> 
    case xs 
    | [] => acc 
    | x::xs => go(xs, x::acc) end in
go(l, []) in

# Check if two lists are equal #
let equal: ([Int], [Int]) -> Bool =
    fun p, xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => x == y && equal(xs, ys)
    | _ => false end
in

# Initialize a list with a given length using an initializer function #
let init: (Int, Int -> Int) -> [Int] =
    fun len, f ->
        let go: (Int, [Int]) -> [Int] =
        fun idx, xs ->
            if idx < len 
            then go(idx + 1, xs @ [f(idx)])   
            else xs
        in
        go(0, [])
in

# Reduce a list from the left. #
let fold_left: ((Int, Int) -> Int, Int, [Int]) -> Int =
  fun f, acc, xs ->
    case xs 
    | [] => acc
    | hd::tl => fold_left(f, f(acc, hd), tl) end in

# Reduce a list from the right. #
let fold_right: ((Int, Int) -> Int, [Int], Int) -> Int =
  fun f, xs, acc ->
    case xs
    | [] => acc
    | hd::tl => f(hd, fold_right(f, tl, acc)) end in


666
LSP: Prelude: String parsed successfully
LSP: Prelude: Info map generated successfully
Debug: true, Constrain: Types
LSP: Init: Recieved string: # Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)











































































































































































LSP: Init: String parsed successfully
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: >( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {go: ((?, ?) -> [?]), filter: (((Int -> Bool), [Int]) -> [Int]), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: 
  LSP: Info: ALL errors:Error in term:
  p
Nature of error: Variable p is not bound    
Error in term:
  p
Nature of error: type ((Int -> Bool), [Int]) is not consistent with arrow type    
Error in term:
  p
Nature of error: Variable p is not bound
  LSP: Info: BidiCtx: Cls: Let expression
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent: Root
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: [?]
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: :: @
  LSP: Concave: Backpack: 
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new_tokens ::= whitespace | "," | "::" | "@"
root ::= new_tokens

Top 20 Logits:

:19.5003
#:15.1994
##:14.3726
let:14.3479
 :13.0962
in:12.6968
    :12.4882
################:12.4356
  :12.4067
   :12.3441
####:12.022
/*:11.9198
```:11.8602
//:11.4042
end:11.2648
                :11.2551
[:11.1961
def:11.1556
        :11.1024
(:11.0456
########:10.9946

================
# Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)













































































































































































LSP: Prelude: Recieved string: ### List ###

# Add an element to the front of a list. #
let cons: (Int, [Int]) -> [Int] = fun x, xs -> x::xs in

# Determine the length of a list. #
let length: [Int] -> Int =
  fun xs ->
    case xs
    | [] => 0
    | _::xs => 1 + length(xs) end in

# Extract the first element of a list. #
let hd: [Int] -> Option =
  fun l ->
    case l
    | [] => None
    | x::xs => Some(x) end in

# Extract the rest of the list. #
let tl: [Int] -> [Int] =
  fun l ->
    case l
    | [] => []
    | x::xs => xs end in

# Determine if a list is empty. #
let is_empty: [Int] -> Bool =
  fun xs ->
    case xs
    | [] => true
    | _::_ => false end in

# Return the element at the index. #
let nth: ([Int], Int) -> Option =
  fun xs, n ->
    case xs, n
    | x::_, 0 => Some(x)
    | _::xs, n => nth(xs, n - 1)
    | [], _ => None end in

# Reverse a List. #
let rev: [Int] -> [Int] =
fun l -> 
let go: ([Int], [Int]) -> [Int] =
  fun xs, acc -> 
    case xs 
    | [] => acc 
    | x::xs => go(xs, x::acc) end in
go(l, []) in

# Check if two lists are equal #
let equal: ([Int], [Int]) -> Bool =
    fun p, xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => x == y && equal(xs, ys)
    | _ => false end
in

# Initialize a list with a given length using an initializer function #
let init: (Int, Int -> Int) -> [Int] =
    fun len, f ->
        let go: (Int, [Int]) -> [Int] =
        fun idx, xs ->
            if idx < len 
            then go(idx + 1, xs @ [f(idx)])   
            else xs
        in
        go(0, [])
in

# Reduce a list from the left. #
let fold_left: ((Int, Int) -> Int, Int, [Int]) -> Int =
  fun f, acc, xs ->
    case xs 
    | [] => acc
    | hd::tl => fold_left(f, f(acc, hd), tl) end in

# Reduce a list from the right. #
let fold_right: ((Int, Int) -> Int, [Int], Int) -> Int =
  fun f, xs, acc ->
    case xs
    | [] => acc
    | hd::tl => f(hd, fold_right(f, tl, acc)) end in


666
LSP: Prelude: String parsed successfully
LSP: Prelude: Info map generated successfully
Debug: true, Constrain: Types
LSP: Init: Recieved string: # Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)












































































































































































LSP: Init: String parsed successfully
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: >( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {go: ((?, ?) -> [?]), filter: (((Int -> Bool), [Int]) -> [Int]), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: 
  LSP: Info: ALL errors:Error in term:
  p
Nature of error: Variable p is not bound    
Error in term:
  p
Nature of error: type ((Int -> Bool), [Int]) is not consistent with arrow type    
Error in term:
  p
Nature of error: Variable p is not bound
  LSP: Info: BidiCtx: Cls: Let expression
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent: Root
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: [?]
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: :: @
  LSP: Concave: Backpack: 
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new_tokens ::= whitespace | "," | "::" | "@"
root ::= new_tokens

Top 20 Logits:

:19.5083
#:15.1889
##:14.3817
let:14.337
 :13.0962
in:12.6354
    :12.4927
################:12.442
  :12.4081
   :12.3444
####:12.032
/*:11.9168
```:11.8502
//:11.404
end:11.2517
                :11.2465
[:11.1916
def:11.1612
        :11.1027
(:11.0369
########:11.0065

================
# Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)














































































































































































LSP: Prelude: Recieved string: ### List ###

# Add an element to the front of a list. #
let cons: (Int, [Int]) -> [Int] = fun x, xs -> x::xs in

# Determine the length of a list. #
let length: [Int] -> Int =
  fun xs ->
    case xs
    | [] => 0
    | _::xs => 1 + length(xs) end in

# Extract the first element of a list. #
let hd: [Int] -> Option =
  fun l ->
    case l
    | [] => None
    | x::xs => Some(x) end in

# Extract the rest of the list. #
let tl: [Int] -> [Int] =
  fun l ->
    case l
    | [] => []
    | x::xs => xs end in

# Determine if a list is empty. #
let is_empty: [Int] -> Bool =
  fun xs ->
    case xs
    | [] => true
    | _::_ => false end in

# Return the element at the index. #
let nth: ([Int], Int) -> Option =
  fun xs, n ->
    case xs, n
    | x::_, 0 => Some(x)
    | _::xs, n => nth(xs, n - 1)
    | [], _ => None end in

# Reverse a List. #
let rev: [Int] -> [Int] =
fun l -> 
let go: ([Int], [Int]) -> [Int] =
  fun xs, acc -> 
    case xs 
    | [] => acc 
    | x::xs => go(xs, x::acc) end in
go(l, []) in

# Check if two lists are equal #
let equal: ([Int], [Int]) -> Bool =
    fun p, xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => x == y && equal(xs, ys)
    | _ => false end
in

# Initialize a list with a given length using an initializer function #
let init: (Int, Int -> Int) -> [Int] =
    fun len, f ->
        let go: (Int, [Int]) -> [Int] =
        fun idx, xs ->
            if idx < len 
            then go(idx + 1, xs @ [f(idx)])   
            else xs
        in
        go(0, [])
in

# Reduce a list from the left. #
let fold_left: ((Int, Int) -> Int, Int, [Int]) -> Int =
  fun f, acc, xs ->
    case xs 
    | [] => acc
    | hd::tl => fold_left(f, f(acc, hd), tl) end in

# Reduce a list from the right. #
let fold_right: ((Int, Int) -> Int, [Int], Int) -> Int =
  fun f, xs, acc ->
    case xs
    | [] => acc
    | hd::tl => f(hd, fold_right(f, tl, acc)) end in


666
LSP: Prelude: String parsed successfully
LSP: Prelude: Info map generated successfully
Debug: true, Constrain: Types
LSP: Init: Recieved string: # Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)













































































































































































LSP: Init: String parsed successfully
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: >( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {go: ((?, ?) -> [?]), filter: (((Int -> Bool), [Int]) -> [Int]), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: 
  LSP: Info: ALL errors:Error in term:
  p
Nature of error: Variable p is not bound    
Error in term:
  p
Nature of error: type ((Int -> Bool), [Int]) is not consistent with arrow type    
Error in term:
  p
Nature of error: Variable p is not bound
  LSP: Info: BidiCtx: Cls: Let expression
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent: Root
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: [?]
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: :: @
  LSP: Concave: Backpack: 
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new_tokens ::= whitespace | "," | "::" | "@"
root ::= new_tokens

Top 20 Logits:

:19.5203
#:15.1813
##:14.3967
let:14.329
 :13.0979
in:12.5779
    :12.4961
################:12.4538
  :12.4135
   :12.3452
####:12.0461
/*:11.9132
```:11.8495
//:11.4034
                :11.2426
end:11.2345
[:11.1925
def:11.1671
        :11.1062
(:11.042
########:11.0232

================
# Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)















































































































































































LSP: Prelude: Recieved string: ### List ###

# Add an element to the front of a list. #
let cons: (Int, [Int]) -> [Int] = fun x, xs -> x::xs in

# Determine the length of a list. #
let length: [Int] -> Int =
  fun xs ->
    case xs
    | [] => 0
    | _::xs => 1 + length(xs) end in

# Extract the first element of a list. #
let hd: [Int] -> Option =
  fun l ->
    case l
    | [] => None
    | x::xs => Some(x) end in

# Extract the rest of the list. #
let tl: [Int] -> [Int] =
  fun l ->
    case l
    | [] => []
    | x::xs => xs end in

# Determine if a list is empty. #
let is_empty: [Int] -> Bool =
  fun xs ->
    case xs
    | [] => true
    | _::_ => false end in

# Return the element at the index. #
let nth: ([Int], Int) -> Option =
  fun xs, n ->
    case xs, n
    | x::_, 0 => Some(x)
    | _::xs, n => nth(xs, n - 1)
    | [], _ => None end in

# Reverse a List. #
let rev: [Int] -> [Int] =
fun l -> 
let go: ([Int], [Int]) -> [Int] =
  fun xs, acc -> 
    case xs 
    | [] => acc 
    | x::xs => go(xs, x::acc) end in
go(l, []) in

# Check if two lists are equal #
let equal: ([Int], [Int]) -> Bool =
    fun p, xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => x == y && equal(xs, ys)
    | _ => false end
in

# Initialize a list with a given length using an initializer function #
let init: (Int, Int -> Int) -> [Int] =
    fun len, f ->
        let go: (Int, [Int]) -> [Int] =
        fun idx, xs ->
            if idx < len 
            then go(idx + 1, xs @ [f(idx)])   
            else xs
        in
        go(0, [])
in

# Reduce a list from the left. #
let fold_left: ((Int, Int) -> Int, Int, [Int]) -> Int =
  fun f, acc, xs ->
    case xs 
    | [] => acc
    | hd::tl => fold_left(f, f(acc, hd), tl) end in

# Reduce a list from the right. #
let fold_right: ((Int, Int) -> Int, [Int], Int) -> Int =
  fun f, xs, acc ->
    case xs
    | [] => acc
    | hd::tl => f(hd, fold_right(f, tl, acc)) end in


666
LSP: Prelude: String parsed successfully
LSP: Prelude: Info map generated successfully
Debug: true, Constrain: Types
LSP: Init: Recieved string: # Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)














































































































































































LSP: Init: String parsed successfully
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: >( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {go: ((?, ?) -> [?]), filter: (((Int -> Bool), [Int]) -> [Int]), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: 
  LSP: Info: ALL errors:Error in term:
  p
Nature of error: type ((Int -> Bool), [Int]) is not consistent with arrow type    
Error in term:
  p
Nature of error: Variable p is not bound    
Error in term:
  p
Nature of error: Variable p is not bound
  LSP: Info: BidiCtx: Cls: Let expression
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent: Root
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: [?]
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: :: @
  LSP: Concave: Backpack: 
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new_tokens ::= whitespace | "," | "::" | "@"
root ::= new_tokens

Top 20 Logits:

:19.5356
#:15.1772
##:14.4084
let:14.3304
 :13.1003
in:12.5489
    :12.4954
################:12.4655
  :12.4209
   :12.3445
####:12.0568
/*:11.909
```:11.8569
//:11.403
                :11.2442
end:11.224
[:11.1999
def:11.1713
        :11.109
(:11.0553
########:11.0341

================
# Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)
















































































































































































LSP: Prelude: Recieved string: ### List ###

# Add an element to the front of a list. #
let cons: (Int, [Int]) -> [Int] = fun x, xs -> x::xs in

# Determine the length of a list. #
let length: [Int] -> Int =
  fun xs ->
    case xs
    | [] => 0
    | _::xs => 1 + length(xs) end in

# Extract the first element of a list. #
let hd: [Int] -> Option =
  fun l ->
    case l
    | [] => None
    | x::xs => Some(x) end in

# Extract the rest of the list. #
let tl: [Int] -> [Int] =
  fun l ->
    case l
    | [] => []
    | x::xs => xs end in

# Determine if a list is empty. #
let is_empty: [Int] -> Bool =
  fun xs ->
    case xs
    | [] => true
    | _::_ => false end in

# Return the element at the index. #
let nth: ([Int], Int) -> Option =
  fun xs, n ->
    case xs, n
    | x::_, 0 => Some(x)
    | _::xs, n => nth(xs, n - 1)
    | [], _ => None end in

# Reverse a List. #
let rev: [Int] -> [Int] =
fun l -> 
let go: ([Int], [Int]) -> [Int] =
  fun xs, acc -> 
    case xs 
    | [] => acc 
    | x::xs => go(xs, x::acc) end in
go(l, []) in

# Check if two lists are equal #
let equal: ([Int], [Int]) -> Bool =
    fun p, xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => x == y && equal(xs, ys)
    | _ => false end
in

# Initialize a list with a given length using an initializer function #
let init: (Int, Int -> Int) -> [Int] =
    fun len, f ->
        let go: (Int, [Int]) -> [Int] =
        fun idx, xs ->
            if idx < len 
            then go(idx + 1, xs @ [f(idx)])   
            else xs
        in
        go(0, [])
in

# Reduce a list from the left. #
let fold_left: ((Int, Int) -> Int, Int, [Int]) -> Int =
  fun f, acc, xs ->
    case xs 
    | [] => acc
    | hd::tl => fold_left(f, f(acc, hd), tl) end in

# Reduce a list from the right. #
let fold_right: ((Int, Int) -> Int, [Int], Int) -> Int =
  fun f, xs, acc ->
    case xs
    | [] => acc
    | hd::tl => f(hd, fold_right(f, tl, acc)) end in


666
LSP: Prelude: String parsed successfully
LSP: Prelude: Info map generated successfully
Debug: true, Constrain: Types
LSP: Init: Recieved string: # Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)















































































































































































LSP: Init: String parsed successfully
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: >( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {go: ((?, ?) -> [?]), filter: (((Int -> Bool), [Int]) -> [Int]), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: 
  LSP: Info: ALL errors:Error in term:
  p
Nature of error: Variable p is not bound    
Error in term:
  p
Nature of error: Variable p is not bound    
Error in term:
  p
Nature of error: type ((Int -> Bool), [Int]) is not consistent with arrow type
  LSP: Info: BidiCtx: Cls: Let expression
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent: Root
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: [?]
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: :: @
  LSP: Concave: Backpack: 
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new_tokens ::= whitespace | "," | "::" | "@"
root ::= new_tokens

Top 20 Logits:

:19.5506
#:15.175
##:14.4067
let:14.3391
 :13.1003
in:12.5555
    :12.4904
################:12.4705
  :12.4263
   :12.3389
####:12.0568
/*:11.9039
```:11.8647
//:11.4011
                :11.2491
end:11.2269
[:11.2092
def:11.1708
        :11.1075
(:11.0673
########:11.0321

================
# Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)

















































































































































































LSP: Prelude: Recieved string: ### List ###

# Add an element to the front of a list. #
let cons: (Int, [Int]) -> [Int] = fun x, xs -> x::xs in

# Determine the length of a list. #
let length: [Int] -> Int =
  fun xs ->
    case xs
    | [] => 0
    | _::xs => 1 + length(xs) end in

# Extract the first element of a list. #
let hd: [Int] -> Option =
  fun l ->
    case l
    | [] => None
    | x::xs => Some(x) end in

# Extract the rest of the list. #
let tl: [Int] -> [Int] =
  fun l ->
    case l
    | [] => []
    | x::xs => xs end in

# Determine if a list is empty. #
let is_empty: [Int] -> Bool =
  fun xs ->
    case xs
    | [] => true
    | _::_ => false end in

# Return the element at the index. #
let nth: ([Int], Int) -> Option =
  fun xs, n ->
    case xs, n
    | x::_, 0 => Some(x)
    | _::xs, n => nth(xs, n - 1)
    | [], _ => None end in

# Reverse a List. #
let rev: [Int] -> [Int] =
fun l -> 
let go: ([Int], [Int]) -> [Int] =
  fun xs, acc -> 
    case xs 
    | [] => acc 
    | x::xs => go(xs, x::acc) end in
go(l, []) in

# Check if two lists are equal #
let equal: ([Int], [Int]) -> Bool =
    fun p, xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => x == y && equal(xs, ys)
    | _ => false end
in

# Initialize a list with a given length using an initializer function #
let init: (Int, Int -> Int) -> [Int] =
    fun len, f ->
        let go: (Int, [Int]) -> [Int] =
        fun idx, xs ->
            if idx < len 
            then go(idx + 1, xs @ [f(idx)])   
            else xs
        in
        go(0, [])
in

# Reduce a list from the left. #
let fold_left: ((Int, Int) -> Int, Int, [Int]) -> Int =
  fun f, acc, xs ->
    case xs 
    | [] => acc
    | hd::tl => fold_left(f, f(acc, hd), tl) end in

# Reduce a list from the right. #
let fold_right: ((Int, Int) -> Int, [Int], Int) -> Int =
  fun f, xs, acc ->
    case xs
    | [] => acc
    | hd::tl => f(hd, fold_right(f, tl, acc)) end in


666
LSP: Prelude: String parsed successfully
LSP: Prelude: Info map generated successfully
Debug: true, Constrain: Types
LSP: Init: Recieved string: # Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)
















































































































































































LSP: Init: String parsed successfully
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: >( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {go: ((?, ?) -> [?]), filter: (((Int -> Bool), [Int]) -> [Int]), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: 
  LSP: Info: ALL errors:Error in term:
  p
Nature of error: type ((Int -> Bool), [Int]) is not consistent with arrow type    
Error in term:
  p
Nature of error: Variable p is not bound    
Error in term:
  p
Nature of error: Variable p is not bound
  LSP: Info: BidiCtx: Cls: Let expression
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent: Root
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: [?]
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: :: @
  LSP: Concave: Backpack: 
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new_tokens ::= whitespace | "," | "::" | "@"
root ::= new_tokens

Top 20 Logits:

:19.5603
#:15.1724
##:14.3898
let:14.3503
 :13.0954
in:12.5753
    :12.4824
################:12.4664
  :12.4244
   :12.3279
####:12.0457
/*:11.8993
```:11.8636
//:11.3979
                :11.2528
end:11.2372
[:11.2163
def:11.1663
        :11.0995
(:11.073
########:11.0178

================
# Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)


















































































































































































LSP: Prelude: Recieved string: ### List ###

# Add an element to the front of a list. #
let cons: (Int, [Int]) -> [Int] = fun x, xs -> x::xs in

# Determine the length of a list. #
let length: [Int] -> Int =
  fun xs ->
    case xs
    | [] => 0
    | _::xs => 1 + length(xs) end in

# Extract the first element of a list. #
let hd: [Int] -> Option =
  fun l ->
    case l
    | [] => None
    | x::xs => Some(x) end in

# Extract the rest of the list. #
let tl: [Int] -> [Int] =
  fun l ->
    case l
    | [] => []
    | x::xs => xs end in

# Determine if a list is empty. #
let is_empty: [Int] -> Bool =
  fun xs ->
    case xs
    | [] => true
    | _::_ => false end in

# Return the element at the index. #
let nth: ([Int], Int) -> Option =
  fun xs, n ->
    case xs, n
    | x::_, 0 => Some(x)
    | _::xs, n => nth(xs, n - 1)
    | [], _ => None end in

# Reverse a List. #
let rev: [Int] -> [Int] =
fun l -> 
let go: ([Int], [Int]) -> [Int] =
  fun xs, acc -> 
    case xs 
    | [] => acc 
    | x::xs => go(xs, x::acc) end in
go(l, []) in

# Check if two lists are equal #
let equal: ([Int], [Int]) -> Bool =
    fun p, xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => x == y && equal(xs, ys)
    | _ => false end
in

# Initialize a list with a given length using an initializer function #
let init: (Int, Int -> Int) -> [Int] =
    fun len, f ->
        let go: (Int, [Int]) -> [Int] =
        fun idx, xs ->
            if idx < len 
            then go(idx + 1, xs @ [f(idx)])   
            else xs
        in
        go(0, [])
in

# Reduce a list from the left. #
let fold_left: ((Int, Int) -> Int, Int, [Int]) -> Int =
  fun f, acc, xs ->
    case xs 
    | [] => acc
    | hd::tl => fold_left(f, f(acc, hd), tl) end in

# Reduce a list from the right. #
let fold_right: ((Int, Int) -> Int, [Int], Int) -> Int =
  fun f, xs, acc ->
    case xs
    | [] => acc
    | hd::tl => f(hd, fold_right(f, tl, acc)) end in


666
LSP: Prelude: String parsed successfully
LSP: Prelude: Info map generated successfully
Debug: true, Constrain: Types
LSP: Init: Recieved string: # Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)

















































































































































































LSP: Init: String parsed successfully
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: >( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {go: ((?, ?) -> [?]), filter: (((Int -> Bool), [Int]) -> [Int]), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: 
  LSP: Info: ALL errors:Error in term:
  p
Nature of error: Variable p is not bound    
Error in term:
  p
Nature of error: Variable p is not bound    
Error in term:
  p
Nature of error: type ((Int -> Bool), [Int]) is not consistent with arrow type
  LSP: Info: BidiCtx: Cls: Let expression
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent: Root
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: [?]
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: :: @
  LSP: Concave: Backpack: 
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new_tokens ::= whitespace | "," | "::" | "@"
root ::= new_tokens

Top 20 Logits:

:19.566
#:15.1706
##:14.3703
let:14.3642
 :13.09
in:12.5696
    :12.4761
################:12.4602
  :12.4186
   :12.3189
####:12.0328
/*:11.8981
```:11.8535
//:11.396
                :11.2534
end:11.2432
[:11.2234
def:11.1626
        :11.0881
(:11.0746
{:11.0197

================
# Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)



















































































































































































LSP: Prelude: Recieved string: ### List ###

# Add an element to the front of a list. #
let cons: (Int, [Int]) -> [Int] = fun x, xs -> x::xs in

# Determine the length of a list. #
let length: [Int] -> Int =
  fun xs ->
    case xs
    | [] => 0
    | _::xs => 1 + length(xs) end in

# Extract the first element of a list. #
let hd: [Int] -> Option =
  fun l ->
    case l
    | [] => None
    | x::xs => Some(x) end in

# Extract the rest of the list. #
let tl: [Int] -> [Int] =
  fun l ->
    case l
    | [] => []
    | x::xs => xs end in

# Determine if a list is empty. #
let is_empty: [Int] -> Bool =
  fun xs ->
    case xs
    | [] => true
    | _::_ => false end in

# Return the element at the index. #
let nth: ([Int], Int) -> Option =
  fun xs, n ->
    case xs, n
    | x::_, 0 => Some(x)
    | _::xs, n => nth(xs, n - 1)
    | [], _ => None end in

# Reverse a List. #
let rev: [Int] -> [Int] =
fun l -> 
let go: ([Int], [Int]) -> [Int] =
  fun xs, acc -> 
    case xs 
    | [] => acc 
    | x::xs => go(xs, x::acc) end in
go(l, []) in

# Check if two lists are equal #
let equal: ([Int], [Int]) -> Bool =
    fun p, xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => x == y && equal(xs, ys)
    | _ => false end
in

# Initialize a list with a given length using an initializer function #
let init: (Int, Int -> Int) -> [Int] =
    fun len, f ->
        let go: (Int, [Int]) -> [Int] =
        fun idx, xs ->
            if idx < len 
            then go(idx + 1, xs @ [f(idx)])   
            else xs
        in
        go(0, [])
in

# Reduce a list from the left. #
let fold_left: ((Int, Int) -> Int, Int, [Int]) -> Int =
  fun f, acc, xs ->
    case xs 
    | [] => acc
    | hd::tl => fold_left(f, f(acc, hd), tl) end in

# Reduce a list from the right. #
let fold_right: ((Int, Int) -> Int, [Int], Int) -> Int =
  fun f, xs, acc ->
    case xs
    | [] => acc
    | hd::tl => f(hd, fold_right(f, tl, acc)) end in


666
LSP: Prelude: String parsed successfully
LSP: Prelude: Info map generated successfully
Debug: true, Constrain: Types
LSP: Init: Recieved string: # Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)


















































































































































































LSP: Init: String parsed successfully
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: >( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {go: ((?, ?) -> [?]), filter: (((Int -> Bool), [Int]) -> [Int]), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: 
  LSP: Info: ALL errors:Error in term:
  p
Nature of error: Variable p is not bound    
Error in term:
  p
Nature of error: type ((Int -> Bool), [Int]) is not consistent with arrow type    
Error in term:
  p
Nature of error: Variable p is not bound
  LSP: Info: BidiCtx: Cls: Let expression
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent: Root
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: [?]
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: :: @
  LSP: Concave: Backpack: 
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new_tokens ::= whitespace | "," | "::" | "@"
root ::= new_tokens

Top 20 Logits:

:19.5743
#:15.1744
let:14.3799
##:14.3646
 :13.091
in:12.5197
    :12.4768
################:12.4628
  :12.4161
   :12.3189
####:12.0319
/*:11.9003
```:11.8465
//:11.3979
                :11.2543
end:11.234
[:11.2333
def:11.1633
        :11.0808
(:11.0782
{:11.0299

================
# Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)




















































































































































































LSP: Prelude: Recieved string: ### List ###

# Add an element to the front of a list. #
let cons: (Int, [Int]) -> [Int] = fun x, xs -> x::xs in

# Determine the length of a list. #
let length: [Int] -> Int =
  fun xs ->
    case xs
    | [] => 0
    | _::xs => 1 + length(xs) end in

# Extract the first element of a list. #
let hd: [Int] -> Option =
  fun l ->
    case l
    | [] => None
    | x::xs => Some(x) end in

# Extract the rest of the list. #
let tl: [Int] -> [Int] =
  fun l ->
    case l
    | [] => []
    | x::xs => xs end in

# Determine if a list is empty. #
let is_empty: [Int] -> Bool =
  fun xs ->
    case xs
    | [] => true
    | _::_ => false end in

# Return the element at the index. #
let nth: ([Int], Int) -> Option =
  fun xs, n ->
    case xs, n
    | x::_, 0 => Some(x)
    | _::xs, n => nth(xs, n - 1)
    | [], _ => None end in

# Reverse a List. #
let rev: [Int] -> [Int] =
fun l -> 
let go: ([Int], [Int]) -> [Int] =
  fun xs, acc -> 
    case xs 
    | [] => acc 
    | x::xs => go(xs, x::acc) end in
go(l, []) in

# Check if two lists are equal #
let equal: ([Int], [Int]) -> Bool =
    fun p, xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => x == y && equal(xs, ys)
    | _ => false end
in

# Initialize a list with a given length using an initializer function #
let init: (Int, Int -> Int) -> [Int] =
    fun len, f ->
        let go: (Int, [Int]) -> [Int] =
        fun idx, xs ->
            if idx < len 
            then go(idx + 1, xs @ [f(idx)])   
            else xs
        in
        go(0, [])
in

# Reduce a list from the left. #
let fold_left: ((Int, Int) -> Int, Int, [Int]) -> Int =
  fun f, acc, xs ->
    case xs 
    | [] => acc
    | hd::tl => fold_left(f, f(acc, hd), tl) end in

# Reduce a list from the right. #
let fold_right: ((Int, Int) -> Int, [Int], Int) -> Int =
  fun f, xs, acc ->
    case xs
    | [] => acc
    | hd::tl => f(hd, fold_right(f, tl, acc)) end in


666
LSP: Prelude: String parsed successfully
LSP: Prelude: Info map generated successfully
Debug: true, Constrain: Types
LSP: Init: Recieved string: # Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)



















































































































































































LSP: Init: String parsed successfully
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: >( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {go: ((?, ?) -> [?]), filter: (((Int -> Bool), [Int]) -> [Int]), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: 
  LSP: Info: ALL errors:Error in term:
  p
Nature of error: type ((Int -> Bool), [Int]) is not consistent with arrow type    
Error in term:
  p
Nature of error: Variable p is not bound    
Error in term:
  p
Nature of error: Variable p is not bound
  LSP: Info: BidiCtx: Cls: Let expression
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent: Root
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: [?]
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: :: @
  LSP: Concave: Backpack: 
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new_tokens ::= whitespace | "," | "::" | "@"
root ::= new_tokens

Top 20 Logits:

:19.5892
#:15.1837
let:14.3941
##:14.3791
 :13.0995
    :12.4834
################:12.4768
in:12.4396
  :12.4195
   :12.3279
####:12.0463
/*:11.9037
```:11.8513
//:11.403
                :11.2568
[:11.246
end:11.2089
def:11.1692
(:11.0862
        :11.0811
{:11.0384

================
# Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)





















































































































































































LSP: Prelude: Recieved string: ### List ###

# Add an element to the front of a list. #
let cons: (Int, [Int]) -> [Int] = fun x, xs -> x::xs in

# Determine the length of a list. #
let length: [Int] -> Int =
  fun xs ->
    case xs
    | [] => 0
    | _::xs => 1 + length(xs) end in

# Extract the first element of a list. #
let hd: [Int] -> Option =
  fun l ->
    case l
    | [] => None
    | x::xs => Some(x) end in

# Extract the rest of the list. #
let tl: [Int] -> [Int] =
  fun l ->
    case l
    | [] => []
    | x::xs => xs end in

# Determine if a list is empty. #
let is_empty: [Int] -> Bool =
  fun xs ->
    case xs
    | [] => true
    | _::_ => false end in

# Return the element at the index. #
let nth: ([Int], Int) -> Option =
  fun xs, n ->
    case xs, n
    | x::_, 0 => Some(x)
    | _::xs, n => nth(xs, n - 1)
    | [], _ => None end in

# Reverse a List. #
let rev: [Int] -> [Int] =
fun l -> 
let go: ([Int], [Int]) -> [Int] =
  fun xs, acc -> 
    case xs 
    | [] => acc 
    | x::xs => go(xs, x::acc) end in
go(l, []) in

# Check if two lists are equal #
let equal: ([Int], [Int]) -> Bool =
    fun p, xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => x == y && equal(xs, ys)
    | _ => false end
in

# Initialize a list with a given length using an initializer function #
let init: (Int, Int -> Int) -> [Int] =
    fun len, f ->
        let go: (Int, [Int]) -> [Int] =
        fun idx, xs ->
            if idx < len 
            then go(idx + 1, xs @ [f(idx)])   
            else xs
        in
        go(0, [])
in

# Reduce a list from the left. #
let fold_left: ((Int, Int) -> Int, Int, [Int]) -> Int =
  fun f, acc, xs ->
    case xs 
    | [] => acc
    | hd::tl => fold_left(f, f(acc, hd), tl) end in

# Reduce a list from the right. #
let fold_right: ((Int, Int) -> Int, [Int], Int) -> Int =
  fun f, xs, acc ->
    case xs
    | [] => acc
    | hd::tl => f(hd, fold_right(f, tl, acc)) end in


666
LSP: Prelude: String parsed successfully
LSP: Prelude: Info map generated successfully
Debug: true, Constrain: Types
LSP: Init: Recieved string: # Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)




















































































































































































LSP: Init: String parsed successfully
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: >( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {go: ((?, ?) -> [?]), filter: (((Int -> Bool), [Int]) -> [Int]), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: 
  LSP: Info: ALL errors:Error in term:
  p
Nature of error: Variable p is not bound    
Error in term:
  p
Nature of error: type ((Int -> Bool), [Int]) is not consistent with arrow type    
Error in term:
  p
Nature of error: Variable p is not bound
  LSP: Info: BidiCtx: Cls: Let expression
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent: Root
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: [?]
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: :: @
  LSP: Concave: Backpack: 
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new_tokens ::= whitespace | "," | "::" | "@"
root ::= new_tokens

Top 20 Logits:

:19.6097
#:15.195
let:14.4054
##:14.4049
 :13.1116
################:12.4961
    :12.492
  :12.4289
in:12.3689
   :12.3412
####:12.0673
/*:11.9067
```:11.8666
//:11.4089
                :11.261
[:11.2596
end:11.1835
def:11.1803
(:11.095
        :11.0871
{:11.0423

================
# Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)






















































































































































































LSP: Prelude: Recieved string: ### List ###

# Add an element to the front of a list. #
let cons: (Int, [Int]) -> [Int] = fun x, xs -> x::xs in

# Determine the length of a list. #
let length: [Int] -> Int =
  fun xs ->
    case xs
    | [] => 0
    | _::xs => 1 + length(xs) end in

# Extract the first element of a list. #
let hd: [Int] -> Option =
  fun l ->
    case l
    | [] => None
    | x::xs => Some(x) end in

# Extract the rest of the list. #
let tl: [Int] -> [Int] =
  fun l ->
    case l
    | [] => []
    | x::xs => xs end in

# Determine if a list is empty. #
let is_empty: [Int] -> Bool =
  fun xs ->
    case xs
    | [] => true
    | _::_ => false end in

# Return the element at the index. #
let nth: ([Int], Int) -> Option =
  fun xs, n ->
    case xs, n
    | x::_, 0 => Some(x)
    | _::xs, n => nth(xs, n - 1)
    | [], _ => None end in

# Reverse a List. #
let rev: [Int] -> [Int] =
fun l -> 
let go: ([Int], [Int]) -> [Int] =
  fun xs, acc -> 
    case xs 
    | [] => acc 
    | x::xs => go(xs, x::acc) end in
go(l, []) in

# Check if two lists are equal #
let equal: ([Int], [Int]) -> Bool =
    fun p, xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => x == y && equal(xs, ys)
    | _ => false end
in

# Initialize a list with a given length using an initializer function #
let init: (Int, Int -> Int) -> [Int] =
    fun len, f ->
        let go: (Int, [Int]) -> [Int] =
        fun idx, xs ->
            if idx < len 
            then go(idx + 1, xs @ [f(idx)])   
            else xs
        in
        go(0, [])
in

# Reduce a list from the left. #
let fold_left: ((Int, Int) -> Int, Int, [Int]) -> Int =
  fun f, acc, xs ->
    case xs 
    | [] => acc
    | hd::tl => fold_left(f, f(acc, hd), tl) end in

# Reduce a list from the right. #
let fold_right: ((Int, Int) -> Int, [Int], Int) -> Int =
  fun f, xs, acc ->
    case xs
    | [] => acc
    | hd::tl => f(hd, fold_right(f, tl, acc)) end in


666
LSP: Prelude: String parsed successfully
LSP: Prelude: Info map generated successfully
Debug: true, Constrain: Types
LSP: Init: Recieved string: # Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)





















































































































































































LSP: Init: String parsed successfully
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: >( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {go: ((?, ?) -> [?]), filter: (((Int -> Bool), [Int]) -> [Int]), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: 
  LSP: Info: ALL errors:Error in term:
  p
Nature of error: Variable p is not bound    
Error in term:
  p
Nature of error: type ((Int -> Bool), [Int]) is not consistent with arrow type    
Error in term:
  p
Nature of error: Variable p is not bound
  LSP: Info: BidiCtx: Cls: Let expression
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent: Root
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: [?]
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: :: @
  LSP: Concave: Backpack: 
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new_tokens ::= whitespace | "," | "::" | "@"
root ::= new_tokens

Top 20 Logits:

:19.6316
#:15.2033
##:14.4247
let:14.4129
 :13.1228
################:12.5137
    :12.5009
  :12.4429
   :12.3516
in:12.3454
####:12.0821
/*:11.9084
```:11.883
//:11.4132
[:11.2683
                :11.2672
def:11.1955
end:11.1801
(:11.0995
        :11.0952
########:11.0506

================
# Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)























































































































































































LSP: Prelude: Recieved string: ### List ###

# Add an element to the front of a list. #
let cons: (Int, [Int]) -> [Int] = fun x, xs -> x::xs in

# Determine the length of a list. #
let length: [Int] -> Int =
  fun xs ->
    case xs
    | [] => 0
    | _::xs => 1 + length(xs) end in

# Extract the first element of a list. #
let hd: [Int] -> Option =
  fun l ->
    case l
    | [] => None
    | x::xs => Some(x) end in

# Extract the rest of the list. #
let tl: [Int] -> [Int] =
  fun l ->
    case l
    | [] => []
    | x::xs => xs end in

# Determine if a list is empty. #
let is_empty: [Int] -> Bool =
  fun xs ->
    case xs
    | [] => true
    | _::_ => false end in

# Return the element at the index. #
let nth: ([Int], Int) -> Option =
  fun xs, n ->
    case xs, n
    | x::_, 0 => Some(x)
    | _::xs, n => nth(xs, n - 1)
    | [], _ => None end in

# Reverse a List. #
let rev: [Int] -> [Int] =
fun l -> 
let go: ([Int], [Int]) -> [Int] =
  fun xs, acc -> 
    case xs 
    | [] => acc 
    | x::xs => go(xs, x::acc) end in
go(l, []) in

# Check if two lists are equal #
let equal: ([Int], [Int]) -> Bool =
    fun p, xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => x == y && equal(xs, ys)
    | _ => false end
in

# Initialize a list with a given length using an initializer function #
let init: (Int, Int -> Int) -> [Int] =
    fun len, f ->
        let go: (Int, [Int]) -> [Int] =
        fun idx, xs ->
            if idx < len 
            then go(idx + 1, xs @ [f(idx)])   
            else xs
        in
        go(0, [])
in

# Reduce a list from the left. #
let fold_left: ((Int, Int) -> Int, Int, [Int]) -> Int =
  fun f, acc, xs ->
    case xs 
    | [] => acc
    | hd::tl => fold_left(f, f(acc, hd), tl) end in

# Reduce a list from the right. #
let fold_right: ((Int, Int) -> Int, [Int], Int) -> Int =
  fun f, xs, acc ->
    case xs
    | [] => acc
    | hd::tl => f(hd, fold_right(f, tl, acc)) end in


666
LSP: Prelude: String parsed successfully
LSP: Prelude: Info map generated successfully
Debug: true, Constrain: Types
LSP: Init: Recieved string: # Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)






















































































































































































LSP: Init: String parsed successfully
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: >( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {go: ((?, ?) -> [?]), filter: (((Int -> Bool), [Int]) -> [Int]), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: 
  LSP: Info: ALL errors:Error in term:
  p
Nature of error: Variable p is not bound    
Error in term:
  p
Nature of error: type ((Int -> Bool), [Int]) is not consistent with arrow type    
Error in term:
  p
Nature of error: Variable p is not bound
  LSP: Info: BidiCtx: Cls: Let expression
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent: Root
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: [?]
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: :: @
  LSP: Concave: Backpack: 
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new_tokens ::= whitespace | "," | "::" | "@"
root ::= new_tokens

Top 20 Logits:

:19.6493
#:15.2047
##:14.4248
let:14.415
 :13.1296
################:12.5227
    :12.5096
  :12.4556
in:12.3727
   :12.3544
####:12.0819
/*:11.909
```:11.8898
//:11.4141
                :11.2729
[:11.2654
def:11.21
end:11.2039
        :11.1018
(:11.0978
########:11.0525

================
# Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)
























































































































































































LSP: Prelude: Recieved string: ### List ###

# Add an element to the front of a list. #
let cons: (Int, [Int]) -> [Int] = fun x, xs -> x::xs in

# Determine the length of a list. #
let length: [Int] -> Int =
  fun xs ->
    case xs
    | [] => 0
    | _::xs => 1 + length(xs) end in

# Extract the first element of a list. #
let hd: [Int] -> Option =
  fun l ->
    case l
    | [] => None
    | x::xs => Some(x) end in

# Extract the rest of the list. #
let tl: [Int] -> [Int] =
  fun l ->
    case l
    | [] => []
    | x::xs => xs end in

# Determine if a list is empty. #
let is_empty: [Int] -> Bool =
  fun xs ->
    case xs
    | [] => true
    | _::_ => false end in

# Return the element at the index. #
let nth: ([Int], Int) -> Option =
  fun xs, n ->
    case xs, n
    | x::_, 0 => Some(x)
    | _::xs, n => nth(xs, n - 1)
    | [], _ => None end in

# Reverse a List. #
let rev: [Int] -> [Int] =
fun l -> 
let go: ([Int], [Int]) -> [Int] =
  fun xs, acc -> 
    case xs 
    | [] => acc 
    | x::xs => go(xs, x::acc) end in
go(l, []) in

# Check if two lists are equal #
let equal: ([Int], [Int]) -> Bool =
    fun p, xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => x == y && equal(xs, ys)
    | _ => false end
in

# Initialize a list with a given length using an initializer function #
let init: (Int, Int -> Int) -> [Int] =
    fun len, f ->
        let go: (Int, [Int]) -> [Int] =
        fun idx, xs ->
            if idx < len 
            then go(idx + 1, xs @ [f(idx)])   
            else xs
        in
        go(0, [])
in

# Reduce a list from the left. #
let fold_left: ((Int, Int) -> Int, Int, [Int]) -> Int =
  fun f, acc, xs ->
    case xs 
    | [] => acc
    | hd::tl => fold_left(f, f(acc, hd), tl) end in

# Reduce a list from the right. #
let fold_right: ((Int, Int) -> Int, [Int], Int) -> Int =
  fun f, xs, acc ->
    case xs
    | [] => acc
    | hd::tl => f(hd, fold_right(f, tl, acc)) end in


666
LSP: Prelude: String parsed successfully
LSP: Prelude: Info map generated successfully
Debug: true, Constrain: Types
LSP: Init: Recieved string: # Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)























































































































































































LSP: Init: String parsed successfully
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: >( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {go: ((?, ?) -> [?]), filter: (((Int -> Bool), [Int]) -> [Int]), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: 
  LSP: Info: ALL errors:Error in term:
  p
Nature of error: type ((Int -> Bool), [Int]) is not consistent with arrow type    
Error in term:
  p
Nature of error: Variable p is not bound    
Error in term:
  p
Nature of error: Variable p is not bound
  LSP: Info: BidiCtx: Cls: Let expression
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent: Root
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: [?]
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: :: @
  LSP: Concave: Backpack: 
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new_tokens ::= whitespace | "," | "::" | "@"
root ::= new_tokens

Top 20 Logits:

:19.6585
#:15.2006
let:14.4153
##:14.406
 :13.1312
################:12.5193
    :12.5175
  :12.4624
in:12.4175
   :12.3504
####:12.068
/*:11.9103
```:11.8818
//:11.4119
                :11.2746
[:11.2537
end:11.2355
def:11.2186
        :11.1037
(:11.0955
########:11.0395

================
# Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)

























































































































































































LSP: Prelude: Recieved string: ### List ###

# Add an element to the front of a list. #
let cons: (Int, [Int]) -> [Int] = fun x, xs -> x::xs in

# Determine the length of a list. #
let length: [Int] -> Int =
  fun xs ->
    case xs
    | [] => 0
    | _::xs => 1 + length(xs) end in

# Extract the first element of a list. #
let hd: [Int] -> Option =
  fun l ->
    case l
    | [] => None
    | x::xs => Some(x) end in

# Extract the rest of the list. #
let tl: [Int] -> [Int] =
  fun l ->
    case l
    | [] => []
    | x::xs => xs end in

# Determine if a list is empty. #
let is_empty: [Int] -> Bool =
  fun xs ->
    case xs
    | [] => true
    | _::_ => false end in

# Return the element at the index. #
let nth: ([Int], Int) -> Option =
  fun xs, n ->
    case xs, n
    | x::_, 0 => Some(x)
    | _::xs, n => nth(xs, n - 1)
    | [], _ => None end in

# Reverse a List. #
let rev: [Int] -> [Int] =
fun l -> 
let go: ([Int], [Int]) -> [Int] =
  fun xs, acc -> 
    case xs 
    | [] => acc 
    | x::xs => go(xs, x::acc) end in
go(l, []) in

# Check if two lists are equal #
let equal: ([Int], [Int]) -> Bool =
    fun p, xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => x == y && equal(xs, ys)
    | _ => false end
in

# Initialize a list with a given length using an initializer function #
let init: (Int, Int -> Int) -> [Int] =
    fun len, f ->
        let go: (Int, [Int]) -> [Int] =
        fun idx, xs ->
            if idx < len 
            then go(idx + 1, xs @ [f(idx)])   
            else xs
        in
        go(0, [])
in

# Reduce a list from the left. #
let fold_left: ((Int, Int) -> Int, Int, [Int]) -> Int =
  fun f, acc, xs ->
    case xs 
    | [] => acc
    | hd::tl => fold_left(f, f(acc, hd), tl) end in

# Reduce a list from the right. #
let fold_right: ((Int, Int) -> Int, [Int], Int) -> Int =
  fun f, xs, acc ->
    case xs
    | [] => acc
    | hd::tl => f(hd, fold_right(f, tl, acc)) end in


666
LSP: Prelude: String parsed successfully
LSP: Prelude: Info map generated successfully
Debug: true, Constrain: Types
LSP: Init: Recieved string: # Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)
























































































































































































LSP: Init: String parsed successfully
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: >( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {go: ((?, ?) -> [?]), filter: (((Int -> Bool), [Int]) -> [Int]), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: 
  LSP: Info: ALL errors:Error in term:
  p
Nature of error: Variable p is not bound    
Error in term:
  p
Nature of error: type ((Int -> Bool), [Int]) is not consistent with arrow type    
Error in term:
  p
Nature of error: Variable p is not bound
  LSP: Info: BidiCtx: Cls: Let expression
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent: Root
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: [?]
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: :: @
  LSP: Concave: Backpack: 
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new_tokens ::= whitespace | "," | "::" | "@"
root ::= new_tokens

Top 20 Logits:

:19.662
#:15.1983
let:14.4201
##:14.3835
 :13.1312
    :12.5246
################:12.5095
  :12.4639
in:12.4398
   :12.3447
####:12.0523
/*:11.9128
```:11.8659
//:11.4089
                :11.2733
end:11.2532
[:11.2432
def:11.2193
        :11.1025
(:11.1006
{:11.0345

================
# Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)


























































































































































































LSP: Prelude: Recieved string: ### List ###

# Add an element to the front of a list. #
let cons: (Int, [Int]) -> [Int] = fun x, xs -> x::xs in

# Determine the length of a list. #
let length: [Int] -> Int =
  fun xs ->
    case xs
    | [] => 0
    | _::xs => 1 + length(xs) end in

# Extract the first element of a list. #
let hd: [Int] -> Option =
  fun l ->
    case l
    | [] => None
    | x::xs => Some(x) end in

# Extract the rest of the list. #
let tl: [Int] -> [Int] =
  fun l ->
    case l
    | [] => []
    | x::xs => xs end in

# Determine if a list is empty. #
let is_empty: [Int] -> Bool =
  fun xs ->
    case xs
    | [] => true
    | _::_ => false end in

# Return the element at the index. #
let nth: ([Int], Int) -> Option =
  fun xs, n ->
    case xs, n
    | x::_, 0 => Some(x)
    | _::xs, n => nth(xs, n - 1)
    | [], _ => None end in

# Reverse a List. #
let rev: [Int] -> [Int] =
fun l -> 
let go: ([Int], [Int]) -> [Int] =
  fun xs, acc -> 
    case xs 
    | [] => acc 
    | x::xs => go(xs, x::acc) end in
go(l, []) in

# Check if two lists are equal #
let equal: ([Int], [Int]) -> Bool =
    fun p, xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => x == y && equal(xs, ys)
    | _ => false end
in

# Initialize a list with a given length using an initializer function #
let init: (Int, Int -> Int) -> [Int] =
    fun len, f ->
        let go: (Int, [Int]) -> [Int] =
        fun idx, xs ->
            if idx < len 
            then go(idx + 1, xs @ [f(idx)])   
            else xs
        in
        go(0, [])
in

# Reduce a list from the left. #
let fold_left: ((Int, Int) -> Int, Int, [Int]) -> Int =
  fun f, acc, xs ->
    case xs 
    | [] => acc
    | hd::tl => fold_left(f, f(acc, hd), tl) end in

# Reduce a list from the right. #
let fold_right: ((Int, Int) -> Int, [Int], Int) -> Int =
  fun f, xs, acc ->
    case xs
    | [] => acc
    | hd::tl => f(hd, fold_right(f, tl, acc)) end in


666
LSP: Prelude: String parsed successfully
LSP: Prelude: Info map generated successfully
Debug: true, Constrain: Types
LSP: Init: Recieved string: # Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)

























































































































































































LSP: Init: String parsed successfully
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: >( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {go: ((?, ?) -> [?]), filter: (((Int -> Bool), [Int]) -> [Int]), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: 
  LSP: Info: ALL errors:Error in term:
  p
Nature of error: Variable p is not bound    
Error in term:
  p
Nature of error: Variable p is not bound    
Error in term:
  p
Nature of error: type ((Int -> Bool), [Int]) is not consistent with arrow type
  LSP: Info: BidiCtx: Cls: Let expression
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent: Root
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: [?]
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: :: @
  LSP: Concave: Backpack: 
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new_tokens ::= whitespace | "," | "::" | "@"
root ::= new_tokens

Top 20 Logits:

:19.6668
#:15.2024
let:14.4305
##:14.3744
 :13.1327
    :12.5294
################:12.5032
  :12.4628
in:12.4265
   :12.3423
####:12.0461
/*:11.9146
```:11.8561
//:11.4084
                :11.2715
end:11.2479
[:11.2424
def:11.2127
(:11.1141
        :11.1005
{:11.0429

================
# Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)



























































































































































































LSP: Prelude: Recieved string: ### List ###

# Add an element to the front of a list. #
let cons: (Int, [Int]) -> [Int] = fun x, xs -> x::xs in

# Determine the length of a list. #
let length: [Int] -> Int =
  fun xs ->
    case xs
    | [] => 0
    | _::xs => 1 + length(xs) end in

# Extract the first element of a list. #
let hd: [Int] -> Option =
  fun l ->
    case l
    | [] => None
    | x::xs => Some(x) end in

# Extract the rest of the list. #
let tl: [Int] -> [Int] =
  fun l ->
    case l
    | [] => []
    | x::xs => xs end in

# Determine if a list is empty. #
let is_empty: [Int] -> Bool =
  fun xs ->
    case xs
    | [] => true
    | _::_ => false end in

# Return the element at the index. #
let nth: ([Int], Int) -> Option =
  fun xs, n ->
    case xs, n
    | x::_, 0 => Some(x)
    | _::xs, n => nth(xs, n - 1)
    | [], _ => None end in

# Reverse a List. #
let rev: [Int] -> [Int] =
fun l -> 
let go: ([Int], [Int]) -> [Int] =
  fun xs, acc -> 
    case xs 
    | [] => acc 
    | x::xs => go(xs, x::acc) end in
go(l, []) in

# Check if two lists are equal #
let equal: ([Int], [Int]) -> Bool =
    fun p, xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => x == y && equal(xs, ys)
    | _ => false end
in

# Initialize a list with a given length using an initializer function #
let init: (Int, Int -> Int) -> [Int] =
    fun len, f ->
        let go: (Int, [Int]) -> [Int] =
        fun idx, xs ->
            if idx < len 
            then go(idx + 1, xs @ [f(idx)])   
            else xs
        in
        go(0, [])
in

# Reduce a list from the left. #
let fold_left: ((Int, Int) -> Int, Int, [Int]) -> Int =
  fun f, acc, xs ->
    case xs 
    | [] => acc
    | hd::tl => fold_left(f, f(acc, hd), tl) end in

# Reduce a list from the right. #
let fold_right: ((Int, Int) -> Int, [Int], Int) -> Int =
  fun f, xs, acc ->
    case xs
    | [] => acc
    | hd::tl => f(hd, fold_right(f, tl, acc)) end in


666
LSP: Prelude: String parsed successfully
LSP: Prelude: Info map generated successfully
Debug: true, Constrain: Types
LSP: Init: Recieved string: # Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)


























































































































































































LSP: Init: String parsed successfully
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: >( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {go: ((?, ?) -> [?]), filter: (((Int -> Bool), [Int]) -> [Int]), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: 
  LSP: Info: ALL errors:Error in term:
  p
Nature of error: Variable p is not bound    
Error in term:
  p
Nature of error: Variable p is not bound    
Error in term:
  p
Nature of error: type ((Int -> Bool), [Int]) is not consistent with arrow type
  LSP: Info: BidiCtx: Cls: Let expression
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent: Root
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: [?]
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: :: @
  LSP: Concave: Backpack: 
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new_tokens ::= whitespace | "," | "::" | "@"
root ::= new_tokens

Top 20 Logits:

:19.6763
#:15.2098
let:14.4439
##:14.3826
 :13.1345
    :12.5299
################:12.5026
  :12.4611
in:12.3899
   :12.3441
####:12.0497
/*:11.9132
```:11.8587
//:11.4096
                :11.2698
[:11.2539
end:11.2266
def:11.2017
(:11.1308
        :11.0976
{:11.0497

================
# Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)




























































































































































































LSP: Prelude: Recieved string: ### List ###

# Add an element to the front of a list. #
let cons: (Int, [Int]) -> [Int] = fun x, xs -> x::xs in

# Determine the length of a list. #
let length: [Int] -> Int =
  fun xs ->
    case xs
    | [] => 0
    | _::xs => 1 + length(xs) end in

# Extract the first element of a list. #
let hd: [Int] -> Option =
  fun l ->
    case l
    | [] => None
    | x::xs => Some(x) end in

# Extract the rest of the list. #
let tl: [Int] -> [Int] =
  fun l ->
    case l
    | [] => []
    | x::xs => xs end in

# Determine if a list is empty. #
let is_empty: [Int] -> Bool =
  fun xs ->
    case xs
    | [] => true
    | _::_ => false end in

# Return the element at the index. #
let nth: ([Int], Int) -> Option =
  fun xs, n ->
    case xs, n
    | x::_, 0 => Some(x)
    | _::xs, n => nth(xs, n - 1)
    | [], _ => None end in

# Reverse a List. #
let rev: [Int] -> [Int] =
fun l -> 
let go: ([Int], [Int]) -> [Int] =
  fun xs, acc -> 
    case xs 
    | [] => acc 
    | x::xs => go(xs, x::acc) end in
go(l, []) in

# Check if two lists are equal #
let equal: ([Int], [Int]) -> Bool =
    fun p, xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => x == y && equal(xs, ys)
    | _ => false end
in

# Initialize a list with a given length using an initializer function #
let init: (Int, Int -> Int) -> [Int] =
    fun len, f ->
        let go: (Int, [Int]) -> [Int] =
        fun idx, xs ->
            if idx < len 
            then go(idx + 1, xs @ [f(idx)])   
            else xs
        in
        go(0, [])
in

# Reduce a list from the left. #
let fold_left: ((Int, Int) -> Int, Int, [Int]) -> Int =
  fun f, acc, xs ->
    case xs 
    | [] => acc
    | hd::tl => fold_left(f, f(acc, hd), tl) end in

# Reduce a list from the right. #
let fold_right: ((Int, Int) -> Int, [Int], Int) -> Int =
  fun f, xs, acc ->
    case xs
    | [] => acc
    | hd::tl => f(hd, fold_right(f, tl, acc)) end in


666
LSP: Prelude: String parsed successfully
LSP: Prelude: Info map generated successfully
Debug: true, Constrain: Types
LSP: Init: Recieved string: # Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)



























































































































































































LSP: Init: String parsed successfully
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: >( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {go: ((?, ?) -> [?]), filter: (((Int -> Bool), [Int]) -> [Int]), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: 
  LSP: Info: ALL errors:Error in term:
  p
Nature of error: type ((Int -> Bool), [Int]) is not consistent with arrow type    
Error in term:
  p
Nature of error: Variable p is not bound    
Error in term:
  p
Nature of error: Variable p is not bound
  LSP: Info: BidiCtx: Cls: Let expression
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent: Root
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: [?]
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: :: @
  LSP: Concave: Backpack: 
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new_tokens ::= whitespace | "," | "::" | "@"
root ::= new_tokens

Top 20 Logits:

:19.6892
#:15.2164
let:14.4557
##:14.3972
 :13.1354
    :12.525
################:12.5036
  :12.4596
in:12.3606
   :12.3484
####:12.055
/*:11.9058
```:11.8673
//:11.4072
[:11.2714
                :11.2707
end:11.2118
def:11.1898
(:11.1431
        :11.0943
{:11.0511

================
# Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)





























































































































































































LSP: Prelude: Recieved string: ### List ###

# Add an element to the front of a list. #
let cons: (Int, [Int]) -> [Int] = fun x, xs -> x::xs in

# Determine the length of a list. #
let length: [Int] -> Int =
  fun xs ->
    case xs
    | [] => 0
    | _::xs => 1 + length(xs) end in

# Extract the first element of a list. #
let hd: [Int] -> Option =
  fun l ->
    case l
    | [] => None
    | x::xs => Some(x) end in

# Extract the rest of the list. #
let tl: [Int] -> [Int] =
  fun l ->
    case l
    | [] => []
    | x::xs => xs end in

# Determine if a list is empty. #
let is_empty: [Int] -> Bool =
  fun xs ->
    case xs
    | [] => true
    | _::_ => false end in

# Return the element at the index. #
let nth: ([Int], Int) -> Option =
  fun xs, n ->
    case xs, n
    | x::_, 0 => Some(x)
    | _::xs, n => nth(xs, n - 1)
    | [], _ => None end in

# Reverse a List. #
let rev: [Int] -> [Int] =
fun l -> 
let go: ([Int], [Int]) -> [Int] =
  fun xs, acc -> 
    case xs 
    | [] => acc 
    | x::xs => go(xs, x::acc) end in
go(l, []) in

# Check if two lists are equal #
let equal: ([Int], [Int]) -> Bool =
    fun p, xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => x == y && equal(xs, ys)
    | _ => false end
in

# Initialize a list with a given length using an initializer function #
let init: (Int, Int -> Int) -> [Int] =
    fun len, f ->
        let go: (Int, [Int]) -> [Int] =
        fun idx, xs ->
            if idx < len 
            then go(idx + 1, xs @ [f(idx)])   
            else xs
        in
        go(0, [])
in

# Reduce a list from the left. #
let fold_left: ((Int, Int) -> Int, Int, [Int]) -> Int =
  fun f, acc, xs ->
    case xs 
    | [] => acc
    | hd::tl => fold_left(f, f(acc, hd), tl) end in

# Reduce a list from the right. #
let fold_right: ((Int, Int) -> Int, [Int], Int) -> Int =
  fun f, xs, acc ->
    case xs
    | [] => acc
    | hd::tl => f(hd, fold_right(f, tl, acc)) end in


666
LSP: Prelude: String parsed successfully
LSP: Prelude: Info map generated successfully
Debug: true, Constrain: Types
LSP: Init: Recieved string: # Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)




























































































































































































LSP: Init: String parsed successfully
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: >( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {go: ((?, ?) -> [?]), filter: (((Int -> Bool), [Int]) -> [Int]), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: 
  LSP: Info: ALL errors:Error in term:
  p
Nature of error: type ((Int -> Bool), [Int]) is not consistent with arrow type    
Error in term:
  p
Nature of error: Variable p is not bound    
Error in term:
  p
Nature of error: Variable p is not bound
  LSP: Info: BidiCtx: Cls: Let expression
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent: Root
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: [?]
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: :: @
  LSP: Concave: Backpack: 
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new_tokens ::= whitespace | "," | "::" | "@"
root ::= new_tokens

Top 20 Logits:

:19.7011
#:15.2174
let:14.4617
##:14.4028
 :13.1347
    :12.5164
################:12.5015
  :12.4577
in:12.3578
   :12.3518
####:12.0531
/*:11.8939
```:11.8702
//:11.3985
[:11.2828
                :11.2755
end:11.2178
def:11.1805
(:11.1474
        :11.0914
{:11.046

================
# Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)






























































































































































































LSP: Prelude: Recieved string: ### List ###

# Add an element to the front of a list. #
let cons: (Int, [Int]) -> [Int] = fun x, xs -> x::xs in

# Determine the length of a list. #
let length: [Int] -> Int =
  fun xs ->
    case xs
    | [] => 0
    | _::xs => 1 + length(xs) end in

# Extract the first element of a list. #
let hd: [Int] -> Option =
  fun l ->
    case l
    | [] => None
    | x::xs => Some(x) end in

# Extract the rest of the list. #
let tl: [Int] -> [Int] =
  fun l ->
    case l
    | [] => []
    | x::xs => xs end in

# Determine if a list is empty. #
let is_empty: [Int] -> Bool =
  fun xs ->
    case xs
    | [] => true
    | _::_ => false end in

# Return the element at the index. #
let nth: ([Int], Int) -> Option =
  fun xs, n ->
    case xs, n
    | x::_, 0 => Some(x)
    | _::xs, n => nth(xs, n - 1)
    | [], _ => None end in

# Reverse a List. #
let rev: [Int] -> [Int] =
fun l -> 
let go: ([Int], [Int]) -> [Int] =
  fun xs, acc -> 
    case xs 
    | [] => acc 
    | x::xs => go(xs, x::acc) end in
go(l, []) in

# Check if two lists are equal #
let equal: ([Int], [Int]) -> Bool =
    fun p, xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => x == y && equal(xs, ys)
    | _ => false end
in

# Initialize a list with a given length using an initializer function #
let init: (Int, Int -> Int) -> [Int] =
    fun len, f ->
        let go: (Int, [Int]) -> [Int] =
        fun idx, xs ->
            if idx < len 
            then go(idx + 1, xs @ [f(idx)])   
            else xs
        in
        go(0, [])
in

# Reduce a list from the left. #
let fold_left: ((Int, Int) -> Int, Int, [Int]) -> Int =
  fun f, acc, xs ->
    case xs 
    | [] => acc
    | hd::tl => fold_left(f, f(acc, hd), tl) end in

# Reduce a list from the right. #
let fold_right: ((Int, Int) -> Int, [Int], Int) -> Int =
  fun f, xs, acc ->
    case xs
    | [] => acc
    | hd::tl => f(hd, fold_right(f, tl, acc)) end in


666
LSP: Prelude: String parsed successfully
LSP: Prelude: Info map generated successfully
Debug: true, Constrain: Types
LSP: Init: Recieved string: # Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)





























































































































































































LSP: Init: String parsed successfully
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: >( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {go: ((?, ?) -> [?]), filter: (((Int -> Bool), [Int]) -> [Int]), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: 
  LSP: Info: ALL errors:Error in term:
  p
Nature of error: Variable p is not bound    
Error in term:
  p
Nature of error: type ((Int -> Bool), [Int]) is not consistent with arrow type    
Error in term:
  p
Nature of error: Variable p is not bound
  LSP: Info: BidiCtx: Cls: Let expression
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent: Root
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: [?]
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: :: @
  LSP: Concave: Backpack: 
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new_tokens ::= whitespace | "," | "::" | "@"
root ::= new_tokens

Top 20 Logits:

:19.7067
#:15.2095
let:14.4625
##:14.3942
 :13.1309
    :12.5085
################:12.4918
  :12.4546
in:12.3691
   :12.3524
####:12.0412
/*:11.8828
```:11.8595
//:11.3861
[:11.2823
                :11.2805
end:11.2372
def:11.1742
(:11.1443
        :11.0874
{:11.0363

================
# Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)































































































































































































LSP: Prelude: Recieved string: ### List ###

# Add an element to the front of a list. #
let cons: (Int, [Int]) -> [Int] = fun x, xs -> x::xs in

# Determine the length of a list. #
let length: [Int] -> Int =
  fun xs ->
    case xs
    | [] => 0
    | _::xs => 1 + length(xs) end in

# Extract the first element of a list. #
let hd: [Int] -> Option =
  fun l ->
    case l
    | [] => None
    | x::xs => Some(x) end in

# Extract the rest of the list. #
let tl: [Int] -> [Int] =
  fun l ->
    case l
    | [] => []
    | x::xs => xs end in

# Determine if a list is empty. #
let is_empty: [Int] -> Bool =
  fun xs ->
    case xs
    | [] => true
    | _::_ => false end in

# Return the element at the index. #
let nth: ([Int], Int) -> Option =
  fun xs, n ->
    case xs, n
    | x::_, 0 => Some(x)
    | _::xs, n => nth(xs, n - 1)
    | [], _ => None end in

# Reverse a List. #
let rev: [Int] -> [Int] =
fun l -> 
let go: ([Int], [Int]) -> [Int] =
  fun xs, acc -> 
    case xs 
    | [] => acc 
    | x::xs => go(xs, x::acc) end in
go(l, []) in

# Check if two lists are equal #
let equal: ([Int], [Int]) -> Bool =
    fun p, xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => x == y && equal(xs, ys)
    | _ => false end
in

# Initialize a list with a given length using an initializer function #
let init: (Int, Int -> Int) -> [Int] =
    fun len, f ->
        let go: (Int, [Int]) -> [Int] =
        fun idx, xs ->
            if idx < len 
            then go(idx + 1, xs @ [f(idx)])   
            else xs
        in
        go(0, [])
in

# Reduce a list from the left. #
let fold_left: ((Int, Int) -> Int, Int, [Int]) -> Int =
  fun f, acc, xs ->
    case xs 
    | [] => acc
    | hd::tl => fold_left(f, f(acc, hd), tl) end in

# Reduce a list from the right. #
let fold_right: ((Int, Int) -> Int, [Int], Int) -> Int =
  fun f, xs, acc ->
    case xs
    | [] => acc
    | hd::tl => f(hd, fold_right(f, tl, acc)) end in


666
LSP: Prelude: String parsed successfully
LSP: Prelude: Info map generated successfully
Debug: true, Constrain: Types
LSP: Init: Recieved string: # Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)






























































































































































































LSP: Init: String parsed successfully
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: >( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {go: ((?, ?) -> [?]), filter: (((Int -> Bool), [Int]) -> [Int]), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: 
  LSP: Info: ALL errors:Error in term:
  p
Nature of error: type ((Int -> Bool), [Int]) is not consistent with arrow type    
Error in term:
  p
Nature of error: Variable p is not bound    
Error in term:
  p
Nature of error: Variable p is not bound
  LSP: Info: BidiCtx: Cls: Let expression
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent: Root
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: [?]
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: :: @
  LSP: Concave: Backpack: 
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new_tokens ::= whitespace | "," | "::" | "@"
root ::= new_tokens

Top 20 Logits:

:19.7059
#:15.1962
let:14.4606
##:14.376
 :13.1265
    :12.504
################:12.4756
  :12.4518
in:12.37
   :12.3515
####:12.0259
/*:11.8761
```:11.8386
//:11.3749
                :11.2821
[:11.2734
end:11.254
def:11.1663
(:11.1427
        :11.0821
{:11.0275

================
# Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)
































































































































































































LSP: Prelude: Recieved string: ### List ###

# Add an element to the front of a list. #
let cons: (Int, [Int]) -> [Int] = fun x, xs -> x::xs in

# Determine the length of a list. #
let length: [Int] -> Int =
  fun xs ->
    case xs
    | [] => 0
    | _::xs => 1 + length(xs) end in

# Extract the first element of a list. #
let hd: [Int] -> Option =
  fun l ->
    case l
    | [] => None
    | x::xs => Some(x) end in

# Extract the rest of the list. #
let tl: [Int] -> [Int] =
  fun l ->
    case l
    | [] => []
    | x::xs => xs end in

# Determine if a list is empty. #
let is_empty: [Int] -> Bool =
  fun xs ->
    case xs
    | [] => true
    | _::_ => false end in

# Return the element at the index. #
let nth: ([Int], Int) -> Option =
  fun xs, n ->
    case xs, n
    | x::_, 0 => Some(x)
    | _::xs, n => nth(xs, n - 1)
    | [], _ => None end in

# Reverse a List. #
let rev: [Int] -> [Int] =
fun l -> 
let go: ([Int], [Int]) -> [Int] =
  fun xs, acc -> 
    case xs 
    | [] => acc 
    | x::xs => go(xs, x::acc) end in
go(l, []) in

# Check if two lists are equal #
let equal: ([Int], [Int]) -> Bool =
    fun p, xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => x == y && equal(xs, ys)
    | _ => false end
in

# Initialize a list with a given length using an initializer function #
let init: (Int, Int -> Int) -> [Int] =
    fun len, f ->
        let go: (Int, [Int]) -> [Int] =
        fun idx, xs ->
            if idx < len 
            then go(idx + 1, xs @ [f(idx)])   
            else xs
        in
        go(0, [])
in

# Reduce a list from the left. #
let fold_left: ((Int, Int) -> Int, Int, [Int]) -> Int =
  fun f, acc, xs ->
    case xs 
    | [] => acc
    | hd::tl => fold_left(f, f(acc, hd), tl) end in

# Reduce a list from the right. #
let fold_right: ((Int, Int) -> Int, [Int], Int) -> Int =
  fun f, xs, acc ->
    case xs
    | [] => acc
    | hd::tl => f(hd, fold_right(f, tl, acc)) end in


666
LSP: Prelude: String parsed successfully
LSP: Prelude: Info map generated successfully
Debug: true, Constrain: Types
LSP: Init: Recieved string: # Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)































































































































































































LSP: Init: String parsed successfully
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: >( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {go: ((?, ?) -> [?]), filter: (((Int -> Bool), [Int]) -> [Int]), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: 
  LSP: Info: ALL errors:Error in term:
  p
Nature of error: Variable p is not bound    
Error in term:
  p
Nature of error: type ((Int -> Bool), [Int]) is not consistent with arrow type    
Error in term:
  p
Nature of error: Variable p is not bound
  LSP: Info: BidiCtx: Cls: Let expression
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent: Root
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: [?]
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: :: @
  LSP: Concave: Backpack: 
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new_tokens ::= whitespace | "," | "::" | "@"
root ::= new_tokens

Top 20 Logits:

:19.7055
#:15.1856
let:14.4589
##:14.3618
 :13.1267
    :12.503
################:12.462
  :12.4528
   :12.3527
in:12.3525
####:12.0191
/*:11.8742
```:11.8206
//:11.3697
                :11.2817
[:11.2656
end:11.2582
def:11.1539
(:11.1495
        :11.0793
{:11.0251

================
# Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)

































































































































































































LSP: Prelude: Recieved string: ### List ###

# Add an element to the front of a list. #
let cons: (Int, [Int]) -> [Int] = fun x, xs -> x::xs in

# Determine the length of a list. #
let length: [Int] -> Int =
  fun xs ->
    case xs
    | [] => 0
    | _::xs => 1 + length(xs) end in

# Extract the first element of a list. #
let hd: [Int] -> Option =
  fun l ->
    case l
    | [] => None
    | x::xs => Some(x) end in

# Extract the rest of the list. #
let tl: [Int] -> [Int] =
  fun l ->
    case l
    | [] => []
    | x::xs => xs end in

# Determine if a list is empty. #
let is_empty: [Int] -> Bool =
  fun xs ->
    case xs
    | [] => true
    | _::_ => false end in

# Return the element at the index. #
let nth: ([Int], Int) -> Option =
  fun xs, n ->
    case xs, n
    | x::_, 0 => Some(x)
    | _::xs, n => nth(xs, n - 1)
    | [], _ => None end in

# Reverse a List. #
let rev: [Int] -> [Int] =
fun l -> 
let go: ([Int], [Int]) -> [Int] =
  fun xs, acc -> 
    case xs 
    | [] => acc 
    | x::xs => go(xs, x::acc) end in
go(l, []) in

# Check if two lists are equal #
let equal: ([Int], [Int]) -> Bool =
    fun p, xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => x == y && equal(xs, ys)
    | _ => false end
in

# Initialize a list with a given length using an initializer function #
let init: (Int, Int -> Int) -> [Int] =
    fun len, f ->
        let go: (Int, [Int]) -> [Int] =
        fun idx, xs ->
            if idx < len 
            then go(idx + 1, xs @ [f(idx)])   
            else xs
        in
        go(0, [])
in

# Reduce a list from the left. #
let fold_left: ((Int, Int) -> Int, Int, [Int]) -> Int =
  fun f, acc, xs ->
    case xs 
    | [] => acc
    | hd::tl => fold_left(f, f(acc, hd), tl) end in

# Reduce a list from the right. #
let fold_right: ((Int, Int) -> Int, [Int], Int) -> Int =
  fun f, xs, acc ->
    case xs
    | [] => acc
    | hd::tl => f(hd, fold_right(f, tl, acc)) end in


666
LSP: Prelude: String parsed successfully
LSP: Prelude: Info map generated successfully
Debug: true, Constrain: Types
LSP: Init: Recieved string: # Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)
































































































































































































LSP: Init: String parsed successfully
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: >( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {go: ((?, ?) -> [?]), filter: (((Int -> Bool), [Int]) -> [Int]), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: 
  LSP: Info: ALL errors:Error in term:
  p
Nature of error: Variable p is not bound    
Error in term:
  p
Nature of error: type ((Int -> Bool), [Int]) is not consistent with arrow type    
Error in term:
  p
Nature of error: Variable p is not bound
  LSP: Info: BidiCtx: Cls: Let expression
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent: Root
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: [?]
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: :: @
  LSP: Concave: Backpack: 
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new_tokens ::= whitespace | "," | "::" | "@"
root ::= new_tokens

Top 20 Logits:

:19.7098
#:15.1781
let:14.46
##:14.3614
 :13.1296
    :12.5023
################:12.4564
  :12.455
   :12.3538
in:12.3167
####:12.0234
/*:11.8759
```:11.8123
//:11.3714
                :11.2793
[:11.2652
end:11.2484
(:11.1613
def:11.1418
        :11.0777
{:11.0254

================
# Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)


































































































































































































LSP: Prelude: Recieved string: ### List ###

# Add an element to the front of a list. #
let cons: (Int, [Int]) -> [Int] = fun x, xs -> x::xs in

# Determine the length of a list. #
let length: [Int] -> Int =
  fun xs ->
    case xs
    | [] => 0
    | _::xs => 1 + length(xs) end in

# Extract the first element of a list. #
let hd: [Int] -> Option =
  fun l ->
    case l
    | [] => None
    | x::xs => Some(x) end in

# Extract the rest of the list. #
let tl: [Int] -> [Int] =
  fun l ->
    case l
    | [] => []
    | x::xs => xs end in

# Determine if a list is empty. #
let is_empty: [Int] -> Bool =
  fun xs ->
    case xs
    | [] => true
    | _::_ => false end in

# Return the element at the index. #
let nth: ([Int], Int) -> Option =
  fun xs, n ->
    case xs, n
    | x::_, 0 => Some(x)
    | _::xs, n => nth(xs, n - 1)
    | [], _ => None end in

# Reverse a List. #
let rev: [Int] -> [Int] =
fun l -> 
let go: ([Int], [Int]) -> [Int] =
  fun xs, acc -> 
    case xs 
    | [] => acc 
    | x::xs => go(xs, x::acc) end in
go(l, []) in

# Check if two lists are equal #
let equal: ([Int], [Int]) -> Bool =
    fun p, xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => x == y && equal(xs, ys)
    | _ => false end
in

# Initialize a list with a given length using an initializer function #
let init: (Int, Int -> Int) -> [Int] =
    fun len, f ->
        let go: (Int, [Int]) -> [Int] =
        fun idx, xs ->
            if idx < len 
            then go(idx + 1, xs @ [f(idx)])   
            else xs
        in
        go(0, [])
in

# Reduce a list from the left. #
let fold_left: ((Int, Int) -> Int, Int, [Int]) -> Int =
  fun f, acc, xs ->
    case xs 
    | [] => acc
    | hd::tl => fold_left(f, f(acc, hd), tl) end in

# Reduce a list from the right. #
let fold_right: ((Int, Int) -> Int, [Int], Int) -> Int =
  fun f, xs, acc ->
    case xs
    | [] => acc
    | hd::tl => f(hd, fold_right(f, tl, acc)) end in


666
LSP: Prelude: String parsed successfully
LSP: Prelude: Info map generated successfully
Debug: true, Constrain: Types
LSP: Init: Recieved string: # Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)

































































































































































































LSP: Init: String parsed successfully
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: >( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {go: ((?, ?) -> [?]), filter: (((Int -> Bool), [Int]) -> [Int]), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: 
  LSP: Info: ALL errors:Error in term:
  p
Nature of error: Variable p is not bound    
Error in term:
  p
Nature of error: type ((Int -> Bool), [Int]) is not consistent with arrow type    
Error in term:
  p
Nature of error: Variable p is not bound
  LSP: Info: BidiCtx: Cls: Let expression
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent: Root
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: [?]
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: :: @
  LSP: Concave: Backpack: 
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new_tokens ::= whitespace | "," | "::" | "@"
root ::= new_tokens

Top 20 Logits:

:19.719
#:15.1714
let:14.4646
##:14.3742
 :13.1319
    :12.5008
################:12.4578
  :12.4565
   :12.353
in:12.2794
####:12.0338
/*:11.8766
```:11.8142
//:11.3753
                :11.2778
[:11.2722
end:11.2379
(:11.1693
def:11.1358
        :11.0771
{:11.0257

================
# Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)



































































































































































































LSP: Prelude: Recieved string: ### List ###

# Add an element to the front of a list. #
let cons: (Int, [Int]) -> [Int] = fun x, xs -> x::xs in

# Determine the length of a list. #
let length: [Int] -> Int =
  fun xs ->
    case xs
    | [] => 0
    | _::xs => 1 + length(xs) end in

# Extract the first element of a list. #
let hd: [Int] -> Option =
  fun l ->
    case l
    | [] => None
    | x::xs => Some(x) end in

# Extract the rest of the list. #
let tl: [Int] -> [Int] =
  fun l ->
    case l
    | [] => []
    | x::xs => xs end in

# Determine if a list is empty. #
let is_empty: [Int] -> Bool =
  fun xs ->
    case xs
    | [] => true
    | _::_ => false end in

# Return the element at the index. #
let nth: ([Int], Int) -> Option =
  fun xs, n ->
    case xs, n
    | x::_, 0 => Some(x)
    | _::xs, n => nth(xs, n - 1)
    | [], _ => None end in

# Reverse a List. #
let rev: [Int] -> [Int] =
fun l -> 
let go: ([Int], [Int]) -> [Int] =
  fun xs, acc -> 
    case xs 
    | [] => acc 
    | x::xs => go(xs, x::acc) end in
go(l, []) in

# Check if two lists are equal #
let equal: ([Int], [Int]) -> Bool =
    fun p, xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => x == y && equal(xs, ys)
    | _ => false end
in

# Initialize a list with a given length using an initializer function #
let init: (Int, Int -> Int) -> [Int] =
    fun len, f ->
        let go: (Int, [Int]) -> [Int] =
        fun idx, xs ->
            if idx < len 
            then go(idx + 1, xs @ [f(idx)])   
            else xs
        in
        go(0, [])
in

# Reduce a list from the left. #
let fold_left: ((Int, Int) -> Int, Int, [Int]) -> Int =
  fun f, acc, xs ->
    case xs 
    | [] => acc
    | hd::tl => fold_left(f, f(acc, hd), tl) end in

# Reduce a list from the right. #
let fold_right: ((Int, Int) -> Int, [Int], Int) -> Int =
  fun f, xs, acc ->
    case xs
    | [] => acc
    | hd::tl => f(hd, fold_right(f, tl, acc)) end in


666
LSP: Prelude: String parsed successfully
LSP: Prelude: Info map generated successfully
Debug: true, Constrain: Types
LSP: Init: Recieved string: # Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)


































































































































































































LSP: Init: String parsed successfully
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: >( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {go: ((?, ?) -> [?]), filter: (((Int -> Bool), [Int]) -> [Int]), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: 
  LSP: Info: ALL errors:Error in term:
  p
Nature of error: Variable p is not bound    
Error in term:
  p
Nature of error: Variable p is not bound    
Error in term:
  p
Nature of error: type ((Int -> Bool), [Int]) is not consistent with arrow type
  LSP: Info: BidiCtx: Cls: Let expression
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent: Root
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: [?]
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: :: @
  LSP: Concave: Backpack: 
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new_tokens ::= whitespace | "," | "::" | "@"
root ::= new_tokens

Top 20 Logits:

:19.7308
#:15.1643
let:14.47
##:14.3895
 :13.1322
    :12.5006
################:12.4619
  :12.457
   :12.3504
in:12.2615
####:12.0414
/*:11.8729
```:11.8198
//:11.3751
                :11.2814
[:11.28
end:11.243
(:11.1668
def:11.1373
        :11.0792
{:11.0241

================
# Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)




































































































































































































LSP: Prelude: Recieved string: ### List ###

# Add an element to the front of a list. #
let cons: (Int, [Int]) -> [Int] = fun x, xs -> x::xs in

# Determine the length of a list. #
let length: [Int] -> Int =
  fun xs ->
    case xs
    | [] => 0
    | _::xs => 1 + length(xs) end in

# Extract the first element of a list. #
let hd: [Int] -> Option =
  fun l ->
    case l
    | [] => None
    | x::xs => Some(x) end in

# Extract the rest of the list. #
let tl: [Int] -> [Int] =
  fun l ->
    case l
    | [] => []
    | x::xs => xs end in

# Determine if a list is empty. #
let is_empty: [Int] -> Bool =
  fun xs ->
    case xs
    | [] => true
    | _::_ => false end in

# Return the element at the index. #
let nth: ([Int], Int) -> Option =
  fun xs, n ->
    case xs, n
    | x::_, 0 => Some(x)
    | _::xs, n => nth(xs, n - 1)
    | [], _ => None end in

# Reverse a List. #
let rev: [Int] -> [Int] =
fun l -> 
let go: ([Int], [Int]) -> [Int] =
  fun xs, acc -> 
    case xs 
    | [] => acc 
    | x::xs => go(xs, x::acc) end in
go(l, []) in

# Check if two lists are equal #
let equal: ([Int], [Int]) -> Bool =
    fun p, xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => x == y && equal(xs, ys)
    | _ => false end
in

# Initialize a list with a given length using an initializer function #
let init: (Int, Int -> Int) -> [Int] =
    fun len, f ->
        let go: (Int, [Int]) -> [Int] =
        fun idx, xs ->
            if idx < len 
            then go(idx + 1, xs @ [f(idx)])   
            else xs
        in
        go(0, [])
in

# Reduce a list from the left. #
let fold_left: ((Int, Int) -> Int, Int, [Int]) -> Int =
  fun f, acc, xs ->
    case xs 
    | [] => acc
    | hd::tl => fold_left(f, f(acc, hd), tl) end in

# Reduce a list from the right. #
let fold_right: ((Int, Int) -> Int, [Int], Int) -> Int =
  fun f, xs, acc ->
    case xs
    | [] => acc
    | hd::tl => f(hd, fold_right(f, tl, acc)) end in


666
LSP: Prelude: String parsed successfully
LSP: Prelude: Info map generated successfully
Debug: true, Constrain: Types
LSP: Init: Recieved string: # Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)



































































































































































































LSP: Init: String parsed successfully
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: >( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {go: ((?, ?) -> [?]), filter: (((Int -> Bool), [Int]) -> [Int]), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: 
  LSP: Info: ALL errors:Error in term:
  p
Nature of error: type ((Int -> Bool), [Int]) is not consistent with arrow type    
Error in term:
  p
Nature of error: Variable p is not bound    
Error in term:
  p
Nature of error: Variable p is not bound
  LSP: Info: BidiCtx: Cls: Let expression
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent: Root
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: [?]
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: :: @
  LSP: Concave: Backpack: 
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new_tokens ::= whitespace | "," | "::" | "@"
root ::= new_tokens

Top 20 Logits:

:19.7408
#:15.1562
let:14.472
##:14.3961
 :13.131
    :12.5038
################:12.4642
  :12.4564
   :12.349
in:12.2702
####:12.0406
/*:11.8661
```:11.8194
//:11.3696
                :11.2886
[:11.284
end:11.2647
(:11.1568
def:11.1421
        :11.0828
{:11.0207

================
# Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)





































































































































































































LSP: Prelude: Recieved string: ### List ###

# Add an element to the front of a list. #
let cons: (Int, [Int]) -> [Int] = fun x, xs -> x::xs in

# Determine the length of a list. #
let length: [Int] -> Int =
  fun xs ->
    case xs
    | [] => 0
    | _::xs => 1 + length(xs) end in

# Extract the first element of a list. #
let hd: [Int] -> Option =
  fun l ->
    case l
    | [] => None
    | x::xs => Some(x) end in

# Extract the rest of the list. #
let tl: [Int] -> [Int] =
  fun l ->
    case l
    | [] => []
    | x::xs => xs end in

# Determine if a list is empty. #
let is_empty: [Int] -> Bool =
  fun xs ->
    case xs
    | [] => true
    | _::_ => false end in

# Return the element at the index. #
let nth: ([Int], Int) -> Option =
  fun xs, n ->
    case xs, n
    | x::_, 0 => Some(x)
    | _::xs, n => nth(xs, n - 1)
    | [], _ => None end in

# Reverse a List. #
let rev: [Int] -> [Int] =
fun l -> 
let go: ([Int], [Int]) -> [Int] =
  fun xs, acc -> 
    case xs 
    | [] => acc 
    | x::xs => go(xs, x::acc) end in
go(l, []) in

# Check if two lists are equal #
let equal: ([Int], [Int]) -> Bool =
    fun p, xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => x == y && equal(xs, ys)
    | _ => false end
in

# Initialize a list with a given length using an initializer function #
let init: (Int, Int -> Int) -> [Int] =
    fun len, f ->
        let go: (Int, [Int]) -> [Int] =
        fun idx, xs ->
            if idx < len 
            then go(idx + 1, xs @ [f(idx)])   
            else xs
        in
        go(0, [])
in

# Reduce a list from the left. #
let fold_left: ((Int, Int) -> Int, Int, [Int]) -> Int =
  fun f, acc, xs ->
    case xs 
    | [] => acc
    | hd::tl => fold_left(f, f(acc, hd), tl) end in

# Reduce a list from the right. #
let fold_right: ((Int, Int) -> Int, [Int], Int) -> Int =
  fun f, xs, acc ->
    case xs
    | [] => acc
    | hd::tl => f(hd, fold_right(f, tl, acc)) end in


666
LSP: Prelude: String parsed successfully
LSP: Prelude: Info map generated successfully
Debug: true, Constrain: Types
LSP: Init: Recieved string: # Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)




































































































































































































LSP: Init: String parsed successfully
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: >( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {go: ((?, ?) -> [?]), filter: (((Int -> Bool), [Int]) -> [Int]), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: 
  LSP: Info: ALL errors:Error in term:
  p
Nature of error: Variable p is not bound    
Error in term:
  p
Nature of error: type ((Int -> Bool), [Int]) is not consistent with arrow type    
Error in term:
  p
Nature of error: Variable p is not bound
  LSP: Info: BidiCtx: Cls: Let expression
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent: Root
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: [?]
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: :: @
  LSP: Concave: Backpack: 
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new_tokens ::= whitespace | "," | "::" | "@"
root ::= new_tokens

Top 20 Logits:

:19.7476
#:15.1509
let:14.4735
##:14.3908
 :13.1316
    :12.5112
################:12.4641
  :12.4562
   :12.3532
in:12.291
####:12.0335
/*:11.8589
```:11.8113
//:11.3616
                :11.2951
end:11.2891
[:11.2884
(:11.1506
def:11.1446
        :11.0853
{:11.0196

================
# Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)






































































































































































































LSP: Prelude: Recieved string: ### List ###

# Add an element to the front of a list. #
let cons: (Int, [Int]) -> [Int] = fun x, xs -> x::xs in

# Determine the length of a list. #
let length: [Int] -> Int =
  fun xs ->
    case xs
    | [] => 0
    | _::xs => 1 + length(xs) end in

# Extract the first element of a list. #
let hd: [Int] -> Option =
  fun l ->
    case l
    | [] => None
    | x::xs => Some(x) end in

# Extract the rest of the list. #
let tl: [Int] -> [Int] =
  fun l ->
    case l
    | [] => []
    | x::xs => xs end in

# Determine if a list is empty. #
let is_empty: [Int] -> Bool =
  fun xs ->
    case xs
    | [] => true
    | _::_ => false end in

# Return the element at the index. #
let nth: ([Int], Int) -> Option =
  fun xs, n ->
    case xs, n
    | x::_, 0 => Some(x)
    | _::xs, n => nth(xs, n - 1)
    | [], _ => None end in

# Reverse a List. #
let rev: [Int] -> [Int] =
fun l -> 
let go: ([Int], [Int]) -> [Int] =
  fun xs, acc -> 
    case xs 
    | [] => acc 
    | x::xs => go(xs, x::acc) end in
go(l, []) in

# Check if two lists are equal #
let equal: ([Int], [Int]) -> Bool =
    fun p, xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => x == y && equal(xs, ys)
    | _ => false end
in

# Initialize a list with a given length using an initializer function #
let init: (Int, Int -> Int) -> [Int] =
    fun len, f ->
        let go: (Int, [Int]) -> [Int] =
        fun idx, xs ->
            if idx < len 
            then go(idx + 1, xs @ [f(idx)])   
            else xs
        in
        go(0, [])
in

# Reduce a list from the left. #
let fold_left: ((Int, Int) -> Int, Int, [Int]) -> Int =
  fun f, acc, xs ->
    case xs 
    | [] => acc
    | hd::tl => fold_left(f, f(acc, hd), tl) end in

# Reduce a list from the right. #
let fold_right: ((Int, Int) -> Int, [Int], Int) -> Int =
  fun f, xs, acc ->
    case xs
    | [] => acc
    | hd::tl => f(hd, fold_right(f, tl, acc)) end in


666
LSP: Prelude: String parsed successfully
LSP: Prelude: Info map generated successfully
Debug: true, Constrain: Types
LSP: Init: Recieved string: # Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)





































































































































































































LSP: Init: String parsed successfully
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: >( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {go: ((?, ?) -> [?]), filter: (((Int -> Bool), [Int]) -> [Int]), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: 
  LSP: Info: ALL errors:Error in term:
  p
Nature of error: Variable p is not bound    
Error in term:
  p
Nature of error: Variable p is not bound    
Error in term:
  p
Nature of error: type ((Int -> Bool), [Int]) is not consistent with arrow type
  LSP: Info: BidiCtx: Cls: Let expression
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent: Root
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: [?]
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: :: @
  LSP: Concave: Backpack: 
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new_tokens ::= whitespace | "," | "::" | "@"
root ::= new_tokens

Top 20 Logits:

:19.7531
#:15.1542
let:14.4799
##:14.3794
 :13.1355
    :12.5211
################:12.4651
  :12.4577
   :12.3623
in:12.3013
####:12.0277
/*:11.8539
```:11.8048
//:11.3548
end:11.3008
[:11.3
                :11.2999
(:11.158
def:11.1421
        :11.0872
{:11.0234

================
# Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)







































































































































































































LSP: Prelude: Recieved string: ### List ###

# Add an element to the front of a list. #
let cons: (Int, [Int]) -> [Int] = fun x, xs -> x::xs in

# Determine the length of a list. #
let length: [Int] -> Int =
  fun xs ->
    case xs
    | [] => 0
    | _::xs => 1 + length(xs) end in

# Extract the first element of a list. #
let hd: [Int] -> Option =
  fun l ->
    case l
    | [] => None
    | x::xs => Some(x) end in

# Extract the rest of the list. #
let tl: [Int] -> [Int] =
  fun l ->
    case l
    | [] => []
    | x::xs => xs end in

# Determine if a list is empty. #
let is_empty: [Int] -> Bool =
  fun xs ->
    case xs
    | [] => true
    | _::_ => false end in

# Return the element at the index. #
let nth: ([Int], Int) -> Option =
  fun xs, n ->
    case xs, n
    | x::_, 0 => Some(x)
    | _::xs, n => nth(xs, n - 1)
    | [], _ => None end in

# Reverse a List. #
let rev: [Int] -> [Int] =
fun l -> 
let go: ([Int], [Int]) -> [Int] =
  fun xs, acc -> 
    case xs 
    | [] => acc 
    | x::xs => go(xs, x::acc) end in
go(l, []) in

# Check if two lists are equal #
let equal: ([Int], [Int]) -> Bool =
    fun p, xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => x == y && equal(xs, ys)
    | _ => false end
in

# Initialize a list with a given length using an initializer function #
let init: (Int, Int -> Int) -> [Int] =
    fun len, f ->
        let go: (Int, [Int]) -> [Int] =
        fun idx, xs ->
            if idx < len 
            then go(idx + 1, xs @ [f(idx)])   
            else xs
        in
        go(0, [])
in

# Reduce a list from the left. #
let fold_left: ((Int, Int) -> Int, Int, [Int]) -> Int =
  fun f, acc, xs ->
    case xs 
    | [] => acc
    | hd::tl => fold_left(f, f(acc, hd), tl) end in

# Reduce a list from the right. #
let fold_right: ((Int, Int) -> Int, [Int], Int) -> Int =
  fun f, xs, acc ->
    case xs
    | [] => acc
    | hd::tl => f(hd, fold_right(f, tl, acc)) end in


666
LSP: Prelude: String parsed successfully
LSP: Prelude: Info map generated successfully
Debug: true, Constrain: Types
LSP: Init: Recieved string: # Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)






































































































































































































LSP: Init: String parsed successfully
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: >( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {go: ((?, ?) -> [?]), filter: (((Int -> Bool), [Int]) -> [Int]), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: 
  LSP: Info: ALL errors:Error in term:
  p
Nature of error: Variable p is not bound    
Error in term:
  p
Nature of error: type ((Int -> Bool), [Int]) is not consistent with arrow type    
Error in term:
  p
Nature of error: Variable p is not bound
  LSP: Info: BidiCtx: Cls: Let expression
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent: Root
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: [?]
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: :: @
  LSP: Concave: Backpack: 
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new_tokens ::= whitespace | "," | "::" | "@"
root ::= new_tokens

Top 20 Logits:

:19.7607
#:15.1667
let:14.4927
##:14.3722
 :13.141
    :12.5291
################:12.4703
  :12.4599
   :12.3723
in:12.2928
####:12.029
/*:11.8527
```:11.8094
//:11.3523
[:11.3199
                :11.3027
end:11.2909
(:11.1773
def:11.1339
        :11.0896
{:11.0303

================
# Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)








































































































































































































LSP: Prelude: Recieved string: ### List ###

# Add an element to the front of a list. #
let cons: (Int, [Int]) -> [Int] = fun x, xs -> x::xs in

# Determine the length of a list. #
let length: [Int] -> Int =
  fun xs ->
    case xs
    | [] => 0
    | _::xs => 1 + length(xs) end in

# Extract the first element of a list. #
let hd: [Int] -> Option =
  fun l ->
    case l
    | [] => None
    | x::xs => Some(x) end in

# Extract the rest of the list. #
let tl: [Int] -> [Int] =
  fun l ->
    case l
    | [] => []
    | x::xs => xs end in

# Determine if a list is empty. #
let is_empty: [Int] -> Bool =
  fun xs ->
    case xs
    | [] => true
    | _::_ => false end in

# Return the element at the index. #
let nth: ([Int], Int) -> Option =
  fun xs, n ->
    case xs, n
    | x::_, 0 => Some(x)
    | _::xs, n => nth(xs, n - 1)
    | [], _ => None end in

# Reverse a List. #
let rev: [Int] -> [Int] =
fun l -> 
let go: ([Int], [Int]) -> [Int] =
  fun xs, acc -> 
    case xs 
    | [] => acc 
    | x::xs => go(xs, x::acc) end in
go(l, []) in

# Check if two lists are equal #
let equal: ([Int], [Int]) -> Bool =
    fun p, xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => x == y && equal(xs, ys)
    | _ => false end
in

# Initialize a list with a given length using an initializer function #
let init: (Int, Int -> Int) -> [Int] =
    fun len, f ->
        let go: (Int, [Int]) -> [Int] =
        fun idx, xs ->
            if idx < len 
            then go(idx + 1, xs @ [f(idx)])   
            else xs
        in
        go(0, [])
in

# Reduce a list from the left. #
let fold_left: ((Int, Int) -> Int, Int, [Int]) -> Int =
  fun f, acc, xs ->
    case xs 
    | [] => acc
    | hd::tl => fold_left(f, f(acc, hd), tl) end in

# Reduce a list from the right. #
let fold_right: ((Int, Int) -> Int, [Int], Int) -> Int =
  fun f, xs, acc ->
    case xs
    | [] => acc
    | hd::tl => f(hd, fold_right(f, tl, acc)) end in


666
LSP: Prelude: String parsed successfully
LSP: Prelude: Info map generated successfully
Debug: true, Constrain: Types
LSP: Init: Recieved string: # Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)







































































































































































































LSP: Init: String parsed successfully
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: >( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {go: ((?, ?) -> [?]), filter: (((Int -> Bool), [Int]) -> [Int]), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: 
  LSP: Info: ALL errors:Error in term:
  p
Nature of error: Variable p is not bound    
Error in term:
  p
Nature of error: Variable p is not bound    
Error in term:
  p
Nature of error: type ((Int -> Bool), [Int]) is not consistent with arrow type
  LSP: Info: BidiCtx: Cls: Let expression
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent: Root
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: [?]
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: :: @
  LSP: Concave: Backpack: 
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new_tokens ::= whitespace | "," | "::" | "@"
root ::= new_tokens

Top 20 Logits:

:19.7708
#:15.1811
let:14.5088
##:14.3734
 :13.144
    :12.5309
################:12.4765
  :12.4598
   :12.3771
in:12.2708
####:12.0364
/*:11.8532
```:11.8253
//:11.3532
[:11.3435
                :11.3036
end:11.2569
(:11.1973
def:11.1224
        :11.091
{:11.0373

================
# Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)









































































































































































































LSP: Prelude: Recieved string: ### List ###

# Add an element to the front of a list. #
let cons: (Int, [Int]) -> [Int] = fun x, xs -> x::xs in

# Determine the length of a list. #
let length: [Int] -> Int =
  fun xs ->
    case xs
    | [] => 0
    | _::xs => 1 + length(xs) end in

# Extract the first element of a list. #
let hd: [Int] -> Option =
  fun l ->
    case l
    | [] => None
    | x::xs => Some(x) end in

# Extract the rest of the list. #
let tl: [Int] -> [Int] =
  fun l ->
    case l
    | [] => []
    | x::xs => xs end in

# Determine if a list is empty. #
let is_empty: [Int] -> Bool =
  fun xs ->
    case xs
    | [] => true
    | _::_ => false end in

# Return the element at the index. #
let nth: ([Int], Int) -> Option =
  fun xs, n ->
    case xs, n
    | x::_, 0 => Some(x)
    | _::xs, n => nth(xs, n - 1)
    | [], _ => None end in

# Reverse a List. #
let rev: [Int] -> [Int] =
fun l -> 
let go: ([Int], [Int]) -> [Int] =
  fun xs, acc -> 
    case xs 
    | [] => acc 
    | x::xs => go(xs, x::acc) end in
go(l, []) in

# Check if two lists are equal #
let equal: ([Int], [Int]) -> Bool =
    fun p, xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => x == y && equal(xs, ys)
    | _ => false end
in

# Initialize a list with a given length using an initializer function #
let init: (Int, Int -> Int) -> [Int] =
    fun len, f ->
        let go: (Int, [Int]) -> [Int] =
        fun idx, xs ->
            if idx < len 
            then go(idx + 1, xs @ [f(idx)])   
            else xs
        in
        go(0, [])
in

# Reduce a list from the left. #
let fold_left: ((Int, Int) -> Int, Int, [Int]) -> Int =
  fun f, acc, xs ->
    case xs 
    | [] => acc
    | hd::tl => fold_left(f, f(acc, hd), tl) end in

# Reduce a list from the right. #
let fold_right: ((Int, Int) -> Int, [Int], Int) -> Int =
  fun f, xs, acc ->
    case xs
    | [] => acc
    | hd::tl => f(hd, fold_right(f, tl, acc)) end in


666
LSP: Prelude: String parsed successfully
LSP: Prelude: Info map generated successfully
Debug: true, Constrain: Types
LSP: Init: Recieved string: # Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)








































































































































































































LSP: Init: String parsed successfully
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: >( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {go: ((?, ?) -> [?]), filter: (((Int -> Bool), [Int]) -> [Int]), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: 
  LSP: Info: ALL errors:Error in term:
  p
Nature of error: Variable p is not bound    
Error in term:
  p
Nature of error: type ((Int -> Bool), [Int]) is not consistent with arrow type    
Error in term:
  p
Nature of error: Variable p is not bound
  LSP: Info: BidiCtx: Cls: Let expression
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent: Root
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: [?]
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: :: @
  LSP: Concave: Backpack: 
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new_tokens ::= whitespace | "," | "::" | "@"
root ::= new_tokens

Top 20 Logits:

:19.7817
#:15.1891
let:14.5232
##:14.3799
 :13.1426
    :12.5283
################:12.4804
  :12.4573
   :12.3756
in:12.2472
####:12.0432
/*:11.8528
```:11.8433
[:11.3611
//:11.3545
                :11.3043
end:11.214
(:11.2055
def:11.1132
        :11.092
{:11.0413

================
# Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)










































































































































































































LSP: Prelude: Recieved string: ### List ###

# Add an element to the front of a list. #
let cons: (Int, [Int]) -> [Int] = fun x, xs -> x::xs in

# Determine the length of a list. #
let length: [Int] -> Int =
  fun xs ->
    case xs
    | [] => 0
    | _::xs => 1 + length(xs) end in

# Extract the first element of a list. #
let hd: [Int] -> Option =
  fun l ->
    case l
    | [] => None
    | x::xs => Some(x) end in

# Extract the rest of the list. #
let tl: [Int] -> [Int] =
  fun l ->
    case l
    | [] => []
    | x::xs => xs end in

# Determine if a list is empty. #
let is_empty: [Int] -> Bool =
  fun xs ->
    case xs
    | [] => true
    | _::_ => false end in

# Return the element at the index. #
let nth: ([Int], Int) -> Option =
  fun xs, n ->
    case xs, n
    | x::_, 0 => Some(x)
    | _::xs, n => nth(xs, n - 1)
    | [], _ => None end in

# Reverse a List. #
let rev: [Int] -> [Int] =
fun l -> 
let go: ([Int], [Int]) -> [Int] =
  fun xs, acc -> 
    case xs 
    | [] => acc 
    | x::xs => go(xs, x::acc) end in
go(l, []) in

# Check if two lists are equal #
let equal: ([Int], [Int]) -> Bool =
    fun p, xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => x == y && equal(xs, ys)
    | _ => false end
in

# Initialize a list with a given length using an initializer function #
let init: (Int, Int -> Int) -> [Int] =
    fun len, f ->
        let go: (Int, [Int]) -> [Int] =
        fun idx, xs ->
            if idx < len 
            then go(idx + 1, xs @ [f(idx)])   
            else xs
        in
        go(0, [])
in

# Reduce a list from the left. #
let fold_left: ((Int, Int) -> Int, Int, [Int]) -> Int =
  fun f, acc, xs ->
    case xs 
    | [] => acc
    | hd::tl => fold_left(f, f(acc, hd), tl) end in

# Reduce a list from the right. #
let fold_right: ((Int, Int) -> Int, [Int], Int) -> Int =
  fun f, xs, acc ->
    case xs
    | [] => acc
    | hd::tl => f(hd, fold_right(f, tl, acc)) end in


666
LSP: Prelude: String parsed successfully
LSP: Prelude: Info map generated successfully
Debug: true, Constrain: Types
LSP: Init: Recieved string: # Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)









































































































































































































LSP: Init: String parsed successfully
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: >( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {go: ((?, ?) -> [?]), filter: (((Int -> Bool), [Int]) -> [Int]), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: 
  LSP: Info: ALL errors:Error in term:
  p
Nature of error: Variable p is not bound    
Error in term:
  p
Nature of error: Variable p is not bound    
Error in term:
  p
Nature of error: type ((Int -> Bool), [Int]) is not consistent with arrow type
  LSP: Info: BidiCtx: Cls: Let expression
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent: Root
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: [?]
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: :: @
  LSP: Concave: Backpack: 
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new_tokens ::= whitespace | "," | "::" | "@"
root ::= new_tokens

Top 20 Logits:

:19.7906
#:15.1871
let:14.5319
##:14.3856
 :13.1372
    :12.5264
################:12.4819
  :12.4533
   :12.3699
in:12.2268
####:12.0443
/*:11.8532
```:11.8523
[:11.3655
//:11.3543
                :11.3056
(:11.1993
end:11.1811
def:11.1123
        :11.0942
{:11.0396

================
# Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)











































































































































































































LSP: Prelude: Recieved string: ### List ###

# Add an element to the front of a list. #
let cons: (Int, [Int]) -> [Int] = fun x, xs -> x::xs in

# Determine the length of a list. #
let length: [Int] -> Int =
  fun xs ->
    case xs
    | [] => 0
    | _::xs => 1 + length(xs) end in

# Extract the first element of a list. #
let hd: [Int] -> Option =
  fun l ->
    case l
    | [] => None
    | x::xs => Some(x) end in

# Extract the rest of the list. #
let tl: [Int] -> [Int] =
  fun l ->
    case l
    | [] => []
    | x::xs => xs end in

# Determine if a list is empty. #
let is_empty: [Int] -> Bool =
  fun xs ->
    case xs
    | [] => true
    | _::_ => false end in

# Return the element at the index. #
let nth: ([Int], Int) -> Option =
  fun xs, n ->
    case xs, n
    | x::_, 0 => Some(x)
    | _::xs, n => nth(xs, n - 1)
    | [], _ => None end in

# Reverse a List. #
let rev: [Int] -> [Int] =
fun l -> 
let go: ([Int], [Int]) -> [Int] =
  fun xs, acc -> 
    case xs 
    | [] => acc 
    | x::xs => go(xs, x::acc) end in
go(l, []) in

# Check if two lists are equal #
let equal: ([Int], [Int]) -> Bool =
    fun p, xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => x == y && equal(xs, ys)
    | _ => false end
in

# Initialize a list with a given length using an initializer function #
let init: (Int, Int -> Int) -> [Int] =
    fun len, f ->
        let go: (Int, [Int]) -> [Int] =
        fun idx, xs ->
            if idx < len 
            then go(idx + 1, xs @ [f(idx)])   
            else xs
        in
        go(0, [])
in

# Reduce a list from the left. #
let fold_left: ((Int, Int) -> Int, Int, [Int]) -> Int =
  fun f, acc, xs ->
    case xs 
    | [] => acc
    | hd::tl => fold_left(f, f(acc, hd), tl) end in

# Reduce a list from the right. #
let fold_right: ((Int, Int) -> Int, [Int], Int) -> Int =
  fun f, xs, acc ->
    case xs
    | [] => acc
    | hd::tl => f(hd, fold_right(f, tl, acc)) end in


666
LSP: Prelude: String parsed successfully
LSP: Prelude: Info map generated successfully
Debug: true, Constrain: Types
LSP: Init: Recieved string: # Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)










































































































































































































LSP: Init: String parsed successfully
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: >( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {go: ((?, ?) -> [?]), filter: (((Int -> Bool), [Int]) -> [Int]), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: 
  LSP: Info: ALL errors:Error in term:
  p
Nature of error: type ((Int -> Bool), [Int]) is not consistent with arrow type    
Error in term:
  p
Nature of error: Variable p is not bound    
Error in term:
  p
Nature of error: Variable p is not bound
  LSP: Info: BidiCtx: Cls: Let expression
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent: Root
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: [?]
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: :: @
  LSP: Concave: Backpack: 
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new_tokens ::= whitespace | "," | "::" | "@"
root ::= new_tokens

Top 20 Logits:

:19.7963
#:15.1778
let:14.5349
##:14.389
 :13.1309
    :12.5291
################:12.4815
  :12.4496
   :12.3649
in:12.2044
####:12.0421
/*:11.8561
```:11.8485
[:11.3601
//:11.3536
                :11.306
(:11.1845
end:11.1667
def:11.1188
        :11.0964
{:11.0353

================
# Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)












































































































































































































LSP: Prelude: Recieved string: ### List ###

# Add an element to the front of a list. #
let cons: (Int, [Int]) -> [Int] = fun x, xs -> x::xs in

# Determine the length of a list. #
let length: [Int] -> Int =
  fun xs ->
    case xs
    | [] => 0
    | _::xs => 1 + length(xs) end in

# Extract the first element of a list. #
let hd: [Int] -> Option =
  fun l ->
    case l
    | [] => None
    | x::xs => Some(x) end in

# Extract the rest of the list. #
let tl: [Int] -> [Int] =
  fun l ->
    case l
    | [] => []
    | x::xs => xs end in

# Determine if a list is empty. #
let is_empty: [Int] -> Bool =
  fun xs ->
    case xs
    | [] => true
    | _::_ => false end in

# Return the element at the index. #
let nth: ([Int], Int) -> Option =
  fun xs, n ->
    case xs, n
    | x::_, 0 => Some(x)
    | _::xs, n => nth(xs, n - 1)
    | [], _ => None end in

# Reverse a List. #
let rev: [Int] -> [Int] =
fun l -> 
let go: ([Int], [Int]) -> [Int] =
  fun xs, acc -> 
    case xs 
    | [] => acc 
    | x::xs => go(xs, x::acc) end in
go(l, []) in

# Check if two lists are equal #
let equal: ([Int], [Int]) -> Bool =
    fun p, xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => x == y && equal(xs, ys)
    | _ => false end
in

# Initialize a list with a given length using an initializer function #
let init: (Int, Int -> Int) -> [Int] =
    fun len, f ->
        let go: (Int, [Int]) -> [Int] =
        fun idx, xs ->
            if idx < len 
            then go(idx + 1, xs @ [f(idx)])   
            else xs
        in
        go(0, [])
in

# Reduce a list from the left. #
let fold_left: ((Int, Int) -> Int, Int, [Int]) -> Int =
  fun f, acc, xs ->
    case xs 
    | [] => acc
    | hd::tl => fold_left(f, f(acc, hd), tl) end in

# Reduce a list from the right. #
let fold_right: ((Int, Int) -> Int, [Int], Int) -> Int =
  fun f, xs, acc ->
    case xs
    | [] => acc
    | hd::tl => f(hd, fold_right(f, tl, acc)) end in


666
LSP: Prelude: String parsed successfully
LSP: Prelude: Info map generated successfully
Debug: true, Constrain: Types
LSP: Init: Recieved string: # Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)











































































































































































































LSP: Init: String parsed successfully
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: >( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {go: ((?, ?) -> [?]), filter: (((Int -> Bool), [Int]) -> [Int]), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: 
  LSP: Info: ALL errors:Error in term:
  p
Nature of error: Variable p is not bound    
Error in term:
  p
Nature of error: type ((Int -> Bool), [Int]) is not consistent with arrow type    
Error in term:
  p
Nature of error: Variable p is not bound
  LSP: Info: BidiCtx: Cls: Let expression
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent: Root
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: [?]
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: :: @
  LSP: Concave: Backpack: 
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new_tokens ::= whitespace | "," | "::" | "@"
root ::= new_tokens

Top 20 Logits:

:19.8014
#:15.1691
let:14.5349
##:14.3901
 :13.1274
    :12.5366
################:12.4798
  :12.4479
   :12.3634
in:12.1852
####:12.0397
/*:11.8606
```:11.8388
//:11.3545
[:11.3528
                :11.3062
(:11.173
end:11.1701
def:11.1253
        :11.0985
{:11.0322

================
# Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)













































































































































































































LSP: Prelude: Recieved string: ### List ###

# Add an element to the front of a list. #
let cons: (Int, [Int]) -> [Int] = fun x, xs -> x::xs in

# Determine the length of a list. #
let length: [Int] -> Int =
  fun xs ->
    case xs
    | [] => 0
    | _::xs => 1 + length(xs) end in

# Extract the first element of a list. #
let hd: [Int] -> Option =
  fun l ->
    case l
    | [] => None
    | x::xs => Some(x) end in

# Extract the rest of the list. #
let tl: [Int] -> [Int] =
  fun l ->
    case l
    | [] => []
    | x::xs => xs end in

# Determine if a list is empty. #
let is_empty: [Int] -> Bool =
  fun xs ->
    case xs
    | [] => true
    | _::_ => false end in

# Return the element at the index. #
let nth: ([Int], Int) -> Option =
  fun xs, n ->
    case xs, n
    | x::_, 0 => Some(x)
    | _::xs, n => nth(xs, n - 1)
    | [], _ => None end in

# Reverse a List. #
let rev: [Int] -> [Int] =
fun l -> 
let go: ([Int], [Int]) -> [Int] =
  fun xs, acc -> 
    case xs 
    | [] => acc 
    | x::xs => go(xs, x::acc) end in
go(l, []) in

# Check if two lists are equal #
let equal: ([Int], [Int]) -> Bool =
    fun p, xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => x == y && equal(xs, ys)
    | _ => false end
in

# Initialize a list with a given length using an initializer function #
let init: (Int, Int -> Int) -> [Int] =
    fun len, f ->
        let go: (Int, [Int]) -> [Int] =
        fun idx, xs ->
            if idx < len 
            then go(idx + 1, xs @ [f(idx)])   
            else xs
        in
        go(0, [])
in

# Reduce a list from the left. #
let fold_left: ((Int, Int) -> Int, Int, [Int]) -> Int =
  fun f, acc, xs ->
    case xs 
    | [] => acc
    | hd::tl => fold_left(f, f(acc, hd), tl) end in

# Reduce a list from the right. #
let fold_right: ((Int, Int) -> Int, [Int], Int) -> Int =
  fun f, xs, acc ->
    case xs
    | [] => acc
    | hd::tl => f(hd, fold_right(f, tl, acc)) end in


666
LSP: Prelude: String parsed successfully
LSP: Prelude: Info map generated successfully
Debug: true, Constrain: Types
LSP: Init: Recieved string: # Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)












































































































































































































LSP: Init: String parsed successfully
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: >( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {go: ((?, ?) -> [?]), filter: (((Int -> Bool), [Int]) -> [Int]), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: 
  LSP: Info: ALL errors:Error in term:
  p
Nature of error: type ((Int -> Bool), [Int]) is not consistent with arrow type    
Error in term:
  p
Nature of error: Variable p is not bound    
Error in term:
  p
Nature of error: Variable p is not bound
  LSP: Info: BidiCtx: Cls: Let expression
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent: Root
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: [?]
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: :: @
  LSP: Concave: Backpack: 
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new_tokens ::= whitespace | "," | "::" | "@"
root ::= new_tokens

Top 20 Logits:

:19.8082
#:15.1675
let:14.5335
##:14.3874
 :13.1271
    :12.5425
################:12.477
  :12.4472
   :12.363
in:12.1863
####:12.038
/*:11.8657
```:11.8315
//:11.3581
[:11.3505
                :11.3069
end:11.1864
(:11.1713
def:11.1271
        :11.1
{:11.03

================
# Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)














































































































































































































LSP: Prelude: Recieved string: ### List ###

# Add an element to the front of a list. #
let cons: (Int, [Int]) -> [Int] = fun x, xs -> x::xs in

# Determine the length of a list. #
let length: [Int] -> Int =
  fun xs ->
    case xs
    | [] => 0
    | _::xs => 1 + length(xs) end in

# Extract the first element of a list. #
let hd: [Int] -> Option =
  fun l ->
    case l
    | [] => None
    | x::xs => Some(x) end in

# Extract the rest of the list. #
let tl: [Int] -> [Int] =
  fun l ->
    case l
    | [] => []
    | x::xs => xs end in

# Determine if a list is empty. #
let is_empty: [Int] -> Bool =
  fun xs ->
    case xs
    | [] => true
    | _::_ => false end in

# Return the element at the index. #
let nth: ([Int], Int) -> Option =
  fun xs, n ->
    case xs, n
    | x::_, 0 => Some(x)
    | _::xs, n => nth(xs, n - 1)
    | [], _ => None end in

# Reverse a List. #
let rev: [Int] -> [Int] =
fun l -> 
let go: ([Int], [Int]) -> [Int] =
  fun xs, acc -> 
    case xs 
    | [] => acc 
    | x::xs => go(xs, x::acc) end in
go(l, []) in

# Check if two lists are equal #
let equal: ([Int], [Int]) -> Bool =
    fun p, xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => x == y && equal(xs, ys)
    | _ => false end
in

# Initialize a list with a given length using an initializer function #
let init: (Int, Int -> Int) -> [Int] =
    fun len, f ->
        let go: (Int, [Int]) -> [Int] =
        fun idx, xs ->
            if idx < len 
            then go(idx + 1, xs @ [f(idx)])   
            else xs
        in
        go(0, [])
in

# Reduce a list from the left. #
let fold_left: ((Int, Int) -> Int, Int, [Int]) -> Int =
  fun f, acc, xs ->
    case xs 
    | [] => acc
    | hd::tl => fold_left(f, f(acc, hd), tl) end in

# Reduce a list from the right. #
let fold_right: ((Int, Int) -> Int, [Int], Int) -> Int =
  fun f, xs, acc ->
    case xs
    | [] => acc
    | hd::tl => f(hd, fold_right(f, tl, acc)) end in


666
LSP: Prelude: String parsed successfully
LSP: Prelude: Info map generated successfully
Debug: true, Constrain: Types
LSP: Init: Recieved string: # Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)













































































































































































































LSP: Init: String parsed successfully
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: >( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {go: ((?, ?) -> [?]), filter: (((Int -> Bool), [Int]) -> [Int]), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: 
  LSP: Info: ALL errors:Error in term:
  p
Nature of error: Variable p is not bound    
Error in term:
  p
Nature of error: type ((Int -> Bool), [Int]) is not consistent with arrow type    
Error in term:
  p
Nature of error: Variable p is not bound
  LSP: Info: BidiCtx: Cls: Let expression
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent: Root
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: [?]
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: :: @
  LSP: Concave: Backpack: 
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new_tokens ::= whitespace | "," | "::" | "@"
root ::= new_tokens

Top 20 Logits:

:19.8178
#:15.1726
let:14.5323
##:14.3783
 :13.1285
    :12.5412
################:12.4698
  :12.4459
   :12.3602
in:12.2161
####:12.0345
/*:11.8692
```:11.8281
//:11.3611
[:11.3544
                :11.3073
end:11.2131
(:11.1748
def:11.1271
        :11.0986
{:11.026

================
# Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)















































































































































































































LSP: Prelude: Recieved string: ### List ###

# Add an element to the front of a list. #
let cons: (Int, [Int]) -> [Int] = fun x, xs -> x::xs in

# Determine the length of a list. #
let length: [Int] -> Int =
  fun xs ->
    case xs
    | [] => 0
    | _::xs => 1 + length(xs) end in

# Extract the first element of a list. #
let hd: [Int] -> Option =
  fun l ->
    case l
    | [] => None
    | x::xs => Some(x) end in

# Extract the rest of the list. #
let tl: [Int] -> [Int] =
  fun l ->
    case l
    | [] => []
    | x::xs => xs end in

# Determine if a list is empty. #
let is_empty: [Int] -> Bool =
  fun xs ->
    case xs
    | [] => true
    | _::_ => false end in

# Return the element at the index. #
let nth: ([Int], Int) -> Option =
  fun xs, n ->
    case xs, n
    | x::_, 0 => Some(x)
    | _::xs, n => nth(xs, n - 1)
    | [], _ => None end in

# Reverse a List. #
let rev: [Int] -> [Int] =
fun l -> 
let go: ([Int], [Int]) -> [Int] =
  fun xs, acc -> 
    case xs 
    | [] => acc 
    | x::xs => go(xs, x::acc) end in
go(l, []) in

# Check if two lists are equal #
let equal: ([Int], [Int]) -> Bool =
    fun p, xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => x == y && equal(xs, ys)
    | _ => false end
in

# Initialize a list with a given length using an initializer function #
let init: (Int, Int -> Int) -> [Int] =
    fun len, f ->
        let go: (Int, [Int]) -> [Int] =
        fun idx, xs ->
            if idx < len 
            then go(idx + 1, xs @ [f(idx)])   
            else xs
        in
        go(0, [])
in

# Reduce a list from the left. #
let fold_left: ((Int, Int) -> Int, Int, [Int]) -> Int =
  fun f, acc, xs ->
    case xs 
    | [] => acc
    | hd::tl => fold_left(f, f(acc, hd), tl) end in

# Reduce a list from the right. #
let fold_right: ((Int, Int) -> Int, [Int], Int) -> Int =
  fun f, xs, acc ->
    case xs
    | [] => acc
    | hd::tl => f(hd, fold_right(f, tl, acc)) end in


666
LSP: Prelude: String parsed successfully
LSP: Prelude: Info map generated successfully
Debug: true, Constrain: Types
LSP: Init: Recieved string: # Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)














































































































































































































LSP: Init: String parsed successfully
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: >( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {go: ((?, ?) -> [?]), filter: (((Int -> Bool), [Int]) -> [Int]), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: 
  LSP: Info: ALL errors:Error in term:
  p
Nature of error: type ((Int -> Bool), [Int]) is not consistent with arrow type    
Error in term:
  p
Nature of error: Variable p is not bound    
Error in term:
  p
Nature of error: Variable p is not bound
  LSP: Info: BidiCtx: Cls: Let expression
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent: Root
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: [?]
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: :: @
  LSP: Concave: Backpack: 
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new_tokens ::= whitespace | "," | "::" | "@"
root ::= new_tokens

Top 20 Logits:

:19.8293
#:15.1819
let:14.5348
##:14.3602
 :13.1308
    :12.5348
################:12.4573
  :12.446
   :12.354
in:12.2693
####:12.0257
/*:11.8705
```:11.8281
//:11.3619
[:11.3586
                :11.3108
end:11.2424
(:11.1767
def:11.1285
        :11.0963
{:11.0205

================
# Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)
















































































































































































































LSP: Prelude: Recieved string: ### List ###

# Add an element to the front of a list. #
let cons: (Int, [Int]) -> [Int] = fun x, xs -> x::xs in

# Determine the length of a list. #
let length: [Int] -> Int =
  fun xs ->
    case xs
    | [] => 0
    | _::xs => 1 + length(xs) end in

# Extract the first element of a list. #
let hd: [Int] -> Option =
  fun l ->
    case l
    | [] => None
    | x::xs => Some(x) end in

# Extract the rest of the list. #
let tl: [Int] -> [Int] =
  fun l ->
    case l
    | [] => []
    | x::xs => xs end in

# Determine if a list is empty. #
let is_empty: [Int] -> Bool =
  fun xs ->
    case xs
    | [] => true
    | _::_ => false end in

# Return the element at the index. #
let nth: ([Int], Int) -> Option =
  fun xs, n ->
    case xs, n
    | x::_, 0 => Some(x)
    | _::xs, n => nth(xs, n - 1)
    | [], _ => None end in

# Reverse a List. #
let rev: [Int] -> [Int] =
fun l -> 
let go: ([Int], [Int]) -> [Int] =
  fun xs, acc -> 
    case xs 
    | [] => acc 
    | x::xs => go(xs, x::acc) end in
go(l, []) in

# Check if two lists are equal #
let equal: ([Int], [Int]) -> Bool =
    fun p, xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => x == y && equal(xs, ys)
    | _ => false end
in

# Initialize a list with a given length using an initializer function #
let init: (Int, Int -> Int) -> [Int] =
    fun len, f ->
        let go: (Int, [Int]) -> [Int] =
        fun idx, xs ->
            if idx < len 
            then go(idx + 1, xs @ [f(idx)])   
            else xs
        in
        go(0, [])
in

# Reduce a list from the left. #
let fold_left: ((Int, Int) -> Int, Int, [Int]) -> Int =
  fun f, acc, xs ->
    case xs 
    | [] => acc
    | hd::tl => fold_left(f, f(acc, hd), tl) end in

# Reduce a list from the right. #
let fold_right: ((Int, Int) -> Int, [Int], Int) -> Int =
  fun f, xs, acc ->
    case xs
    | [] => acc
    | hd::tl => f(hd, fold_right(f, tl, acc)) end in


666
LSP: Prelude: String parsed successfully
LSP: Prelude: Info map generated successfully
Debug: true, Constrain: Types
LSP: Init: Recieved string: # Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)















































































































































































































LSP: Init: String parsed successfully
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: >( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {go: ((?, ?) -> [?]), filter: (((Int -> Bool), [Int]) -> [Int]), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: 
  LSP: Info: ALL errors:Error in term:
  p
Nature of error: Variable p is not bound    
Error in term:
  p
Nature of error: Variable p is not bound    
Error in term:
  p
Nature of error: type ((Int -> Bool), [Int]) is not consistent with arrow type
  LSP: Info: BidiCtx: Cls: Let expression
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent: Root
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: [?]
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: :: @
  LSP: Concave: Backpack: 
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new_tokens ::= whitespace | "," | "::" | "@"
root ::= new_tokens

Top 20 Logits:

:19.839
#:15.1919
let:14.5417
##:14.3367
 :13.1329
    :12.5291
  :12.4488
################:12.4441
   :12.3479
in:12.3277
####:12.0129
/*:11.8722
```:11.8293
//:11.3627
[:11.3571
                :11.3175
end:11.2639
(:11.1739
def:11.1303
        :11.096
{:11.0161

================
# Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)

















































































































































































































LSP: Prelude: Recieved string: ### List ###

# Add an element to the front of a list. #
let cons: (Int, [Int]) -> [Int] = fun x, xs -> x::xs in

# Determine the length of a list. #
let length: [Int] -> Int =
  fun xs ->
    case xs
    | [] => 0
    | _::xs => 1 + length(xs) end in

# Extract the first element of a list. #
let hd: [Int] -> Option =
  fun l ->
    case l
    | [] => None
    | x::xs => Some(x) end in

# Extract the rest of the list. #
let tl: [Int] -> [Int] =
  fun l ->
    case l
    | [] => []
    | x::xs => xs end in

# Determine if a list is empty. #
let is_empty: [Int] -> Bool =
  fun xs ->
    case xs
    | [] => true
    | _::_ => false end in

# Return the element at the index. #
let nth: ([Int], Int) -> Option =
  fun xs, n ->
    case xs, n
    | x::_, 0 => Some(x)
    | _::xs, n => nth(xs, n - 1)
    | [], _ => None end in

# Reverse a List. #
let rev: [Int] -> [Int] =
fun l -> 
let go: ([Int], [Int]) -> [Int] =
  fun xs, acc -> 
    case xs 
    | [] => acc 
    | x::xs => go(xs, x::acc) end in
go(l, []) in

# Check if two lists are equal #
let equal: ([Int], [Int]) -> Bool =
    fun p, xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => x == y && equal(xs, ys)
    | _ => false end
in

# Initialize a list with a given length using an initializer function #
let init: (Int, Int -> Int) -> [Int] =
    fun len, f ->
        let go: (Int, [Int]) -> [Int] =
        fun idx, xs ->
            if idx < len 
            then go(idx + 1, xs @ [f(idx)])   
            else xs
        in
        go(0, [])
in

# Reduce a list from the left. #
let fold_left: ((Int, Int) -> Int, Int, [Int]) -> Int =
  fun f, acc, xs ->
    case xs 
    | [] => acc
    | hd::tl => fold_left(f, f(acc, hd), tl) end in

# Reduce a list from the right. #
let fold_right: ((Int, Int) -> Int, [Int], Int) -> Int =
  fun f, xs, acc ->
    case xs
    | [] => acc
    | hd::tl => f(hd, fold_right(f, tl, acc)) end in


666
LSP: Prelude: String parsed successfully
LSP: Prelude: Info map generated successfully
Debug: true, Constrain: Types
LSP: Init: Recieved string: # Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)
















































































































































































































LSP: Init: String parsed successfully
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: >( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {go: ((?, ?) -> [?]), filter: (((Int -> Bool), [Int]) -> [Int]), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: 
  LSP: Info: ALL errors:Error in term:
  p
Nature of error: Variable p is not bound    
Error in term:
  p
Nature of error: type ((Int -> Bool), [Int]) is not consistent with arrow type    
Error in term:
  p
Nature of error: Variable p is not bound
  LSP: Info: BidiCtx: Cls: Let expression
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent: Root
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: [?]
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: :: @
  LSP: Concave: Backpack: 
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new_tokens ::= whitespace | "," | "::" | "@"
root ::= new_tokens

Top 20 Logits:

:19.8438
#:15.1979
let:14.5508
##:14.3175
 :13.1338
    :12.5265
  :12.4516
################:12.4343
in:12.359
   :12.344
####:12.0012
/*:11.8767
```:11.8256
//:11.3644
[:11.352
                :11.3211
end:11.2697
(:11.1674
def:11.1306
        :11.0957
{:11.0163

================
# Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)


















































































































































































































LSP: Prelude: Recieved string: ### List ###

# Add an element to the front of a list. #
let cons: (Int, [Int]) -> [Int] = fun x, xs -> x::xs in

# Determine the length of a list. #
let length: [Int] -> Int =
  fun xs ->
    case xs
    | [] => 0
    | _::xs => 1 + length(xs) end in

# Extract the first element of a list. #
let hd: [Int] -> Option =
  fun l ->
    case l
    | [] => None
    | x::xs => Some(x) end in

# Extract the rest of the list. #
let tl: [Int] -> [Int] =
  fun l ->
    case l
    | [] => []
    | x::xs => xs end in

# Determine if a list is empty. #
let is_empty: [Int] -> Bool =
  fun xs ->
    case xs
    | [] => true
    | _::_ => false end in

# Return the element at the index. #
let nth: ([Int], Int) -> Option =
  fun xs, n ->
    case xs, n
    | x::_, 0 => Some(x)
    | _::xs, n => nth(xs, n - 1)
    | [], _ => None end in

# Reverse a List. #
let rev: [Int] -> [Int] =
fun l -> 
let go: ([Int], [Int]) -> [Int] =
  fun xs, acc -> 
    case xs 
    | [] => acc 
    | x::xs => go(xs, x::acc) end in
go(l, []) in

# Check if two lists are equal #
let equal: ([Int], [Int]) -> Bool =
    fun p, xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => x == y && equal(xs, ys)
    | _ => false end
in

# Initialize a list with a given length using an initializer function #
let init: (Int, Int -> Int) -> [Int] =
    fun len, f ->
        let go: (Int, [Int]) -> [Int] =
        fun idx, xs ->
            if idx < len 
            then go(idx + 1, xs @ [f(idx)])   
            else xs
        in
        go(0, [])
in

# Reduce a list from the left. #
let fold_left: ((Int, Int) -> Int, Int, [Int]) -> Int =
  fun f, acc, xs ->
    case xs 
    | [] => acc
    | hd::tl => fold_left(f, f(acc, hd), tl) end in

# Reduce a list from the right. #
let fold_right: ((Int, Int) -> Int, [Int], Int) -> Int =
  fun f, xs, acc ->
    case xs
    | [] => acc
    | hd::tl => f(hd, fold_right(f, tl, acc)) end in


666
LSP: Prelude: String parsed successfully
LSP: Prelude: Info map generated successfully
Debug: true, Constrain: Types
LSP: Init: Recieved string: # Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)

















































































































































































































LSP: Init: String parsed successfully
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: >( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {go: ((?, ?) -> [?]), filter: (((Int -> Bool), [Int]) -> [Int]), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: 
  LSP: Info: ALL errors:Error in term:
  p
Nature of error: type ((Int -> Bool), [Int]) is not consistent with arrow type    
Error in term:
  p
Nature of error: Variable p is not bound    
Error in term:
  p
Nature of error: Variable p is not bound
  LSP: Info: BidiCtx: Cls: Let expression
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent: Root
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: [?]
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: :: @
  LSP: Concave: Backpack: 
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new_tokens ::= whitespace | "," | "::" | "@"
root ::= new_tokens

Top 20 Logits:

:19.8465
#:15.2014
let:14.5609
##:14.3148
 :13.135
    :12.5284
  :12.454
################:12.4352
   :12.3432
in:12.3366
####:12.0008
/*:11.883
```:11.8192
//:11.366
[:11.3515
                :11.3205
end:11.255
(:11.1643
def:11.1299
        :11.0956
{:11.021

================
# Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)



















































































































































































































LSP: Prelude: Recieved string: ### List ###

# Add an element to the front of a list. #
let cons: (Int, [Int]) -> [Int] = fun x, xs -> x::xs in

# Determine the length of a list. #
let length: [Int] -> Int =
  fun xs ->
    case xs
    | [] => 0
    | _::xs => 1 + length(xs) end in

# Extract the first element of a list. #
let hd: [Int] -> Option =
  fun l ->
    case l
    | [] => None
    | x::xs => Some(x) end in

# Extract the rest of the list. #
let tl: [Int] -> [Int] =
  fun l ->
    case l
    | [] => []
    | x::xs => xs end in

# Determine if a list is empty. #
let is_empty: [Int] -> Bool =
  fun xs ->
    case xs
    | [] => true
    | _::_ => false end in

# Return the element at the index. #
let nth: ([Int], Int) -> Option =
  fun xs, n ->
    case xs, n
    | x::_, 0 => Some(x)
    | _::xs, n => nth(xs, n - 1)
    | [], _ => None end in

# Reverse a List. #
let rev: [Int] -> [Int] =
fun l -> 
let go: ([Int], [Int]) -> [Int] =
  fun xs, acc -> 
    case xs 
    | [] => acc 
    | x::xs => go(xs, x::acc) end in
go(l, []) in

# Check if two lists are equal #
let equal: ([Int], [Int]) -> Bool =
    fun p, xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => x == y && equal(xs, ys)
    | _ => false end
in

# Initialize a list with a given length using an initializer function #
let init: (Int, Int -> Int) -> [Int] =
    fun len, f ->
        let go: (Int, [Int]) -> [Int] =
        fun idx, xs ->
            if idx < len 
            then go(idx + 1, xs @ [f(idx)])   
            else xs
        in
        go(0, [])
in

# Reduce a list from the left. #
let fold_left: ((Int, Int) -> Int, Int, [Int]) -> Int =
  fun f, acc, xs ->
    case xs 
    | [] => acc
    | hd::tl => fold_left(f, f(acc, hd), tl) end in

# Reduce a list from the right. #
let fold_right: ((Int, Int) -> Int, [Int], Int) -> Int =
  fun f, xs, acc ->
    case xs
    | [] => acc
    | hd::tl => f(hd, fold_right(f, tl, acc)) end in


666
LSP: Prelude: String parsed successfully
LSP: Prelude: Info map generated successfully
Debug: true, Constrain: Types
LSP: Init: Recieved string: # Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)


















































































































































































































LSP: Init: String parsed successfully
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: >( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {go: ((?, ?) -> [?]), filter: (((Int -> Bool), [Int]) -> [Int]), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: 
  LSP: Info: ALL errors:Error in term:
  p
Nature of error: type ((Int -> Bool), [Int]) is not consistent with arrow type    
Error in term:
  p
Nature of error: Variable p is not bound    
Error in term:
  p
Nature of error: Variable p is not bound
  LSP: Info: BidiCtx: Cls: Let expression
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent: Root
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: [?]
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: :: @
  LSP: Concave: Backpack: 
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new_tokens ::= whitespace | "," | "::" | "@"
root ::= new_tokens

Top 20 Logits:

:19.8525
#:15.2032
let:14.5662
##:14.3329
 :13.1382
    :12.5319
  :12.4567
################:12.4506
   :12.3444
in:12.271
####:12.0168
/*:11.8861
```:11.8197
//:11.3663
[:11.3593
                :11.3164
end:11.2284
(:11.1685
def:11.127
        :11.0961
{:11.0282

================
# Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)




















































































































































































































LSP: Prelude: Recieved string: ### List ###

# Add an element to the front of a list. #
let cons: (Int, [Int]) -> [Int] = fun x, xs -> x::xs in

# Determine the length of a list. #
let length: [Int] -> Int =
  fun xs ->
    case xs
    | [] => 0
    | _::xs => 1 + length(xs) end in

# Extract the first element of a list. #
let hd: [Int] -> Option =
  fun l ->
    case l
    | [] => None
    | x::xs => Some(x) end in

# Extract the rest of the list. #
let tl: [Int] -> [Int] =
  fun l ->
    case l
    | [] => []
    | x::xs => xs end in

# Determine if a list is empty. #
let is_empty: [Int] -> Bool =
  fun xs ->
    case xs
    | [] => true
    | _::_ => false end in

# Return the element at the index. #
let nth: ([Int], Int) -> Option =
  fun xs, n ->
    case xs, n
    | x::_, 0 => Some(x)
    | _::xs, n => nth(xs, n - 1)
    | [], _ => None end in

# Reverse a List. #
let rev: [Int] -> [Int] =
fun l -> 
let go: ([Int], [Int]) -> [Int] =
  fun xs, acc -> 
    case xs 
    | [] => acc 
    | x::xs => go(xs, x::acc) end in
go(l, []) in

# Check if two lists are equal #
let equal: ([Int], [Int]) -> Bool =
    fun p, xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => x == y && equal(xs, ys)
    | _ => false end
in

# Initialize a list with a given length using an initializer function #
let init: (Int, Int -> Int) -> [Int] =
    fun len, f ->
        let go: (Int, [Int]) -> [Int] =
        fun idx, xs ->
            if idx < len 
            then go(idx + 1, xs @ [f(idx)])   
            else xs
        in
        go(0, [])
in

# Reduce a list from the left. #
let fold_left: ((Int, Int) -> Int, Int, [Int]) -> Int =
  fun f, acc, xs ->
    case xs 
    | [] => acc
    | hd::tl => fold_left(f, f(acc, hd), tl) end in

# Reduce a list from the right. #
let fold_right: ((Int, Int) -> Int, [Int], Int) -> Int =
  fun f, xs, acc ->
    case xs
    | [] => acc
    | hd::tl => f(hd, fold_right(f, tl, acc)) end in


666
LSP: Prelude: String parsed successfully
LSP: Prelude: Info map generated successfully
Debug: true, Constrain: Types
LSP: Init: Recieved string: # Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)



















































































































































































































LSP: Init: String parsed successfully
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: >( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {go: ((?, ?) -> [?]), filter: (((Int -> Bool), [Int]) -> [Int]), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: 
  LSP: Info: ALL errors:Error in term:
  p
Nature of error: Variable p is not bound    
Error in term:
  p
Nature of error: type ((Int -> Bool), [Int]) is not consistent with arrow type    
Error in term:
  p
Nature of error: Variable p is not bound
  LSP: Info: BidiCtx: Cls: Let expression
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent: Root
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: [?]
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: :: @
  LSP: Concave: Backpack: 
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new_tokens ::= whitespace | "," | "::" | "@"
root ::= new_tokens

Top 20 Logits:

:19.8627
#:15.2012
let:14.5639
##:14.3637
 :13.1415
    :12.5324
################:12.474
  :12.4597
   :12.3435
in:12.2039
####:12.0437
/*:11.8832
```:11.8301
[:11.3726
//:11.3632
                :11.3113
end:11.2052
(:11.1774
def:11.124
        :11.0968
{:11.0334

================
# Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)





















































































































































































































LSP: Prelude: Recieved string: ### List ###

# Add an element to the front of a list. #
let cons: (Int, [Int]) -> [Int] = fun x, xs -> x::xs in

# Determine the length of a list. #
let length: [Int] -> Int =
  fun xs ->
    case xs
    | [] => 0
    | _::xs => 1 + length(xs) end in

# Extract the first element of a list. #
let hd: [Int] -> Option =
  fun l ->
    case l
    | [] => None
    | x::xs => Some(x) end in

# Extract the rest of the list. #
let tl: [Int] -> [Int] =
  fun l ->
    case l
    | [] => []
    | x::xs => xs end in

# Determine if a list is empty. #
let is_empty: [Int] -> Bool =
  fun xs ->
    case xs
    | [] => true
    | _::_ => false end in

# Return the element at the index. #
let nth: ([Int], Int) -> Option =
  fun xs, n ->
    case xs, n
    | x::_, 0 => Some(x)
    | _::xs, n => nth(xs, n - 1)
    | [], _ => None end in

# Reverse a List. #
let rev: [Int] -> [Int] =
fun l -> 
let go: ([Int], [Int]) -> [Int] =
  fun xs, acc -> 
    case xs 
    | [] => acc 
    | x::xs => go(xs, x::acc) end in
go(l, []) in

# Check if two lists are equal #
let equal: ([Int], [Int]) -> Bool =
    fun p, xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => x == y && equal(xs, ys)
    | _ => false end
in

# Initialize a list with a given length using an initializer function #
let init: (Int, Int -> Int) -> [Int] =
    fun len, f ->
        let go: (Int, [Int]) -> [Int] =
        fun idx, xs ->
            if idx < len 
            then go(idx + 1, xs @ [f(idx)])   
            else xs
        in
        go(0, [])
in

# Reduce a list from the left. #
let fold_left: ((Int, Int) -> Int, Int, [Int]) -> Int =
  fun f, acc, xs ->
    case xs 
    | [] => acc
    | hd::tl => fold_left(f, f(acc, hd), tl) end in

# Reduce a list from the right. #
let fold_right: ((Int, Int) -> Int, [Int], Int) -> Int =
  fun f, xs, acc ->
    case xs
    | [] => acc
    | hd::tl => f(hd, fold_right(f, tl, acc)) end in


666
LSP: Prelude: String parsed successfully
LSP: Prelude: Info map generated successfully
Debug: true, Constrain: Types
LSP: Init: Recieved string: # Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)




















































































































































































































LSP: Init: String parsed successfully
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: >( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {go: ((?, ?) -> [?]), filter: (((Int -> Bool), [Int]) -> [Int]), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: 
  LSP: Info: ALL errors:Error in term:
  p
Nature of error: Variable p is not bound    
Error in term:
  p
Nature of error: type ((Int -> Bool), [Int]) is not consistent with arrow type    
Error in term:
  p
Nature of error: Variable p is not bound
  LSP: Info: BidiCtx: Cls: Let expression
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent: Root
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: [?]
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: :: @
  LSP: Concave: Backpack: 
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new_tokens ::= whitespace | "," | "::" | "@"
root ::= new_tokens

Top 20 Logits:

:19.8755
#:15.1952
let:14.5579
##:14.392
 :13.1437
    :12.5315
################:12.4941
  :12.4668
   :12.339
in:12.1753
####:12.0689
/*:11.8762
```:11.8461
[:11.3868
//:11.3563
                :11.3102
end:11.1978
(:11.1845
def:11.1257
        :11.0998
{:11.0349

================
# Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)






















































































































































































































LSP: Prelude: Recieved string: ### List ###

# Add an element to the front of a list. #
let cons: (Int, [Int]) -> [Int] = fun x, xs -> x::xs in

# Determine the length of a list. #
let length: [Int] -> Int =
  fun xs ->
    case xs
    | [] => 0
    | _::xs => 1 + length(xs) end in

# Extract the first element of a list. #
let hd: [Int] -> Option =
  fun l ->
    case l
    | [] => None
    | x::xs => Some(x) end in

# Extract the rest of the list. #
let tl: [Int] -> [Int] =
  fun l ->
    case l
    | [] => []
    | x::xs => xs end in

# Determine if a list is empty. #
let is_empty: [Int] -> Bool =
  fun xs ->
    case xs
    | [] => true
    | _::_ => false end in

# Return the element at the index. #
let nth: ([Int], Int) -> Option =
  fun xs, n ->
    case xs, n
    | x::_, 0 => Some(x)
    | _::xs, n => nth(xs, n - 1)
    | [], _ => None end in

# Reverse a List. #
let rev: [Int] -> [Int] =
fun l -> 
let go: ([Int], [Int]) -> [Int] =
  fun xs, acc -> 
    case xs 
    | [] => acc 
    | x::xs => go(xs, x::acc) end in
go(l, []) in

# Check if two lists are equal #
let equal: ([Int], [Int]) -> Bool =
    fun p, xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => x == y && equal(xs, ys)
    | _ => false end
in

# Initialize a list with a given length using an initializer function #
let init: (Int, Int -> Int) -> [Int] =
    fun len, f ->
        let go: (Int, [Int]) -> [Int] =
        fun idx, xs ->
            if idx < len 
            then go(idx + 1, xs @ [f(idx)])   
            else xs
        in
        go(0, [])
in

# Reduce a list from the left. #
let fold_left: ((Int, Int) -> Int, Int, [Int]) -> Int =
  fun f, acc, xs ->
    case xs 
    | [] => acc
    | hd::tl => fold_left(f, f(acc, hd), tl) end in

# Reduce a list from the right. #
let fold_right: ((Int, Int) -> Int, [Int], Int) -> Int =
  fun f, xs, acc ->
    case xs
    | [] => acc
    | hd::tl => f(hd, fold_right(f, tl, acc)) end in


666
LSP: Prelude: String parsed successfully
LSP: Prelude: Info map generated successfully
Debug: true, Constrain: Types
LSP: Init: Recieved string: # Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)





















































































































































































































LSP: Init: String parsed successfully
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: >( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {go: ((?, ?) -> [?]), filter: (((Int -> Bool), [Int]) -> [Int]), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: 
  LSP: Info: ALL errors:Error in term:
  p
Nature of error: Variable p is not bound    
Error in term:
  p
Nature of error: Variable p is not bound    
Error in term:
  p
Nature of error: type ((Int -> Bool), [Int]) is not consistent with arrow type
  LSP: Info: BidiCtx: Cls: Let expression
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent: Root
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: [?]
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: :: @
  LSP: Concave: Backpack: 
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new_tokens ::= whitespace | "," | "::" | "@"
root ::= new_tokens

Top 20 Logits:

:19.8877
#:15.1861
let:14.5518
##:14.4028
 :13.1436
    :12.5325
################:12.5034
  :12.4776
   :12.3308
in:12.1968
####:12.081
/*:11.8694
```:11.8597
[:11.3946
//:11.3493
                :11.3143
end:11.2084
(:11.1851
def:11.1313
        :11.1058
{:11.0331

================
# Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)























































































































































































































LSP: Prelude: Recieved string: ### List ###

# Add an element to the front of a list. #
let cons: (Int, [Int]) -> [Int] = fun x, xs -> x::xs in

# Determine the length of a list. #
let length: [Int] -> Int =
  fun xs ->
    case xs
    | [] => 0
    | _::xs => 1 + length(xs) end in

# Extract the first element of a list. #
let hd: [Int] -> Option =
  fun l ->
    case l
    | [] => None
    | x::xs => Some(x) end in

# Extract the rest of the list. #
let tl: [Int] -> [Int] =
  fun l ->
    case l
    | [] => []
    | x::xs => xs end in

# Determine if a list is empty. #
let is_empty: [Int] -> Bool =
  fun xs ->
    case xs
    | [] => true
    | _::_ => false end in

# Return the element at the index. #
let nth: ([Int], Int) -> Option =
  fun xs, n ->
    case xs, n
    | x::_, 0 => Some(x)
    | _::xs, n => nth(xs, n - 1)
    | [], _ => None end in

# Reverse a List. #
let rev: [Int] -> [Int] =
fun l -> 
let go: ([Int], [Int]) -> [Int] =
  fun xs, acc -> 
    case xs 
    | [] => acc 
    | x::xs => go(xs, x::acc) end in
go(l, []) in

# Check if two lists are equal #
let equal: ([Int], [Int]) -> Bool =
    fun p, xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => x == y && equal(xs, ys)
    | _ => false end
in

# Initialize a list with a given length using an initializer function #
let init: (Int, Int -> Int) -> [Int] =
    fun len, f ->
        let go: (Int, [Int]) -> [Int] =
        fun idx, xs ->
            if idx < len 
            then go(idx + 1, xs @ [f(idx)])   
            else xs
        in
        go(0, [])
in

# Reduce a list from the left. #
let fold_left: ((Int, Int) -> Int, Int, [Int]) -> Int =
  fun f, acc, xs ->
    case xs 
    | [] => acc
    | hd::tl => fold_left(f, f(acc, hd), tl) end in

# Reduce a list from the right. #
let fold_right: ((Int, Int) -> Int, [Int], Int) -> Int =
  fun f, xs, acc ->
    case xs
    | [] => acc
    | hd::tl => f(hd, fold_right(f, tl, acc)) end in


666
LSP: Prelude: String parsed successfully
LSP: Prelude: Info map generated successfully
Debug: true, Constrain: Types
LSP: Init: Recieved string: # Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)






















































































































































































































LSP: Init: String parsed successfully
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: >( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {go: ((?, ?) -> [?]), filter: (((Int -> Bool), [Int]) -> [Int]), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: 
  LSP: Info: ALL errors:Error in term:
  p
Nature of error: type ((Int -> Bool), [Int]) is not consistent with arrow type    
Error in term:
  p
Nature of error: Variable p is not bound    
Error in term:
  p
Nature of error: Variable p is not bound
  LSP: Info: BidiCtx: Cls: Let expression
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent: Root
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: [?]
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: :: @
  LSP: Concave: Backpack: 
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new_tokens ::= whitespace | "," | "::" | "@"
root ::= new_tokens

Top 20 Logits:

:19.8964
#:15.1767
let:14.5489
##:14.3922
 :13.1417
    :12.5351
################:12.5017
  :12.4866
   :12.3211
in:12.2475
####:12.0788
/*:11.8668
```:11.8633
[:11.3955
//:11.3466
                :11.3199
end:11.2269
(:11.1812
def:11.134
        :11.1112
{:11.0327

================
# Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)
























































































































































































































LSP: Prelude: Recieved string: ### List ###

# Add an element to the front of a list. #
let cons: (Int, [Int]) -> [Int] = fun x, xs -> x::xs in

# Determine the length of a list. #
let length: [Int] -> Int =
  fun xs ->
    case xs
    | [] => 0
    | _::xs => 1 + length(xs) end in

# Extract the first element of a list. #
let hd: [Int] -> Option =
  fun l ->
    case l
    | [] => None
    | x::xs => Some(x) end in

# Extract the rest of the list. #
let tl: [Int] -> [Int] =
  fun l ->
    case l
    | [] => []
    | x::xs => xs end in

# Determine if a list is empty. #
let is_empty: [Int] -> Bool =
  fun xs ->
    case xs
    | [] => true
    | _::_ => false end in

# Return the element at the index. #
let nth: ([Int], Int) -> Option =
  fun xs, n ->
    case xs, n
    | x::_, 0 => Some(x)
    | _::xs, n => nth(xs, n - 1)
    | [], _ => None end in

# Reverse a List. #
let rev: [Int] -> [Int] =
fun l -> 
let go: ([Int], [Int]) -> [Int] =
  fun xs, acc -> 
    case xs 
    | [] => acc 
    | x::xs => go(xs, x::acc) end in
go(l, []) in

# Check if two lists are equal #
let equal: ([Int], [Int]) -> Bool =
    fun p, xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => x == y && equal(xs, ys)
    | _ => false end
in

# Initialize a list with a given length using an initializer function #
let init: (Int, Int -> Int) -> [Int] =
    fun len, f ->
        let go: (Int, [Int]) -> [Int] =
        fun idx, xs ->
            if idx < len 
            then go(idx + 1, xs @ [f(idx)])   
            else xs
        in
        go(0, [])
in

# Reduce a list from the left. #
let fold_left: ((Int, Int) -> Int, Int, [Int]) -> Int =
  fun f, acc, xs ->
    case xs 
    | [] => acc
    | hd::tl => fold_left(f, f(acc, hd), tl) end in

# Reduce a list from the right. #
let fold_right: ((Int, Int) -> Int, [Int], Int) -> Int =
  fun f, xs, acc ->
    case xs
    | [] => acc
    | hd::tl => f(hd, fold_right(f, tl, acc)) end in


666
LSP: Prelude: String parsed successfully
LSP: Prelude: Info map generated successfully
Debug: true, Constrain: Types
LSP: Init: Recieved string: # Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)























































































































































































































LSP: Init: String parsed successfully
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: >( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {go: ((?, ?) -> [?]), filter: (((Int -> Bool), [Int]) -> [Int]), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: 
  LSP: Info: ALL errors:Error in term:
  p
Nature of error: Variable p is not bound    
Error in term:
  p
Nature of error: type ((Int -> Bool), [Int]) is not consistent with arrow type    
Error in term:
  p
Nature of error: Variable p is not bound
  LSP: Info: BidiCtx: Cls: Let expression
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent: Root
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: [?]
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: :: @
  LSP: Concave: Backpack: 
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new_tokens ::= whitespace | "," | "::" | "@"
root ::= new_tokens

Top 20 Logits:

:19.9004
#:15.1715
let:14.5541
##:14.3692
 :13.139
    :12.5362
################:12.4924
  :12.4891
   :12.3129
in:12.2826
####:12.0689
/*:11.8695
```:11.8556
[:11.3971
//:11.3486
                :11.3215
end:11.2356
(:11.1784
def:11.1294
        :11.1105
{:11.0392

================
# Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)

























































































































































































































LSP: Prelude: Recieved string: ### List ###

# Add an element to the front of a list. #
let cons: (Int, [Int]) -> [Int] = fun x, xs -> x::xs in

# Determine the length of a list. #
let length: [Int] -> Int =
  fun xs ->
    case xs
    | [] => 0
    | _::xs => 1 + length(xs) end in

# Extract the first element of a list. #
let hd: [Int] -> Option =
  fun l ->
    case l
    | [] => None
    | x::xs => Some(x) end in

# Extract the rest of the list. #
let tl: [Int] -> [Int] =
  fun l ->
    case l
    | [] => []
    | x::xs => xs end in

# Determine if a list is empty. #
let is_empty: [Int] -> Bool =
  fun xs ->
    case xs
    | [] => true
    | _::_ => false end in

# Return the element at the index. #
let nth: ([Int], Int) -> Option =
  fun xs, n ->
    case xs, n
    | x::_, 0 => Some(x)
    | _::xs, n => nth(xs, n - 1)
    | [], _ => None end in

# Reverse a List. #
let rev: [Int] -> [Int] =
fun l -> 
let go: ([Int], [Int]) -> [Int] =
  fun xs, acc -> 
    case xs 
    | [] => acc 
    | x::xs => go(xs, x::acc) end in
go(l, []) in

# Check if two lists are equal #
let equal: ([Int], [Int]) -> Bool =
    fun p, xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => x == y && equal(xs, ys)
    | _ => false end
in

# Initialize a list with a given length using an initializer function #
let init: (Int, Int -> Int) -> [Int] =
    fun len, f ->
        let go: (Int, [Int]) -> [Int] =
        fun idx, xs ->
            if idx < len 
            then go(idx + 1, xs @ [f(idx)])   
            else xs
        in
        go(0, [])
in

# Reduce a list from the left. #
let fold_left: ((Int, Int) -> Int, Int, [Int]) -> Int =
  fun f, acc, xs ->
    case xs 
    | [] => acc
    | hd::tl => fold_left(f, f(acc, hd), tl) end in

# Reduce a list from the right. #
let fold_right: ((Int, Int) -> Int, [Int], Int) -> Int =
  fun f, xs, acc ->
    case xs
    | [] => acc
    | hd::tl => f(hd, fold_right(f, tl, acc)) end in


666
LSP: Prelude: String parsed successfully
LSP: Prelude: Info map generated successfully
Debug: true, Constrain: Types
LSP: Init: Recieved string: # Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)
























































































































































































































LSP: Init: String parsed successfully
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: >( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {go: ((?, ?) -> [?]), filter: (((Int -> Bool), [Int]) -> [Int]), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: 
  LSP: Info: ALL errors:Error in term:
  p
Nature of error: type ((Int -> Bool), [Int]) is not consistent with arrow type    
Error in term:
  p
Nature of error: Variable p is not bound    
Error in term:
  p
Nature of error: Variable p is not bound
  LSP: Info: BidiCtx: Cls: Let expression
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent: Root
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: [?]
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: :: @
  LSP: Concave: Backpack: 
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new_tokens ::= whitespace | "," | "::" | "@"
root ::= new_tokens

Top 20 Logits:

:19.9027
#:15.1739
let:14.5646
##:14.3492
 :13.1353
    :12.5332
################:12.4832
  :12.4831
   :12.3058
in:12.2698
####:12.0617
/*:11.874
```:11.845
[:11.4057
//:11.3529
                :11.3168
end:11.2196
(:11.1817
def:11.1188
        :11.1036
{:11.0512

================
# Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)


























































































































































































































LSP: Prelude: Recieved string: ### List ###

# Add an element to the front of a list. #
let cons: (Int, [Int]) -> [Int] = fun x, xs -> x::xs in

# Determine the length of a list. #
let length: [Int] -> Int =
  fun xs ->
    case xs
    | [] => 0
    | _::xs => 1 + length(xs) end in

# Extract the first element of a list. #
let hd: [Int] -> Option =
  fun l ->
    case l
    | [] => None
    | x::xs => Some(x) end in

# Extract the rest of the list. #
let tl: [Int] -> [Int] =
  fun l ->
    case l
    | [] => []
    | x::xs => xs end in

# Determine if a list is empty. #
let is_empty: [Int] -> Bool =
  fun xs ->
    case xs
    | [] => true
    | _::_ => false end in

# Return the element at the index. #
let nth: ([Int], Int) -> Option =
  fun xs, n ->
    case xs, n
    | x::_, 0 => Some(x)
    | _::xs, n => nth(xs, n - 1)
    | [], _ => None end in

# Reverse a List. #
let rev: [Int] -> [Int] =
fun l -> 
let go: ([Int], [Int]) -> [Int] =
  fun xs, acc -> 
    case xs 
    | [] => acc 
    | x::xs => go(xs, x::acc) end in
go(l, []) in

# Check if two lists are equal #
let equal: ([Int], [Int]) -> Bool =
    fun p, xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => x == y && equal(xs, ys)
    | _ => false end
in

# Initialize a list with a given length using an initializer function #
let init: (Int, Int -> Int) -> [Int] =
    fun len, f ->
        let go: (Int, [Int]) -> [Int] =
        fun idx, xs ->
            if idx < len 
            then go(idx + 1, xs @ [f(idx)])   
            else xs
        in
        go(0, [])
in

# Reduce a list from the left. #
let fold_left: ((Int, Int) -> Int, Int, [Int]) -> Int =
  fun f, acc, xs ->
    case xs 
    | [] => acc
    | hd::tl => fold_left(f, f(acc, hd), tl) end in

# Reduce a list from the right. #
let fold_right: ((Int, Int) -> Int, [Int], Int) -> Int =
  fun f, xs, acc ->
    case xs
    | [] => acc
    | hd::tl => f(hd, fold_right(f, tl, acc)) end in


666
LSP: Prelude: String parsed successfully
LSP: Prelude: Info map generated successfully
Debug: true, Constrain: Types
LSP: Init: Recieved string: # Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)

























































































































































































































LSP: Init: String parsed successfully
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: >( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {go: ((?, ?) -> [?]), filter: (((Int -> Bool), [Int]) -> [Int]), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: 
  LSP: Info: ALL errors:Error in term:
  p
Nature of error: Variable p is not bound    
Error in term:
  p
Nature of error: Variable p is not bound    
Error in term:
  p
Nature of error: type ((Int -> Bool), [Int]) is not consistent with arrow type
  LSP: Info: BidiCtx: Cls: Let expression
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent: Root
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: [?]
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: :: @
  LSP: Concave: Backpack: 
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new_tokens ::= whitespace | "," | "::" | "@"
root ::= new_tokens

Top 20 Logits:

:19.9087
#:15.1812
let:14.5737
##:14.3455
 :13.1302
    :12.5263
################:12.4808
  :12.4706
   :12.2982
in:12.2147
####:12.0652
/*:11.8748
```:11.8427
[:11.4212
//:11.3563
                :11.3073
(:11.1885
end:11.1823
def:11.1062
        :11.0947
{:11.0622

================
# Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)



























































































































































































































LSP: Prelude: Recieved string: ### List ###

# Add an element to the front of a list. #
let cons: (Int, [Int]) -> [Int] = fun x, xs -> x::xs in

# Determine the length of a list. #
let length: [Int] -> Int =
  fun xs ->
    case xs
    | [] => 0
    | _::xs => 1 + length(xs) end in

# Extract the first element of a list. #
let hd: [Int] -> Option =
  fun l ->
    case l
    | [] => None
    | x::xs => Some(x) end in

# Extract the rest of the list. #
let tl: [Int] -> [Int] =
  fun l ->
    case l
    | [] => []
    | x::xs => xs end in

# Determine if a list is empty. #
let is_empty: [Int] -> Bool =
  fun xs ->
    case xs
    | [] => true
    | _::_ => false end in

# Return the element at the index. #
let nth: ([Int], Int) -> Option =
  fun xs, n ->
    case xs, n
    | x::_, 0 => Some(x)
    | _::xs, n => nth(xs, n - 1)
    | [], _ => None end in

# Reverse a List. #
let rev: [Int] -> [Int] =
fun l -> 
let go: ([Int], [Int]) -> [Int] =
  fun xs, acc -> 
    case xs 
    | [] => acc 
    | x::xs => go(xs, x::acc) end in
go(l, []) in

# Check if two lists are equal #
let equal: ([Int], [Int]) -> Bool =
    fun p, xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => x == y && equal(xs, ys)
    | _ => false end
in

# Initialize a list with a given length using an initializer function #
let init: (Int, Int -> Int) -> [Int] =
    fun len, f ->
        let go: (Int, [Int]) -> [Int] =
        fun idx, xs ->
            if idx < len 
            then go(idx + 1, xs @ [f(idx)])   
            else xs
        in
        go(0, [])
in

# Reduce a list from the left. #
let fold_left: ((Int, Int) -> Int, Int, [Int]) -> Int =
  fun f, acc, xs ->
    case xs 
    | [] => acc
    | hd::tl => fold_left(f, f(acc, hd), tl) end in

# Reduce a list from the right. #
let fold_right: ((Int, Int) -> Int, [Int], Int) -> Int =
  fun f, xs, acc ->
    case xs
    | [] => acc
    | hd::tl => f(hd, fold_right(f, tl, acc)) end in


666
LSP: Prelude: String parsed successfully
LSP: Prelude: Info map generated successfully
Debug: true, Constrain: Types
LSP: Init: Recieved string: # Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)


























































































































































































































LSP: Init: String parsed successfully
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: >( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {go: ((?, ?) -> [?]), filter: (((Int -> Bool), [Int]) -> [Int]), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: 
  LSP: Info: ALL errors:Error in term:
  p
Nature of error: Variable p is not bound    
Error in term:
  p
Nature of error: type ((Int -> Bool), [Int]) is not consistent with arrow type    
Error in term:
  p
Nature of error: Variable p is not bound
  LSP: Info: BidiCtx: Cls: Let expression
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent: Root
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: [?]
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: :: @
  LSP: Concave: Backpack: 
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new_tokens ::= whitespace | "," | "::" | "@"
root ::= new_tokens

Top 20 Logits:

:19.9194
#:15.188
let:14.5774
##:14.3594
 :13.1251
    :12.5179
################:12.4854
  :12.4572
   :12.2916
in:12.1502
####:12.0791
/*:11.8683
```:11.852
[:11.4378
//:11.355
                :11.2977
(:11.1915
end:11.1436
def:11.0999
        :11.0886
{:11.0684

================
# Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)




























































































































































































































LSP: Prelude: Recieved string: ### List ###

# Add an element to the front of a list. #
let cons: (Int, [Int]) -> [Int] = fun x, xs -> x::xs in

# Determine the length of a list. #
let length: [Int] -> Int =
  fun xs ->
    case xs
    | [] => 0
    | _::xs => 1 + length(xs) end in

# Extract the first element of a list. #
let hd: [Int] -> Option =
  fun l ->
    case l
    | [] => None
    | x::xs => Some(x) end in

# Extract the rest of the list. #
let tl: [Int] -> [Int] =
  fun l ->
    case l
    | [] => []
    | x::xs => xs end in

# Determine if a list is empty. #
let is_empty: [Int] -> Bool =
  fun xs ->
    case xs
    | [] => true
    | _::_ => false end in

# Return the element at the index. #
let nth: ([Int], Int) -> Option =
  fun xs, n ->
    case xs, n
    | x::_, 0 => Some(x)
    | _::xs, n => nth(xs, n - 1)
    | [], _ => None end in

# Reverse a List. #
let rev: [Int] -> [Int] =
fun l -> 
let go: ([Int], [Int]) -> [Int] =
  fun xs, acc -> 
    case xs 
    | [] => acc 
    | x::xs => go(xs, x::acc) end in
go(l, []) in

# Check if two lists are equal #
let equal: ([Int], [Int]) -> Bool =
    fun p, xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => x == y && equal(xs, ys)
    | _ => false end
in

# Initialize a list with a given length using an initializer function #
let init: (Int, Int -> Int) -> [Int] =
    fun len, f ->
        let go: (Int, [Int]) -> [Int] =
        fun idx, xs ->
            if idx < len 
            then go(idx + 1, xs @ [f(idx)])   
            else xs
        in
        go(0, [])
in

# Reduce a list from the left. #
let fold_left: ((Int, Int) -> Int, Int, [Int]) -> Int =
  fun f, acc, xs ->
    case xs 
    | [] => acc
    | hd::tl => fold_left(f, f(acc, hd), tl) end in

# Reduce a list from the right. #
let fold_right: ((Int, Int) -> Int, [Int], Int) -> Int =
  fun f, xs, acc ->
    case xs
    | [] => acc
    | hd::tl => f(hd, fold_right(f, tl, acc)) end in


666
LSP: Prelude: String parsed successfully
LSP: Prelude: Info map generated successfully
Debug: true, Constrain: Types
LSP: Init: Recieved string: # Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)



























































































































































































































LSP: Init: String parsed successfully
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: >( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {go: ((?, ?) -> [?]), filter: (((Int -> Bool), [Int]) -> [Int]), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: 
  LSP: Info: ALL errors:Error in term:
  p
Nature of error: Variable p is not bound    
Error in term:
  p
Nature of error: Variable p is not bound    
Error in term:
  p
Nature of error: type ((Int -> Bool), [Int]) is not consistent with arrow type
  LSP: Info: BidiCtx: Cls: Let expression
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent: Root
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: [?]
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: :: @
  LSP: Concave: Backpack: 
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new_tokens ::= whitespace | "," | "::" | "@"
root ::= new_tokens

Top 20 Logits:

:19.933
#:15.189
let:14.5756
##:14.3787
 :13.1225
    :12.5134
################:12.4933
  :12.4505
   :12.2885
in:12.1093
####:12.0941
```:11.8655
/*:11.8557
[:11.4458
//:11.3469
                :11.2926
(:11.1856
end:11.1227
def:11.1076
        :11.0884
{:11.0662

================
# Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)





























































































































































































































LSP: Prelude: Recieved string: ### List ###

# Add an element to the front of a list. #
let cons: (Int, [Int]) -> [Int] = fun x, xs -> x::xs in

# Determine the length of a list. #
let length: [Int] -> Int =
  fun xs ->
    case xs
    | [] => 0
    | _::xs => 1 + length(xs) end in

# Extract the first element of a list. #
let hd: [Int] -> Option =
  fun l ->
    case l
    | [] => None
    | x::xs => Some(x) end in

# Extract the rest of the list. #
let tl: [Int] -> [Int] =
  fun l ->
    case l
    | [] => []
    | x::xs => xs end in

# Determine if a list is empty. #
let is_empty: [Int] -> Bool =
  fun xs ->
    case xs
    | [] => true
    | _::_ => false end in

# Return the element at the index. #
let nth: ([Int], Int) -> Option =
  fun xs, n ->
    case xs, n
    | x::_, 0 => Some(x)
    | _::xs, n => nth(xs, n - 1)
    | [], _ => None end in

# Reverse a List. #
let rev: [Int] -> [Int] =
fun l -> 
let go: ([Int], [Int]) -> [Int] =
  fun xs, acc -> 
    case xs 
    | [] => acc 
    | x::xs => go(xs, x::acc) end in
go(l, []) in

# Check if two lists are equal #
let equal: ([Int], [Int]) -> Bool =
    fun p, xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => x == y && equal(xs, ys)
    | _ => false end
in

# Initialize a list with a given length using an initializer function #
let init: (Int, Int -> Int) -> [Int] =
    fun len, f ->
        let go: (Int, [Int]) -> [Int] =
        fun idx, xs ->
            if idx < len 
            then go(idx + 1, xs @ [f(idx)])   
            else xs
        in
        go(0, [])
in

# Reduce a list from the left. #
let fold_left: ((Int, Int) -> Int, Int, [Int]) -> Int =
  fun f, acc, xs ->
    case xs 
    | [] => acc
    | hd::tl => fold_left(f, f(acc, hd), tl) end in

# Reduce a list from the right. #
let fold_right: ((Int, Int) -> Int, [Int], Int) -> Int =
  fun f, xs, acc ->
    case xs
    | [] => acc
    | hd::tl => f(hd, fold_right(f, tl, acc)) end in


666
LSP: Prelude: String parsed successfully
LSP: Prelude: Info map generated successfully
Debug: true, Constrain: Types
LSP: Init: Recieved string: # Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)




























































































































































































































LSP: Init: String parsed successfully
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: >( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {go: ((?, ?) -> [?]), filter: (((Int -> Bool), [Int]) -> [Int]), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: 
  LSP: Info: ALL errors:Error in term:
  p
Nature of error: Variable p is not bound    
Error in term:
  p
Nature of error: type ((Int -> Bool), [Int]) is not consistent with arrow type    
Error in term:
  p
Nature of error: Variable p is not bound
  LSP: Info: BidiCtx: Cls: Let expression
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent: Root
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: [?]
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: :: @
  LSP: Concave: Backpack: 
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new_tokens ::= whitespace | "," | "::" | "@"
root ::= new_tokens

Top 20 Logits:

:19.9454
#:15.1832
let:14.5696
##:14.3912
 :13.1229
    :12.5173
################:12.5005
  :12.4533
   :12.289
in:12.1075
####:12.1028
```:11.8741
/*:11.845
[:11.4414
//:11.3367
                :11.2923
(:11.1733
def:11.1261
end:11.1245
        :11.0938
{:11.0579

================
# Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)






























































































































































































































LSP: Prelude: Recieved string: ### List ###

# Add an element to the front of a list. #
let cons: (Int, [Int]) -> [Int] = fun x, xs -> x::xs in

# Determine the length of a list. #
let length: [Int] -> Int =
  fun xs ->
    case xs
    | [] => 0
    | _::xs => 1 + length(xs) end in

# Extract the first element of a list. #
let hd: [Int] -> Option =
  fun l ->
    case l
    | [] => None
    | x::xs => Some(x) end in

# Extract the rest of the list. #
let tl: [Int] -> [Int] =
  fun l ->
    case l
    | [] => []
    | x::xs => xs end in

# Determine if a list is empty. #
let is_empty: [Int] -> Bool =
  fun xs ->
    case xs
    | [] => true
    | _::_ => false end in

# Return the element at the index. #
let nth: ([Int], Int) -> Option =
  fun xs, n ->
    case xs, n
    | x::_, 0 => Some(x)
    | _::xs, n => nth(xs, n - 1)
    | [], _ => None end in

# Reverse a List. #
let rev: [Int] -> [Int] =
fun l -> 
let go: ([Int], [Int]) -> [Int] =
  fun xs, acc -> 
    case xs 
    | [] => acc 
    | x::xs => go(xs, x::acc) end in
go(l, []) in

# Check if two lists are equal #
let equal: ([Int], [Int]) -> Bool =
    fun p, xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => x == y && equal(xs, ys)
    | _ => false end
in

# Initialize a list with a given length using an initializer function #
let init: (Int, Int -> Int) -> [Int] =
    fun len, f ->
        let go: (Int, [Int]) -> [Int] =
        fun idx, xs ->
            if idx < len 
            then go(idx + 1, xs @ [f(idx)])   
            else xs
        in
        go(0, [])
in

# Reduce a list from the left. #
let fold_left: ((Int, Int) -> Int, Int, [Int]) -> Int =
  fun f, acc, xs ->
    case xs 
    | [] => acc
    | hd::tl => fold_left(f, f(acc, hd), tl) end in

# Reduce a list from the right. #
let fold_right: ((Int, Int) -> Int, [Int], Int) -> Int =
  fun f, xs, acc ->
    case xs
    | [] => acc
    | hd::tl => f(hd, fold_right(f, tl, acc)) end in


666
LSP: Prelude: String parsed successfully
LSP: Prelude: Info map generated successfully
Debug: true, Constrain: Types
LSP: Init: Recieved string: # Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)





























































































































































































































LSP: Init: String parsed successfully
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: >( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {go: ((?, ?) -> [?]), filter: (((Int -> Bool), [Int]) -> [Int]), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: 
  LSP: Info: ALL errors:Error in term:
  p
Nature of error: Variable p is not bound    
Error in term:
  p
Nature of error: Variable p is not bound    
Error in term:
  p
Nature of error: type ((Int -> Bool), [Int]) is not consistent with arrow type
  LSP: Info: BidiCtx: Cls: Let expression
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent: Root
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: [?]
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: :: @
  LSP: Concave: Backpack: 
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new_tokens ::= whitespace | "," | "::" | "@"
root ::= new_tokens

Top 20 Logits:

:19.9532
#:15.1748
let:14.5627
##:14.3912
 :13.1238
    :12.528
################:12.5026
  :12.4602
   :12.2897
in:12.1355
####:12.1029
```:11.8724
/*:11.8427
[:11.4296
//:11.3304
                :11.2927
(:11.1623
def:11.1449
end:11.1392
        :11.1007
{:11.0505

================
# Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)































































































































































































































LSP: Prelude: Recieved string: ### List ###

# Add an element to the front of a list. #
let cons: (Int, [Int]) -> [Int] = fun x, xs -> x::xs in

# Determine the length of a list. #
let length: [Int] -> Int =
  fun xs ->
    case xs
    | [] => 0
    | _::xs => 1 + length(xs) end in

# Extract the first element of a list. #
let hd: [Int] -> Option =
  fun l ->
    case l
    | [] => None
    | x::xs => Some(x) end in

# Extract the rest of the list. #
let tl: [Int] -> [Int] =
  fun l ->
    case l
    | [] => []
    | x::xs => xs end in

# Determine if a list is empty. #
let is_empty: [Int] -> Bool =
  fun xs ->
    case xs
    | [] => true
    | _::_ => false end in

# Return the element at the index. #
let nth: ([Int], Int) -> Option =
  fun xs, n ->
    case xs, n
    | x::_, 0 => Some(x)
    | _::xs, n => nth(xs, n - 1)
    | [], _ => None end in

# Reverse a List. #
let rev: [Int] -> [Int] =
fun l -> 
let go: ([Int], [Int]) -> [Int] =
  fun xs, acc -> 
    case xs 
    | [] => acc 
    | x::xs => go(xs, x::acc) end in
go(l, []) in

# Check if two lists are equal #
let equal: ([Int], [Int]) -> Bool =
    fun p, xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => x == y && equal(xs, ys)
    | _ => false end
in

# Initialize a list with a given length using an initializer function #
let init: (Int, Int -> Int) -> [Int] =
    fun len, f ->
        let go: (Int, [Int]) -> [Int] =
        fun idx, xs ->
            if idx < len 
            then go(idx + 1, xs @ [f(idx)])   
            else xs
        in
        go(0, [])
in

# Reduce a list from the left. #
let fold_left: ((Int, Int) -> Int, Int, [Int]) -> Int =
  fun f, acc, xs ->
    case xs 
    | [] => acc
    | hd::tl => fold_left(f, f(acc, hd), tl) end in

# Reduce a list from the right. #
let fold_right: ((Int, Int) -> Int, [Int], Int) -> Int =
  fun f, xs, acc ->
    case xs
    | [] => acc
    | hd::tl => f(hd, fold_right(f, tl, acc)) end in


666
LSP: Prelude: String parsed successfully
LSP: Prelude: Info map generated successfully
Debug: true, Constrain: Types
LSP: Init: Recieved string: # Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)






























































































































































































































LSP: Init: String parsed successfully
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: >( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {go: ((?, ?) -> [?]), filter: (((Int -> Bool), [Int]) -> [Int]), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: 
  LSP: Info: ALL errors:Error in term:
  p
Nature of error: Variable p is not bound    
Error in term:
  p
Nature of error: Variable p is not bound    
Error in term:
  p
Nature of error: type ((Int -> Bool), [Int]) is not consistent with arrow type
  LSP: Info: BidiCtx: Cls: Let expression
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent: Root
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: [?]
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: :: @
  LSP: Concave: Backpack: 
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new_tokens ::= whitespace | "," | "::" | "@"
root ::= new_tokens

Top 20 Logits:

:19.9575
#:15.1712
let:14.5586
##:14.3819
 :13.1246
    :12.5386
################:12.501
  :12.4649
   :12.2874
in:12.1703
####:12.0983
```:11.8644
/*:11.8465
[:11.4193
//:11.3293
                :11.2929
(:11.1603
def:11.1569
end:11.1535
        :11.1056
{:11.0495

================
# Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)
































































































































































































































LSP: Prelude: Recieved string: ### List ###

# Add an element to the front of a list. #
let cons: (Int, [Int]) -> [Int] = fun x, xs -> x::xs in

# Determine the length of a list. #
let length: [Int] -> Int =
  fun xs ->
    case xs
    | [] => 0
    | _::xs => 1 + length(xs) end in

# Extract the first element of a list. #
let hd: [Int] -> Option =
  fun l ->
    case l
    | [] => None
    | x::xs => Some(x) end in

# Extract the rest of the list. #
let tl: [Int] -> [Int] =
  fun l ->
    case l
    | [] => []
    | x::xs => xs end in

# Determine if a list is empty. #
let is_empty: [Int] -> Bool =
  fun xs ->
    case xs
    | [] => true
    | _::_ => false end in

# Return the element at the index. #
let nth: ([Int], Int) -> Option =
  fun xs, n ->
    case xs, n
    | x::_, 0 => Some(x)
    | _::xs, n => nth(xs, n - 1)
    | [], _ => None end in

# Reverse a List. #
let rev: [Int] -> [Int] =
fun l -> 
let go: ([Int], [Int]) -> [Int] =
  fun xs, acc -> 
    case xs 
    | [] => acc 
    | x::xs => go(xs, x::acc) end in
go(l, []) in

# Check if two lists are equal #
let equal: ([Int], [Int]) -> Bool =
    fun p, xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => x == y && equal(xs, ys)
    | _ => false end
in

# Initialize a list with a given length using an initializer function #
let init: (Int, Int -> Int) -> [Int] =
    fun len, f ->
        let go: (Int, [Int]) -> [Int] =
        fun idx, xs ->
            if idx < len 
            then go(idx + 1, xs @ [f(idx)])   
            else xs
        in
        go(0, [])
in

# Reduce a list from the left. #
let fold_left: ((Int, Int) -> Int, Int, [Int]) -> Int =
  fun f, acc, xs ->
    case xs 
    | [] => acc
    | hd::tl => fold_left(f, f(acc, hd), tl) end in

# Reduce a list from the right. #
let fold_right: ((Int, Int) -> Int, [Int], Int) -> Int =
  fun f, xs, acc ->
    case xs
    | [] => acc
    | hd::tl => f(hd, fold_right(f, tl, acc)) end in


666
LSP: Prelude: String parsed successfully
LSP: Prelude: Info map generated successfully
Debug: true, Constrain: Types
LSP: Init: Recieved string: # Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)































































































































































































































LSP: Init: String parsed successfully
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: >( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {go: ((?, ?) -> [?]), filter: (((Int -> Bool), [Int]) -> [Int]), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: 
  LSP: Info: ALL errors:Error in term:
  p
Nature of error: Variable p is not bound    
Error in term:
  p
Nature of error: Variable p is not bound    
Error in term:
  p
Nature of error: type ((Int -> Bool), [Int]) is not consistent with arrow type
  LSP: Info: BidiCtx: Cls: Let expression
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent: Root
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: [?]
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: :: @
  LSP: Concave: Backpack: 
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new_tokens ::= whitespace | "," | "::" | "@"
root ::= new_tokens

Top 20 Logits:

:19.9638
#:15.1762
let:14.5584
##:14.3741
 :13.1259
    :12.5425
################:12.5009
  :12.4644
   :12.2821
in:12.1923
####:12.0949
```:11.8589
/*:11.8514
[:11.4182
//:11.3333
                :11.2927
(:11.1676
def:11.1606
end:11.1595
        :11.1057
{:11.0554

================
# Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)

































































































































































































































LSP: Prelude: Recieved string: ### List ###

# Add an element to the front of a list. #
let cons: (Int, [Int]) -> [Int] = fun x, xs -> x::xs in

# Determine the length of a list. #
let length: [Int] -> Int =
  fun xs ->
    case xs
    | [] => 0
    | _::xs => 1 + length(xs) end in

# Extract the first element of a list. #
let hd: [Int] -> Option =
  fun l ->
    case l
    | [] => None
    | x::xs => Some(x) end in

# Extract the rest of the list. #
let tl: [Int] -> [Int] =
  fun l ->
    case l
    | [] => []
    | x::xs => xs end in

# Determine if a list is empty. #
let is_empty: [Int] -> Bool =
  fun xs ->
    case xs
    | [] => true
    | _::_ => false end in

# Return the element at the index. #
let nth: ([Int], Int) -> Option =
  fun xs, n ->
    case xs, n
    | x::_, 0 => Some(x)
    | _::xs, n => nth(xs, n - 1)
    | [], _ => None end in

# Reverse a List. #
let rev: [Int] -> [Int] =
fun l -> 
let go: ([Int], [Int]) -> [Int] =
  fun xs, acc -> 
    case xs 
    | [] => acc 
    | x::xs => go(xs, x::acc) end in
go(l, []) in

# Check if two lists are equal #
let equal: ([Int], [Int]) -> Bool =
    fun p, xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => x == y && equal(xs, ys)
    | _ => false end
in

# Initialize a list with a given length using an initializer function #
let init: (Int, Int -> Int) -> [Int] =
    fun len, f ->
        let go: (Int, [Int]) -> [Int] =
        fun idx, xs ->
            if idx < len 
            then go(idx + 1, xs @ [f(idx)])   
            else xs
        in
        go(0, [])
in

# Reduce a list from the left. #
let fold_left: ((Int, Int) -> Int, Int, [Int]) -> Int =
  fun f, acc, xs ->
    case xs 
    | [] => acc
    | hd::tl => fold_left(f, f(acc, hd), tl) end in

# Reduce a list from the right. #
let fold_right: ((Int, Int) -> Int, [Int], Int) -> Int =
  fun f, xs, acc ->
    case xs
    | [] => acc
    | hd::tl => f(hd, fold_right(f, tl, acc)) end in


666
LSP: Prelude: String parsed successfully
LSP: Prelude: Info map generated successfully
Debug: true, Constrain: Types
LSP: Init: Recieved string: # Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)
































































































































































































































LSP: Init: String parsed successfully
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: >( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {go: ((?, ?) -> [?]), filter: (((Int -> Bool), [Int]) -> [Int]), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: 
  LSP: Info: ALL errors:Error in term:
  p
Nature of error: type ((Int -> Bool), [Int]) is not consistent with arrow type    
Error in term:
  p
Nature of error: Variable p is not bound    
Error in term:
  p
Nature of error: Variable p is not bound
  LSP: Info: BidiCtx: Cls: Let expression
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent: Root
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: [?]
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: :: @
  LSP: Concave: Backpack: 
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new_tokens ::= whitespace | "," | "::" | "@"
root ::= new_tokens

Top 20 Logits:

:19.9749
#:15.1877
let:14.5614
##:14.3753
 :13.1273
    :12.5391
################:12.5043
  :12.4602
   :12.2767
in:12.1977
####:12.0969
```:11.8613
/*:11.8538
[:11.4284
//:11.3396
                :11.2927
(:11.1775
end:11.1572
def:11.1558
        :11.1007
{:11.0646

================
# Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)


































































































































































































































LSP: Prelude: Recieved string: ### List ###

# Add an element to the front of a list. #
let cons: (Int, [Int]) -> [Int] = fun x, xs -> x::xs in

# Determine the length of a list. #
let length: [Int] -> Int =
  fun xs ->
    case xs
    | [] => 0
    | _::xs => 1 + length(xs) end in

# Extract the first element of a list. #
let hd: [Int] -> Option =
  fun l ->
    case l
    | [] => None
    | x::xs => Some(x) end in

# Extract the rest of the list. #
let tl: [Int] -> [Int] =
  fun l ->
    case l
    | [] => []
    | x::xs => xs end in

# Determine if a list is empty. #
let is_empty: [Int] -> Bool =
  fun xs ->
    case xs
    | [] => true
    | _::_ => false end in

# Return the element at the index. #
let nth: ([Int], Int) -> Option =
  fun xs, n ->
    case xs, n
    | x::_, 0 => Some(x)
    | _::xs, n => nth(xs, n - 1)
    | [], _ => None end in

# Reverse a List. #
let rev: [Int] -> [Int] =
fun l -> 
let go: ([Int], [Int]) -> [Int] =
  fun xs, acc -> 
    case xs 
    | [] => acc 
    | x::xs => go(xs, x::acc) end in
go(l, []) in

# Check if two lists are equal #
let equal: ([Int], [Int]) -> Bool =
    fun p, xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => x == y && equal(xs, ys)
    | _ => false end
in

# Initialize a list with a given length using an initializer function #
let init: (Int, Int -> Int) -> [Int] =
    fun len, f ->
        let go: (Int, [Int]) -> [Int] =
        fun idx, xs ->
            if idx < len 
            then go(idx + 1, xs @ [f(idx)])   
            else xs
        in
        go(0, [])
in

# Reduce a list from the left. #
let fold_left: ((Int, Int) -> Int, Int, [Int]) -> Int =
  fun f, acc, xs ->
    case xs 
    | [] => acc
    | hd::tl => fold_left(f, f(acc, hd), tl) end in

# Reduce a list from the right. #
let fold_right: ((Int, Int) -> Int, [Int], Int) -> Int =
  fun f, xs, acc ->
    case xs
    | [] => acc
    | hd::tl => f(hd, fold_right(f, tl, acc)) end in


666
LSP: Prelude: String parsed successfully
LSP: Prelude: Info map generated successfully
Debug: true, Constrain: Types
LSP: Init: Recieved string: # Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)

































































































































































































































LSP: Init: String parsed successfully
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: >( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {go: ((?, ?) -> [?]), filter: (((Int -> Bool), [Int]) -> [Int]), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: 
  LSP: Info: ALL errors:Error in term:
  p
Nature of error: Variable p is not bound    
Error in term:
  p
Nature of error: Variable p is not bound    
Error in term:
  p
Nature of error: type ((Int -> Bool), [Int]) is not consistent with arrow type
  LSP: Info: BidiCtx: Cls: Let expression
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent: Root
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: [?]
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: :: @
  LSP: Concave: Backpack: 
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new_tokens ::= whitespace | "," | "::" | "@"
root ::= new_tokens

Top 20 Logits:

:19.9904
#:15.2005
let:14.5652
##:14.383
 :13.1299
    :12.5337
################:12.5103
  :12.4577
   :12.2754
in:12.199
####:12.1015
```:11.8676
/*:11.8513
[:11.4421
//:11.3434
                :11.2961
(:11.1795
end:11.1575
def:11.1472
        :11.0956
{:11.0704

================
# Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)



































































































































































































































LSP: Prelude: Recieved string: ### List ###

# Add an element to the front of a list. #
let cons: (Int, [Int]) -> [Int] = fun x, xs -> x::xs in

# Determine the length of a list. #
let length: [Int] -> Int =
  fun xs ->
    case xs
    | [] => 0
    | _::xs => 1 + length(xs) end in

# Extract the first element of a list. #
let hd: [Int] -> Option =
  fun l ->
    case l
    | [] => None
    | x::xs => Some(x) end in

# Extract the rest of the list. #
let tl: [Int] -> [Int] =
  fun l ->
    case l
    | [] => []
    | x::xs => xs end in

# Determine if a list is empty. #
let is_empty: [Int] -> Bool =
  fun xs ->
    case xs
    | [] => true
    | _::_ => false end in

# Return the element at the index. #
let nth: ([Int], Int) -> Option =
  fun xs, n ->
    case xs, n
    | x::_, 0 => Some(x)
    | _::xs, n => nth(xs, n - 1)
    | [], _ => None end in

# Reverse a List. #
let rev: [Int] -> [Int] =
fun l -> 
let go: ([Int], [Int]) -> [Int] =
  fun xs, acc -> 
    case xs 
    | [] => acc 
    | x::xs => go(xs, x::acc) end in
go(l, []) in

# Check if two lists are equal #
let equal: ([Int], [Int]) -> Bool =
    fun p, xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => x == y && equal(xs, ys)
    | _ => false end
in

# Initialize a list with a given length using an initializer function #
let init: (Int, Int -> Int) -> [Int] =
    fun len, f ->
        let go: (Int, [Int]) -> [Int] =
        fun idx, xs ->
            if idx < len 
            then go(idx + 1, xs @ [f(idx)])   
            else xs
        in
        go(0, [])
in

# Reduce a list from the left. #
let fold_left: ((Int, Int) -> Int, Int, [Int]) -> Int =
  fun f, acc, xs ->
    case xs 
    | [] => acc
    | hd::tl => fold_left(f, f(acc, hd), tl) end in

# Reduce a list from the right. #
let fold_right: ((Int, Int) -> Int, [Int], Int) -> Int =
  fun f, xs, acc ->
    case xs
    | [] => acc
    | hd::tl => f(hd, fold_right(f, tl, acc)) end in


666
LSP: Prelude: String parsed successfully
LSP: Prelude: Info map generated successfully
Debug: true, Constrain: Types
LSP: Init: Recieved string: # Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)


































































































































































































































LSP: Init: String parsed successfully
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: >( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {go: ((?, ?) -> [?]), filter: (((Int -> Bool), [Int]) -> [Int]), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: 
  LSP: Info: ALL errors:Error in term:
  p
Nature of error: type ((Int -> Bool), [Int]) is not consistent with arrow type    
Error in term:
  p
Nature of error: Variable p is not bound    
Error in term:
  p
Nature of error: Variable p is not bound
  LSP: Info: BidiCtx: Cls: Let expression
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent: Root
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: [?]
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: :: @
  LSP: Concave: Backpack: 
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new_tokens ::= whitespace | "," | "::" | "@"
root ::= new_tokens

Top 20 Logits:

:20.0077
#:15.2084
let:14.5663
##:14.3877
 :13.1347
    :12.5325
################:12.5161
  :12.4605
   :12.2803
in:12.2135
####:12.1019
```:11.8697
/*:11.8496
[:11.4495
//:11.3462
                :11.3035
end:11.1708
(:11.1692
def:11.1439
        :11.0944
{:11.0704

================
# Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)




































































































































































































































LSP: Prelude: Recieved string: ### List ###

# Add an element to the front of a list. #
let cons: (Int, [Int]) -> [Int] = fun x, xs -> x::xs in

# Determine the length of a list. #
let length: [Int] -> Int =
  fun xs ->
    case xs
    | [] => 0
    | _::xs => 1 + length(xs) end in

# Extract the first element of a list. #
let hd: [Int] -> Option =
  fun l ->
    case l
    | [] => None
    | x::xs => Some(x) end in

# Extract the rest of the list. #
let tl: [Int] -> [Int] =
  fun l ->
    case l
    | [] => []
    | x::xs => xs end in

# Determine if a list is empty. #
let is_empty: [Int] -> Bool =
  fun xs ->
    case xs
    | [] => true
    | _::_ => false end in

# Return the element at the index. #
let nth: ([Int], Int) -> Option =
  fun xs, n ->
    case xs, n
    | x::_, 0 => Some(x)
    | _::xs, n => nth(xs, n - 1)
    | [], _ => None end in

# Reverse a List. #
let rev: [Int] -> [Int] =
fun l -> 
let go: ([Int], [Int]) -> [Int] =
  fun xs, acc -> 
    case xs 
    | [] => acc 
    | x::xs => go(xs, x::acc) end in
go(l, []) in

# Check if two lists are equal #
let equal: ([Int], [Int]) -> Bool =
    fun p, xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => x == y && equal(xs, ys)
    | _ => false end
in

# Initialize a list with a given length using an initializer function #
let init: (Int, Int -> Int) -> [Int] =
    fun len, f ->
        let go: (Int, [Int]) -> [Int] =
        fun idx, xs ->
            if idx < len 
            then go(idx + 1, xs @ [f(idx)])   
            else xs
        in
        go(0, [])
in

# Reduce a list from the left. #
let fold_left: ((Int, Int) -> Int, Int, [Int]) -> Int =
  fun f, acc, xs ->
    case xs 
    | [] => acc
    | hd::tl => fold_left(f, f(acc, hd), tl) end in

# Reduce a list from the right. #
let fold_right: ((Int, Int) -> Int, [Int], Int) -> Int =
  fun f, xs, acc ->
    case xs
    | [] => acc
    | hd::tl => f(hd, fold_right(f, tl, acc)) end in


666
LSP: Prelude: String parsed successfully
LSP: Prelude: Info map generated successfully
Debug: true, Constrain: Types
LSP: Init: Recieved string: # Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)



































































































































































































































LSP: Init: String parsed successfully
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: >( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {go: ((?, ?) -> [?]), filter: (((Int -> Bool), [Int]) -> [Int]), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: 
  LSP: Info: ALL errors:Error in term:
  p
Nature of error: type ((Int -> Bool), [Int]) is not consistent with arrow type    
Error in term:
  p
Nature of error: Variable p is not bound    
Error in term:
  p
Nature of error: Variable p is not bound
  LSP: Info: BidiCtx: Cls: Let expression
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent: Root
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: [?]
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: :: @
  LSP: Concave: Backpack: 
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new_tokens ::= whitespace | "," | "::" | "@"
root ::= new_tokens

Top 20 Logits:

:20.0209
#:15.2068
let:14.5596
##:14.382
 :13.1386
    :12.536
################:12.5173
  :12.4654
   :12.2879
in:12.2387
####:12.0938
```:11.8605
/*:11.8547
[:11.4487
//:11.3522
                :11.3082
end:11.1943
(:11.1512
def:11.1472
        :11.0941
{:11.0677

================
# Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)





































































































































































































































LSP: Prelude: Recieved string: ### List ###

# Add an element to the front of a list. #
let cons: (Int, [Int]) -> [Int] = fun x, xs -> x::xs in

# Determine the length of a list. #
let length: [Int] -> Int =
  fun xs ->
    case xs
    | [] => 0
    | _::xs => 1 + length(xs) end in

# Extract the first element of a list. #
let hd: [Int] -> Option =
  fun l ->
    case l
    | [] => None
    | x::xs => Some(x) end in

# Extract the rest of the list. #
let tl: [Int] -> [Int] =
  fun l ->
    case l
    | [] => []
    | x::xs => xs end in

# Determine if a list is empty. #
let is_empty: [Int] -> Bool =
  fun xs ->
    case xs
    | [] => true
    | _::_ => false end in

# Return the element at the index. #
let nth: ([Int], Int) -> Option =
  fun xs, n ->
    case xs, n
    | x::_, 0 => Some(x)
    | _::xs, n => nth(xs, n - 1)
    | [], _ => None end in

# Reverse a List. #
let rev: [Int] -> [Int] =
fun l -> 
let go: ([Int], [Int]) -> [Int] =
  fun xs, acc -> 
    case xs 
    | [] => acc 
    | x::xs => go(xs, x::acc) end in
go(l, []) in

# Check if two lists are equal #
let equal: ([Int], [Int]) -> Bool =
    fun p, xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => x == y && equal(xs, ys)
    | _ => false end
in

# Initialize a list with a given length using an initializer function #
let init: (Int, Int -> Int) -> [Int] =
    fun len, f ->
        let go: (Int, [Int]) -> [Int] =
        fun idx, xs ->
            if idx < len 
            then go(idx + 1, xs @ [f(idx)])   
            else xs
        in
        go(0, [])
in

# Reduce a list from the left. #
let fold_left: ((Int, Int) -> Int, Int, [Int]) -> Int =
  fun f, acc, xs ->
    case xs 
    | [] => acc
    | hd::tl => fold_left(f, f(acc, hd), tl) end in

# Reduce a list from the right. #
let fold_right: ((Int, Int) -> Int, [Int], Int) -> Int =
  fun f, xs, acc ->
    case xs
    | [] => acc
    | hd::tl => f(hd, fold_right(f, tl, acc)) end in


666
LSP: Prelude: String parsed successfully
LSP: Prelude: Info map generated successfully
Debug: true, Constrain: Types
LSP: Init: Recieved string: # Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)




































































































































































































































LSP: Init: String parsed successfully
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: >( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {go: ((?, ?) -> [?]), filter: (((Int -> Bool), [Int]) -> [Int]), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: 
  LSP: Info: ALL errors:Error in term:
  p
Nature of error: Variable p is not bound    
Error in term:
  p
Nature of error: type ((Int -> Bool), [Int]) is not consistent with arrow type    
Error in term:
  p
Nature of error: Variable p is not bound
  LSP: Info: BidiCtx: Cls: Let expression
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent: Root
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: [?]
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: :: @
  LSP: Concave: Backpack: 
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new_tokens ::= whitespace | "," | "::" | "@"
root ::= new_tokens

Top 20 Logits:

:20.0306
#:15.2004
let:14.5464
##:14.3664
 :13.1429
    :12.5419
################:12.5142
  :12.4712
   :12.2944
in:12.2588
####:12.0822
/*:11.8644
```:11.8432
[:11.4432
//:11.3611
                :11.309
end:11.2133
def:11.1493
(:11.1369
        :11.0951
{:11.0668

================
# Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)






































































































































































































































LSP: Prelude: Recieved string: ### List ###

# Add an element to the front of a list. #
let cons: (Int, [Int]) -> [Int] = fun x, xs -> x::xs in

# Determine the length of a list. #
let length: [Int] -> Int =
  fun xs ->
    case xs
    | [] => 0
    | _::xs => 1 + length(xs) end in

# Extract the first element of a list. #
let hd: [Int] -> Option =
  fun l ->
    case l
    | [] => None
    | x::xs => Some(x) end in

# Extract the rest of the list. #
let tl: [Int] -> [Int] =
  fun l ->
    case l
    | [] => []
    | x::xs => xs end in

# Determine if a list is empty. #
let is_empty: [Int] -> Bool =
  fun xs ->
    case xs
    | [] => true
    | _::_ => false end in

# Return the element at the index. #
let nth: ([Int], Int) -> Option =
  fun xs, n ->
    case xs, n
    | x::_, 0 => Some(x)
    | _::xs, n => nth(xs, n - 1)
    | [], _ => None end in

# Reverse a List. #
let rev: [Int] -> [Int] =
fun l -> 
let go: ([Int], [Int]) -> [Int] =
  fun xs, acc -> 
    case xs 
    | [] => acc 
    | x::xs => go(xs, x::acc) end in
go(l, []) in

# Check if two lists are equal #
let equal: ([Int], [Int]) -> Bool =
    fun p, xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => x == y && equal(xs, ys)
    | _ => false end
in

# Initialize a list with a given length using an initializer function #
let init: (Int, Int -> Int) -> [Int] =
    fun len, f ->
        let go: (Int, [Int]) -> [Int] =
        fun idx, xs ->
            if idx < len 
            then go(idx + 1, xs @ [f(idx)])   
            else xs
        in
        go(0, [])
in

# Reduce a list from the left. #
let fold_left: ((Int, Int) -> Int, Int, [Int]) -> Int =
  fun f, acc, xs ->
    case xs 
    | [] => acc
    | hd::tl => fold_left(f, f(acc, hd), tl) end in

# Reduce a list from the right. #
let fold_right: ((Int, Int) -> Int, [Int], Int) -> Int =
  fun f, xs, acc ->
    case xs
    | [] => acc
    | hd::tl => f(hd, fold_right(f, tl, acc)) end in


666
LSP: Prelude: String parsed successfully
LSP: Prelude: Info map generated successfully
Debug: true, Constrain: Types
LSP: Init: Recieved string: # Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)





































































































































































































































LSP: Init: String parsed successfully
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: >( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {go: ((?, ?) -> [?]), filter: (((Int -> Bool), [Int]) -> [Int]), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: 
  LSP: Info: ALL errors:Error in term:
  p
Nature of error: Variable p is not bound    
Error in term:
  p
Nature of error: Variable p is not bound    
Error in term:
  p
Nature of error: type ((Int -> Bool), [Int]) is not consistent with arrow type
  LSP: Info: BidiCtx: Cls: Let expression
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent: Root
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: [?]
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: :: @
  LSP: Concave: Backpack: 
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new_tokens ::= whitespace | "," | "::" | "@"
root ::= new_tokens

Top 20 Logits:

:20.0412
#:15.1964
let:14.5322
##:14.3482
 :13.1484
    :12.5459
################:12.5099
  :12.4773
   :12.296
in:12.2622
####:12.0741
/*:11.8735
```:11.8283
[:11.4391
//:11.3701
                :11.3074
end:11.2142
def:11.1431
(:11.1325
        :11.0976
{:11.0695

================
# Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)







































































































































































































































LSP: Prelude: Recieved string: ### List ###

# Add an element to the front of a list. #
let cons: (Int, [Int]) -> [Int] = fun x, xs -> x::xs in

# Determine the length of a list. #
let length: [Int] -> Int =
  fun xs ->
    case xs
    | [] => 0
    | _::xs => 1 + length(xs) end in

# Extract the first element of a list. #
let hd: [Int] -> Option =
  fun l ->
    case l
    | [] => None
    | x::xs => Some(x) end in

# Extract the rest of the list. #
let tl: [Int] -> [Int] =
  fun l ->
    case l
    | [] => []
    | x::xs => xs end in

# Determine if a list is empty. #
let is_empty: [Int] -> Bool =
  fun xs ->
    case xs
    | [] => true
    | _::_ => false end in

# Return the element at the index. #
let nth: ([Int], Int) -> Option =
  fun xs, n ->
    case xs, n
    | x::_, 0 => Some(x)
    | _::xs, n => nth(xs, n - 1)
    | [], _ => None end in

# Reverse a List. #
let rev: [Int] -> [Int] =
fun l -> 
let go: ([Int], [Int]) -> [Int] =
  fun xs, acc -> 
    case xs 
    | [] => acc 
    | x::xs => go(xs, x::acc) end in
go(l, []) in

# Check if two lists are equal #
let equal: ([Int], [Int]) -> Bool =
    fun p, xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => x == y && equal(xs, ys)
    | _ => false end
in

# Initialize a list with a given length using an initializer function #
let init: (Int, Int -> Int) -> [Int] =
    fun len, f ->
        let go: (Int, [Int]) -> [Int] =
        fun idx, xs ->
            if idx < len 
            then go(idx + 1, xs @ [f(idx)])   
            else xs
        in
        go(0, [])
in

# Reduce a list from the left. #
let fold_left: ((Int, Int) -> Int, Int, [Int]) -> Int =
  fun f, acc, xs ->
    case xs 
    | [] => acc
    | hd::tl => fold_left(f, f(acc, hd), tl) end in

# Reduce a list from the right. #
let fold_right: ((Int, Int) -> Int, [Int], Int) -> Int =
  fun f, xs, acc ->
    case xs
    | [] => acc
    | hd::tl => f(hd, fold_right(f, tl, acc)) end in


666
LSP: Prelude: String parsed successfully
LSP: Prelude: Info map generated successfully
Debug: true, Constrain: Types
LSP: Init: Recieved string: # Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)






































































































































































































































LSP: Init: String parsed successfully
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: >( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {go: ((?, ?) -> [?]), filter: (((Int -> Bool), [Int]) -> [Int]), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: 
  LSP: Info: ALL errors:Error in term:
  p
Nature of error: Variable p is not bound    
Error in term:
  p
Nature of error: Variable p is not bound    
Error in term:
  p
Nature of error: type ((Int -> Bool), [Int]) is not consistent with arrow type
  LSP: Info: BidiCtx: Cls: Let expression
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent: Root
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: [?]
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: :: @
  LSP: Concave: Backpack: 
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new_tokens ::= whitespace | "," | "::" | "@"
root ::= new_tokens

Top 20 Logits:

:20.0553
#:15.1973
let:14.525
##:14.3373
 :13.1533
    :12.5461
################:12.5092
  :12.4823
   :12.2907
in:12.249
####:12.0739
/*:11.8799
```:11.8235
[:11.4414
//:11.3785
                :11.3055
end:11.1935
(:11.1379
def:11.1301
        :11.1007
{:11.0745

================
# Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)








































































































































































































































LSP: Prelude: Recieved string: ### List ###

# Add an element to the front of a list. #
let cons: (Int, [Int]) -> [Int] = fun x, xs -> x::xs in

# Determine the length of a list. #
let length: [Int] -> Int =
  fun xs ->
    case xs
    | [] => 0
    | _::xs => 1 + length(xs) end in

# Extract the first element of a list. #
let hd: [Int] -> Option =
  fun l ->
    case l
    | [] => None
    | x::xs => Some(x) end in

# Extract the rest of the list. #
let tl: [Int] -> [Int] =
  fun l ->
    case l
    | [] => []
    | x::xs => xs end in

# Determine if a list is empty. #
let is_empty: [Int] -> Bool =
  fun xs ->
    case xs
    | [] => true
    | _::_ => false end in

# Return the element at the index. #
let nth: ([Int], Int) -> Option =
  fun xs, n ->
    case xs, n
    | x::_, 0 => Some(x)
    | _::xs, n => nth(xs, n - 1)
    | [], _ => None end in

# Reverse a List. #
let rev: [Int] -> [Int] =
fun l -> 
let go: ([Int], [Int]) -> [Int] =
  fun xs, acc -> 
    case xs 
    | [] => acc 
    | x::xs => go(xs, x::acc) end in
go(l, []) in

# Check if two lists are equal #
let equal: ([Int], [Int]) -> Bool =
    fun p, xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => x == y && equal(xs, ys)
    | _ => false end
in

# Initialize a list with a given length using an initializer function #
let init: (Int, Int -> Int) -> [Int] =
    fun len, f ->
        let go: (Int, [Int]) -> [Int] =
        fun idx, xs ->
            if idx < len 
            then go(idx + 1, xs @ [f(idx)])   
            else xs
        in
        go(0, [])
in

# Reduce a list from the left. #
let fold_left: ((Int, Int) -> Int, Int, [Int]) -> Int =
  fun f, acc, xs ->
    case xs 
    | [] => acc
    | hd::tl => fold_left(f, f(acc, hd), tl) end in

# Reduce a list from the right. #
let fold_right: ((Int, Int) -> Int, [Int], Int) -> Int =
  fun f, xs, acc ->
    case xs
    | [] => acc
    | hd::tl => f(hd, fold_right(f, tl, acc)) end in


666
LSP: Prelude: String parsed successfully
LSP: Prelude: Info map generated successfully
Debug: true, Constrain: Types
LSP: Init: Recieved string: # Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)







































































































































































































































LSP: Init: String parsed successfully
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: >( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {go: ((?, ?) -> [?]), filter: (((Int -> Bool), [Int]) -> [Int]), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: 
  LSP: Info: ALL errors:Error in term:
  p
Nature of error: Variable p is not bound    
Error in term:
  p
Nature of error: type ((Int -> Bool), [Int]) is not consistent with arrow type    
Error in term:
  p
Nature of error: Variable p is not bound
  LSP: Info: BidiCtx: Cls: Let expression
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent: Root
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: [?]
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: :: @
  LSP: Concave: Backpack: 
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new_tokens ::= whitespace | "," | "::" | "@"
root ::= new_tokens

Top 20 Logits:

:20.0719
#:15.1996
let:14.5264
##:14.3379
 :13.1559
    :12.5427
################:12.5126
  :12.486
   :12.2802
in:12.2291
####:12.079
/*:11.8811
```:11.8287
[:11.4471
//:11.3835
                :11.305
end:11.1628
(:11.1444
def:11.1147
        :11.1029
{:11.0793

================
# Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)









































































































































































































































LSP: Prelude: Recieved string: ### List ###

# Add an element to the front of a list. #
let cons: (Int, [Int]) -> [Int] = fun x, xs -> x::xs in

# Determine the length of a list. #
let length: [Int] -> Int =
  fun xs ->
    case xs
    | [] => 0
    | _::xs => 1 + length(xs) end in

# Extract the first element of a list. #
let hd: [Int] -> Option =
  fun l ->
    case l
    | [] => None
    | x::xs => Some(x) end in

# Extract the rest of the list. #
let tl: [Int] -> [Int] =
  fun l ->
    case l
    | [] => []
    | x::xs => xs end in

# Determine if a list is empty. #
let is_empty: [Int] -> Bool =
  fun xs ->
    case xs
    | [] => true
    | _::_ => false end in

# Return the element at the index. #
let nth: ([Int], Int) -> Option =
  fun xs, n ->
    case xs, n
    | x::_, 0 => Some(x)
    | _::xs, n => nth(xs, n - 1)
    | [], _ => None end in

# Reverse a List. #
let rev: [Int] -> [Int] =
fun l -> 
let go: ([Int], [Int]) -> [Int] =
  fun xs, acc -> 
    case xs 
    | [] => acc 
    | x::xs => go(xs, x::acc) end in
go(l, []) in

# Check if two lists are equal #
let equal: ([Int], [Int]) -> Bool =
    fun p, xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => x == y && equal(xs, ys)
    | _ => false end
in

# Initialize a list with a given length using an initializer function #
let init: (Int, Int -> Int) -> [Int] =
    fun len, f ->
        let go: (Int, [Int]) -> [Int] =
        fun idx, xs ->
            if idx < len 
            then go(idx + 1, xs @ [f(idx)])   
            else xs
        in
        go(0, [])
in

# Reduce a list from the left. #
let fold_left: ((Int, Int) -> Int, Int, [Int]) -> Int =
  fun f, acc, xs ->
    case xs 
    | [] => acc
    | hd::tl => fold_left(f, f(acc, hd), tl) end in

# Reduce a list from the right. #
let fold_right: ((Int, Int) -> Int, [Int], Int) -> Int =
  fun f, xs, acc ->
    case xs
    | [] => acc
    | hd::tl => f(hd, fold_right(f, tl, acc)) end in


666
LSP: Prelude: String parsed successfully
LSP: Prelude: Info map generated successfully
Debug: true, Constrain: Types
LSP: Init: Recieved string: # Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)








































































































































































































































LSP: Init: String parsed successfully
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: >( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {go: ((?, ?) -> [?]), filter: (((Int -> Bool), [Int]) -> [Int]), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: 
  LSP: Info: ALL errors:Error in term:
  p
Nature of error: Variable p is not bound    
Error in term:
  p
Nature of error: Variable p is not bound    
Error in term:
  p
Nature of error: type ((Int -> Bool), [Int]) is not consistent with arrow type
  LSP: Info: BidiCtx: Cls: Let expression
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent: Root
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: [?]
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: :: @
  LSP: Concave: Backpack: 
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new_tokens ::= whitespace | "," | "::" | "@"
root ::= new_tokens

Top 20 Logits:

:20.0859
#:15.1975
let:14.5302
##:14.3435
 :13.1544
    :12.5366
################:12.5158
  :12.487
   :12.2661
in:12.2099
####:12.0815
/*:11.8784
```:11.8337
[:11.4485
//:11.3823
                :11.3052
(:11.1444
end:11.1364
def:11.1038
        :11.1024
{:11.079

================
# Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)










































































































































































































































LSP: Prelude: Recieved string: ### List ###

# Add an element to the front of a list. #
let cons: (Int, [Int]) -> [Int] = fun x, xs -> x::xs in

# Determine the length of a list. #
let length: [Int] -> Int =
  fun xs ->
    case xs
    | [] => 0
    | _::xs => 1 + length(xs) end in

# Extract the first element of a list. #
let hd: [Int] -> Option =
  fun l ->
    case l
    | [] => None
    | x::xs => Some(x) end in

# Extract the rest of the list. #
let tl: [Int] -> [Int] =
  fun l ->
    case l
    | [] => []
    | x::xs => xs end in

# Determine if a list is empty. #
let is_empty: [Int] -> Bool =
  fun xs ->
    case xs
    | [] => true
    | _::_ => false end in

# Return the element at the index. #
let nth: ([Int], Int) -> Option =
  fun xs, n ->
    case xs, n
    | x::_, 0 => Some(x)
    | _::xs, n => nth(xs, n - 1)
    | [], _ => None end in

# Reverse a List. #
let rev: [Int] -> [Int] =
fun l -> 
let go: ([Int], [Int]) -> [Int] =
  fun xs, acc -> 
    case xs 
    | [] => acc 
    | x::xs => go(xs, x::acc) end in
go(l, []) in

# Check if two lists are equal #
let equal: ([Int], [Int]) -> Bool =
    fun p, xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => x == y && equal(xs, ys)
    | _ => false end
in

# Initialize a list with a given length using an initializer function #
let init: (Int, Int -> Int) -> [Int] =
    fun len, f ->
        let go: (Int, [Int]) -> [Int] =
        fun idx, xs ->
            if idx < len 
            then go(idx + 1, xs @ [f(idx)])   
            else xs
        in
        go(0, [])
in

# Reduce a list from the left. #
let fold_left: ((Int, Int) -> Int, Int, [Int]) -> Int =
  fun f, acc, xs ->
    case xs 
    | [] => acc
    | hd::tl => fold_left(f, f(acc, hd), tl) end in

# Reduce a list from the right. #
let fold_right: ((Int, Int) -> Int, [Int], Int) -> Int =
  fun f, xs, acc ->
    case xs
    | [] => acc
    | hd::tl => f(hd, fold_right(f, tl, acc)) end in


666
LSP: Prelude: String parsed successfully
LSP: Prelude: Info map generated successfully
Debug: true, Constrain: Types
LSP: Init: Recieved string: # Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)









































































































































































































































LSP: Init: String parsed successfully
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: >( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {go: ((?, ?) -> [?]), filter: (((Int -> Bool), [Int]) -> [Int]), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: 
  LSP: Info: ALL errors:Error in term:
  p
Nature of error: type ((Int -> Bool), [Int]) is not consistent with arrow type    
Error in term:
  p
Nature of error: Variable p is not bound    
Error in term:
  p
Nature of error: Variable p is not bound
  LSP: Info: BidiCtx: Cls: Let expression
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent: Root
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: [?]
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: :: @
  LSP: Concave: Backpack: 
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new_tokens ::= whitespace | "," | "::" | "@"
root ::= new_tokens

Top 20 Logits:

:20.0958
#:15.1907
let:14.5307
##:14.3495
 :13.1504
    :12.5307
################:12.5176
  :12.486
   :12.2536
in:12.1975
####:12.0797
/*:11.8772
```:11.83
[:11.4457
//:11.3787
                :11.3047
(:11.1383
end:11.1236
        :11.0989
def:11.0981
{:11.077

================
# Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)











































































































































































































































LSP: Prelude: Recieved string: ### List ###

# Add an element to the front of a list. #
let cons: (Int, [Int]) -> [Int] = fun x, xs -> x::xs in

# Determine the length of a list. #
let length: [Int] -> Int =
  fun xs ->
    case xs
    | [] => 0
    | _::xs => 1 + length(xs) end in

# Extract the first element of a list. #
let hd: [Int] -> Option =
  fun l ->
    case l
    | [] => None
    | x::xs => Some(x) end in

# Extract the rest of the list. #
let tl: [Int] -> [Int] =
  fun l ->
    case l
    | [] => []
    | x::xs => xs end in

# Determine if a list is empty. #
let is_empty: [Int] -> Bool =
  fun xs ->
    case xs
    | [] => true
    | _::_ => false end in

# Return the element at the index. #
let nth: ([Int], Int) -> Option =
  fun xs, n ->
    case xs, n
    | x::_, 0 => Some(x)
    | _::xs, n => nth(xs, n - 1)
    | [], _ => None end in

# Reverse a List. #
let rev: [Int] -> [Int] =
fun l -> 
let go: ([Int], [Int]) -> [Int] =
  fun xs, acc -> 
    case xs 
    | [] => acc 
    | x::xs => go(xs, x::acc) end in
go(l, []) in

# Check if two lists are equal #
let equal: ([Int], [Int]) -> Bool =
    fun p, xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => x == y && equal(xs, ys)
    | _ => false end
in

# Initialize a list with a given length using an initializer function #
let init: (Int, Int -> Int) -> [Int] =
    fun len, f ->
        let go: (Int, [Int]) -> [Int] =
        fun idx, xs ->
            if idx < len 
            then go(idx + 1, xs @ [f(idx)])   
            else xs
        in
        go(0, [])
in

# Reduce a list from the left. #
let fold_left: ((Int, Int) -> Int, Int, [Int]) -> Int =
  fun f, acc, xs ->
    case xs 
    | [] => acc
    | hd::tl => fold_left(f, f(acc, hd), tl) end in

# Reduce a list from the right. #
let fold_right: ((Int, Int) -> Int, [Int], Int) -> Int =
  fun f, xs, acc ->
    case xs
    | [] => acc
    | hd::tl => f(hd, fold_right(f, tl, acc)) end in


666
LSP: Prelude: String parsed successfully
LSP: Prelude: Info map generated successfully
Debug: true, Constrain: Types
LSP: Init: Recieved string: # Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)










































































































































































































































LSP: Init: String parsed successfully
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: >( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {go: ((?, ?) -> [?]), filter: (((Int -> Bool), [Int]) -> [Int]), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: 
  LSP: Info: ALL errors:Error in term:
  p
Nature of error: Variable p is not bound    
Error in term:
  p
Nature of error: Variable p is not bound    
Error in term:
  p
Nature of error: type ((Int -> Bool), [Int]) is not consistent with arrow type
  LSP: Info: BidiCtx: Cls: Let expression
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent: Root
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: [?]
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: :: @
  LSP: Concave: Backpack: 
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new_tokens ::= whitespace | "," | "::" | "@"
root ::= new_tokens

Top 20 Logits:

:20.1039
#:15.1857
let:14.5291
##:14.3563
 :13.1475
    :12.5273
################:12.5205
  :12.4849
   :12.2471
in:12.1912
####:12.0783
/*:11.8787
```:11.8199
[:11.4447
//:11.3774
                :11.305
(:11.1335
end:11.1212
        :11.0946
def:11.0926
{:11.079

================
# Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)












































































































































































































































LSP: Prelude: Recieved string: ### List ###

# Add an element to the front of a list. #
let cons: (Int, [Int]) -> [Int] = fun x, xs -> x::xs in

# Determine the length of a list. #
let length: [Int] -> Int =
  fun xs ->
    case xs
    | [] => 0
    | _::xs => 1 + length(xs) end in

# Extract the first element of a list. #
let hd: [Int] -> Option =
  fun l ->
    case l
    | [] => None
    | x::xs => Some(x) end in

# Extract the rest of the list. #
let tl: [Int] -> [Int] =
  fun l ->
    case l
    | [] => []
    | x::xs => xs end in

# Determine if a list is empty. #
let is_empty: [Int] -> Bool =
  fun xs ->
    case xs
    | [] => true
    | _::_ => false end in

# Return the element at the index. #
let nth: ([Int], Int) -> Option =
  fun xs, n ->
    case xs, n
    | x::_, 0 => Some(x)
    | _::xs, n => nth(xs, n - 1)
    | [], _ => None end in

# Reverse a List. #
let rev: [Int] -> [Int] =
fun l -> 
let go: ([Int], [Int]) -> [Int] =
  fun xs, acc -> 
    case xs 
    | [] => acc 
    | x::xs => go(xs, x::acc) end in
go(l, []) in

# Check if two lists are equal #
let equal: ([Int], [Int]) -> Bool =
    fun p, xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => x == y && equal(xs, ys)
    | _ => false end
in

# Initialize a list with a given length using an initializer function #
let init: (Int, Int -> Int) -> [Int] =
    fun len, f ->
        let go: (Int, [Int]) -> [Int] =
        fun idx, xs ->
            if idx < len 
            then go(idx + 1, xs @ [f(idx)])   
            else xs
        in
        go(0, [])
in

# Reduce a list from the left. #
let fold_left: ((Int, Int) -> Int, Int, [Int]) -> Int =
  fun f, acc, xs ->
    case xs 
    | [] => acc
    | hd::tl => fold_left(f, f(acc, hd), tl) end in

# Reduce a list from the right. #
let fold_right: ((Int, Int) -> Int, [Int], Int) -> Int =
  fun f, xs, acc ->
    case xs
    | [] => acc
    | hd::tl => f(hd, fold_right(f, tl, acc)) end in


666
LSP: Prelude: String parsed successfully
LSP: Prelude: Info map generated successfully
Debug: true, Constrain: Types
LSP: Init: Recieved string: # Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)











































































































































































































































LSP: Init: String parsed successfully
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: >( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {go: ((?, ?) -> [?]), filter: (((Int -> Bool), [Int]) -> [Int]), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: 
  LSP: Info: ALL errors:Error in term:
  p
Nature of error: Variable p is not bound    
Error in term:
  p
Nature of error: Variable p is not bound    
Error in term:
  p
Nature of error: type ((Int -> Bool), [Int]) is not consistent with arrow type
  LSP: Info: BidiCtx: Cls: Let expression
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent: Root
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: [?]
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: :: @
  LSP: Concave: Backpack: 
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new_tokens ::= whitespace | "," | "::" | "@"
root ::= new_tokens

Top 20 Logits:

:20.1132
#:15.1879
let:14.528
##:14.3633
 :13.1476
################:12.5264
    :12.5251
  :12.4833
   :12.2464
in:12.1873
####:12.0801
/*:11.8806
```:11.8117
[:11.449
//:11.3792
                :11.3082
(:11.1381
end:11.119
        :11.0917
{:11.0849
def:11.0843

================
# Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)













































































































































































































































LSP: Prelude: Recieved string: ### List ###

# Add an element to the front of a list. #
let cons: (Int, [Int]) -> [Int] = fun x, xs -> x::xs in

# Determine the length of a list. #
let length: [Int] -> Int =
  fun xs ->
    case xs
    | [] => 0
    | _::xs => 1 + length(xs) end in

# Extract the first element of a list. #
let hd: [Int] -> Option =
  fun l ->
    case l
    | [] => None
    | x::xs => Some(x) end in

# Extract the rest of the list. #
let tl: [Int] -> [Int] =
  fun l ->
    case l
    | [] => []
    | x::xs => xs end in

# Determine if a list is empty. #
let is_empty: [Int] -> Bool =
  fun xs ->
    case xs
    | [] => true
    | _::_ => false end in

# Return the element at the index. #
let nth: ([Int], Int) -> Option =
  fun xs, n ->
    case xs, n
    | x::_, 0 => Some(x)
    | _::xs, n => nth(xs, n - 1)
    | [], _ => None end in

# Reverse a List. #
let rev: [Int] -> [Int] =
fun l -> 
let go: ([Int], [Int]) -> [Int] =
  fun xs, acc -> 
    case xs 
    | [] => acc 
    | x::xs => go(xs, x::acc) end in
go(l, []) in

# Check if two lists are equal #
let equal: ([Int], [Int]) -> Bool =
    fun p, xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => x == y && equal(xs, ys)
    | _ => false end
in

# Initialize a list with a given length using an initializer function #
let init: (Int, Int -> Int) -> [Int] =
    fun len, f ->
        let go: (Int, [Int]) -> [Int] =
        fun idx, xs ->
            if idx < len 
            then go(idx + 1, xs @ [f(idx)])   
            else xs
        in
        go(0, [])
in

# Reduce a list from the left. #
let fold_left: ((Int, Int) -> Int, Int, [Int]) -> Int =
  fun f, acc, xs ->
    case xs 
    | [] => acc
    | hd::tl => fold_left(f, f(acc, hd), tl) end in

# Reduce a list from the right. #
let fold_right: ((Int, Int) -> Int, [Int], Int) -> Int =
  fun f, xs, acc ->
    case xs
    | [] => acc
    | hd::tl => f(hd, fold_right(f, tl, acc)) end in


666
LSP: Prelude: String parsed successfully
LSP: Prelude: Info map generated successfully
Debug: true, Constrain: Types
LSP: Init: Recieved string: # Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)












































































































































































































































LSP: Init: String parsed successfully
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: >( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {go: ((?, ?) -> [?]), filter: (((Int -> Bool), [Int]) -> [Int]), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: 
  LSP: Info: ALL errors:Error in term:
  p
Nature of error: Variable p is not bound    
Error in term:
  p
Nature of error: type ((Int -> Bool), [Int]) is not consistent with arrow type    
Error in term:
  p
Nature of error: Variable p is not bound
  LSP: Info: BidiCtx: Cls: Let expression
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent: Root
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: [?]
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: :: @
  LSP: Concave: Backpack: 
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new_tokens ::= whitespace | "," | "::" | "@"
root ::= new_tokens

Top 20 Logits:

:20.1257
#:15.1973
let:14.5311
##:14.3709
 :13.1507
################:12.5331
    :12.5226
  :12.4822
   :12.2489
in:12.1847
####:12.0855
/*:11.8816
```:11.8115
[:11.4606
//:11.3821
                :11.3132
(:11.1524
end:11.1135
{:11.0926
        :11.0907
def:11.0714

================
# Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)














































































































































































































































LSP: Prelude: Recieved string: ### List ###

# Add an element to the front of a list. #
let cons: (Int, [Int]) -> [Int] = fun x, xs -> x::xs in

# Determine the length of a list. #
let length: [Int] -> Int =
  fun xs ->
    case xs
    | [] => 0
    | _::xs => 1 + length(xs) end in

# Extract the first element of a list. #
let hd: [Int] -> Option =
  fun l ->
    case l
    | [] => None
    | x::xs => Some(x) end in

# Extract the rest of the list. #
let tl: [Int] -> [Int] =
  fun l ->
    case l
    | [] => []
    | x::xs => xs end in

# Determine if a list is empty. #
let is_empty: [Int] -> Bool =
  fun xs ->
    case xs
    | [] => true
    | _::_ => false end in

# Return the element at the index. #
let nth: ([Int], Int) -> Option =
  fun xs, n ->
    case xs, n
    | x::_, 0 => Some(x)
    | _::xs, n => nth(xs, n - 1)
    | [], _ => None end in

# Reverse a List. #
let rev: [Int] -> [Int] =
fun l -> 
let go: ([Int], [Int]) -> [Int] =
  fun xs, acc -> 
    case xs 
    | [] => acc 
    | x::xs => go(xs, x::acc) end in
go(l, []) in

# Check if two lists are equal #
let equal: ([Int], [Int]) -> Bool =
    fun p, xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => x == y && equal(xs, ys)
    | _ => false end
in

# Initialize a list with a given length using an initializer function #
let init: (Int, Int -> Int) -> [Int] =
    fun len, f ->
        let go: (Int, [Int]) -> [Int] =
        fun idx, xs ->
            if idx < len 
            then go(idx + 1, xs @ [f(idx)])   
            else xs
        in
        go(0, [])
in

# Reduce a list from the left. #
let fold_left: ((Int, Int) -> Int, Int, [Int]) -> Int =
  fun f, acc, xs ->
    case xs 
    | [] => acc
    | hd::tl => fold_left(f, f(acc, hd), tl) end in

# Reduce a list from the right. #
let fold_right: ((Int, Int) -> Int, [Int], Int) -> Int =
  fun f, xs, acc ->
    case xs
    | [] => acc
    | hd::tl => f(hd, fold_right(f, tl, acc)) end in


666
LSP: Prelude: String parsed successfully
LSP: Prelude: Info map generated successfully
Debug: true, Constrain: Types
LSP: Init: Recieved string: # Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)













































































































































































































































LSP: Init: String parsed successfully
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: >( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {go: ((?, ?) -> [?]), filter: (((Int -> Bool), [Int]) -> [Int]), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: 
  LSP: Info: ALL errors:Error in term:
  p
Nature of error: type ((Int -> Bool), [Int]) is not consistent with arrow type    
Error in term:
  p
Nature of error: Variable p is not bound    
Error in term:
  p
Nature of error: Variable p is not bound
  LSP: Info: BidiCtx: Cls: Let expression
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent: Root
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: [?]
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: :: @
  LSP: Concave: Backpack: 
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new_tokens ::= whitespace | "," | "::" | "@"
root ::= new_tokens

Top 20 Logits:

:20.1407
#:15.2091
let:14.5403
##:14.3785
 :13.1558
################:12.5372
    :12.5195
  :12.4826
   :12.252
in:12.1821
####:12.092
/*:11.8805
```:11.8188
[:11.4752
//:11.3844
                :11.3196
(:11.1679
end:11.1044
{:11.0984
        :11.0909
def:11.0545

================
# Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)















































































































































































































































LSP: Prelude: Recieved string: ### List ###

# Add an element to the front of a list. #
let cons: (Int, [Int]) -> [Int] = fun x, xs -> x::xs in

# Determine the length of a list. #
let length: [Int] -> Int =
  fun xs ->
    case xs
    | [] => 0
    | _::xs => 1 + length(xs) end in

# Extract the first element of a list. #
let hd: [Int] -> Option =
  fun l ->
    case l
    | [] => None
    | x::xs => Some(x) end in

# Extract the rest of the list. #
let tl: [Int] -> [Int] =
  fun l ->
    case l
    | [] => []
    | x::xs => xs end in

# Determine if a list is empty. #
let is_empty: [Int] -> Bool =
  fun xs ->
    case xs
    | [] => true
    | _::_ => false end in

# Return the element at the index. #
let nth: ([Int], Int) -> Option =
  fun xs, n ->
    case xs, n
    | x::_, 0 => Some(x)
    | _::xs, n => nth(xs, n - 1)
    | [], _ => None end in

# Reverse a List. #
let rev: [Int] -> [Int] =
fun l -> 
let go: ([Int], [Int]) -> [Int] =
  fun xs, acc -> 
    case xs 
    | [] => acc 
    | x::xs => go(xs, x::acc) end in
go(l, []) in

# Check if two lists are equal #
let equal: ([Int], [Int]) -> Bool =
    fun p, xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => x == y && equal(xs, ys)
    | _ => false end
in

# Initialize a list with a given length using an initializer function #
let init: (Int, Int -> Int) -> [Int] =
    fun len, f ->
        let go: (Int, [Int]) -> [Int] =
        fun idx, xs ->
            if idx < len 
            then go(idx + 1, xs @ [f(idx)])   
            else xs
        in
        go(0, [])
in

# Reduce a list from the left. #
let fold_left: ((Int, Int) -> Int, Int, [Int]) -> Int =
  fun f, acc, xs ->
    case xs 
    | [] => acc
    | hd::tl => fold_left(f, f(acc, hd), tl) end in

# Reduce a list from the right. #
let fold_right: ((Int, Int) -> Int, [Int], Int) -> Int =
  fun f, xs, acc ->
    case xs
    | [] => acc
    | hd::tl => f(hd, fold_right(f, tl, acc)) end in


666
LSP: Prelude: String parsed successfully
LSP: Prelude: Info map generated successfully
Debug: true, Constrain: Types
LSP: Init: Recieved string: # Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)














































































































































































































































LSP: Init: String parsed successfully
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: >( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {go: ((?, ?) -> [?]), filter: (((Int -> Bool), [Int]) -> [Int]), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: 
  LSP: Info: ALL errors:Error in term:
  p
Nature of error: type ((Int -> Bool), [Int]) is not consistent with arrow type    
Error in term:
  p
Nature of error: Variable p is not bound    
Error in term:
  p
Nature of error: Variable p is not bound
  LSP: Info: BidiCtx: Cls: Let expression
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent: Root
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: [?]
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: :: @
  LSP: Concave: Backpack: 
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new_tokens ::= whitespace | "," | "::" | "@"
root ::= new_tokens

Top 20 Logits:

:20.1547
#:15.216
let:14.5533
##:14.3838
 :13.1607
################:12.5362
    :12.5174
  :12.4836
   :12.255
in:12.1761
####:12.0947
/*:11.879
```:11.8263
[:11.4822
//:11.3858
                :11.3279
(:11.1742
{:11.0963
end:11.0959
        :11.0912
def:11.0397

================
# Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)
















































































































































































































































LSP: Prelude: Recieved string: ### List ###

# Add an element to the front of a list. #
let cons: (Int, [Int]) -> [Int] = fun x, xs -> x::xs in

# Determine the length of a list. #
let length: [Int] -> Int =
  fun xs ->
    case xs
    | [] => 0
    | _::xs => 1 + length(xs) end in

# Extract the first element of a list. #
let hd: [Int] -> Option =
  fun l ->
    case l
    | [] => None
    | x::xs => Some(x) end in

# Extract the rest of the list. #
let tl: [Int] -> [Int] =
  fun l ->
    case l
    | [] => []
    | x::xs => xs end in

# Determine if a list is empty. #
let is_empty: [Int] -> Bool =
  fun xs ->
    case xs
    | [] => true
    | _::_ => false end in

# Return the element at the index. #
let nth: ([Int], Int) -> Option =
  fun xs, n ->
    case xs, n
    | x::_, 0 => Some(x)
    | _::xs, n => nth(xs, n - 1)
    | [], _ => None end in

# Reverse a List. #
let rev: [Int] -> [Int] =
fun l -> 
let go: ([Int], [Int]) -> [Int] =
  fun xs, acc -> 
    case xs 
    | [] => acc 
    | x::xs => go(xs, x::acc) end in
go(l, []) in

# Check if two lists are equal #
let equal: ([Int], [Int]) -> Bool =
    fun p, xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => x == y && equal(xs, ys)
    | _ => false end
in

# Initialize a list with a given length using an initializer function #
let init: (Int, Int -> Int) -> [Int] =
    fun len, f ->
        let go: (Int, [Int]) -> [Int] =
        fun idx, xs ->
            if idx < len 
            then go(idx + 1, xs @ [f(idx)])   
            else xs
        in
        go(0, [])
in

# Reduce a list from the left. #
let fold_left: ((Int, Int) -> Int, Int, [Int]) -> Int =
  fun f, acc, xs ->
    case xs 
    | [] => acc
    | hd::tl => fold_left(f, f(acc, hd), tl) end in

# Reduce a list from the right. #
let fold_right: ((Int, Int) -> Int, [Int], Int) -> Int =
  fun f, xs, acc ->
    case xs
    | [] => acc
    | hd::tl => f(hd, fold_right(f, tl, acc)) end in


666
LSP: Prelude: String parsed successfully
LSP: Prelude: Info map generated successfully
Debug: true, Constrain: Types
LSP: Init: Recieved string: # Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)















































































































































































































































LSP: Init: String parsed successfully
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: >( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {go: ((?, ?) -> [?]), filter: (((Int -> Bool), [Int]) -> [Int]), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: 
  LSP: Info: ALL errors:Error in term:
  p
Nature of error: type ((Int -> Bool), [Int]) is not consistent with arrow type    
Error in term:
  p
Nature of error: Variable p is not bound    
Error in term:
  p
Nature of error: Variable p is not bound
  LSP: Info: BidiCtx: Cls: Let expression
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent: Root
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: [?]
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: :: @
  LSP: Concave: Backpack: 
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new_tokens ::= whitespace | "," | "::" | "@"
root ::= new_tokens

Top 20 Logits:

:20.1638
#:15.2133
let:14.563
##:14.3855
 :13.1627
################:12.5306
    :12.5181
  :12.4834
   :12.2562
in:12.1586
####:12.0902
/*:11.8819
```:11.8254
[:11.4765
//:11.3889
                :11.3343
(:11.1675
end:11.0928
        :11.0913
{:11.0874
def:11.0343

================
# Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)

















































































































































































































































LSP: Prelude: Recieved string: ### List ###

# Add an element to the front of a list. #
let cons: (Int, [Int]) -> [Int] = fun x, xs -> x::xs in

# Determine the length of a list. #
let length: [Int] -> Int =
  fun xs ->
    case xs
    | [] => 0
    | _::xs => 1 + length(xs) end in

# Extract the first element of a list. #
let hd: [Int] -> Option =
  fun l ->
    case l
    | [] => None
    | x::xs => Some(x) end in

# Extract the rest of the list. #
let tl: [Int] -> [Int] =
  fun l ->
    case l
    | [] => []
    | x::xs => xs end in

# Determine if a list is empty. #
let is_empty: [Int] -> Bool =
  fun xs ->
    case xs
    | [] => true
    | _::_ => false end in

# Return the element at the index. #
let nth: ([Int], Int) -> Option =
  fun xs, n ->
    case xs, n
    | x::_, 0 => Some(x)
    | _::xs, n => nth(xs, n - 1)
    | [], _ => None end in

# Reverse a List. #
let rev: [Int] -> [Int] =
fun l -> 
let go: ([Int], [Int]) -> [Int] =
  fun xs, acc -> 
    case xs 
    | [] => acc 
    | x::xs => go(xs, x::acc) end in
go(l, []) in

# Check if two lists are equal #
let equal: ([Int], [Int]) -> Bool =
    fun p, xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => x == y && equal(xs, ys)
    | _ => false end
in

# Initialize a list with a given length using an initializer function #
let init: (Int, Int -> Int) -> [Int] =
    fun len, f ->
        let go: (Int, [Int]) -> [Int] =
        fun idx, xs ->
            if idx < len 
            then go(idx + 1, xs @ [f(idx)])   
            else xs
        in
        go(0, [])
in

# Reduce a list from the left. #
let fold_left: ((Int, Int) -> Int, Int, [Int]) -> Int =
  fun f, acc, xs ->
    case xs 
    | [] => acc
    | hd::tl => fold_left(f, f(acc, hd), tl) end in

# Reduce a list from the right. #
let fold_right: ((Int, Int) -> Int, [Int], Int) -> Int =
  fun f, xs, acc ->
    case xs
    | [] => acc
    | hd::tl => f(hd, fold_right(f, tl, acc)) end in


666
LSP: Prelude: String parsed successfully
LSP: Prelude: Info map generated successfully
Debug: true, Constrain: Types
LSP: Init: Recieved string: # Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)
















































































































































































































































LSP: Init: String parsed successfully
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: >( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {go: ((?, ?) -> [?]), filter: (((Int -> Bool), [Int]) -> [Int]), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: 
  LSP: Info: ALL errors:Error in term:
  p
Nature of error: type ((Int -> Bool), [Int]) is not consistent with arrow type    
Error in term:
  p
Nature of error: Variable p is not bound    
Error in term:
  p
Nature of error: Variable p is not bound
  LSP: Info: BidiCtx: Cls: Let expression
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent: Root
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: [?]
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: :: @
  LSP: Concave: Backpack: 
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new_tokens ::= whitespace | "," | "::" | "@"
root ::= new_tokens

Top 20 Logits:

:20.1691
#:15.2026
let:14.5648
##:14.3868
 :13.1624
################:12.5246
    :12.5235
  :12.482
   :12.2558
in:12.1232
####:12.0837
/*:11.8907
```:11.8138
[:11.4628
//:11.3959
                :11.3353
(:11.1547
end:11.0944
        :11.0923
{:11.0789
def:11.0374

================
# Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)


















































































































































































































































LSP: Prelude: Recieved string: ### List ###

# Add an element to the front of a list. #
let cons: (Int, [Int]) -> [Int] = fun x, xs -> x::xs in

# Determine the length of a list. #
let length: [Int] -> Int =
  fun xs ->
    case xs
    | [] => 0
    | _::xs => 1 + length(xs) end in

# Extract the first element of a list. #
let hd: [Int] -> Option =
  fun l ->
    case l
    | [] => None
    | x::xs => Some(x) end in

# Extract the rest of the list. #
let tl: [Int] -> [Int] =
  fun l ->
    case l
    | [] => []
    | x::xs => xs end in

# Determine if a list is empty. #
let is_empty: [Int] -> Bool =
  fun xs ->
    case xs
    | [] => true
    | _::_ => false end in

# Return the element at the index. #
let nth: ([Int], Int) -> Option =
  fun xs, n ->
    case xs, n
    | x::_, 0 => Some(x)
    | _::xs, n => nth(xs, n - 1)
    | [], _ => None end in

# Reverse a List. #
let rev: [Int] -> [Int] =
fun l -> 
let go: ([Int], [Int]) -> [Int] =
  fun xs, acc -> 
    case xs 
    | [] => acc 
    | x::xs => go(xs, x::acc) end in
go(l, []) in

# Check if two lists are equal #
let equal: ([Int], [Int]) -> Bool =
    fun p, xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => x == y && equal(xs, ys)
    | _ => false end
in

# Initialize a list with a given length using an initializer function #
let init: (Int, Int -> Int) -> [Int] =
    fun len, f ->
        let go: (Int, [Int]) -> [Int] =
        fun idx, xs ->
            if idx < len 
            then go(idx + 1, xs @ [f(idx)])   
            else xs
        in
        go(0, [])
in

# Reduce a list from the left. #
let fold_left: ((Int, Int) -> Int, Int, [Int]) -> Int =
  fun f, acc, xs ->
    case xs 
    | [] => acc
    | hd::tl => fold_left(f, f(acc, hd), tl) end in

# Reduce a list from the right. #
let fold_right: ((Int, Int) -> Int, [Int], Int) -> Int =
  fun f, xs, acc ->
    case xs
    | [] => acc
    | hd::tl => f(hd, fold_right(f, tl, acc)) end in


666
LSP: Prelude: String parsed successfully
LSP: Prelude: Info map generated successfully
Debug: true, Constrain: Types
LSP: Init: Recieved string: # Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)

















































































































































































































































LSP: Init: String parsed successfully
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: >( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {go: ((?, ?) -> [?]), filter: (((Int -> Bool), [Int]) -> [Int]), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: 
  LSP: Info: ALL errors:Error in term:
  p
Nature of error: type ((Int -> Bool), [Int]) is not consistent with arrow type    
Error in term:
  p
Nature of error: Variable p is not bound    
Error in term:
  p
Nature of error: Variable p is not bound
  LSP: Info: BidiCtx: Cls: Let expression
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent: Root
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: [?]
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: :: @
  LSP: Concave: Backpack: 
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new_tokens ::= whitespace | "," | "::" | "@"
root ::= new_tokens

Top 20 Logits:

:20.1775
#:15.1929
let:14.5608
##:14.3939
 :13.1655
    :12.5345
################:12.5261
  :12.4828
   :12.2588
in:12.0852
####:12.0849
/*:11.9011
```:11.8003
[:11.4509
//:11.4068
                :11.3345
(:11.148
end:11.1011
        :11.0978
{:11.0781
def:11.0392

================
# Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)



















































































































































































































































LSP: Prelude: Recieved string: ### List ###

# Add an element to the front of a list. #
let cons: (Int, [Int]) -> [Int] = fun x, xs -> x::xs in

# Determine the length of a list. #
let length: [Int] -> Int =
  fun xs ->
    case xs
    | [] => 0
    | _::xs => 1 + length(xs) end in

# Extract the first element of a list. #
let hd: [Int] -> Option =
  fun l ->
    case l
    | [] => None
    | x::xs => Some(x) end in

# Extract the rest of the list. #
let tl: [Int] -> [Int] =
  fun l ->
    case l
    | [] => []
    | x::xs => xs end in

# Determine if a list is empty. #
let is_empty: [Int] -> Bool =
  fun xs ->
    case xs
    | [] => true
    | _::_ => false end in

# Return the element at the index. #
let nth: ([Int], Int) -> Option =
  fun xs, n ->
    case xs, n
    | x::_, 0 => Some(x)
    | _::xs, n => nth(xs, n - 1)
    | [], _ => None end in

# Reverse a List. #
let rev: [Int] -> [Int] =
fun l -> 
let go: ([Int], [Int]) -> [Int] =
  fun xs, acc -> 
    case xs 
    | [] => acc 
    | x::xs => go(xs, x::acc) end in
go(l, []) in

# Check if two lists are equal #
let equal: ([Int], [Int]) -> Bool =
    fun p, xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => x == y && equal(xs, ys)
    | _ => false end
in

# Initialize a list with a given length using an initializer function #
let init: (Int, Int -> Int) -> [Int] =
    fun len, f ->
        let go: (Int, [Int]) -> [Int] =
        fun idx, xs ->
            if idx < len 
            then go(idx + 1, xs @ [f(idx)])   
            else xs
        in
        go(0, [])
in

# Reduce a list from the left. #
let fold_left: ((Int, Int) -> Int, Int, [Int]) -> Int =
  fun f, acc, xs ->
    case xs 
    | [] => acc
    | hd::tl => fold_left(f, f(acc, hd), tl) end in

# Reduce a list from the right. #
let fold_right: ((Int, Int) -> Int, [Int], Int) -> Int =
  fun f, xs, acc ->
    case xs
    | [] => acc
    | hd::tl => f(hd, fold_right(f, tl, acc)) end in


666
LSP: Prelude: String parsed successfully
LSP: Prelude: Info map generated successfully
Debug: true, Constrain: Types
LSP: Init: Recieved string: # Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)


















































































































































































































































LSP: Init: String parsed successfully
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: >( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {go: ((?, ?) -> [?]), filter: (((Int -> Bool), [Int]) -> [Int]), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: 
  LSP: Info: ALL errors:Error in term:
  p
Nature of error: Variable p is not bound    
Error in term:
  p
Nature of error: type ((Int -> Bool), [Int]) is not consistent with arrow type    
Error in term:
  p
Nature of error: Variable p is not bound
  LSP: Info: BidiCtx: Cls: Let expression
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent: Root
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: [?]
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: :: @
  LSP: Concave: Backpack: 
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new_tokens ::= whitespace | "," | "::" | "@"
root ::= new_tokens

Top 20 Logits:

:20.1902
#:15.1899
let:14.555
##:14.4051
 :13.171
    :12.5467
################:12.5337
  :12.4836
   :12.2634
####:12.0926
in:12.0641
/*:11.9085
```:11.7922
[:11.4486
//:11.4183
                :11.3339
(:11.1528
end:11.1121
        :11.1061
{:11.0832
def:11.0367

================
# Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)




















































































































































































































































LSP: Prelude: Recieved string: ### List ###

# Add an element to the front of a list. #
let cons: (Int, [Int]) -> [Int] = fun x, xs -> x::xs in

# Determine the length of a list. #
let length: [Int] -> Int =
  fun xs ->
    case xs
    | [] => 0
    | _::xs => 1 + length(xs) end in

# Extract the first element of a list. #
let hd: [Int] -> Option =
  fun l ->
    case l
    | [] => None
    | x::xs => Some(x) end in

# Extract the rest of the list. #
let tl: [Int] -> [Int] =
  fun l ->
    case l
    | [] => []
    | x::xs => xs end in

# Determine if a list is empty. #
let is_empty: [Int] -> Bool =
  fun xs ->
    case xs
    | [] => true
    | _::_ => false end in

# Return the element at the index. #
let nth: ([Int], Int) -> Option =
  fun xs, n ->
    case xs, n
    | x::_, 0 => Some(x)
    | _::xs, n => nth(xs, n - 1)
    | [], _ => None end in

# Reverse a List. #
let rev: [Int] -> [Int] =
fun l -> 
let go: ([Int], [Int]) -> [Int] =
  fun xs, acc -> 
    case xs 
    | [] => acc 
    | x::xs => go(xs, x::acc) end in
go(l, []) in

# Check if two lists are equal #
let equal: ([Int], [Int]) -> Bool =
    fun p, xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => x == y && equal(xs, ys)
    | _ => false end
in

# Initialize a list with a given length using an initializer function #
let init: (Int, Int -> Int) -> [Int] =
    fun len, f ->
        let go: (Int, [Int]) -> [Int] =
        fun idx, xs ->
            if idx < len 
            then go(idx + 1, xs @ [f(idx)])   
            else xs
        in
        go(0, [])
in

# Reduce a list from the left. #
let fold_left: ((Int, Int) -> Int, Int, [Int]) -> Int =
  fun f, acc, xs ->
    case xs 
    | [] => acc
    | hd::tl => fold_left(f, f(acc, hd), tl) end in

# Reduce a list from the right. #
let fold_right: ((Int, Int) -> Int, [Int], Int) -> Int =
  fun f, xs, acc ->
    case xs
    | [] => acc
    | hd::tl => f(hd, fold_right(f, tl, acc)) end in


666
LSP: Prelude: String parsed successfully
LSP: Prelude: Info map generated successfully
Debug: true, Constrain: Types
LSP: Init: Recieved string: # Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)



















































































































































































































































LSP: Init: String parsed successfully
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: >( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {go: ((?, ?) -> [?]), filter: (((Int -> Bool), [Int]) -> [Int]), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: 
  LSP: Info: ALL errors:Error in term:
  p
Nature of error: type ((Int -> Bool), [Int]) is not consistent with arrow type    
Error in term:
  p
Nature of error: Variable p is not bound    
Error in term:
  p
Nature of error: Variable p is not bound
  LSP: Info: BidiCtx: Cls: Let expression
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent: Root
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: [?]
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: :: @
  LSP: Concave: Backpack: 
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new_tokens ::= whitespace | "," | "::" | "@"
root ::= new_tokens

Top 20 Logits:

:20.2056
#:15.1935
let:14.5522
##:14.414
 :13.1754
    :12.5563
################:12.5396
  :12.4836
   :12.2668
####:12.0993
in:12.071
/*:11.9091
```:11.7913
[:11.4574
//:11.4252
                :11.335
(:11.1632
end:11.1331
        :11.1148
{:11.089
########:11.0356

================
# Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)





















































































































































































































































LSP: Prelude: Recieved string: ### List ###

# Add an element to the front of a list. #
let cons: (Int, [Int]) -> [Int] = fun x, xs -> x::xs in

# Determine the length of a list. #
let length: [Int] -> Int =
  fun xs ->
    case xs
    | [] => 0
    | _::xs => 1 + length(xs) end in

# Extract the first element of a list. #
let hd: [Int] -> Option =
  fun l ->
    case l
    | [] => None
    | x::xs => Some(x) end in

# Extract the rest of the list. #
let tl: [Int] -> [Int] =
  fun l ->
    case l
    | [] => []
    | x::xs => xs end in

# Determine if a list is empty. #
let is_empty: [Int] -> Bool =
  fun xs ->
    case xs
    | [] => true
    | _::_ => false end in

# Return the element at the index. #
let nth: ([Int], Int) -> Option =
  fun xs, n ->
    case xs, n
    | x::_, 0 => Some(x)
    | _::xs, n => nth(xs, n - 1)
    | [], _ => None end in

# Reverse a List. #
let rev: [Int] -> [Int] =
fun l -> 
let go: ([Int], [Int]) -> [Int] =
  fun xs, acc -> 
    case xs 
    | [] => acc 
    | x::xs => go(xs, x::acc) end in
go(l, []) in

# Check if two lists are equal #
let equal: ([Int], [Int]) -> Bool =
    fun p, xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => x == y && equal(xs, ys)
    | _ => false end
in

# Initialize a list with a given length using an initializer function #
let init: (Int, Int -> Int) -> [Int] =
    fun len, f ->
        let go: (Int, [Int]) -> [Int] =
        fun idx, xs ->
            if idx < len 
            then go(idx + 1, xs @ [f(idx)])   
            else xs
        in
        go(0, [])
in

# Reduce a list from the left. #
let fold_left: ((Int, Int) -> Int, Int, [Int]) -> Int =
  fun f, acc, xs ->
    case xs 
    | [] => acc
    | hd::tl => fold_left(f, f(acc, hd), tl) end in

# Reduce a list from the right. #
let fold_right: ((Int, Int) -> Int, [Int], Int) -> Int =
  fun f, xs, acc ->
    case xs
    | [] => acc
    | hd::tl => f(hd, fold_right(f, tl, acc)) end in


666
LSP: Prelude: String parsed successfully
LSP: Prelude: Info map generated successfully
Debug: true, Constrain: Types
LSP: Init: Recieved string: # Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)




















































































































































































































































LSP: Init: String parsed successfully
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: >( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {go: ((?, ?) -> [?]), filter: (((Int -> Bool), [Int]) -> [Int]), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: 
  LSP: Info: ALL errors:Error in term:
  p
Nature of error: type ((Int -> Bool), [Int]) is not consistent with arrow type    
Error in term:
  p
Nature of error: Variable p is not bound    
Error in term:
  p
Nature of error: Variable p is not bound
  LSP: Info: BidiCtx: Cls: Let expression
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent: Root
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: [?]
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: :: @
  LSP: Concave: Backpack: 
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new_tokens ::= whitespace | "," | "::" | "@"
root ::= new_tokens

Top 20 Logits:

:20.2216
#:15.2002
let:14.5554
##:14.4117
 :13.1796
    :12.5633
################:12.5392
  :12.4863
   :12.269
in:12.1039
####:12.0977
/*:11.9024
```:11.7949
[:11.4682
//:11.4268
                :11.3401
(:11.1727
end:11.1626
        :11.1238
{:11.092
def:11.0324

================
# Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)






















































































































































































































































LSP: Prelude: Recieved string: ### List ###

# Add an element to the front of a list. #
let cons: (Int, [Int]) -> [Int] = fun x, xs -> x::xs in

# Determine the length of a list. #
let length: [Int] -> Int =
  fun xs ->
    case xs
    | [] => 0
    | _::xs => 1 + length(xs) end in

# Extract the first element of a list. #
let hd: [Int] -> Option =
  fun l ->
    case l
    | [] => None
    | x::xs => Some(x) end in

# Extract the rest of the list. #
let tl: [Int] -> [Int] =
  fun l ->
    case l
    | [] => []
    | x::xs => xs end in

# Determine if a list is empty. #
let is_empty: [Int] -> Bool =
  fun xs ->
    case xs
    | [] => true
    | _::_ => false end in

# Return the element at the index. #
let nth: ([Int], Int) -> Option =
  fun xs, n ->
    case xs, n
    | x::_, 0 => Some(x)
    | _::xs, n => nth(xs, n - 1)
    | [], _ => None end in

# Reverse a List. #
let rev: [Int] -> [Int] =
fun l -> 
let go: ([Int], [Int]) -> [Int] =
  fun xs, acc -> 
    case xs 
    | [] => acc 
    | x::xs => go(xs, x::acc) end in
go(l, []) in

# Check if two lists are equal #
let equal: ([Int], [Int]) -> Bool =
    fun p, xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => x == y && equal(xs, ys)
    | _ => false end
in

# Initialize a list with a given length using an initializer function #
let init: (Int, Int -> Int) -> [Int] =
    fun len, f ->
        let go: (Int, [Int]) -> [Int] =
        fun idx, xs ->
            if idx < len 
            then go(idx + 1, xs @ [f(idx)])   
            else xs
        in
        go(0, [])
in

# Reduce a list from the left. #
let fold_left: ((Int, Int) -> Int, Int, [Int]) -> Int =
  fun f, acc, xs ->
    case xs 
    | [] => acc
    | hd::tl => fold_left(f, f(acc, hd), tl) end in

# Reduce a list from the right. #
let fold_right: ((Int, Int) -> Int, [Int], Int) -> Int =
  fun f, xs, acc ->
    case xs
    | [] => acc
    | hd::tl => f(hd, fold_right(f, tl, acc)) end in


666
LSP: Prelude: String parsed successfully
LSP: Prelude: Info map generated successfully
Debug: true, Constrain: Types
LSP: Init: Recieved string: # Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)





















































































































































































































































LSP: Init: String parsed successfully
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: >( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {go: ((?, ?) -> [?]), filter: (((Int -> Bool), [Int]) -> [Int]), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: 
  LSP: Info: ALL errors:Error in term:
  p
Nature of error: type ((Int -> Bool), [Int]) is not consistent with arrow type    
Error in term:
  p
Nature of error: Variable p is not bound    
Error in term:
  p
Nature of error: Variable p is not bound
  LSP: Info: BidiCtx: Cls: Let expression
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent: Root
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: [?]
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: :: @
  LSP: Concave: Backpack: 
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new_tokens ::= whitespace | "," | "::" | "@"
root ::= new_tokens

Top 20 Logits:

:20.2316
#:15.2037
let:14.5633
##:14.3927
 :13.1814
    :12.5663
################:12.5305
  :12.489
   :12.2678
in:12.1395
####:12.0845
/*:11.8938
```:11.7937
[:11.4702
//:11.4255
                :11.3443
end:11.1852
(:11.1789
        :11.1291
{:11.091
def:11.0296

================
# Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)























































































































































































































































LSP: Prelude: Recieved string: ### List ###

# Add an element to the front of a list. #
let cons: (Int, [Int]) -> [Int] = fun x, xs -> x::xs in

# Determine the length of a list. #
let length: [Int] -> Int =
  fun xs ->
    case xs
    | [] => 0
    | _::xs => 1 + length(xs) end in

# Extract the first element of a list. #
let hd: [Int] -> Option =
  fun l ->
    case l
    | [] => None
    | x::xs => Some(x) end in

# Extract the rest of the list. #
let tl: [Int] -> [Int] =
  fun l ->
    case l
    | [] => []
    | x::xs => xs end in

# Determine if a list is empty. #
let is_empty: [Int] -> Bool =
  fun xs ->
    case xs
    | [] => true
    | _::_ => false end in

# Return the element at the index. #
let nth: ([Int], Int) -> Option =
  fun xs, n ->
    case xs, n
    | x::_, 0 => Some(x)
    | _::xs, n => nth(xs, n - 1)
    | [], _ => None end in

# Reverse a List. #
let rev: [Int] -> [Int] =
fun l -> 
let go: ([Int], [Int]) -> [Int] =
  fun xs, acc -> 
    case xs 
    | [] => acc 
    | x::xs => go(xs, x::acc) end in
go(l, []) in

# Check if two lists are equal #
let equal: ([Int], [Int]) -> Bool =
    fun p, xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => x == y && equal(xs, ys)
    | _ => false end
in

# Initialize a list with a given length using an initializer function #
let init: (Int, Int -> Int) -> [Int] =
    fun len, f ->
        let go: (Int, [Int]) -> [Int] =
        fun idx, xs ->
            if idx < len 
            then go(idx + 1, xs @ [f(idx)])   
            else xs
        in
        go(0, [])
in

# Reduce a list from the left. #
let fold_left: ((Int, Int) -> Int, Int, [Int]) -> Int =
  fun f, acc, xs ->
    case xs 
    | [] => acc
    | hd::tl => fold_left(f, f(acc, hd), tl) end in

# Reduce a list from the right. #
let fold_right: ((Int, Int) -> Int, [Int], Int) -> Int =
  fun f, xs, acc ->
    case xs
    | [] => acc
    | hd::tl => f(hd, fold_right(f, tl, acc)) end in


666
LSP: Prelude: String parsed successfully
LSP: Prelude: Info map generated successfully
Debug: true, Constrain: Types
LSP: Init: Recieved string: # Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)






















































































































































































































































LSP: Init: String parsed successfully
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: >( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {go: ((?, ?) -> [?]), filter: (((Int -> Bool), [Int]) -> [Int]), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: 
  LSP: Info: ALL errors:Error in term:
  p
Nature of error: Variable p is not bound    
Error in term:
  p
Nature of error: type ((Int -> Bool), [Int]) is not consistent with arrow type    
Error in term:
  p
Nature of error: Variable p is not bound
  LSP: Info: BidiCtx: Cls: Let expression
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent: Root
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: [?]
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: :: @
  LSP: Concave: Backpack: 
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new_tokens ::= whitespace | "," | "::" | "@"
root ::= new_tokens

Top 20 Logits:

:20.2317
#:15.2018
let:14.5725
##:14.3653
 :13.1787
    :12.5646
################:12.5156
  :12.4872
   :12.2632
in:12.1472
####:12.0655
/*:11.8893
```:11.782
[:11.4645
//:11.4255
                :11.3411
end:11.1875
(:11.184
        :11.1268
{:11.0913
def:11.0208

================
# Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)
























































































































































































































































LSP: Prelude: Recieved string: ### List ###

# Add an element to the front of a list. #
let cons: (Int, [Int]) -> [Int] = fun x, xs -> x::xs in

# Determine the length of a list. #
let length: [Int] -> Int =
  fun xs ->
    case xs
    | [] => 0
    | _::xs => 1 + length(xs) end in

# Extract the first element of a list. #
let hd: [Int] -> Option =
  fun l ->
    case l
    | [] => None
    | x::xs => Some(x) end in

# Extract the rest of the list. #
let tl: [Int] -> [Int] =
  fun l ->
    case l
    | [] => []
    | x::xs => xs end in

# Determine if a list is empty. #
let is_empty: [Int] -> Bool =
  fun xs ->
    case xs
    | [] => true
    | _::_ => false end in

# Return the element at the index. #
let nth: ([Int], Int) -> Option =
  fun xs, n ->
    case xs, n
    | x::_, 0 => Some(x)
    | _::xs, n => nth(xs, n - 1)
    | [], _ => None end in

# Reverse a List. #
let rev: [Int] -> [Int] =
fun l -> 
let go: ([Int], [Int]) -> [Int] =
  fun xs, acc -> 
    case xs 
    | [] => acc 
    | x::xs => go(xs, x::acc) end in
go(l, []) in

# Check if two lists are equal #
let equal: ([Int], [Int]) -> Bool =
    fun p, xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => x == y && equal(xs, ys)
    | _ => false end
in

# Initialize a list with a given length using an initializer function #
let init: (Int, Int -> Int) -> [Int] =
    fun len, f ->
        let go: (Int, [Int]) -> [Int] =
        fun idx, xs ->
            if idx < len 
            then go(idx + 1, xs @ [f(idx)])   
            else xs
        in
        go(0, [])
in

# Reduce a list from the left. #
let fold_left: ((Int, Int) -> Int, Int, [Int]) -> Int =
  fun f, acc, xs ->
    case xs 
    | [] => acc
    | hd::tl => fold_left(f, f(acc, hd), tl) end in

# Reduce a list from the right. #
let fold_right: ((Int, Int) -> Int, [Int], Int) -> Int =
  fun f, xs, acc ->
    case xs
    | [] => acc
    | hd::tl => f(hd, fold_right(f, tl, acc)) end in


666
LSP: Prelude: String parsed successfully
LSP: Prelude: Info map generated successfully
Debug: true, Constrain: Types
LSP: Init: Recieved string: # Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)























































































































































































































































LSP: Init: String parsed successfully
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: >( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {go: ((?, ?) -> [?]), filter: (((Int -> Bool), [Int]) -> [Int]), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: 
  LSP: Info: ALL errors:Error in term:
  p
Nature of error: Variable p is not bound    
Error in term:
  p
Nature of error: Variable p is not bound    
Error in term:
  p
Nature of error: type ((Int -> Bool), [Int]) is not consistent with arrow type
  LSP: Info: BidiCtx: Cls: Let expression
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent: Root
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: [?]
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: :: @
  LSP: Concave: Backpack: 
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new_tokens ::= whitespace | "," | "::" | "@"
root ::= new_tokens

Top 20 Logits:

:20.2278
#:15.2001
let:14.5827
##:14.3472
 :13.175
    :12.56
################:12.5057
  :12.4821
   :12.2592
in:12.1087
####:12.0547
/*:11.8907
```:11.7672
[:11.4615
//:11.4294
                :11.3334
(:11.1939
end:11.1602
        :11.1197
{:11.0993
def:11.0029

================
# Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)

























































































































































































































































LSP: Prelude: Recieved string: ### List ###

# Add an element to the front of a list. #
let cons: (Int, [Int]) -> [Int] = fun x, xs -> x::xs in

# Determine the length of a list. #
let length: [Int] -> Int =
  fun xs ->
    case xs
    | [] => 0
    | _::xs => 1 + length(xs) end in

# Extract the first element of a list. #
let hd: [Int] -> Option =
  fun l ->
    case l
    | [] => None
    | x::xs => Some(x) end in

# Extract the rest of the list. #
let tl: [Int] -> [Int] =
  fun l ->
    case l
    | [] => []
    | x::xs => xs end in

# Determine if a list is empty. #
let is_empty: [Int] -> Bool =
  fun xs ->
    case xs
    | [] => true
    | _::_ => false end in

# Return the element at the index. #
let nth: ([Int], Int) -> Option =
  fun xs, n ->
    case xs, n
    | x::_, 0 => Some(x)
    | _::xs, n => nth(xs, n - 1)
    | [], _ => None end in

# Reverse a List. #
let rev: [Int] -> [Int] =
fun l -> 
let go: ([Int], [Int]) -> [Int] =
  fun xs, acc -> 
    case xs 
    | [] => acc 
    | x::xs => go(xs, x::acc) end in
go(l, []) in

# Check if two lists are equal #
let equal: ([Int], [Int]) -> Bool =
    fun p, xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => x == y && equal(xs, ys)
    | _ => false end
in

# Initialize a list with a given length using an initializer function #
let init: (Int, Int -> Int) -> [Int] =
    fun len, f ->
        let go: (Int, [Int]) -> [Int] =
        fun idx, xs ->
            if idx < len 
            then go(idx + 1, xs @ [f(idx)])   
            else xs
        in
        go(0, [])
in

# Reduce a list from the left. #
let fold_left: ((Int, Int) -> Int, Int, [Int]) -> Int =
  fun f, acc, xs ->
    case xs 
    | [] => acc
    | hd::tl => fold_left(f, f(acc, hd), tl) end in

# Reduce a list from the right. #
let fold_right: ((Int, Int) -> Int, [Int], Int) -> Int =
  fun f, xs, acc ->
    case xs
    | [] => acc
    | hd::tl => f(hd, fold_right(f, tl, acc)) end in


666
LSP: Prelude: String parsed successfully
LSP: Prelude: Info map generated successfully
Debug: true, Constrain: Types
LSP: Init: Recieved string: # Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)
























































































































































































































































LSP: Init: String parsed successfully
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: >( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {go: ((?, ?) -> [?]), filter: (((Int -> Bool), [Int]) -> [Int]), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: 
  LSP: Info: ALL errors:Error in term:
  p
Nature of error: Variable p is not bound    
Error in term:
  p
Nature of error: type ((Int -> Bool), [Int]) is not consistent with arrow type    
Error in term:
  p
Nature of error: Variable p is not bound
  LSP: Info: BidiCtx: Cls: Let expression
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent: Root
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: [?]
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: :: @
  LSP: Concave: Backpack: 
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new_tokens ::= whitespace | "," | "::" | "@"
root ::= new_tokens

Top 20 Logits:

:20.2269
#:15.1992
let:14.5905
##:14.3496
 :13.171
    :12.5528
################:12.5057
  :12.4743
   :12.2552
####:12.0585
in:12.0309
/*:11.8941
```:11.7577
[:11.4657
//:11.4356
                :11.3237
(:11.2067
{:11.1113
        :11.1101
end:11.1083
########:10.984

================
# Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)


























































































































































































































































LSP: Prelude: Recieved string: ### List ###

# Add an element to the front of a list. #
let cons: (Int, [Int]) -> [Int] = fun x, xs -> x::xs in

# Determine the length of a list. #
let length: [Int] -> Int =
  fun xs ->
    case xs
    | [] => 0
    | _::xs => 1 + length(xs) end in

# Extract the first element of a list. #
let hd: [Int] -> Option =
  fun l ->
    case l
    | [] => None
    | x::xs => Some(x) end in

# Extract the rest of the list. #
let tl: [Int] -> [Int] =
  fun l ->
    case l
    | [] => []
    | x::xs => xs end in

# Determine if a list is empty. #
let is_empty: [Int] -> Bool =
  fun xs ->
    case xs
    | [] => true
    | _::_ => false end in

# Return the element at the index. #
let nth: ([Int], Int) -> Option =
  fun xs, n ->
    case xs, n
    | x::_, 0 => Some(x)
    | _::xs, n => nth(xs, n - 1)
    | [], _ => None end in

# Reverse a List. #
let rev: [Int] -> [Int] =
fun l -> 
let go: ([Int], [Int]) -> [Int] =
  fun xs, acc -> 
    case xs 
    | [] => acc 
    | x::xs => go(xs, x::acc) end in
go(l, []) in

# Check if two lists are equal #
let equal: ([Int], [Int]) -> Bool =
    fun p, xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => x == y && equal(xs, ys)
    | _ => false end
in

# Initialize a list with a given length using an initializer function #
let init: (Int, Int -> Int) -> [Int] =
    fun len, f ->
        let go: (Int, [Int]) -> [Int] =
        fun idx, xs ->
            if idx < len 
            then go(idx + 1, xs @ [f(idx)])   
            else xs
        in
        go(0, [])
in

# Reduce a list from the left. #
let fold_left: ((Int, Int) -> Int, Int, [Int]) -> Int =
  fun f, acc, xs ->
    case xs 
    | [] => acc
    | hd::tl => fold_left(f, f(acc, hd), tl) end in

# Reduce a list from the right. #
let fold_right: ((Int, Int) -> Int, [Int], Int) -> Int =
  fun f, xs, acc ->
    case xs
    | [] => acc
    | hd::tl => f(hd, fold_right(f, tl, acc)) end in


666
LSP: Prelude: String parsed successfully
LSP: Prelude: Info map generated successfully
Debug: true, Constrain: Types
LSP: Init: Recieved string: # Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)

























































































































































































































































LSP: Init: String parsed successfully
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: >( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {go: ((?, ?) -> [?]), filter: (((Int -> Bool), [Int]) -> [Int]), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: 
  LSP: Info: ALL errors:Error in term:
  p
Nature of error: Variable p is not bound    
Error in term:
  p
Nature of error: Variable p is not bound    
Error in term:
  p
Nature of error: type ((Int -> Bool), [Int]) is not consistent with arrow type
  LSP: Info: BidiCtx: Cls: Let expression
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent: Root
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: [?]
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: :: @
  LSP: Concave: Backpack: 
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new_tokens ::= whitespace | "," | "::" | "@"
root ::= new_tokens

Top 20 Logits:

:20.2334
#:15.1948
let:14.5922
##:14.371
 :13.1673
    :12.5446
################:12.5118
  :12.467
   :12.2503
####:12.0746
in:11.951
/*:11.8928
```:11.7558
[:11.4747
//:11.4386
                :11.3159
(:11.2156
{:11.1222
        :11.102
end:11.0562
########:10.996

================
# Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)



























































































































































































































































LSP: Prelude: Recieved string: ### List ###

# Add an element to the front of a list. #
let cons: (Int, [Int]) -> [Int] = fun x, xs -> x::xs in

# Determine the length of a list. #
let length: [Int] -> Int =
  fun xs ->
    case xs
    | [] => 0
    | _::xs => 1 + length(xs) end in

# Extract the first element of a list. #
let hd: [Int] -> Option =
  fun l ->
    case l
    | [] => None
    | x::xs => Some(x) end in

# Extract the rest of the list. #
let tl: [Int] -> [Int] =
  fun l ->
    case l
    | [] => []
    | x::xs => xs end in

# Determine if a list is empty. #
let is_empty: [Int] -> Bool =
  fun xs ->
    case xs
    | [] => true
    | _::_ => false end in

# Return the element at the index. #
let nth: ([Int], Int) -> Option =
  fun xs, n ->
    case xs, n
    | x::_, 0 => Some(x)
    | _::xs, n => nth(xs, n - 1)
    | [], _ => None end in

# Reverse a List. #
let rev: [Int] -> [Int] =
fun l -> 
let go: ([Int], [Int]) -> [Int] =
  fun xs, acc -> 
    case xs 
    | [] => acc 
    | x::xs => go(xs, x::acc) end in
go(l, []) in

# Check if two lists are equal #
let equal: ([Int], [Int]) -> Bool =
    fun p, xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => x == y && equal(xs, ys)
    | _ => false end
in

# Initialize a list with a given length using an initializer function #
let init: (Int, Int -> Int) -> [Int] =
    fun len, f ->
        let go: (Int, [Int]) -> [Int] =
        fun idx, xs ->
            if idx < len 
            then go(idx + 1, xs @ [f(idx)])   
            else xs
        in
        go(0, [])
in

# Reduce a list from the left. #
let fold_left: ((Int, Int) -> Int, Int, [Int]) -> Int =
  fun f, acc, xs ->
    case xs 
    | [] => acc
    | hd::tl => fold_left(f, f(acc, hd), tl) end in

# Reduce a list from the right. #
let fold_right: ((Int, Int) -> Int, [Int], Int) -> Int =
  fun f, xs, acc ->
    case xs
    | [] => acc
    | hd::tl => f(hd, fold_right(f, tl, acc)) end in


666
LSP: Prelude: String parsed successfully
LSP: Prelude: Info map generated successfully
Debug: true, Constrain: Types
LSP: Init: Recieved string: # Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)


























































































































































































































































LSP: Init: String parsed successfully
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: >( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {go: ((?, ?) -> [?]), filter: (((Int -> Bool), [Int]) -> [Int]), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: 
  LSP: Info: ALL errors:Error in term:
  p
Nature of error: type ((Int -> Bool), [Int]) is not consistent with arrow type    
Error in term:
  p
Nature of error: Variable p is not bound    
Error in term:
  p
Nature of error: Variable p is not bound
  LSP: Info: BidiCtx: Cls: Let expression
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent: Root
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: [?]
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: :: @
  LSP: Concave: Backpack: 
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new_tokens ::= whitespace | "," | "::" | "@"
root ::= new_tokens

Top 20 Logits:

:20.2474
#:15.1853
let:14.5891
##:14.397
 :13.1667
    :12.542
################:12.5182
  :12.467
   :12.2473
####:12.0919
in:11.9055
/*:11.8862
```:11.7579
[:11.4813
//:11.4354
                :11.3156
(:11.2156
{:11.1279
        :11.1011
end:11.0317
########:11.01

================
# Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)




























































































































































































































































LSP: Prelude: Recieved string: ### List ###

# Add an element to the front of a list. #
let cons: (Int, [Int]) -> [Int] = fun x, xs -> x::xs in

# Determine the length of a list. #
let length: [Int] -> Int =
  fun xs ->
    case xs
    | [] => 0
    | _::xs => 1 + length(xs) end in

# Extract the first element of a list. #
let hd: [Int] -> Option =
  fun l ->
    case l
    | [] => None
    | x::xs => Some(x) end in

# Extract the rest of the list. #
let tl: [Int] -> [Int] =
  fun l ->
    case l
    | [] => []
    | x::xs => xs end in

# Determine if a list is empty. #
let is_empty: [Int] -> Bool =
  fun xs ->
    case xs
    | [] => true
    | _::_ => false end in

# Return the element at the index. #
let nth: ([Int], Int) -> Option =
  fun xs, n ->
    case xs, n
    | x::_, 0 => Some(x)
    | _::xs, n => nth(xs, n - 1)
    | [], _ => None end in

# Reverse a List. #
let rev: [Int] -> [Int] =
fun l -> 
let go: ([Int], [Int]) -> [Int] =
  fun xs, acc -> 
    case xs 
    | [] => acc 
    | x::xs => go(xs, x::acc) end in
go(l, []) in

# Check if two lists are equal #
let equal: ([Int], [Int]) -> Bool =
    fun p, xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => x == y && equal(xs, ys)
    | _ => false end
in

# Initialize a list with a given length using an initializer function #
let init: (Int, Int -> Int) -> [Int] =
    fun len, f ->
        let go: (Int, [Int]) -> [Int] =
        fun idx, xs ->
            if idx < len 
            then go(idx + 1, xs @ [f(idx)])   
            else xs
        in
        go(0, [])
in

# Reduce a list from the left. #
let fold_left: ((Int, Int) -> Int, Int, [Int]) -> Int =
  fun f, acc, xs ->
    case xs 
    | [] => acc
    | hd::tl => fold_left(f, f(acc, hd), tl) end in

# Reduce a list from the right. #
let fold_right: ((Int, Int) -> Int, [Int], Int) -> Int =
  fun f, xs, acc ->
    case xs
    | [] => acc
    | hd::tl => f(hd, fold_right(f, tl, acc)) end in


666
LSP: Prelude: String parsed successfully
LSP: Prelude: Info map generated successfully
Debug: true, Constrain: Types
LSP: Init: Recieved string: # Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)



























































































































































































































































LSP: Init: String parsed successfully
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: >( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {go: ((?, ?) -> [?]), filter: (((Int -> Bool), [Int]) -> [Int]), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: 
  LSP: Info: ALL errors:Error in term:
  p
Nature of error: type ((Int -> Bool), [Int]) is not consistent with arrow type    
Error in term:
  p
Nature of error: Variable p is not bound    
Error in term:
  p
Nature of error: Variable p is not bound
  LSP: Info: BidiCtx: Cls: Let expression
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent: Root
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: [?]
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: :: @
  LSP: Concave: Backpack: 
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new_tokens ::= whitespace | "," | "::" | "@"
root ::= new_tokens

Top 20 Logits:

:20.263
#:15.1724
let:14.5833
##:14.409
 :13.1685
    :12.5485
################:12.5202
  :12.4748
   :12.2456
####:12.0978
in:11.906
/*:11.8801
```:11.756
[:11.479
//:11.4291
                :11.3228
(:11.2088
{:11.1255
        :11.108
end:11.0405
########:11.0167

================
# Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)





























































































































































































































































LSP: Prelude: Recieved string: ### List ###

# Add an element to the front of a list. #
let cons: (Int, [Int]) -> [Int] = fun x, xs -> x::xs in

# Determine the length of a list. #
let length: [Int] -> Int =
  fun xs ->
    case xs
    | [] => 0
    | _::xs => 1 + length(xs) end in

# Extract the first element of a list. #
let hd: [Int] -> Option =
  fun l ->
    case l
    | [] => None
    | x::xs => Some(x) end in

# Extract the rest of the list. #
let tl: [Int] -> [Int] =
  fun l ->
    case l
    | [] => []
    | x::xs => xs end in

# Determine if a list is empty. #
let is_empty: [Int] -> Bool =
  fun xs ->
    case xs
    | [] => true
    | _::_ => false end in

# Return the element at the index. #
let nth: ([Int], Int) -> Option =
  fun xs, n ->
    case xs, n
    | x::_, 0 => Some(x)
    | _::xs, n => nth(xs, n - 1)
    | [], _ => None end in

# Reverse a List. #
let rev: [Int] -> [Int] =
fun l -> 
let go: ([Int], [Int]) -> [Int] =
  fun xs, acc -> 
    case xs 
    | [] => acc 
    | x::xs => go(xs, x::acc) end in
go(l, []) in

# Check if two lists are equal #
let equal: ([Int], [Int]) -> Bool =
    fun p, xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => x == y && equal(xs, ys)
    | _ => false end
in

# Initialize a list with a given length using an initializer function #
let init: (Int, Int -> Int) -> [Int] =
    fun len, f ->
        let go: (Int, [Int]) -> [Int] =
        fun idx, xs ->
            if idx < len 
            then go(idx + 1, xs @ [f(idx)])   
            else xs
        in
        go(0, [])
in

# Reduce a list from the left. #
let fold_left: ((Int, Int) -> Int, Int, [Int]) -> Int =
  fun f, acc, xs ->
    case xs 
    | [] => acc
    | hd::tl => fold_left(f, f(acc, hd), tl) end in

# Reduce a list from the right. #
let fold_right: ((Int, Int) -> Int, [Int], Int) -> Int =
  fun f, xs, acc ->
    case xs
    | [] => acc
    | hd::tl => f(hd, fold_right(f, tl, acc)) end in


666
LSP: Prelude: String parsed successfully
LSP: Prelude: Info map generated successfully
Debug: true, Constrain: Types
LSP: Init: Recieved string: # Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)




























































































































































































































































LSP: Init: String parsed successfully
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: >( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {go: ((?, ?) -> [?]), filter: (((Int -> Bool), [Int]) -> [Int]), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: 
  LSP: Info: ALL errors:Error in term:
  p
Nature of error: type ((Int -> Bool), [Int]) is not consistent with arrow type    
Error in term:
  p
Nature of error: Variable p is not bound    
Error in term:
  p
Nature of error: Variable p is not bound
  LSP: Info: BidiCtx: Cls: Let expression
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent: Root
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: [?]
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: :: @
  LSP: Concave: Backpack: 
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new_tokens ::= whitespace | "," | "::" | "@"
root ::= new_tokens

Top 20 Logits:

:20.2744
#:15.1603
let:14.5754
##:14.399
 :13.1714
    :12.5603
################:12.5156
  :12.4845
   :12.2432
####:12.0897
in:11.9458
/*:11.8787
```:11.7449
[:11.4697
//:11.4256
                :11.3314
(:11.2026
{:11.1196
        :11.1164
end:11.0689
########:11.0107

================
# Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)






























































































































































































































































LSP: Prelude: Recieved string: ### List ###

# Add an element to the front of a list. #
let cons: (Int, [Int]) -> [Int] = fun x, xs -> x::xs in

# Determine the length of a list. #
let length: [Int] -> Int =
  fun xs ->
    case xs
    | [] => 0
    | _::xs => 1 + length(xs) end in

# Extract the first element of a list. #
let hd: [Int] -> Option =
  fun l ->
    case l
    | [] => None
    | x::xs => Some(x) end in

# Extract the rest of the list. #
let tl: [Int] -> [Int] =
  fun l ->
    case l
    | [] => []
    | x::xs => xs end in

# Determine if a list is empty. #
let is_empty: [Int] -> Bool =
  fun xs ->
    case xs
    | [] => true
    | _::_ => false end in

# Return the element at the index. #
let nth: ([Int], Int) -> Option =
  fun xs, n ->
    case xs, n
    | x::_, 0 => Some(x)
    | _::xs, n => nth(xs, n - 1)
    | [], _ => None end in

# Reverse a List. #
let rev: [Int] -> [Int] =
fun l -> 
let go: ([Int], [Int]) -> [Int] =
  fun xs, acc -> 
    case xs 
    | [] => acc 
    | x::xs => go(xs, x::acc) end in
go(l, []) in

# Check if two lists are equal #
let equal: ([Int], [Int]) -> Bool =
    fun p, xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => x == y && equal(xs, ys)
    | _ => false end
in

# Initialize a list with a given length using an initializer function #
let init: (Int, Int -> Int) -> [Int] =
    fun len, f ->
        let go: (Int, [Int]) -> [Int] =
        fun idx, xs ->
            if idx < len 
            then go(idx + 1, xs @ [f(idx)])   
            else xs
        in
        go(0, [])
in

# Reduce a list from the left. #
let fold_left: ((Int, Int) -> Int, Int, [Int]) -> Int =
  fun f, acc, xs ->
    case xs 
    | [] => acc
    | hd::tl => fold_left(f, f(acc, hd), tl) end in

# Reduce a list from the right. #
let fold_right: ((Int, Int) -> Int, [Int], Int) -> Int =
  fun f, xs, acc ->
    case xs
    | [] => acc
    | hd::tl => f(hd, fold_right(f, tl, acc)) end in


666
LSP: Prelude: String parsed successfully
LSP: Prelude: Info map generated successfully
Debug: true, Constrain: Types
LSP: Init: Recieved string: # Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)





























































































































































































































































LSP: Init: String parsed successfully
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: >( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {go: ((?, ?) -> [?]), filter: (((Int -> Bool), [Int]) -> [Int]), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: 
  LSP: Info: ALL errors:Error in term:
  p
Nature of error: type ((Int -> Bool), [Int]) is not consistent with arrow type    
Error in term:
  p
Nature of error: Variable p is not bound    
Error in term:
  p
Nature of error: Variable p is not bound
  LSP: Info: BidiCtx: Cls: Let expression
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent: Root
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: [?]
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: :: @
  LSP: Concave: Backpack: 
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new_tokens ::= whitespace | "," | "::" | "@"
root ::= new_tokens

Top 20 Logits:

:20.2812
#:15.1556
let:14.5698
##:14.3744
 :13.1759
    :12.5707
################:12.5065
  :12.4909
   :12.2414
####:12.0755
in:11.9972
/*:11.881
```:11.7279
[:11.4613
//:11.4258
                :11.3374
(:11.2042
        :11.121
{:11.118
end:11.0976
########:10.9957

================
# Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)































































































































































































































































LSP: Prelude: Recieved string: ### List ###

# Add an element to the front of a list. #
let cons: (Int, [Int]) -> [Int] = fun x, xs -> x::xs in

# Determine the length of a list. #
let length: [Int] -> Int =
  fun xs ->
    case xs
    | [] => 0
    | _::xs => 1 + length(xs) end in

# Extract the first element of a list. #
let hd: [Int] -> Option =
  fun l ->
    case l
    | [] => None
    | x::xs => Some(x) end in

# Extract the rest of the list. #
let tl: [Int] -> [Int] =
  fun l ->
    case l
    | [] => []
    | x::xs => xs end in

# Determine if a list is empty. #
let is_empty: [Int] -> Bool =
  fun xs ->
    case xs
    | [] => true
    | _::_ => false end in

# Return the element at the index. #
let nth: ([Int], Int) -> Option =
  fun xs, n ->
    case xs, n
    | x::_, 0 => Some(x)
    | _::xs, n => nth(xs, n - 1)
    | [], _ => None end in

# Reverse a List. #
let rev: [Int] -> [Int] =
fun l -> 
let go: ([Int], [Int]) -> [Int] =
  fun xs, acc -> 
    case xs 
    | [] => acc 
    | x::xs => go(xs, x::acc) end in
go(l, []) in

# Check if two lists are equal #
let equal: ([Int], [Int]) -> Bool =
    fun p, xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => x == y && equal(xs, ys)
    | _ => false end
in

# Initialize a list with a given length using an initializer function #
let init: (Int, Int -> Int) -> [Int] =
    fun len, f ->
        let go: (Int, [Int]) -> [Int] =
        fun idx, xs ->
            if idx < len 
            then go(idx + 1, xs @ [f(idx)])   
            else xs
        in
        go(0, [])
in

# Reduce a list from the left. #
let fold_left: ((Int, Int) -> Int, Int, [Int]) -> Int =
  fun f, acc, xs ->
    case xs 
    | [] => acc
    | hd::tl => fold_left(f, f(acc, hd), tl) end in

# Reduce a list from the right. #
let fold_right: ((Int, Int) -> Int, [Int], Int) -> Int =
  fun f, xs, acc ->
    case xs
    | [] => acc
    | hd::tl => f(hd, fold_right(f, tl, acc)) end in


666
LSP: Prelude: String parsed successfully
LSP: Prelude: Info map generated successfully
Debug: true, Constrain: Types
LSP: Init: Recieved string: # Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)






























































































































































































































































LSP: Init: String parsed successfully
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: >( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {go: ((?, ?) -> [?]), filter: (((Int -> Bool), [Int]) -> [Int]), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: 
  LSP: Info: ALL errors:Error in term:
  p
Nature of error: type ((Int -> Bool), [Int]) is not consistent with arrow type    
Error in term:
  p
Nature of error: Variable p is not bound    
Error in term:
  p
Nature of error: Variable p is not bound
  LSP: Info: BidiCtx: Cls: Let expression
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent: Root
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: [?]
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: :: @
  LSP: Concave: Backpack: 
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new_tokens ::= whitespace | "," | "::" | "@"
root ::= new_tokens

Top 20 Logits:

:20.2865
#:15.1614
let:14.5707
##:14.3491
 :13.1805
    :12.5756
################:12.4972
  :12.4902
   :12.2406
####:12.0639
in:12.0231
/*:11.8845
```:11.7137
[:11.4599
//:11.4274
                :11.3388
(:11.2159
{:11.1229
        :11.1194
end:11.1063
def:10.9839

================
# Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)
































































































































































































































































LSP: Prelude: Recieved string: ### List ###

# Add an element to the front of a list. #
let cons: (Int, [Int]) -> [Int] = fun x, xs -> x::xs in

# Determine the length of a list. #
let length: [Int] -> Int =
  fun xs ->
    case xs
    | [] => 0
    | _::xs => 1 + length(xs) end in

# Extract the first element of a list. #
let hd: [Int] -> Option =
  fun l ->
    case l
    | [] => None
    | x::xs => Some(x) end in

# Extract the rest of the list. #
let tl: [Int] -> [Int] =
  fun l ->
    case l
    | [] => []
    | x::xs => xs end in

# Determine if a list is empty. #
let is_empty: [Int] -> Bool =
  fun xs ->
    case xs
    | [] => true
    | _::_ => false end in

# Return the element at the index. #
let nth: ([Int], Int) -> Option =
  fun xs, n ->
    case xs, n
    | x::_, 0 => Some(x)
    | _::xs, n => nth(xs, n - 1)
    | [], _ => None end in

# Reverse a List. #
let rev: [Int] -> [Int] =
fun l -> 
let go: ([Int], [Int]) -> [Int] =
  fun xs, acc -> 
    case xs 
    | [] => acc 
    | x::xs => go(xs, x::acc) end in
go(l, []) in

# Check if two lists are equal #
let equal: ([Int], [Int]) -> Bool =
    fun p, xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => x == y && equal(xs, ys)
    | _ => false end
in

# Initialize a list with a given length using an initializer function #
let init: (Int, Int -> Int) -> [Int] =
    fun len, f ->
        let go: (Int, [Int]) -> [Int] =
        fun idx, xs ->
            if idx < len 
            then go(idx + 1, xs @ [f(idx)])   
            else xs
        in
        go(0, [])
in

# Reduce a list from the left. #
let fold_left: ((Int, Int) -> Int, Int, [Int]) -> Int =
  fun f, acc, xs ->
    case xs 
    | [] => acc
    | hd::tl => fold_left(f, f(acc, hd), tl) end in

# Reduce a list from the right. #
let fold_right: ((Int, Int) -> Int, [Int], Int) -> Int =
  fun f, xs, acc ->
    case xs
    | [] => acc
    | hd::tl => f(hd, fold_right(f, tl, acc)) end in


666
LSP: Prelude: String parsed successfully
LSP: Prelude: Info map generated successfully
Debug: true, Constrain: Types
LSP: Init: Recieved string: # Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)































































































































































































































































LSP: Init: String parsed successfully
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: >( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {go: ((?, ?) -> [?]), filter: (((Int -> Bool), [Int]) -> [Int]), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: 
  LSP: Info: ALL errors:Error in term:
  p
Nature of error: Variable p is not bound    
Error in term:
  p
Nature of error: type ((Int -> Bool), [Int]) is not consistent with arrow type    
Error in term:
  p
Nature of error: Variable p is not bound
  LSP: Info: BidiCtx: Cls: Let expression
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent: Root
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: [?]
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: :: @
  LSP: Concave: Backpack: 
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new_tokens ::= whitespace | "," | "::" | "@"
root ::= new_tokens

Top 20 Logits:

:20.2926
#:15.1735
let:14.577
##:14.3369
 :13.1822
    :12.574
################:12.4919
  :12.4816
   :12.2393
####:12.0614
in:12.0076
/*:11.8842
```:11.7103
[:11.4684
//:11.4272
                :11.3355
(:11.2305
{:11.131
        :11.1129
end:11.0857
########:10.9757

================
# Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)

































































































































































































































































LSP: Prelude: Recieved string: ### List ###

# Add an element to the front of a list. #
let cons: (Int, [Int]) -> [Int] = fun x, xs -> x::xs in

# Determine the length of a list. #
let length: [Int] -> Int =
  fun xs ->
    case xs
    | [] => 0
    | _::xs => 1 + length(xs) end in

# Extract the first element of a list. #
let hd: [Int] -> Option =
  fun l ->
    case l
    | [] => None
    | x::xs => Some(x) end in

# Extract the rest of the list. #
let tl: [Int] -> [Int] =
  fun l ->
    case l
    | [] => []
    | x::xs => xs end in

# Determine if a list is empty. #
let is_empty: [Int] -> Bool =
  fun xs ->
    case xs
    | [] => true
    | _::_ => false end in

# Return the element at the index. #
let nth: ([Int], Int) -> Option =
  fun xs, n ->
    case xs, n
    | x::_, 0 => Some(x)
    | _::xs, n => nth(xs, n - 1)
    | [], _ => None end in

# Reverse a List. #
let rev: [Int] -> [Int] =
fun l -> 
let go: ([Int], [Int]) -> [Int] =
  fun xs, acc -> 
    case xs 
    | [] => acc 
    | x::xs => go(xs, x::acc) end in
go(l, []) in

# Check if two lists are equal #
let equal: ([Int], [Int]) -> Bool =
    fun p, xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => x == y && equal(xs, ys)
    | _ => false end
in

# Initialize a list with a given length using an initializer function #
let init: (Int, Int -> Int) -> [Int] =
    fun len, f ->
        let go: (Int, [Int]) -> [Int] =
        fun idx, xs ->
            if idx < len 
            then go(idx + 1, xs @ [f(idx)])   
            else xs
        in
        go(0, [])
in

# Reduce a list from the left. #
let fold_left: ((Int, Int) -> Int, Int, [Int]) -> Int =
  fun f, acc, xs ->
    case xs 
    | [] => acc
    | hd::tl => fold_left(f, f(acc, hd), tl) end in

# Reduce a list from the right. #
let fold_right: ((Int, Int) -> Int, [Int], Int) -> Int =
  fun f, xs, acc ->
    case xs
    | [] => acc
    | hd::tl => f(hd, fold_right(f, tl, acc)) end in


666
LSP: Prelude: String parsed successfully
LSP: Prelude: Info map generated successfully
Debug: true, Constrain: Types
LSP: Init: Recieved string: # Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)
































































































































































































































































LSP: Init: String parsed successfully
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: >( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {go: ((?, ?) -> [?]), filter: (((Int -> Bool), [Int]) -> [Int]), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: 
  LSP: Info: ALL errors:Error in term:
  p
Nature of error: type ((Int -> Bool), [Int]) is not consistent with arrow type    
Error in term:
  p
Nature of error: Variable p is not bound    
Error in term:
  p
Nature of error: Variable p is not bound
  LSP: Info: BidiCtx: Cls: Let expression
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent: Root
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: [?]
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: :: @
  LSP: Concave: Backpack: 
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new_tokens ::= whitespace | "," | "::" | "@"
root ::= new_tokens

Top 20 Logits:

:20.3005
#:15.1846
let:14.5863
##:14.3423
 :13.1819
    :12.569
################:12.4934
  :12.4713
   :12.2387
####:12.0684
in:11.9719
/*:11.876
```:11.7179
[:11.4821
//:11.422
                :11.3313
(:11.2385
{:11.1379
        :11.1062
end:11.0511
########:10.9804

================
# Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)


































































































































































































































































LSP: Prelude: Recieved string: ### List ###

# Add an element to the front of a list. #
let cons: (Int, [Int]) -> [Int] = fun x, xs -> x::xs in

# Determine the length of a list. #
let length: [Int] -> Int =
  fun xs ->
    case xs
    | [] => 0
    | _::xs => 1 + length(xs) end in

# Extract the first element of a list. #
let hd: [Int] -> Option =
  fun l ->
    case l
    | [] => None
    | x::xs => Some(x) end in

# Extract the rest of the list. #
let tl: [Int] -> [Int] =
  fun l ->
    case l
    | [] => []
    | x::xs => xs end in

# Determine if a list is empty. #
let is_empty: [Int] -> Bool =
  fun xs ->
    case xs
    | [] => true
    | _::_ => false end in

# Return the element at the index. #
let nth: ([Int], Int) -> Option =
  fun xs, n ->
    case xs, n
    | x::_, 0 => Some(x)
    | _::xs, n => nth(xs, n - 1)
    | [], _ => None end in

# Reverse a List. #
let rev: [Int] -> [Int] =
fun l -> 
let go: ([Int], [Int]) -> [Int] =
  fun xs, acc -> 
    case xs 
    | [] => acc 
    | x::xs => go(xs, x::acc) end in
go(l, []) in

# Check if two lists are equal #
let equal: ([Int], [Int]) -> Bool =
    fun p, xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => x == y && equal(xs, ys)
    | _ => false end
in

# Initialize a list with a given length using an initializer function #
let init: (Int, Int -> Int) -> [Int] =
    fun len, f ->
        let go: (Int, [Int]) -> [Int] =
        fun idx, xs ->
            if idx < len 
            then go(idx + 1, xs @ [f(idx)])   
            else xs
        in
        go(0, [])
in

# Reduce a list from the left. #
let fold_left: ((Int, Int) -> Int, Int, [Int]) -> Int =
  fun f, acc, xs ->
    case xs 
    | [] => acc
    | hd::tl => fold_left(f, f(acc, hd), tl) end in

# Reduce a list from the right. #
let fold_right: ((Int, Int) -> Int, [Int], Int) -> Int =
  fun f, xs, acc ->
    case xs
    | [] => acc
    | hd::tl => f(hd, fold_right(f, tl, acc)) end in


666
LSP: Prelude: String parsed successfully
LSP: Prelude: Info map generated successfully
Debug: true, Constrain: Types
LSP: Init: Recieved string: # Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)

































































































































































































































































LSP: Init: String parsed successfully
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: >( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {go: ((?, ?) -> [?]), filter: (((Int -> Bool), [Int]) -> [Int]), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: 
  LSP: Info: ALL errors:Error in term:
  p
Nature of error: type ((Int -> Bool), [Int]) is not consistent with arrow type    
Error in term:
  p
Nature of error: Variable p is not bound    
Error in term:
  p
Nature of error: Variable p is not bound
  LSP: Info: BidiCtx: Cls: Let expression
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent: Root
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: [?]
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: :: @
  LSP: Concave: Backpack: 
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new_tokens ::= whitespace | "," | "::" | "@"
root ::= new_tokens

Top 20 Logits:

:20.3086
#:15.189
let:14.5944
##:14.3566
 :13.1829
    :12.5665
################:12.5004
  :12.4669
   :12.2417
####:12.0782
in:11.9493
/*:11.864
```:11.7277
[:11.4916
//:11.4133
                :11.3298
(:11.2378
{:11.1403
        :11.1039
end:11.0263
########:10.9899

================
# Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)



































































































































































































































































LSP: Prelude: Recieved string: ### List ###

# Add an element to the front of a list. #
let cons: (Int, [Int]) -> [Int] = fun x, xs -> x::xs in

# Determine the length of a list. #
let length: [Int] -> Int =
  fun xs ->
    case xs
    | [] => 0
    | _::xs => 1 + length(xs) end in

# Extract the first element of a list. #
let hd: [Int] -> Option =
  fun l ->
    case l
    | [] => None
    | x::xs => Some(x) end in

# Extract the rest of the list. #
let tl: [Int] -> [Int] =
  fun l ->
    case l
    | [] => []
    | x::xs => xs end in

# Determine if a list is empty. #
let is_empty: [Int] -> Bool =
  fun xs ->
    case xs
    | [] => true
    | _::_ => false end in

# Return the element at the index. #
let nth: ([Int], Int) -> Option =
  fun xs, n ->
    case xs, n
    | x::_, 0 => Some(x)
    | _::xs, n => nth(xs, n - 1)
    | [], _ => None end in

# Reverse a List. #
let rev: [Int] -> [Int] =
fun l -> 
let go: ([Int], [Int]) -> [Int] =
  fun xs, acc -> 
    case xs 
    | [] => acc 
    | x::xs => go(xs, x::acc) end in
go(l, []) in

# Check if two lists are equal #
let equal: ([Int], [Int]) -> Bool =
    fun p, xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => x == y && equal(xs, ys)
    | _ => false end
in

# Initialize a list with a given length using an initializer function #
let init: (Int, Int -> Int) -> [Int] =
    fun len, f ->
        let go: (Int, [Int]) -> [Int] =
        fun idx, xs ->
            if idx < len 
            then go(idx + 1, xs @ [f(idx)])   
            else xs
        in
        go(0, [])
in

# Reduce a list from the left. #
let fold_left: ((Int, Int) -> Int, Int, [Int]) -> Int =
  fun f, acc, xs ->
    case xs 
    | [] => acc
    | hd::tl => fold_left(f, f(acc, hd), tl) end in

# Reduce a list from the right. #
let fold_right: ((Int, Int) -> Int, [Int], Int) -> Int =
  fun f, xs, acc ->
    case xs
    | [] => acc
    | hd::tl => f(hd, fold_right(f, tl, acc)) end in


666
LSP: Prelude: String parsed successfully
LSP: Prelude: Info map generated successfully
Debug: true, Constrain: Types
LSP: Init: Recieved string: # Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)


































































































































































































































































LSP: Init: String parsed successfully
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: >( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {go: ((?, ?) -> [?]), filter: (((Int -> Bool), [Int]) -> [Int]), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: 
  LSP: Info: ALL errors:Error in term:
  p
Nature of error: type ((Int -> Bool), [Int]) is not consistent with arrow type    
Error in term:
  p
Nature of error: Variable p is not bound    
Error in term:
  p
Nature of error: Variable p is not bound
  LSP: Info: BidiCtx: Cls: Let expression
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent: Root
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: [?]
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: :: @
  LSP: Concave: Backpack: 
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new_tokens ::= whitespace | "," | "::" | "@"
root ::= new_tokens

Top 20 Logits:

:20.3119
#:15.1839
let:14.5952
##:14.3681
 :13.1848
    :12.5705
################:12.5087
  :12.4689
   :12.2467
####:12.084
in:11.9509
/*:11.8557
```:11.7304
[:11.4913
//:11.4049
                :11.3288
(:11.231
{:11.138
        :11.1057
end:11.0183
########:10.9981

================
# Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)




































































































































































































































































LSP: Prelude: Recieved string: ### List ###

# Add an element to the front of a list. #
let cons: (Int, [Int]) -> [Int] = fun x, xs -> x::xs in

# Determine the length of a list. #
let length: [Int] -> Int =
  fun xs ->
    case xs
    | [] => 0
    | _::xs => 1 + length(xs) end in

# Extract the first element of a list. #
let hd: [Int] -> Option =
  fun l ->
    case l
    | [] => None
    | x::xs => Some(x) end in

# Extract the rest of the list. #
let tl: [Int] -> [Int] =
  fun l ->
    case l
    | [] => []
    | x::xs => xs end in

# Determine if a list is empty. #
let is_empty: [Int] -> Bool =
  fun xs ->
    case xs
    | [] => true
    | _::_ => false end in

# Return the element at the index. #
let nth: ([Int], Int) -> Option =
  fun xs, n ->
    case xs, n
    | x::_, 0 => Some(x)
    | _::xs, n => nth(xs, n - 1)
    | [], _ => None end in

# Reverse a List. #
let rev: [Int] -> [Int] =
fun l -> 
let go: ([Int], [Int]) -> [Int] =
  fun xs, acc -> 
    case xs 
    | [] => acc 
    | x::xs => go(xs, x::acc) end in
go(l, []) in

# Check if two lists are equal #
let equal: ([Int], [Int]) -> Bool =
    fun p, xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => x == y && equal(xs, ys)
    | _ => false end
in

# Initialize a list with a given length using an initializer function #
let init: (Int, Int -> Int) -> [Int] =
    fun len, f ->
        let go: (Int, [Int]) -> [Int] =
        fun idx, xs ->
            if idx < len 
            then go(idx + 1, xs @ [f(idx)])   
            else xs
        in
        go(0, [])
in

# Reduce a list from the left. #
let fold_left: ((Int, Int) -> Int, Int, [Int]) -> Int =
  fun f, acc, xs ->
    case xs 
    | [] => acc
    | hd::tl => fold_left(f, f(acc, hd), tl) end in

# Reduce a list from the right. #
let fold_right: ((Int, Int) -> Int, [Int], Int) -> Int =
  fun f, xs, acc ->
    case xs
    | [] => acc
    | hd::tl => f(hd, fold_right(f, tl, acc)) end in


666
LSP: Prelude: String parsed successfully
LSP: Prelude: Info map generated successfully
Debug: true, Constrain: Types
LSP: Init: Recieved string: # Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)



































































































































































































































































LSP: Init: String parsed successfully
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: >( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {go: ((?, ?) -> [?]), filter: (((Int -> Bool), [Int]) -> [Int]), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: 
  LSP: Info: ALL errors:Error in term:
  p
Nature of error: Variable p is not bound    
Error in term:
  p
Nature of error: type ((Int -> Bool), [Int]) is not consistent with arrow type    
Error in term:
  p
Nature of error: Variable p is not bound
  LSP: Info: BidiCtx: Cls: Let expression
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent: Root
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: [?]
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: :: @
  LSP: Concave: Backpack: 
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new_tokens ::= whitespace | "," | "::" | "@"
root ::= new_tokens

Top 20 Logits:

:20.3097
#:15.1738
let:14.5899
##:14.3721
 :13.1871
    :12.5811
################:12.5148
  :12.4755
   :12.2513
####:12.0853
in:11.9686
/*:11.8538
```:11.7246
[:11.4849
//:11.3998
                :11.326
(:11.2263
{:11.1358
        :11.1105
end:11.0217
########:11.0017

================
# Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)





































































































































































































































































LSP: Prelude: Recieved string: ### List ###

# Add an element to the front of a list. #
let cons: (Int, [Int]) -> [Int] = fun x, xs -> x::xs in

# Determine the length of a list. #
let length: [Int] -> Int =
  fun xs ->
    case xs
    | [] => 0
    | _::xs => 1 + length(xs) end in

# Extract the first element of a list. #
let hd: [Int] -> Option =
  fun l ->
    case l
    | [] => None
    | x::xs => Some(x) end in

# Extract the rest of the list. #
let tl: [Int] -> [Int] =
  fun l ->
    case l
    | [] => []
    | x::xs => xs end in

# Determine if a list is empty. #
let is_empty: [Int] -> Bool =
  fun xs ->
    case xs
    | [] => true
    | _::_ => false end in

# Return the element at the index. #
let nth: ([Int], Int) -> Option =
  fun xs, n ->
    case xs, n
    | x::_, 0 => Some(x)
    | _::xs, n => nth(xs, n - 1)
    | [], _ => None end in

# Reverse a List. #
let rev: [Int] -> [Int] =
fun l -> 
let go: ([Int], [Int]) -> [Int] =
  fun xs, acc -> 
    case xs 
    | [] => acc 
    | x::xs => go(xs, x::acc) end in
go(l, []) in

# Check if two lists are equal #
let equal: ([Int], [Int]) -> Bool =
    fun p, xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => x == y && equal(xs, ys)
    | _ => false end
in

# Initialize a list with a given length using an initializer function #
let init: (Int, Int -> Int) -> [Int] =
    fun len, f ->
        let go: (Int, [Int]) -> [Int] =
        fun idx, xs ->
            if idx < len 
            then go(idx + 1, xs @ [f(idx)])   
            else xs
        in
        go(0, [])
in

# Reduce a list from the left. #
let fold_left: ((Int, Int) -> Int, Int, [Int]) -> Int =
  fun f, acc, xs ->
    case xs 
    | [] => acc
    | hd::tl => fold_left(f, f(acc, hd), tl) end in

# Reduce a list from the right. #
let fold_right: ((Int, Int) -> Int, [Int], Int) -> Int =
  fun f, xs, acc ->
    case xs
    | [] => acc
    | hd::tl => f(hd, fold_right(f, tl, acc)) end in


666
LSP: Prelude: String parsed successfully
LSP: Prelude: Info map generated successfully
Debug: true, Constrain: Types
LSP: Init: Recieved string: # Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)




































































































































































































































































LSP: Init: String parsed successfully
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: >( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {go: ((?, ?) -> [?]), filter: (((Int -> Bool), [Int]) -> [Int]), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: 
  LSP: Info: ALL errors:Error in term:
  p
Nature of error: type ((Int -> Bool), [Int]) is not consistent with arrow type    
Error in term:
  p
Nature of error: Variable p is not bound    
Error in term:
  p
Nature of error: Variable p is not bound
  LSP: Info: BidiCtx: Cls: Let expression
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent: Root
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: [?]
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: :: @
  LSP: Concave: Backpack: 
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new_tokens ::= whitespace | "," | "::" | "@"
root ::= new_tokens

Top 20 Logits:

:20.3061
#:15.1665
let:14.5839
##:14.3705
 :13.1899
    :12.5923
################:12.5156
  :12.4832
   :12.2534
####:12.0846
in:11.9925
/*:11.8553
```:11.7179
[:11.4793
//:11.3984
                :11.3217
(:11.2291
{:11.1391
        :11.1152
end:11.0264
########:11.0001

================
# Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)






































































































































































































































































LSP: Prelude: Recieved string: ### List ###

# Add an element to the front of a list. #
let cons: (Int, [Int]) -> [Int] = fun x, xs -> x::xs in

# Determine the length of a list. #
let length: [Int] -> Int =
  fun xs ->
    case xs
    | [] => 0
    | _::xs => 1 + length(xs) end in

# Extract the first element of a list. #
let hd: [Int] -> Option =
  fun l ->
    case l
    | [] => None
    | x::xs => Some(x) end in

# Extract the rest of the list. #
let tl: [Int] -> [Int] =
  fun l ->
    case l
    | [] => []
    | x::xs => xs end in

# Determine if a list is empty. #
let is_empty: [Int] -> Bool =
  fun xs ->
    case xs
    | [] => true
    | _::_ => false end in

# Return the element at the index. #
let nth: ([Int], Int) -> Option =
  fun xs, n ->
    case xs, n
    | x::_, 0 => Some(x)
    | _::xs, n => nth(xs, n - 1)
    | [], _ => None end in

# Reverse a List. #
let rev: [Int] -> [Int] =
fun l -> 
let go: ([Int], [Int]) -> [Int] =
  fun xs, acc -> 
    case xs 
    | [] => acc 
    | x::xs => go(xs, x::acc) end in
go(l, []) in

# Check if two lists are equal #
let equal: ([Int], [Int]) -> Bool =
    fun p, xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => x == y && equal(xs, ys)
    | _ => false end
in

# Initialize a list with a given length using an initializer function #
let init: (Int, Int -> Int) -> [Int] =
    fun len, f ->
        let go: (Int, [Int]) -> [Int] =
        fun idx, xs ->
            if idx < len 
            then go(idx + 1, xs @ [f(idx)])   
            else xs
        in
        go(0, [])
in

# Reduce a list from the left. #
let fold_left: ((Int, Int) -> Int, Int, [Int]) -> Int =
  fun f, acc, xs ->
    case xs 
    | [] => acc
    | hd::tl => fold_left(f, f(acc, hd), tl) end in

# Reduce a list from the right. #
let fold_right: ((Int, Int) -> Int, [Int], Int) -> Int =
  fun f, xs, acc ->
    case xs
    | [] => acc
    | hd::tl => f(hd, fold_right(f, tl, acc)) end in


666
LSP: Prelude: String parsed successfully
LSP: Prelude: Info map generated successfully
Debug: true, Constrain: Types
LSP: Init: Recieved string: # Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)





































































































































































































































































LSP: Init: String parsed successfully
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: >( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {go: ((?, ?) -> [?]), filter: (((Int -> Bool), [Int]) -> [Int]), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: 
  LSP: Info: ALL errors:Error in term:
  p
Nature of error: Variable p is not bound    
Error in term:
  p
Nature of error: type ((Int -> Bool), [Int]) is not consistent with arrow type    
Error in term:
  p
Nature of error: Variable p is not bound
  LSP: Info: BidiCtx: Cls: Let expression
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent: Root
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: [?]
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: :: @
  LSP: Concave: Backpack: 
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new_tokens ::= whitespace | "," | "::" | "@"
root ::= new_tokens

Top 20 Logits:

:20.3045
#:15.1641
let:14.5807
##:14.3673
 :13.1911
    :12.5956
################:12.5104
  :12.4859
   :12.2509
####:12.084
in:12.0153
/*:11.8561
```:11.7157
[:11.4797
//:11.399
                :11.3166
(:11.2388
{:11.147
        :11.1159
end:11.0227
########:10.9949

================
# Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)







































































































































































































































































LSP: Prelude: Recieved string: ### List ###

# Add an element to the front of a list. #
let cons: (Int, [Int]) -> [Int] = fun x, xs -> x::xs in

# Determine the length of a list. #
let length: [Int] -> Int =
  fun xs ->
    case xs
    | [] => 0
    | _::xs => 1 + length(xs) end in

# Extract the first element of a list. #
let hd: [Int] -> Option =
  fun l ->
    case l
    | [] => None
    | x::xs => Some(x) end in

# Extract the rest of the list. #
let tl: [Int] -> [Int] =
  fun l ->
    case l
    | [] => []
    | x::xs => xs end in

# Determine if a list is empty. #
let is_empty: [Int] -> Bool =
  fun xs ->
    case xs
    | [] => true
    | _::_ => false end in

# Return the element at the index. #
let nth: ([Int], Int) -> Option =
  fun xs, n ->
    case xs, n
    | x::_, 0 => Some(x)
    | _::xs, n => nth(xs, n - 1)
    | [], _ => None end in

# Reverse a List. #
let rev: [Int] -> [Int] =
fun l -> 
let go: ([Int], [Int]) -> [Int] =
  fun xs, acc -> 
    case xs 
    | [] => acc 
    | x::xs => go(xs, x::acc) end in
go(l, []) in

# Check if two lists are equal #
let equal: ([Int], [Int]) -> Bool =
    fun p, xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => x == y && equal(xs, ys)
    | _ => false end
in

# Initialize a list with a given length using an initializer function #
let init: (Int, Int -> Int) -> [Int] =
    fun len, f ->
        let go: (Int, [Int]) -> [Int] =
        fun idx, xs ->
            if idx < len 
            then go(idx + 1, xs @ [f(idx)])   
            else xs
        in
        go(0, [])
in

# Reduce a list from the left. #
let fold_left: ((Int, Int) -> Int, Int, [Int]) -> Int =
  fun f, acc, xs ->
    case xs 
    | [] => acc
    | hd::tl => fold_left(f, f(acc, hd), tl) end in

# Reduce a list from the right. #
let fold_right: ((Int, Int) -> Int, [Int], Int) -> Int =
  fun f, xs, acc ->
    case xs
    | [] => acc
    | hd::tl => f(hd, fold_right(f, tl, acc)) end in


666
LSP: Prelude: String parsed successfully
LSP: Prelude: Info map generated successfully
Debug: true, Constrain: Types
LSP: Init: Recieved string: # Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)






































































































































































































































































LSP: Init: String parsed successfully
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: >( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {go: ((?, ?) -> [?]), filter: (((Int -> Bool), [Int]) -> [Int]), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: 
  LSP: Info: ALL errors:Error in term:
  p
Nature of error: Variable p is not bound    
Error in term:
  p
Nature of error: type ((Int -> Bool), [Int]) is not consistent with arrow type    
Error in term:
  p
Nature of error: Variable p is not bound
  LSP: Info: BidiCtx: Cls: Let expression
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent: Root
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: [?]
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: :: @
  LSP: Concave: Backpack: 
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new_tokens ::= whitespace | "," | "::" | "@"
root ::= new_tokens

Top 20 Logits:

:20.3075
#:15.1641
let:14.5838
##:14.3642
 :13.1894
    :12.5909
################:12.5012
  :12.4829
   :12.2455
####:12.0828
in:12.0362
/*:11.8543
```:11.7181
[:11.4848
//:11.4001
                :11.3127
(:11.2489
{:11.1552
        :11.1128
end:11.013
########:10.9876

================
# Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)








































































































































































































































































LSP: Prelude: Recieved string: ### List ###

# Add an element to the front of a list. #
let cons: (Int, [Int]) -> [Int] = fun x, xs -> x::xs in

# Determine the length of a list. #
let length: [Int] -> Int =
  fun xs ->
    case xs
    | [] => 0
    | _::xs => 1 + length(xs) end in

# Extract the first element of a list. #
let hd: [Int] -> Option =
  fun l ->
    case l
    | [] => None
    | x::xs => Some(x) end in

# Extract the rest of the list. #
let tl: [Int] -> [Int] =
  fun l ->
    case l
    | [] => []
    | x::xs => xs end in

# Determine if a list is empty. #
let is_empty: [Int] -> Bool =
  fun xs ->
    case xs
    | [] => true
    | _::_ => false end in

# Return the element at the index. #
let nth: ([Int], Int) -> Option =
  fun xs, n ->
    case xs, n
    | x::_, 0 => Some(x)
    | _::xs, n => nth(xs, n - 1)
    | [], _ => None end in

# Reverse a List. #
let rev: [Int] -> [Int] =
fun l -> 
let go: ([Int], [Int]) -> [Int] =
  fun xs, acc -> 
    case xs 
    | [] => acc 
    | x::xs => go(xs, x::acc) end in
go(l, []) in

# Check if two lists are equal #
let equal: ([Int], [Int]) -> Bool =
    fun p, xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => x == y && equal(xs, ys)
    | _ => false end
in

# Initialize a list with a given length using an initializer function #
let init: (Int, Int -> Int) -> [Int] =
    fun len, f ->
        let go: (Int, [Int]) -> [Int] =
        fun idx, xs ->
            if idx < len 
            then go(idx + 1, xs @ [f(idx)])   
            else xs
        in
        go(0, [])
in

# Reduce a list from the left. #
let fold_left: ((Int, Int) -> Int, Int, [Int]) -> Int =
  fun f, acc, xs ->
    case xs 
    | [] => acc
    | hd::tl => fold_left(f, f(acc, hd), tl) end in

# Reduce a list from the right. #
let fold_right: ((Int, Int) -> Int, [Int], Int) -> Int =
  fun f, xs, acc ->
    case xs
    | [] => acc
    | hd::tl => f(hd, fold_right(f, tl, acc)) end in


666
LSP: Prelude: String parsed successfully
LSP: Prelude: Info map generated successfully
Debug: true, Constrain: Types
LSP: Init: Recieved string: # Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)







































































































































































































































































LSP: Init: String parsed successfully
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: >( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {go: ((?, ?) -> [?]), filter: (((Int -> Bool), [Int]) -> [Int]), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: 
  LSP: Info: ALL errors:Error in term:
  p
Nature of error: Variable p is not bound    
Error in term:
  p
Nature of error: Variable p is not bound    
Error in term:
  p
Nature of error: type ((Int -> Bool), [Int]) is not consistent with arrow type
  LSP: Info: BidiCtx: Cls: Let expression
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent: Root
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: [?]
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: :: @
  LSP: Concave: Backpack: 
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new_tokens ::= whitespace | "," | "::" | "@"
root ::= new_tokens

Top 20 Logits:

:20.3127
#:15.1632
let:14.5916
##:14.3589
 :13.185
    :12.5834
################:12.4902
  :12.4782
   :12.2397
####:12.0777
in:12.0543
/*:11.8514
```:11.7188
[:11.4885
//:11.4019
                :11.3115
(:11.252
{:11.1611
        :11.1082
end:11.0044
########:10.9787

================
# Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)









































































































































































































































































LSP: Prelude: Recieved string: ### List ###

# Add an element to the front of a list. #
let cons: (Int, [Int]) -> [Int] = fun x, xs -> x::xs in

# Determine the length of a list. #
let length: [Int] -> Int =
  fun xs ->
    case xs
    | [] => 0
    | _::xs => 1 + length(xs) end in

# Extract the first element of a list. #
let hd: [Int] -> Option =
  fun l ->
    case l
    | [] => None
    | x::xs => Some(x) end in

# Extract the rest of the list. #
let tl: [Int] -> [Int] =
  fun l ->
    case l
    | [] => []
    | x::xs => xs end in

# Determine if a list is empty. #
let is_empty: [Int] -> Bool =
  fun xs ->
    case xs
    | [] => true
    | _::_ => false end in

# Return the element at the index. #
let nth: ([Int], Int) -> Option =
  fun xs, n ->
    case xs, n
    | x::_, 0 => Some(x)
    | _::xs, n => nth(xs, n - 1)
    | [], _ => None end in

# Reverse a List. #
let rev: [Int] -> [Int] =
fun l -> 
let go: ([Int], [Int]) -> [Int] =
  fun xs, acc -> 
    case xs 
    | [] => acc 
    | x::xs => go(xs, x::acc) end in
go(l, []) in

# Check if two lists are equal #
let equal: ([Int], [Int]) -> Bool =
    fun p, xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => x == y && equal(xs, ys)
    | _ => false end
in

# Initialize a list with a given length using an initializer function #
let init: (Int, Int -> Int) -> [Int] =
    fun len, f ->
        let go: (Int, [Int]) -> [Int] =
        fun idx, xs ->
            if idx < len 
            then go(idx + 1, xs @ [f(idx)])   
            else xs
        in
        go(0, [])
in

# Reduce a list from the left. #
let fold_left: ((Int, Int) -> Int, Int, [Int]) -> Int =
  fun f, acc, xs ->
    case xs 
    | [] => acc
    | hd::tl => fold_left(f, f(acc, hd), tl) end in

# Reduce a list from the right. #
let fold_right: ((Int, Int) -> Int, [Int], Int) -> Int =
  fun f, xs, acc ->
    case xs
    | [] => acc
    | hd::tl => f(hd, fold_right(f, tl, acc)) end in


666
LSP: Prelude: String parsed successfully
LSP: Prelude: Info map generated successfully
Debug: true, Constrain: Types
LSP: Init: Recieved string: # Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)








































































































































































































































































LSP: Init: String parsed successfully
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: >( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {go: ((?, ?) -> [?]), filter: (((Int -> Bool), [Int]) -> [Int]), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: 
  LSP: Info: ALL errors:Error in term:
  p
Nature of error: type ((Int -> Bool), [Int]) is not consistent with arrow type    
Error in term:
  p
Nature of error: Variable p is not bound    
Error in term:
  p
Nature of error: Variable p is not bound
  LSP: Info: BidiCtx: Cls: Let expression
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent: Root
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: [?]
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: :: @
  LSP: Concave: Backpack: 
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new_tokens ::= whitespace | "," | "::" | "@"
root ::= new_tokens

Top 20 Logits:

:20.316
#:15.1592
let:14.5978
##:14.35
 :13.1798
    :12.5778
################:12.4802
  :12.4751
   :12.2355
in:12.0729
####:12.0682
/*:11.8508
```:11.7115
[:11.4876
//:11.4055
                :11.3099
(:11.2458
{:11.1654
        :11.1032
end:11.0048
########:10.9693

================
# Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)










































































































































































































































































LSP: Prelude: Recieved string: ### List ###

# Add an element to the front of a list. #
let cons: (Int, [Int]) -> [Int] = fun x, xs -> x::xs in

# Determine the length of a list. #
let length: [Int] -> Int =
  fun xs ->
    case xs
    | [] => 0
    | _::xs => 1 + length(xs) end in

# Extract the first element of a list. #
let hd: [Int] -> Option =
  fun l ->
    case l
    | [] => None
    | x::xs => Some(x) end in

# Extract the rest of the list. #
let tl: [Int] -> [Int] =
  fun l ->
    case l
    | [] => []
    | x::xs => xs end in

# Determine if a list is empty. #
let is_empty: [Int] -> Bool =
  fun xs ->
    case xs
    | [] => true
    | _::_ => false end in

# Return the element at the index. #
let nth: ([Int], Int) -> Option =
  fun xs, n ->
    case xs, n
    | x::_, 0 => Some(x)
    | _::xs, n => nth(xs, n - 1)
    | [], _ => None end in

# Reverse a List. #
let rev: [Int] -> [Int] =
fun l -> 
let go: ([Int], [Int]) -> [Int] =
  fun xs, acc -> 
    case xs 
    | [] => acc 
    | x::xs => go(xs, x::acc) end in
go(l, []) in

# Check if two lists are equal #
let equal: ([Int], [Int]) -> Bool =
    fun p, xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => x == y && equal(xs, ys)
    | _ => false end
in

# Initialize a list with a given length using an initializer function #
let init: (Int, Int -> Int) -> [Int] =
    fun len, f ->
        let go: (Int, [Int]) -> [Int] =
        fun idx, xs ->
            if idx < len 
            then go(idx + 1, xs @ [f(idx)])   
            else xs
        in
        go(0, [])
in

# Reduce a list from the left. #
let fold_left: ((Int, Int) -> Int, Int, [Int]) -> Int =
  fun f, acc, xs ->
    case xs 
    | [] => acc
    | hd::tl => fold_left(f, f(acc, hd), tl) end in

# Reduce a list from the right. #
let fold_right: ((Int, Int) -> Int, [Int], Int) -> Int =
  fun f, xs, acc ->
    case xs
    | [] => acc
    | hd::tl => f(hd, fold_right(f, tl, acc)) end in


666
LSP: Prelude: String parsed successfully
LSP: Prelude: Info map generated successfully
Debug: true, Constrain: Types
LSP: Init: Recieved string: # Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)









































































































































































































































































LSP: Init: String parsed successfully
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: >( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {go: ((?, ?) -> [?]), filter: (((Int -> Bool), [Int]) -> [Int]), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: 
  LSP: Info: ALL errors:Error in term:
  p
Nature of error: Variable p is not bound    
Error in term:
  p
Nature of error: type ((Int -> Bool), [Int]) is not consistent with arrow type    
Error in term:
  p
Nature of error: Variable p is not bound
  LSP: Info: BidiCtx: Cls: Let expression
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent: Root
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: [?]
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: :: @
  LSP: Concave: Backpack: 
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new_tokens ::= whitespace | "," | "::" | "@"
root ::= new_tokens

Top 20 Logits:

:20.3167
#:15.1539
let:14.5997
##:14.3403
 :13.1761
    :12.5771
  :12.474
################:12.4735
   :12.234
in:12.0973
####:12.058
/*:11.8546
```:11.6973
[:11.4857
//:11.4102
                :11.3056
(:11.2362
{:11.1717
        :11.0995
end:11.0168
########:10.9627

================
# Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)











































































































































































































































































LSP: Prelude: Recieved string: ### List ###

# Add an element to the front of a list. #
let cons: (Int, [Int]) -> [Int] = fun x, xs -> x::xs in

# Determine the length of a list. #
let length: [Int] -> Int =
  fun xs ->
    case xs
    | [] => 0
    | _::xs => 1 + length(xs) end in

# Extract the first element of a list. #
let hd: [Int] -> Option =
  fun l ->
    case l
    | [] => None
    | x::xs => Some(x) end in

# Extract the rest of the list. #
let tl: [Int] -> [Int] =
  fun l ->
    case l
    | [] => []
    | x::xs => xs end in

# Determine if a list is empty. #
let is_empty: [Int] -> Bool =
  fun xs ->
    case xs
    | [] => true
    | _::_ => false end in

# Return the element at the index. #
let nth: ([Int], Int) -> Option =
  fun xs, n ->
    case xs, n
    | x::_, 0 => Some(x)
    | _::xs, n => nth(xs, n - 1)
    | [], _ => None end in

# Reverse a List. #
let rev: [Int] -> [Int] =
fun l -> 
let go: ([Int], [Int]) -> [Int] =
  fun xs, acc -> 
    case xs 
    | [] => acc 
    | x::xs => go(xs, x::acc) end in
go(l, []) in

# Check if two lists are equal #
let equal: ([Int], [Int]) -> Bool =
    fun p, xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => x == y && equal(xs, ys)
    | _ => false end
in

# Initialize a list with a given length using an initializer function #
let init: (Int, Int -> Int) -> [Int] =
    fun len, f ->
        let go: (Int, [Int]) -> [Int] =
        fun idx, xs ->
            if idx < len 
            then go(idx + 1, xs @ [f(idx)])   
            else xs
        in
        go(0, [])
in

# Reduce a list from the left. #
let fold_left: ((Int, Int) -> Int, Int, [Int]) -> Int =
  fun f, acc, xs ->
    case xs 
    | [] => acc
    | hd::tl => fold_left(f, f(acc, hd), tl) end in

# Reduce a list from the right. #
let fold_right: ((Int, Int) -> Int, [Int], Int) -> Int =
  fun f, xs, acc ->
    case xs
    | [] => acc
    | hd::tl => f(hd, fold_right(f, tl, acc)) end in


666
LSP: Prelude: String parsed successfully
LSP: Prelude: Info map generated successfully
Debug: true, Constrain: Types
LSP: Init: Recieved string: # Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)










































































































































































































































































LSP: Init: String parsed successfully
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: >( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {go: ((?, ?) -> [?]), filter: (((Int -> Bool), [Int]) -> [Int]), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: 
  LSP: Info: ALL errors:Error in term:
  p
Nature of error: type ((Int -> Bool), [Int]) is not consistent with arrow type    
Error in term:
  p
Nature of error: Variable p is not bound    
Error in term:
  p
Nature of error: Variable p is not bound
  LSP: Info: BidiCtx: Cls: Let expression
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent: Root
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: [?]
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: :: @
  LSP: Concave: Backpack: 
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new_tokens ::= whitespace | "," | "::" | "@"
root ::= new_tokens

Top 20 Logits:

:20.3174
#:15.1514
let:14.5961
##:14.3327
 :13.1763
    :12.5807
  :12.4741
################:12.4717
   :12.2362
in:12.1236
####:12.0517
/*:11.8599
```:11.6841
[:11.486
//:11.4144
                :11.3001
(:11.2322
{:11.1816
        :11.0991
end:11.0275
########:10.9625

================
# Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)












































































































































































































































































LSP: Prelude: Recieved string: ### List ###

# Add an element to the front of a list. #
let cons: (Int, [Int]) -> [Int] = fun x, xs -> x::xs in

# Determine the length of a list. #
let length: [Int] -> Int =
  fun xs ->
    case xs
    | [] => 0
    | _::xs => 1 + length(xs) end in

# Extract the first element of a list. #
let hd: [Int] -> Option =
  fun l ->
    case l
    | [] => None
    | x::xs => Some(x) end in

# Extract the rest of the list. #
let tl: [Int] -> [Int] =
  fun l ->
    case l
    | [] => []
    | x::xs => xs end in

# Determine if a list is empty. #
let is_empty: [Int] -> Bool =
  fun xs ->
    case xs
    | [] => true
    | _::_ => false end in

# Return the element at the index. #
let nth: ([Int], Int) -> Option =
  fun xs, n ->
    case xs, n
    | x::_, 0 => Some(x)
    | _::xs, n => nth(xs, n - 1)
    | [], _ => None end in

# Reverse a List. #
let rev: [Int] -> [Int] =
fun l -> 
let go: ([Int], [Int]) -> [Int] =
  fun xs, acc -> 
    case xs 
    | [] => acc 
    | x::xs => go(xs, x::acc) end in
go(l, []) in

# Check if two lists are equal #
let equal: ([Int], [Int]) -> Bool =
    fun p, xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => x == y && equal(xs, ys)
    | _ => false end
in

# Initialize a list with a given length using an initializer function #
let init: (Int, Int -> Int) -> [Int] =
    fun len, f ->
        let go: (Int, [Int]) -> [Int] =
        fun idx, xs ->
            if idx < len 
            then go(idx + 1, xs @ [f(idx)])   
            else xs
        in
        go(0, [])
in

# Reduce a list from the left. #
let fold_left: ((Int, Int) -> Int, Int, [Int]) -> Int =
  fun f, acc, xs ->
    case xs 
    | [] => acc
    | hd::tl => fold_left(f, f(acc, hd), tl) end in

# Reduce a list from the right. #
let fold_right: ((Int, Int) -> Int, [Int], Int) -> Int =
  fun f, xs, acc ->
    case xs
    | [] => acc
    | hd::tl => f(hd, fold_right(f, tl, acc)) end in


666
LSP: Prelude: String parsed successfully
LSP: Prelude: Info map generated successfully
Debug: true, Constrain: Types
LSP: Init: Recieved string: # Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)











































































































































































































































































LSP: Init: String parsed successfully
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: >( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {go: ((?, ?) -> [?]), filter: (((Int -> Bool), [Int]) -> [Int]), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: 
  LSP: Info: ALL errors:Error in term:
  p
Nature of error: Variable p is not bound    
Error in term:
  p
Nature of error: Variable p is not bound    
Error in term:
  p
Nature of error: type ((Int -> Bool), [Int]) is not consistent with arrow type
  LSP: Info: BidiCtx: Cls: Let expression
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent: Root
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: [?]
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: :: @
  LSP: Concave: Backpack: 
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new_tokens ::= whitespace | "," | "::" | "@"
root ::= new_tokens

Top 20 Logits:

:20.3213
#:15.1519
let:14.5871
##:14.3313
 :13.1803
    :12.5844
################:12.4748
  :12.4746
   :12.2406
in:12.1402
####:12.0533
/*:11.8625
```:11.679
[:11.4896
//:11.4154
                :11.2948
(:11.2355
{:11.1924
        :11.1011
end:11.0284
########:10.9681

================
# Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)













































































































































































































































































LSP: Prelude: Recieved string: ### List ###

# Add an element to the front of a list. #
let cons: (Int, [Int]) -> [Int] = fun x, xs -> x::xs in

# Determine the length of a list. #
let length: [Int] -> Int =
  fun xs ->
    case xs
    | [] => 0
    | _::xs => 1 + length(xs) end in

# Extract the first element of a list. #
let hd: [Int] -> Option =
  fun l ->
    case l
    | [] => None
    | x::xs => Some(x) end in

# Extract the rest of the list. #
let tl: [Int] -> [Int] =
  fun l ->
    case l
    | [] => []
    | x::xs => xs end in

# Determine if a list is empty. #
let is_empty: [Int] -> Bool =
  fun xs ->
    case xs
    | [] => true
    | _::_ => false end in

# Return the element at the index. #
let nth: ([Int], Int) -> Option =
  fun xs, n ->
    case xs, n
    | x::_, 0 => Some(x)
    | _::xs, n => nth(xs, n - 1)
    | [], _ => None end in

# Reverse a List. #
let rev: [Int] -> [Int] =
fun l -> 
let go: ([Int], [Int]) -> [Int] =
  fun xs, acc -> 
    case xs 
    | [] => acc 
    | x::xs => go(xs, x::acc) end in
go(l, []) in

# Check if two lists are equal #
let equal: ([Int], [Int]) -> Bool =
    fun p, xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => x == y && equal(xs, ys)
    | _ => false end
in

# Initialize a list with a given length using an initializer function #
let init: (Int, Int -> Int) -> [Int] =
    fun len, f ->
        let go: (Int, [Int]) -> [Int] =
        fun idx, xs ->
            if idx < len 
            then go(idx + 1, xs @ [f(idx)])   
            else xs
        in
        go(0, [])
in

# Reduce a list from the left. #
let fold_left: ((Int, Int) -> Int, Int, [Int]) -> Int =
  fun f, acc, xs ->
    case xs 
    | [] => acc
    | hd::tl => fold_left(f, f(acc, hd), tl) end in

# Reduce a list from the right. #
let fold_right: ((Int, Int) -> Int, [Int], Int) -> Int =
  fun f, xs, acc ->
    case xs
    | [] => acc
    | hd::tl => f(hd, fold_right(f, tl, acc)) end in


666
LSP: Prelude: String parsed successfully
LSP: Prelude: Info map generated successfully
Debug: true, Constrain: Types
LSP: Init: Recieved string: # Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)












































































































































































































































































LSP: Init: String parsed successfully
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: >( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {go: ((?, ?) -> [?]), filter: (((Int -> Bool), [Int]) -> [Int]), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: 
  LSP: Info: ALL errors:Error in term:
  p
Nature of error: Variable p is not bound    
Error in term:
  p
Nature of error: Variable p is not bound    
Error in term:
  p
Nature of error: type ((Int -> Bool), [Int]) is not consistent with arrow type
  LSP: Info: BidiCtx: Cls: Let expression
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent: Root
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: [?]
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: :: @
  LSP: Concave: Backpack: 
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new_tokens ::= whitespace | "," | "::" | "@"
root ::= new_tokens

Top 20 Logits:

:20.3297
#:15.1523
let:14.5808
##:14.336
 :13.1862
    :12.5873
################:12.4813
  :12.4777
   :12.2447
in:12.1463
####:12.0605
/*:11.8614
```:11.6854
[:11.4949
//:11.413
                :11.2922
(:11.2422
{:11.2004
        :11.1052
end:11.0196
########:10.9763

================
# Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)














































































































































































































































































LSP: Prelude: Recieved string: ### List ###

# Add an element to the front of a list. #
let cons: (Int, [Int]) -> [Int] = fun x, xs -> x::xs in

# Determine the length of a list. #
let length: [Int] -> Int =
  fun xs ->
    case xs
    | [] => 0
    | _::xs => 1 + length(xs) end in

# Extract the first element of a list. #
let hd: [Int] -> Option =
  fun l ->
    case l
    | [] => None
    | x::xs => Some(x) end in

# Extract the rest of the list. #
let tl: [Int] -> [Int] =
  fun l ->
    case l
    | [] => []
    | x::xs => xs end in

# Determine if a list is empty. #
let is_empty: [Int] -> Bool =
  fun xs ->
    case xs
    | [] => true
    | _::_ => false end in

# Return the element at the index. #
let nth: ([Int], Int) -> Option =
  fun xs, n ->
    case xs, n
    | x::_, 0 => Some(x)
    | _::xs, n => nth(xs, n - 1)
    | [], _ => None end in

# Reverse a List. #
let rev: [Int] -> [Int] =
fun l -> 
let go: ([Int], [Int]) -> [Int] =
  fun xs, acc -> 
    case xs 
    | [] => acc 
    | x::xs => go(xs, x::acc) end in
go(l, []) in

# Check if two lists are equal #
let equal: ([Int], [Int]) -> Bool =
    fun p, xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => x == y && equal(xs, ys)
    | _ => false end
in

# Initialize a list with a given length using an initializer function #
let init: (Int, Int -> Int) -> [Int] =
    fun len, f ->
        let go: (Int, [Int]) -> [Int] =
        fun idx, xs ->
            if idx < len 
            then go(idx + 1, xs @ [f(idx)])   
            else xs
        in
        go(0, [])
in

# Reduce a list from the left. #
let fold_left: ((Int, Int) -> Int, Int, [Int]) -> Int =
  fun f, acc, xs ->
    case xs 
    | [] => acc
    | hd::tl => fold_left(f, f(acc, hd), tl) end in

# Reduce a list from the right. #
let fold_right: ((Int, Int) -> Int, [Int], Int) -> Int =
  fun f, xs, acc ->
    case xs
    | [] => acc
    | hd::tl => f(hd, fold_right(f, tl, acc)) end in


666
LSP: Prelude: String parsed successfully
LSP: Prelude: Info map generated successfully
Debug: true, Constrain: Types
LSP: Init: Recieved string: # Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)













































































































































































































































































LSP: Init: String parsed successfully
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: >( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {go: ((?, ?) -> [?]), filter: (((Int -> Bool), [Int]) -> [Int]), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: 
  LSP: Info: ALL errors:Error in term:
  p
Nature of error: type ((Int -> Bool), [Int]) is not consistent with arrow type    
Error in term:
  p
Nature of error: Variable p is not bound    
Error in term:
  p
Nature of error: Variable p is not bound
  LSP: Info: BidiCtx: Cls: Let expression
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent: Root
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: [?]
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: :: @
  LSP: Concave: Backpack: 
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new_tokens ::= whitespace | "," | "::" | "@"
root ::= new_tokens

Top 20 Logits:

:20.3396
#:15.1495
let:14.581
##:14.3412
 :13.1917
    :12.5907
################:12.4875
  :12.485
   :12.2464
in:12.1515
####:12.0654
/*:11.8583
```:11.6987
[:11.4978
//:11.4085
                :11.2924
(:11.2461
{:11.2055
        :11.1101
end:11.0063
########:10.9829

================
# Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)















































































































































































































































































LSP: Prelude: Recieved string: ### List ###

# Add an element to the front of a list. #
let cons: (Int, [Int]) -> [Int] = fun x, xs -> x::xs in

# Determine the length of a list. #
let length: [Int] -> Int =
  fun xs ->
    case xs
    | [] => 0
    | _::xs => 1 + length(xs) end in

# Extract the first element of a list. #
let hd: [Int] -> Option =
  fun l ->
    case l
    | [] => None
    | x::xs => Some(x) end in

# Extract the rest of the list. #
let tl: [Int] -> [Int] =
  fun l ->
    case l
    | [] => []
    | x::xs => xs end in

# Determine if a list is empty. #
let is_empty: [Int] -> Bool =
  fun xs ->
    case xs
    | [] => true
    | _::_ => false end in

# Return the element at the index. #
let nth: ([Int], Int) -> Option =
  fun xs, n ->
    case xs, n
    | x::_, 0 => Some(x)
    | _::xs, n => nth(xs, n - 1)
    | [], _ => None end in

# Reverse a List. #
let rev: [Int] -> [Int] =
fun l -> 
let go: ([Int], [Int]) -> [Int] =
  fun xs, acc -> 
    case xs 
    | [] => acc 
    | x::xs => go(xs, x::acc) end in
go(l, []) in

# Check if two lists are equal #
let equal: ([Int], [Int]) -> Bool =
    fun p, xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => x == y && equal(xs, ys)
    | _ => false end
in

# Initialize a list with a given length using an initializer function #
let init: (Int, Int -> Int) -> [Int] =
    fun len, f ->
        let go: (Int, [Int]) -> [Int] =
        fun idx, xs ->
            if idx < len 
            then go(idx + 1, xs @ [f(idx)])   
            else xs
        in
        go(0, [])
in

# Reduce a list from the left. #
let fold_left: ((Int, Int) -> Int, Int, [Int]) -> Int =
  fun f, acc, xs ->
    case xs 
    | [] => acc
    | hd::tl => fold_left(f, f(acc, hd), tl) end in

# Reduce a list from the right. #
let fold_right: ((Int, Int) -> Int, [Int], Int) -> Int =
  fun f, xs, acc ->
    case xs
    | [] => acc
    | hd::tl => f(hd, fold_right(f, tl, acc)) end in


666
LSP: Prelude: String parsed successfully
LSP: Prelude: Info map generated successfully
Debug: true, Constrain: Types
LSP: Init: Recieved string: # Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)














































































































































































































































































LSP: Init: String parsed successfully
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: >( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {go: ((?, ?) -> [?]), filter: (((Int -> Bool), [Int]) -> [Int]), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: 
  LSP: Info: ALL errors:Error in term:
  p
Nature of error: type ((Int -> Bool), [Int]) is not consistent with arrow type    
Error in term:
  p
Nature of error: Variable p is not bound    
Error in term:
  p
Nature of error: Variable p is not bound
  LSP: Info: BidiCtx: Cls: Let expression
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent: Root
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: [?]
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: :: @
  LSP: Concave: Backpack: 
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new_tokens ::= whitespace | "," | "::" | "@"
root ::= new_tokens

Top 20 Logits:

:20.3453
#:15.1421
let:14.5828
##:14.3395
 :13.1928
    :12.5936
  :12.4925
################:12.4901
   :12.2421
in:12.164
####:12.0614
/*:11.8582
```:11.7062
[:11.4954
//:11.404
                :11.2923
(:11.2431
{:11.2079
        :11.1126
end:10.994
########:10.9838

================
# Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)
















































































































































































































































































LSP: Prelude: Recieved string: ### List ###

# Add an element to the front of a list. #
let cons: (Int, [Int]) -> [Int] = fun x, xs -> x::xs in

# Determine the length of a list. #
let length: [Int] -> Int =
  fun xs ->
    case xs
    | [] => 0
    | _::xs => 1 + length(xs) end in

# Extract the first element of a list. #
let hd: [Int] -> Option =
  fun l ->
    case l
    | [] => None
    | x::xs => Some(x) end in

# Extract the rest of the list. #
let tl: [Int] -> [Int] =
  fun l ->
    case l
    | [] => []
    | x::xs => xs end in

# Determine if a list is empty. #
let is_empty: [Int] -> Bool =
  fun xs ->
    case xs
    | [] => true
    | _::_ => false end in

# Return the element at the index. #
let nth: ([Int], Int) -> Option =
  fun xs, n ->
    case xs, n
    | x::_, 0 => Some(x)
    | _::xs, n => nth(xs, n - 1)
    | [], _ => None end in

# Reverse a List. #
let rev: [Int] -> [Int] =
fun l -> 
let go: ([Int], [Int]) -> [Int] =
  fun xs, acc -> 
    case xs 
    | [] => acc 
    | x::xs => go(xs, x::acc) end in
go(l, []) in

# Check if two lists are equal #
let equal: ([Int], [Int]) -> Bool =
    fun p, xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => x == y && equal(xs, ys)
    | _ => false end
in

# Initialize a list with a given length using an initializer function #
let init: (Int, Int -> Int) -> [Int] =
    fun len, f ->
        let go: (Int, [Int]) -> [Int] =
        fun idx, xs ->
            if idx < len 
            then go(idx + 1, xs @ [f(idx)])   
            else xs
        in
        go(0, [])
in

# Reduce a list from the left. #
let fold_left: ((Int, Int) -> Int, Int, [Int]) -> Int =
  fun f, acc, xs ->
    case xs 
    | [] => acc
    | hd::tl => fold_left(f, f(acc, hd), tl) end in

# Reduce a list from the right. #
let fold_right: ((Int, Int) -> Int, [Int], Int) -> Int =
  fun f, xs, acc ->
    case xs
    | [] => acc
    | hd::tl => f(hd, fold_right(f, tl, acc)) end in


666
LSP: Prelude: String parsed successfully
LSP: Prelude: Info map generated successfully
Debug: true, Constrain: Types
LSP: Init: Recieved string: # Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)















































































































































































































































































LSP: Init: String parsed successfully
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: >( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {go: ((?, ?) -> [?]), filter: (((Int -> Bool), [Int]) -> [Int]), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: 
  LSP: Info: ALL errors:Error in term:
  p
Nature of error: Variable p is not bound    
Error in term:
  p
Nature of error: Variable p is not bound    
Error in term:
  p
Nature of error: type ((Int -> Bool), [Int]) is not consistent with arrow type
  LSP: Info: BidiCtx: Cls: Let expression
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent: Root
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: [?]
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: :: @
  LSP: Concave: Backpack: 
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new_tokens ::= whitespace | "," | "::" | "@"
root ::= new_tokens

Top 20 Logits:

:20.3461
#:15.1338
let:14.5831
##:14.3317
 :13.1901
    :12.5948
  :12.496
################:12.4909
   :12.2331
in:12.1863
####:12.0517
/*:11.8645
```:11.7019
[:11.493
//:11.4029
                :11.2903
(:11.2348
{:11.2124
        :11.1109
end:10.9878
########:10.9811

================
# Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)

















































































































































































































































































LSP: Prelude: Recieved string: ### List ###

# Add an element to the front of a list. #
let cons: (Int, [Int]) -> [Int] = fun x, xs -> x::xs in

# Determine the length of a list. #
let length: [Int] -> Int =
  fun xs ->
    case xs
    | [] => 0
    | _::xs => 1 + length(xs) end in

# Extract the first element of a list. #
let hd: [Int] -> Option =
  fun l ->
    case l
    | [] => None
    | x::xs => Some(x) end in

# Extract the rest of the list. #
let tl: [Int] -> [Int] =
  fun l ->
    case l
    | [] => []
    | x::xs => xs end in

# Determine if a list is empty. #
let is_empty: [Int] -> Bool =
  fun xs ->
    case xs
    | [] => true
    | _::_ => false end in

# Return the element at the index. #
let nth: ([Int], Int) -> Option =
  fun xs, n ->
    case xs, n
    | x::_, 0 => Some(x)
    | _::xs, n => nth(xs, n - 1)
    | [], _ => None end in

# Reverse a List. #
let rev: [Int] -> [Int] =
fun l -> 
let go: ([Int], [Int]) -> [Int] =
  fun xs, acc -> 
    case xs 
    | [] => acc 
    | x::xs => go(xs, x::acc) end in
go(l, []) in

# Check if two lists are equal #
let equal: ([Int], [Int]) -> Bool =
    fun p, xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => x == y && equal(xs, ys)
    | _ => false end
in

# Initialize a list with a given length using an initializer function #
let init: (Int, Int -> Int) -> [Int] =
    fun len, f ->
        let go: (Int, [Int]) -> [Int] =
        fun idx, xs ->
            if idx < len 
            then go(idx + 1, xs @ [f(idx)])   
            else xs
        in
        go(0, [])
in

# Reduce a list from the left. #
let fold_left: ((Int, Int) -> Int, Int, [Int]) -> Int =
  fun f, acc, xs ->
    case xs 
    | [] => acc
    | hd::tl => fold_left(f, f(acc, hd), tl) end in

# Reduce a list from the right. #
let fold_right: ((Int, Int) -> Int, [Int], Int) -> Int =
  fun f, xs, acc ->
    case xs
    | [] => acc
    | hd::tl => f(hd, fold_right(f, tl, acc)) end in


666
LSP: Prelude: String parsed successfully
LSP: Prelude: Info map generated successfully
Debug: true, Constrain: Types
LSP: Init: Recieved string: # Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)
















































































































































































































































































LSP: Init: String parsed successfully
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: >( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {go: ((?, ?) -> [?]), filter: (((Int -> Bool), [Int]) -> [Int]), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: 
  LSP: Info: ALL errors:Error in term:
  p
Nature of error: Variable p is not bound    
Error in term:
  p
Nature of error: type ((Int -> Bool), [Int]) is not consistent with arrow type    
Error in term:
  p
Nature of error: Variable p is not bound
  LSP: Info: BidiCtx: Cls: Let expression
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent: Root
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: [?]
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: :: @
  LSP: Concave: Backpack: 
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new_tokens ::= whitespace | "," | "::" | "@"
root ::= new_tokens

Top 20 Logits:

:20.3462
#:15.1303
let:14.5817
##:14.3257
 :13.1873
    :12.5927
################:12.494
  :12.4936
   :12.2255
in:12.2091
####:12.0445
/*:11.8726
```:11.6905
[:11.4957
//:11.4071
                :11.288
(:11.2267
{:11.2213
        :11.1049
end:10.9843
########:10.9807

================
# Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)


















































































































































































































































































LSP: Prelude: Recieved string: ### List ###

# Add an element to the front of a list. #
let cons: (Int, [Int]) -> [Int] = fun x, xs -> x::xs in

# Determine the length of a list. #
let length: [Int] -> Int =
  fun xs ->
    case xs
    | [] => 0
    | _::xs => 1 + length(xs) end in

# Extract the first element of a list. #
let hd: [Int] -> Option =
  fun l ->
    case l
    | [] => None
    | x::xs => Some(x) end in

# Extract the rest of the list. #
let tl: [Int] -> [Int] =
  fun l ->
    case l
    | [] => []
    | x::xs => xs end in

# Determine if a list is empty. #
let is_empty: [Int] -> Bool =
  fun xs ->
    case xs
    | [] => true
    | _::_ => false end in

# Return the element at the index. #
let nth: ([Int], Int) -> Option =
  fun xs, n ->
    case xs, n
    | x::_, 0 => Some(x)
    | _::xs, n => nth(xs, n - 1)
    | [], _ => None end in

# Reverse a List. #
let rev: [Int] -> [Int] =
fun l -> 
let go: ([Int], [Int]) -> [Int] =
  fun xs, acc -> 
    case xs 
    | [] => acc 
    | x::xs => go(xs, x::acc) end in
go(l, []) in

# Check if two lists are equal #
let equal: ([Int], [Int]) -> Bool =
    fun p, xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => x == y && equal(xs, ys)
    | _ => false end
in

# Initialize a list with a given length using an initializer function #
let init: (Int, Int -> Int) -> [Int] =
    fun len, f ->
        let go: (Int, [Int]) -> [Int] =
        fun idx, xs ->
            if idx < len 
            then go(idx + 1, xs @ [f(idx)])   
            else xs
        in
        go(0, [])
in

# Reduce a list from the left. #
let fold_left: ((Int, Int) -> Int, Int, [Int]) -> Int =
  fun f, acc, xs ->
    case xs 
    | [] => acc
    | hd::tl => fold_left(f, f(acc, hd), tl) end in

# Reduce a list from the right. #
let fold_right: ((Int, Int) -> Int, [Int], Int) -> Int =
  fun f, xs, acc ->
    case xs
    | [] => acc
    | hd::tl => f(hd, fold_right(f, tl, acc)) end in


666
LSP: Prelude: String parsed successfully
LSP: Prelude: Info map generated successfully
Debug: true, Constrain: Types
LSP: Init: Recieved string: # Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)

















































































































































































































































































LSP: Init: String parsed successfully
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: >( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {go: ((?, ?) -> [?]), filter: (((Int -> Bool), [Int]) -> [Int]), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: 
  LSP: Info: ALL errors:Error in term:
  p
Nature of error: type ((Int -> Bool), [Int]) is not consistent with arrow type    
Error in term:
  p
Nature of error: Variable p is not bound    
Error in term:
  p
Nature of error: Variable p is not bound
  LSP: Info: BidiCtx: Cls: Let expression
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent: Root
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: [?]
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: :: @
  LSP: Concave: Backpack: 
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new_tokens ::= whitespace | "," | "::" | "@"
root ::= new_tokens

Top 20 Logits:

:20.3484
#:15.1326
let:14.5763
##:14.3253
 :13.1854
    :12.5849
################:12.4979
  :12.4837
   :12.2221
in:12.2206
####:12.0431
/*:11.8773
```:11.6798
[:11.5026
//:11.4139
                :11.2852
{:11.2309
(:11.2218
        :11.0954
end:10.9815
########:10.9809

================
# Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)



















































































































































































































































































LSP: Prelude: Recieved string: ### List ###

# Add an element to the front of a list. #
let cons: (Int, [Int]) -> [Int] = fun x, xs -> x::xs in

# Determine the length of a list. #
let length: [Int] -> Int =
  fun xs ->
    case xs
    | [] => 0
    | _::xs => 1 + length(xs) end in

# Extract the first element of a list. #
let hd: [Int] -> Option =
  fun l ->
    case l
    | [] => None
    | x::xs => Some(x) end in

# Extract the rest of the list. #
let tl: [Int] -> [Int] =
  fun l ->
    case l
    | [] => []
    | x::xs => xs end in

# Determine if a list is empty. #
let is_empty: [Int] -> Bool =
  fun xs ->
    case xs
    | [] => true
    | _::_ => false end in

# Return the element at the index. #
let nth: ([Int], Int) -> Option =
  fun xs, n ->
    case xs, n
    | x::_, 0 => Some(x)
    | _::xs, n => nth(xs, n - 1)
    | [], _ => None end in

# Reverse a List. #
let rev: [Int] -> [Int] =
fun l -> 
let go: ([Int], [Int]) -> [Int] =
  fun xs, acc -> 
    case xs 
    | [] => acc 
    | x::xs => go(xs, x::acc) end in
go(l, []) in

# Check if two lists are equal #
let equal: ([Int], [Int]) -> Bool =
    fun p, xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => x == y && equal(xs, ys)
    | _ => false end
in

# Initialize a list with a given length using an initializer function #
let init: (Int, Int -> Int) -> [Int] =
    fun len, f ->
        let go: (Int, [Int]) -> [Int] =
        fun idx, xs ->
            if idx < len 
            then go(idx + 1, xs @ [f(idx)])   
            else xs
        in
        go(0, [])
in

# Reduce a list from the left. #
let fold_left: ((Int, Int) -> Int, Int, [Int]) -> Int =
  fun f, acc, xs ->
    case xs 
    | [] => acc
    | hd::tl => fold_left(f, f(acc, hd), tl) end in

# Reduce a list from the right. #
let fold_right: ((Int, Int) -> Int, [Int], Int) -> Int =
  fun f, xs, acc ->
    case xs
    | [] => acc
    | hd::tl => f(hd, fold_right(f, tl, acc)) end in


666
LSP: Prelude: String parsed successfully
LSP: Prelude: Info map generated successfully
Debug: true, Constrain: Types
LSP: Init: Recieved string: # Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)


















































































































































































































































































LSP: Init: String parsed successfully
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: >( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {go: ((?, ?) -> [?]), filter: (((Int -> Bool), [Int]) -> [Int]), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: 
  LSP: Info: ALL errors:Error in term:
  p
Nature of error: Variable p is not bound    
Error in term:
  p
Nature of error: Variable p is not bound    
Error in term:
  p
Nature of error: type ((Int -> Bool), [Int]) is not consistent with arrow type
  LSP: Info: BidiCtx: Cls: Let expression
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent: Root
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: [?]
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: :: @
  LSP: Concave: Backpack: 
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new_tokens ::= whitespace | "," | "::" | "@"
root ::= new_tokens

Top 20 Logits:

:20.3556
#:15.1389
let:14.5709
##:14.3259
 :13.1849
    :12.5755
################:12.4992
  :12.4717
in:12.2303
   :12.223
####:12.0435
/*:11.879
```:11.6764
[:11.5125
//:11.4213
                :11.283
{:11.2374
(:11.2205
        :11.0873
end:10.9827
########:10.9781

================
# Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)




















































































































































































































































































LSP: Prelude: Recieved string: ### List ###

# Add an element to the front of a list. #
let cons: (Int, [Int]) -> [Int] = fun x, xs -> x::xs in

# Determine the length of a list. #
let length: [Int] -> Int =
  fun xs ->
    case xs
    | [] => 0
    | _::xs => 1 + length(xs) end in

# Extract the first element of a list. #
let hd: [Int] -> Option =
  fun l ->
    case l
    | [] => None
    | x::xs => Some(x) end in

# Extract the rest of the list. #
let tl: [Int] -> [Int] =
  fun l ->
    case l
    | [] => []
    | x::xs => xs end in

# Determine if a list is empty. #
let is_empty: [Int] -> Bool =
  fun xs ->
    case xs
    | [] => true
    | _::_ => false end in

# Return the element at the index. #
let nth: ([Int], Int) -> Option =
  fun xs, n ->
    case xs, n
    | x::_, 0 => Some(x)
    | _::xs, n => nth(xs, n - 1)
    | [], _ => None end in

# Reverse a List. #
let rev: [Int] -> [Int] =
fun l -> 
let go: ([Int], [Int]) -> [Int] =
  fun xs, acc -> 
    case xs 
    | [] => acc 
    | x::xs => go(xs, x::acc) end in
go(l, []) in

# Check if two lists are equal #
let equal: ([Int], [Int]) -> Bool =
    fun p, xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => x == y && equal(xs, ys)
    | _ => false end
in

# Initialize a list with a given length using an initializer function #
let init: (Int, Int -> Int) -> [Int] =
    fun len, f ->
        let go: (Int, [Int]) -> [Int] =
        fun idx, xs ->
            if idx < len 
            then go(idx + 1, xs @ [f(idx)])   
            else xs
        in
        go(0, [])
in

# Reduce a list from the left. #
let fold_left: ((Int, Int) -> Int, Int, [Int]) -> Int =
  fun f, acc, xs ->
    case xs 
    | [] => acc
    | hd::tl => fold_left(f, f(acc, hd), tl) end in

# Reduce a list from the right. #
let fold_right: ((Int, Int) -> Int, [Int], Int) -> Int =
  fun f, xs, acc ->
    case xs
    | [] => acc
    | hd::tl => f(hd, fold_right(f, tl, acc)) end in


666
LSP: Prelude: String parsed successfully
LSP: Prelude: Info map generated successfully
Debug: true, Constrain: Types
LSP: Init: Recieved string: # Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)



















































































































































































































































































LSP: Init: String parsed successfully
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: >( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {go: ((?, ?) -> [?]), filter: (((Int -> Bool), [Int]) -> [Int]), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: 
  LSP: Info: ALL errors:Error in term:
  p
Nature of error: type ((Int -> Bool), [Int]) is not consistent with arrow type    
Error in term:
  p
Nature of error: Variable p is not bound    
Error in term:
  p
Nature of error: Variable p is not bound
  LSP: Info: BidiCtx: Cls: Let expression
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent: Root
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: [?]
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: :: @
  LSP: Concave: Backpack: 
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new_tokens ::= whitespace | "," | "::" | "@"
root ::= new_tokens

Top 20 Logits:

:20.3673
#:15.1452
let:14.571
##:14.3193
 :13.1864
    :12.5686
################:12.4962
  :12.4637
in:12.2511
   :12.2256
####:12.0392
/*:11.8794
```:11.6785
[:11.5203
//:11.4282
                :11.2843
{:11.2372
(:11.2197
        :11.0833
end:10.9889
########:10.9696

================
# Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)





















































































































































































































































































LSP: Prelude: Recieved string: ### List ###

# Add an element to the front of a list. #
let cons: (Int, [Int]) -> [Int] = fun x, xs -> x::xs in

# Determine the length of a list. #
let length: [Int] -> Int =
  fun xs ->
    case xs
    | [] => 0
    | _::xs => 1 + length(xs) end in

# Extract the first element of a list. #
let hd: [Int] -> Option =
  fun l ->
    case l
    | [] => None
    | x::xs => Some(x) end in

# Extract the rest of the list. #
let tl: [Int] -> [Int] =
  fun l ->
    case l
    | [] => []
    | x::xs => xs end in

# Determine if a list is empty. #
let is_empty: [Int] -> Bool =
  fun xs ->
    case xs
    | [] => true
    | _::_ => false end in

# Return the element at the index. #
let nth: ([Int], Int) -> Option =
  fun xs, n ->
    case xs, n
    | x::_, 0 => Some(x)
    | _::xs, n => nth(xs, n - 1)
    | [], _ => None end in

# Reverse a List. #
let rev: [Int] -> [Int] =
fun l -> 
let go: ([Int], [Int]) -> [Int] =
  fun xs, acc -> 
    case xs 
    | [] => acc 
    | x::xs => go(xs, x::acc) end in
go(l, []) in

# Check if two lists are equal #
let equal: ([Int], [Int]) -> Bool =
    fun p, xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => x == y && equal(xs, ys)
    | _ => false end
in

# Initialize a list with a given length using an initializer function #
let init: (Int, Int -> Int) -> [Int] =
    fun len, f ->
        let go: (Int, [Int]) -> [Int] =
        fun idx, xs ->
            if idx < len 
            then go(idx + 1, xs @ [f(idx)])   
            else xs
        in
        go(0, [])
in

# Reduce a list from the left. #
let fold_left: ((Int, Int) -> Int, Int, [Int]) -> Int =
  fun f, acc, xs ->
    case xs 
    | [] => acc
    | hd::tl => fold_left(f, f(acc, hd), tl) end in

# Reduce a list from the right. #
let fold_right: ((Int, Int) -> Int, [Int], Int) -> Int =
  fun f, xs, acc ->
    case xs
    | [] => acc
    | hd::tl => f(hd, fold_right(f, tl, acc)) end in


666
LSP: Prelude: String parsed successfully
LSP: Prelude: Info map generated successfully
Debug: true, Constrain: Types
LSP: Init: Recieved string: # Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)




















































































































































































































































































LSP: Init: String parsed successfully
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: >( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {go: ((?, ?) -> [?]), filter: (((Int -> Bool), [Int]) -> [Int]), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: 
  LSP: Info: ALL errors:Error in term:
  p
Nature of error: Variable p is not bound    
Error in term:
  p
Nature of error: Variable p is not bound    
Error in term:
  p
Nature of error: type ((Int -> Bool), [Int]) is not consistent with arrow type
  LSP: Info: BidiCtx: Cls: Let expression
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent: Root
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: [?]
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: :: @
  LSP: Concave: Backpack: 
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new_tokens ::= whitespace | "," | "::" | "@"
root ::= new_tokens

Top 20 Logits:

:20.378
#:15.1468
let:14.5739
##:14.301
 :13.1885
    :12.5643
################:12.4864
  :12.4605
in:12.2851
   :12.2266
####:12.0263
/*:11.8813
```:11.6777
[:11.516
//:11.4356
                :11.2876
{:11.2283
(:11.211
        :11.0813
end:10.9974
########:10.9527

================
# Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)






















































































































































































































































































LSP: Prelude: Recieved string: ### List ###

# Add an element to the front of a list. #
let cons: (Int, [Int]) -> [Int] = fun x, xs -> x::xs in

# Determine the length of a list. #
let length: [Int] -> Int =
  fun xs ->
    case xs
    | [] => 0
    | _::xs => 1 + length(xs) end in

# Extract the first element of a list. #
let hd: [Int] -> Option =
  fun l ->
    case l
    | [] => None
    | x::xs => Some(x) end in

# Extract the rest of the list. #
let tl: [Int] -> [Int] =
  fun l ->
    case l
    | [] => []
    | x::xs => xs end in

# Determine if a list is empty. #
let is_empty: [Int] -> Bool =
  fun xs ->
    case xs
    | [] => true
    | _::_ => false end in

# Return the element at the index. #
let nth: ([Int], Int) -> Option =
  fun xs, n ->
    case xs, n
    | x::_, 0 => Some(x)
    | _::xs, n => nth(xs, n - 1)
    | [], _ => None end in

# Reverse a List. #
let rev: [Int] -> [Int] =
fun l -> 
let go: ([Int], [Int]) -> [Int] =
  fun xs, acc -> 
    case xs 
    | [] => acc 
    | x::xs => go(xs, x::acc) end in
go(l, []) in

# Check if two lists are equal #
let equal: ([Int], [Int]) -> Bool =
    fun p, xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => x == y && equal(xs, ys)
    | _ => false end
in

# Initialize a list with a given length using an initializer function #
let init: (Int, Int -> Int) -> [Int] =
    fun len, f ->
        let go: (Int, [Int]) -> [Int] =
        fun idx, xs ->
            if idx < len 
            then go(idx + 1, xs @ [f(idx)])   
            else xs
        in
        go(0, [])
in

# Reduce a list from the left. #
let fold_left: ((Int, Int) -> Int, Int, [Int]) -> Int =
  fun f, acc, xs ->
    case xs 
    | [] => acc
    | hd::tl => fold_left(f, f(acc, hd), tl) end in

# Reduce a list from the right. #
let fold_right: ((Int, Int) -> Int, [Int], Int) -> Int =
  fun f, xs, acc ->
    case xs
    | [] => acc
    | hd::tl => f(hd, fold_right(f, tl, acc)) end in


666
LSP: Prelude: String parsed successfully
LSP: Prelude: Info map generated successfully
Debug: true, Constrain: Types
LSP: Init: Recieved string: # Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)





















































































































































































































































































LSP: Init: String parsed successfully
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: >( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {go: ((?, ?) -> [?]), filter: (((Int -> Bool), [Int]) -> [Int]), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: 
  LSP: Info: ALL errors:Error in term:
  p
Nature of error: Variable p is not bound    
Error in term:
  p
Nature of error: type ((Int -> Bool), [Int]) is not consistent with arrow type    
Error in term:
  p
Nature of error: Variable p is not bound
  LSP: Info: BidiCtx: Cls: Let expression
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent: Root
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: [?]
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: :: @
  LSP: Concave: Backpack: 
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new_tokens ::= whitespace | "," | "::" | "@"
root ::= new_tokens

Top 20 Logits:

:20.3825
#:15.1417
let:14.5752
##:14.275
 :13.1882
    :12.5608
################:12.4692
  :12.4584
in:12.3168
   :12.2241
####:12.0069
/*:11.8873
```:11.6658
[:11.4981
//:11.4438
                :11.2875
{:11.2154
(:11.1935
        :11.0773
end:11.0041
########:10.9294

================
# Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)























































































































































































































































































LSP: Prelude: Recieved string: ### List ###

# Add an element to the front of a list. #
let cons: (Int, [Int]) -> [Int] = fun x, xs -> x::xs in

# Determine the length of a list. #
let length: [Int] -> Int =
  fun xs ->
    case xs
    | [] => 0
    | _::xs => 1 + length(xs) end in

# Extract the first element of a list. #
let hd: [Int] -> Option =
  fun l ->
    case l
    | [] => None
    | x::xs => Some(x) end in

# Extract the rest of the list. #
let tl: [Int] -> [Int] =
  fun l ->
    case l
    | [] => []
    | x::xs => xs end in

# Determine if a list is empty. #
let is_empty: [Int] -> Bool =
  fun xs ->
    case xs
    | [] => true
    | _::_ => false end in

# Return the element at the index. #
let nth: ([Int], Int) -> Option =
  fun xs, n ->
    case xs, n
    | x::_, 0 => Some(x)
    | _::xs, n => nth(xs, n - 1)
    | [], _ => None end in

# Reverse a List. #
let rev: [Int] -> [Int] =
fun l -> 
let go: ([Int], [Int]) -> [Int] =
  fun xs, acc -> 
    case xs 
    | [] => acc 
    | x::xs => go(xs, x::acc) end in
go(l, []) in

# Check if two lists are equal #
let equal: ([Int], [Int]) -> Bool =
    fun p, xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => x == y && equal(xs, ys)
    | _ => false end
in

# Initialize a list with a given length using an initializer function #
let init: (Int, Int -> Int) -> [Int] =
    fun len, f ->
        let go: (Int, [Int]) -> [Int] =
        fun idx, xs ->
            if idx < len 
            then go(idx + 1, xs @ [f(idx)])   
            else xs
        in
        go(0, [])
in

# Reduce a list from the left. #
let fold_left: ((Int, Int) -> Int, Int, [Int]) -> Int =
  fun f, acc, xs ->
    case xs 
    | [] => acc
    | hd::tl => fold_left(f, f(acc, hd), tl) end in

# Reduce a list from the right. #
let fold_right: ((Int, Int) -> Int, [Int], Int) -> Int =
  fun f, xs, acc ->
    case xs
    | [] => acc
    | hd::tl => f(hd, fold_right(f, tl, acc)) end in


666
LSP: Prelude: String parsed successfully
LSP: Prelude: Info map generated successfully
Debug: true, Constrain: Types
LSP: Init: Recieved string: # Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)






















































































































































































































































































LSP: Init: String parsed successfully
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: >( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {go: ((?, ?) -> [?]), filter: (((Int -> Bool), [Int]) -> [Int]), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: 
  LSP: Info: ALL errors:Error in term:
  p
Nature of error: Variable p is not bound    
Error in term:
  p
Nature of error: Variable p is not bound    
Error in term:
  p
Nature of error: type ((Int -> Bool), [Int]) is not consistent with arrow type
  LSP: Info: BidiCtx: Cls: Let expression
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent: Root
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: [?]
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: :: @
  LSP: Concave: Backpack: 
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new_tokens ::= whitespace | "," | "::" | "@"
root ::= new_tokens

Top 20 Logits:

:20.3811
#:15.1347
let:14.573
##:14.2525
 :13.1853
    :12.5575
  :12.4543
################:12.4508
in:12.3242
   :12.2183
####:11.9903
/*:11.8946
```:11.644
[:11.4745
//:11.4507
                :11.2825
{:11.206
(:11.1755
        :11.0714
end:11.0006
########:10.9097

================
# Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)
























































































































































































































































































LSP: Prelude: Recieved string: ### List ###

# Add an element to the front of a list. #
let cons: (Int, [Int]) -> [Int] = fun x, xs -> x::xs in

# Determine the length of a list. #
let length: [Int] -> Int =
  fun xs ->
    case xs
    | [] => 0
    | _::xs => 1 + length(xs) end in

# Extract the first element of a list. #
let hd: [Int] -> Option =
  fun l ->
    case l
    | [] => None
    | x::xs => Some(x) end in

# Extract the rest of the list. #
let tl: [Int] -> [Int] =
  fun l ->
    case l
    | [] => []
    | x::xs => xs end in

# Determine if a list is empty. #
let is_empty: [Int] -> Bool =
  fun xs ->
    case xs
    | [] => true
    | _::_ => false end in

# Return the element at the index. #
let nth: ([Int], Int) -> Option =
  fun xs, n ->
    case xs, n
    | x::_, 0 => Some(x)
    | _::xs, n => nth(xs, n - 1)
    | [], _ => None end in

# Reverse a List. #
let rev: [Int] -> [Int] =
fun l -> 
let go: ([Int], [Int]) -> [Int] =
  fun xs, acc -> 
    case xs 
    | [] => acc 
    | x::xs => go(xs, x::acc) end in
go(l, []) in

# Check if two lists are equal #
let equal: ([Int], [Int]) -> Bool =
    fun p, xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => x == y && equal(xs, ys)
    | _ => false end
in

# Initialize a list with a given length using an initializer function #
let init: (Int, Int -> Int) -> [Int] =
    fun len, f ->
        let go: (Int, [Int]) -> [Int] =
        fun idx, xs ->
            if idx < len 
            then go(idx + 1, xs @ [f(idx)])   
            else xs
        in
        go(0, [])
in

# Reduce a list from the left. #
let fold_left: ((Int, Int) -> Int, Int, [Int]) -> Int =
  fun f, acc, xs ->
    case xs 
    | [] => acc
    | hd::tl => fold_left(f, f(acc, hd), tl) end in

# Reduce a list from the right. #
let fold_right: ((Int, Int) -> Int, [Int], Int) -> Int =
  fun f, xs, acc ->
    case xs
    | [] => acc
    | hd::tl => f(hd, fold_right(f, tl, acc)) end in


666
LSP: Prelude: String parsed successfully
LSP: Prelude: Info map generated successfully
Debug: true, Constrain: Types
LSP: Init: Recieved string: # Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)























































































































































































































































































LSP: Init: String parsed successfully
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: >( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {go: ((?, ?) -> [?]), filter: (((Int -> Bool), [Int]) -> [Int]), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: 
  LSP: Info: ALL errors:Error in term:
  p
Nature of error: Variable p is not bound    
Error in term:
  p
Nature of error: type ((Int -> Bool), [Int]) is not consistent with arrow type    
Error in term:
  p
Nature of error: Variable p is not bound
  LSP: Info: BidiCtx: Cls: Let expression
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent: Root
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: [?]
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: :: @
  LSP: Concave: Backpack: 
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new_tokens ::= whitespace | "," | "::" | "@"
root ::= new_tokens

Top 20 Logits:

:20.3814
#:15.1305
let:14.5649
##:14.2479
 :13.1833
    :12.5536
  :12.4491
################:12.4419
in:12.3059
   :12.2134
####:11.9881
/*:11.8979
```:11.6246
//:11.4568
[:11.4564
                :11.2747
{:11.2046
(:11.1628
        :11.066
end:10.9875
########:10.9067

================
# Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)

























































































































































































































































































LSP: Prelude: Recieved string: ### List ###

# Add an element to the front of a list. #
let cons: (Int, [Int]) -> [Int] = fun x, xs -> x::xs in

# Determine the length of a list. #
let length: [Int] -> Int =
  fun xs ->
    case xs
    | [] => 0
    | _::xs => 1 + length(xs) end in

# Extract the first element of a list. #
let hd: [Int] -> Option =
  fun l ->
    case l
    | [] => None
    | x::xs => Some(x) end in

# Extract the rest of the list. #
let tl: [Int] -> [Int] =
  fun l ->
    case l
    | [] => []
    | x::xs => xs end in

# Determine if a list is empty. #
let is_empty: [Int] -> Bool =
  fun xs ->
    case xs
    | [] => true
    | _::_ => false end in

# Return the element at the index. #
let nth: ([Int], Int) -> Option =
  fun xs, n ->
    case xs, n
    | x::_, 0 => Some(x)
    | _::xs, n => nth(xs, n - 1)
    | [], _ => None end in

# Reverse a List. #
let rev: [Int] -> [Int] =
fun l -> 
let go: ([Int], [Int]) -> [Int] =
  fun xs, acc -> 
    case xs 
    | [] => acc 
    | x::xs => go(xs, x::acc) end in
go(l, []) in

# Check if two lists are equal #
let equal: ([Int], [Int]) -> Bool =
    fun p, xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => x == y && equal(xs, ys)
    | _ => false end
in

# Initialize a list with a given length using an initializer function #
let init: (Int, Int -> Int) -> [Int] =
    fun len, f ->
        let go: (Int, [Int]) -> [Int] =
        fun idx, xs ->
            if idx < len 
            then go(idx + 1, xs @ [f(idx)])   
            else xs
        in
        go(0, [])
in

# Reduce a list from the left. #
let fold_left: ((Int, Int) -> Int, Int, [Int]) -> Int =
  fun f, acc, xs ->
    case xs 
    | [] => acc
    | hd::tl => fold_left(f, f(acc, hd), tl) end in

# Reduce a list from the right. #
let fold_right: ((Int, Int) -> Int, [Int], Int) -> Int =
  fun f, xs, acc ->
    case xs
    | [] => acc
    | hd::tl => f(hd, fold_right(f, tl, acc)) end in


666
LSP: Prelude: String parsed successfully
LSP: Prelude: Info map generated successfully
Debug: true, Constrain: Types
LSP: Init: Recieved string: # Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)
























































































































































































































































































LSP: Init: String parsed successfully
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: >( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {go: ((?, ?) -> [?]), filter: (((Int -> Bool), [Int]) -> [Int]), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: 
  LSP: Info: ALL errors:Error in term:
  p
Nature of error: Variable p is not bound    
Error in term:
  p
Nature of error: Variable p is not bound    
Error in term:
  p
Nature of error: type ((Int -> Bool), [Int]) is not consistent with arrow type
  LSP: Info: BidiCtx: Cls: Let expression
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent: Root
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: [?]
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: :: @
  LSP: Concave: Backpack: 
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new_tokens ::= whitespace | "," | "::" | "@"
root ::= new_tokens

Top 20 Logits:

:20.3878
#:15.1273
let:14.5537
##:14.2639
 :13.1829
    :12.5481
################:12.4454
  :12.4434
in:12.2792
   :12.2112
####:11.9999
/*:11.8968
```:11.6162
//:11.4623
[:11.4509
                :11.2666
{:11.2074
(:11.1566
        :11.0613
end:10.9758
########:10.9194

================
# Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)


























































































































































































































































































LSP: Prelude: Recieved string: ### List ###

# Add an element to the front of a list. #
let cons: (Int, [Int]) -> [Int] = fun x, xs -> x::xs in

# Determine the length of a list. #
let length: [Int] -> Int =
  fun xs ->
    case xs
    | [] => 0
    | _::xs => 1 + length(xs) end in

# Extract the first element of a list. #
let hd: [Int] -> Option =
  fun l ->
    case l
    | [] => None
    | x::xs => Some(x) end in

# Extract the rest of the list. #
let tl: [Int] -> [Int] =
  fun l ->
    case l
    | [] => []
    | x::xs => xs end in

# Determine if a list is empty. #
let is_empty: [Int] -> Bool =
  fun xs ->
    case xs
    | [] => true
    | _::_ => false end in

# Return the element at the index. #
let nth: ([Int], Int) -> Option =
  fun xs, n ->
    case xs, n
    | x::_, 0 => Some(x)
    | _::xs, n => nth(xs, n - 1)
    | [], _ => None end in

# Reverse a List. #
let rev: [Int] -> [Int] =
fun l -> 
let go: ([Int], [Int]) -> [Int] =
  fun xs, acc -> 
    case xs 
    | [] => acc 
    | x::xs => go(xs, x::acc) end in
go(l, []) in

# Check if two lists are equal #
let equal: ([Int], [Int]) -> Bool =
    fun p, xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => x == y && equal(xs, ys)
    | _ => false end
in

# Initialize a list with a given length using an initializer function #
let init: (Int, Int -> Int) -> [Int] =
    fun len, f ->
        let go: (Int, [Int]) -> [Int] =
        fun idx, xs ->
            if idx < len 
            then go(idx + 1, xs @ [f(idx)])   
            else xs
        in
        go(0, [])
in

# Reduce a list from the left. #
let fold_left: ((Int, Int) -> Int, Int, [Int]) -> Int =
  fun f, acc, xs ->
    case xs 
    | [] => acc
    | hd::tl => fold_left(f, f(acc, hd), tl) end in

# Reduce a list from the right. #
let fold_right: ((Int, Int) -> Int, [Int], Int) -> Int =
  fun f, xs, acc ->
    case xs
    | [] => acc
    | hd::tl => f(hd, fold_right(f, tl, acc)) end in


666
LSP: Prelude: String parsed successfully
LSP: Prelude: Info map generated successfully
Debug: true, Constrain: Types
LSP: Init: Recieved string: # Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)

























































































































































































































































































LSP: Init: String parsed successfully
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: >( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {go: ((?, ?) -> [?]), filter: (((Int -> Bool), [Int]) -> [Int]), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: 
  LSP: Info: ALL errors:Error in term:
  p
Nature of error: type ((Int -> Bool), [Int]) is not consistent with arrow type    
Error in term:
  p
Nature of error: Variable p is not bound    
Error in term:
  p
Nature of error: Variable p is not bound
  LSP: Info: BidiCtx: Cls: Let expression
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent: Root
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: [?]
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: :: @
  LSP: Concave: Backpack: 
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new_tokens ::= whitespace | "," | "::" | "@"
root ::= new_tokens

Top 20 Logits:

:20.3984
#:15.1218
let:14.5441
##:14.2866
 :13.1829
    :12.5411
################:12.4548
  :12.4387
in:12.2665
   :12.2098
####:12.0132
/*:11.8915
```:11.6183
//:11.4637
[:11.456
                :11.2626
{:11.208
(:11.1546
        :11.057
end:10.9779
########:10.9351

================
# Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)



























































































































































































































































































LSP: Prelude: Recieved string: ### List ###

# Add an element to the front of a list. #
let cons: (Int, [Int]) -> [Int] = fun x, xs -> x::xs in

# Determine the length of a list. #
let length: [Int] -> Int =
  fun xs ->
    case xs
    | [] => 0
    | _::xs => 1 + length(xs) end in

# Extract the first element of a list. #
let hd: [Int] -> Option =
  fun l ->
    case l
    | [] => None
    | x::xs => Some(x) end in

# Extract the rest of the list. #
let tl: [Int] -> [Int] =
  fun l ->
    case l
    | [] => []
    | x::xs => xs end in

# Determine if a list is empty. #
let is_empty: [Int] -> Bool =
  fun xs ->
    case xs
    | [] => true
    | _::_ => false end in

# Return the element at the index. #
let nth: ([Int], Int) -> Option =
  fun xs, n ->
    case xs, n
    | x::_, 0 => Some(x)
    | _::xs, n => nth(xs, n - 1)
    | [], _ => None end in

# Reverse a List. #
let rev: [Int] -> [Int] =
fun l -> 
let go: ([Int], [Int]) -> [Int] =
  fun xs, acc -> 
    case xs 
    | [] => acc 
    | x::xs => go(xs, x::acc) end in
go(l, []) in

# Check if two lists are equal #
let equal: ([Int], [Int]) -> Bool =
    fun p, xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => x == y && equal(xs, ys)
    | _ => false end
in

# Initialize a list with a given length using an initializer function #
let init: (Int, Int -> Int) -> [Int] =
    fun len, f ->
        let go: (Int, [Int]) -> [Int] =
        fun idx, xs ->
            if idx < len 
            then go(idx + 1, xs @ [f(idx)])   
            else xs
        in
        go(0, [])
in

# Reduce a list from the left. #
let fold_left: ((Int, Int) -> Int, Int, [Int]) -> Int =
  fun f, acc, xs ->
    case xs 
    | [] => acc
    | hd::tl => fold_left(f, f(acc, hd), tl) end in

# Reduce a list from the right. #
let fold_right: ((Int, Int) -> Int, [Int], Int) -> Int =
  fun f, xs, acc ->
    case xs
    | [] => acc
    | hd::tl => f(hd, fold_right(f, tl, acc)) end in


666
LSP: Prelude: String parsed successfully
LSP: Prelude: Info map generated successfully
Debug: true, Constrain: Types
LSP: Init: Recieved string: # Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)


























































































































































































































































































LSP: Init: String parsed successfully
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: >( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {go: ((?, ?) -> [?]), filter: (((Int -> Bool), [Int]) -> [Int]), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: 
  LSP: Info: ALL errors:Error in term:
  p
Nature of error: Variable p is not bound    
Error in term:
  p
Nature of error: type ((Int -> Bool), [Int]) is not consistent with arrow type    
Error in term:
  p
Nature of error: Variable p is not bound
  LSP: Info: BidiCtx: Cls: Let expression
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent: Root
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: [?]
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: :: @
  LSP: Concave: Backpack: 
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new_tokens ::= whitespace | "," | "::" | "@"
root ::= new_tokens

Top 20 Logits:

:20.4093
#:15.1143
let:14.5358
##:14.2983
 :13.1829
    :12.5332
################:12.4616
  :12.437
in:12.284
   :12.2057
####:12.0165
/*:11.8829
```:11.6216
[:11.4623
//:11.4595
                :11.265
{:11.2031
(:11.1518
        :11.0531
end:10.9992
########:10.942

================
# Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)




























































































































































































































































































LSP: Prelude: Recieved string: ### List ###

# Add an element to the front of a list. #
let cons: (Int, [Int]) -> [Int] = fun x, xs -> x::xs in

# Determine the length of a list. #
let length: [Int] -> Int =
  fun xs ->
    case xs
    | [] => 0
    | _::xs => 1 + length(xs) end in

# Extract the first element of a list. #
let hd: [Int] -> Option =
  fun l ->
    case l
    | [] => None
    | x::xs => Some(x) end in

# Extract the rest of the list. #
let tl: [Int] -> [Int] =
  fun l ->
    case l
    | [] => []
    | x::xs => xs end in

# Determine if a list is empty. #
let is_empty: [Int] -> Bool =
  fun xs ->
    case xs
    | [] => true
    | _::_ => false end in

# Return the element at the index. #
let nth: ([Int], Int) -> Option =
  fun xs, n ->
    case xs, n
    | x::_, 0 => Some(x)
    | _::xs, n => nth(xs, n - 1)
    | [], _ => None end in

# Reverse a List. #
let rev: [Int] -> [Int] =
fun l -> 
let go: ([Int], [Int]) -> [Int] =
  fun xs, acc -> 
    case xs 
    | [] => acc 
    | x::xs => go(xs, x::acc) end in
go(l, []) in

# Check if two lists are equal #
let equal: ([Int], [Int]) -> Bool =
    fun p, xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => x == y && equal(xs, ys)
    | _ => false end
in

# Initialize a list with a given length using an initializer function #
let init: (Int, Int -> Int) -> [Int] =
    fun len, f ->
        let go: (Int, [Int]) -> [Int] =
        fun idx, xs ->
            if idx < len 
            then go(idx + 1, xs @ [f(idx)])   
            else xs
        in
        go(0, [])
in

# Reduce a list from the left. #
let fold_left: ((Int, Int) -> Int, Int, [Int]) -> Int =
  fun f, acc, xs ->
    case xs 
    | [] => acc
    | hd::tl => fold_left(f, f(acc, hd), tl) end in

# Reduce a list from the right. #
let fold_right: ((Int, Int) -> Int, [Int], Int) -> Int =
  fun f, xs, acc ->
    case xs
    | [] => acc
    | hd::tl => f(hd, fold_right(f, tl, acc)) end in


666
LSP: Prelude: String parsed successfully
LSP: Prelude: Info map generated successfully
Debug: true, Constrain: Types
LSP: Init: Recieved string: # Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)



























































































































































































































































































LSP: Init: String parsed successfully
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: >( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {go: ((?, ?) -> [?]), filter: (((Int -> Bool), [Int]) -> [Int]), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: 
  LSP: Info: ALL errors:Error in term:
  p
Nature of error: type ((Int -> Bool), [Int]) is not consistent with arrow type    
Error in term:
  p
Nature of error: Variable p is not bound    
Error in term:
  p
Nature of error: Variable p is not bound
  LSP: Info: BidiCtx: Cls: Let expression
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent: Root
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: [?]
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: :: @
  LSP: Concave: Backpack: 
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new_tokens ::= whitespace | "," | "::" | "@"
root ::= new_tokens

Top 20 Logits:

:20.4161
#:15.1071
let:14.5286
##:14.2913
 :13.1827
    :12.5259
################:12.4609
  :12.4379
in:12.3287
   :12.1993
####:12.007
/*:11.8766
```:11.6179
[:11.4636
//:11.4549
                :11.2706
{:11.1967
(:11.1469
        :11.0496
end:11.0357
########:10.9352

================
# Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)





























































































































































































































































































LSP: Prelude: Recieved string: ### List ###

# Add an element to the front of a list. #
let cons: (Int, [Int]) -> [Int] = fun x, xs -> x::xs in

# Determine the length of a list. #
let length: [Int] -> Int =
  fun xs ->
    case xs
    | [] => 0
    | _::xs => 1 + length(xs) end in

# Extract the first element of a list. #
let hd: [Int] -> Option =
  fun l ->
    case l
    | [] => None
    | x::xs => Some(x) end in

# Extract the rest of the list. #
let tl: [Int] -> [Int] =
  fun l ->
    case l
    | [] => []
    | x::xs => xs end in

# Determine if a list is empty. #
let is_empty: [Int] -> Bool =
  fun xs ->
    case xs
    | [] => true
    | _::_ => false end in

# Return the element at the index. #
let nth: ([Int], Int) -> Option =
  fun xs, n ->
    case xs, n
    | x::_, 0 => Some(x)
    | _::xs, n => nth(xs, n - 1)
    | [], _ => None end in

# Reverse a List. #
let rev: [Int] -> [Int] =
fun l -> 
let go: ([Int], [Int]) -> [Int] =
  fun xs, acc -> 
    case xs 
    | [] => acc 
    | x::xs => go(xs, x::acc) end in
go(l, []) in

# Check if two lists are equal #
let equal: ([Int], [Int]) -> Bool =
    fun p, xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => x == y && equal(xs, ys)
    | _ => false end
in

# Initialize a list with a given length using an initializer function #
let init: (Int, Int -> Int) -> [Int] =
    fun len, f ->
        let go: (Int, [Int]) -> [Int] =
        fun idx, xs ->
            if idx < len 
            then go(idx + 1, xs @ [f(idx)])   
            else xs
        in
        go(0, [])
in

# Reduce a list from the left. #
let fold_left: ((Int, Int) -> Int, Int, [Int]) -> Int =
  fun f, acc, xs ->
    case xs 
    | [] => acc
    | hd::tl => fold_left(f, f(acc, hd), tl) end in

# Reduce a list from the right. #
let fold_right: ((Int, Int) -> Int, [Int], Int) -> Int =
  fun f, xs, acc ->
    case xs
    | [] => acc
    | hd::tl => f(hd, fold_right(f, tl, acc)) end in


666
LSP: Prelude: String parsed successfully
LSP: Prelude: Info map generated successfully
Debug: true, Constrain: Types
LSP: Init: Recieved string: # Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)




























































































































































































































































































LSP: Init: String parsed successfully
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: >( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {go: ((?, ?) -> [?]), filter: (((Int -> Bool), [Int]) -> [Int]), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: 
  LSP: Info: ALL errors:Error in term:
  p
Nature of error: Variable p is not bound    
Error in term:
  p
Nature of error: Variable p is not bound    
Error in term:
  p
Nature of error: type ((Int -> Bool), [Int]) is not consistent with arrow type
  LSP: Info: BidiCtx: Cls: Let expression
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent: Root
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: [?]
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: :: @
  LSP: Concave: Backpack: 
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new_tokens ::= whitespace | "," | "::" | "@"
root ::= new_tokens

Top 20 Logits:

:20.4179
#:15.1038
let:14.5249
##:14.2701
 :13.1827
    :12.5204
################:12.4535
  :12.4396
in:12.3722
   :12.1939
####:11.9909
/*:11.8751
```:11.6071
[:11.4615
//:11.4539
                :11.2758
{:11.1954
(:11.1446
end:11.0687
        :11.0467
########:10.9199

================
# Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)






























































































































































































































































































LSP: Prelude: Recieved string: ### List ###

# Add an element to the front of a list. #
let cons: (Int, [Int]) -> [Int] = fun x, xs -> x::xs in

# Determine the length of a list. #
let length: [Int] -> Int =
  fun xs ->
    case xs
    | [] => 0
    | _::xs => 1 + length(xs) end in

# Extract the first element of a list. #
let hd: [Int] -> Option =
  fun l ->
    case l
    | [] => None
    | x::xs => Some(x) end in

# Extract the rest of the list. #
let tl: [Int] -> [Int] =
  fun l ->
    case l
    | [] => []
    | x::xs => xs end in

# Determine if a list is empty. #
let is_empty: [Int] -> Bool =
  fun xs ->
    case xs
    | [] => true
    | _::_ => false end in

# Return the element at the index. #
let nth: ([Int], Int) -> Option =
  fun xs, n ->
    case xs, n
    | x::_, 0 => Some(x)
    | _::xs, n => nth(xs, n - 1)
    | [], _ => None end in

# Reverse a List. #
let rev: [Int] -> [Int] =
fun l -> 
let go: ([Int], [Int]) -> [Int] =
  fun xs, acc -> 
    case xs 
    | [] => acc 
    | x::xs => go(xs, x::acc) end in
go(l, []) in

# Check if two lists are equal #
let equal: ([Int], [Int]) -> Bool =
    fun p, xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => x == y && equal(xs, ys)
    | _ => false end
in

# Initialize a list with a given length using an initializer function #
let init: (Int, Int -> Int) -> [Int] =
    fun len, f ->
        let go: (Int, [Int]) -> [Int] =
        fun idx, xs ->
            if idx < len 
            then go(idx + 1, xs @ [f(idx)])   
            else xs
        in
        go(0, [])
in

# Reduce a list from the left. #
let fold_left: ((Int, Int) -> Int, Int, [Int]) -> Int =
  fun f, acc, xs ->
    case xs 
    | [] => acc
    | hd::tl => fold_left(f, f(acc, hd), tl) end in

# Reduce a list from the right. #
let fold_right: ((Int, Int) -> Int, [Int], Int) -> Int =
  fun f, xs, acc ->
    case xs
    | [] => acc
    | hd::tl => f(hd, fold_right(f, tl, acc)) end in


666
LSP: Prelude: String parsed successfully
LSP: Prelude: Info map generated successfully
Debug: true, Constrain: Types
LSP: Init: Recieved string: # Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)





























































































































































































































































































LSP: Init: String parsed successfully
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: >( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {go: ((?, ?) -> [?]), filter: (((Int -> Bool), [Int]) -> [Int]), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: 
  LSP: Info: ALL errors:Error in term:
  p
Nature of error: Variable p is not bound    
Error in term:
  p
Nature of error: Variable p is not bound    
Error in term:
  p
Nature of error: type ((Int -> Bool), [Int]) is not consistent with arrow type
  LSP: Info: BidiCtx: Cls: Let expression
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent: Root
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: [?]
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: :: @
  LSP: Concave: Backpack: 
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new_tokens ::= whitespace | "," | "::" | "@"
root ::= new_tokens

Top 20 Logits:

:20.4186
#:15.1076
let:14.5259
##:14.2508
 :13.1842
    :12.5165
################:12.4476
  :12.4407
in:12.3749
   :12.1929
####:11.9818
/*:11.8777
```:11.5985
[:11.4628
//:11.4569
                :11.2786
{:11.2019
(:11.1489
end:11.0741
        :11.0446
########:10.909

================
# Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)































































































































































































































































































LSP: Prelude: Recieved string: ### List ###

# Add an element to the front of a list. #
let cons: (Int, [Int]) -> [Int] = fun x, xs -> x::xs in

# Determine the length of a list. #
let length: [Int] -> Int =
  fun xs ->
    case xs
    | [] => 0
    | _::xs => 1 + length(xs) end in

# Extract the first element of a list. #
let hd: [Int] -> Option =
  fun l ->
    case l
    | [] => None
    | x::xs => Some(x) end in

# Extract the rest of the list. #
let tl: [Int] -> [Int] =
  fun l ->
    case l
    | [] => []
    | x::xs => xs end in

# Determine if a list is empty. #
let is_empty: [Int] -> Bool =
  fun xs ->
    case xs
    | [] => true
    | _::_ => false end in

# Return the element at the index. #
let nth: ([Int], Int) -> Option =
  fun xs, n ->
    case xs, n
    | x::_, 0 => Some(x)
    | _::xs, n => nth(xs, n - 1)
    | [], _ => None end in

# Reverse a List. #
let rev: [Int] -> [Int] =
fun l -> 
let go: ([Int], [Int]) -> [Int] =
  fun xs, acc -> 
    case xs 
    | [] => acc 
    | x::xs => go(xs, x::acc) end in
go(l, []) in

# Check if two lists are equal #
let equal: ([Int], [Int]) -> Bool =
    fun p, xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => x == y && equal(xs, ys)
    | _ => false end
in

# Initialize a list with a given length using an initializer function #
let init: (Int, Int -> Int) -> [Int] =
    fun len, f ->
        let go: (Int, [Int]) -> [Int] =
        fun idx, xs ->
            if idx < len 
            then go(idx + 1, xs @ [f(idx)])   
            else xs
        in
        go(0, [])
in

# Reduce a list from the left. #
let fold_left: ((Int, Int) -> Int, Int, [Int]) -> Int =
  fun f, acc, xs ->
    case xs 
    | [] => acc
    | hd::tl => fold_left(f, f(acc, hd), tl) end in

# Reduce a list from the right. #
let fold_right: ((Int, Int) -> Int, [Int], Int) -> Int =
  fun f, xs, acc ->
    case xs
    | [] => acc
    | hd::tl => f(hd, fold_right(f, tl, acc)) end in


666
LSP: Prelude: String parsed successfully
LSP: Prelude: Info map generated successfully
Debug: true, Constrain: Types
LSP: Init: Recieved string: # Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)






























































































































































































































































































LSP: Init: String parsed successfully
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: >( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {go: ((?, ?) -> [?]), filter: (((Int -> Bool), [Int]) -> [Int]), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: 
  LSP: Info: ALL errors:Error in term:
  p
Nature of error: Variable p is not bound    
Error in term:
  p
Nature of error: Variable p is not bound    
Error in term:
  p
Nature of error: type ((Int -> Bool), [Int]) is not consistent with arrow type
  LSP: Info: BidiCtx: Cls: Let expression
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent: Root
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: [?]
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: :: @
  LSP: Concave: Backpack: 
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new_tokens ::= whitespace | "," | "::" | "@"
root ::= new_tokens

Top 20 Logits:

:20.422
#:15.1137
let:14.5299
##:14.2482
 :13.1843
    :12.5107
################:12.4504
  :12.4379
in:12.3173
   :12.1938
####:11.9872
/*:11.8829
```:11.5978
[:11.4712
//:11.4628
                :11.2758
{:11.2111
(:11.1562
end:11.0409
        :11.04
########:10.9108

================
# Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)
































































































































































































































































































LSP: Prelude: Recieved string: ### List ###

# Add an element to the front of a list. #
let cons: (Int, [Int]) -> [Int] = fun x, xs -> x::xs in

# Determine the length of a list. #
let length: [Int] -> Int =
  fun xs ->
    case xs
    | [] => 0
    | _::xs => 1 + length(xs) end in

# Extract the first element of a list. #
let hd: [Int] -> Option =
  fun l ->
    case l
    | [] => None
    | x::xs => Some(x) end in

# Extract the rest of the list. #
let tl: [Int] -> [Int] =
  fun l ->
    case l
    | [] => []
    | x::xs => xs end in

# Determine if a list is empty. #
let is_empty: [Int] -> Bool =
  fun xs ->
    case xs
    | [] => true
    | _::_ => false end in

# Return the element at the index. #
let nth: ([Int], Int) -> Option =
  fun xs, n ->
    case xs, n
    | x::_, 0 => Some(x)
    | _::xs, n => nth(xs, n - 1)
    | [], _ => None end in

# Reverse a List. #
let rev: [Int] -> [Int] =
fun l -> 
let go: ([Int], [Int]) -> [Int] =
  fun xs, acc -> 
    case xs 
    | [] => acc 
    | x::xs => go(xs, x::acc) end in
go(l, []) in

# Check if two lists are equal #
let equal: ([Int], [Int]) -> Bool =
    fun p, xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => x == y && equal(xs, ys)
    | _ => false end
in

# Initialize a list with a given length using an initializer function #
let init: (Int, Int -> Int) -> [Int] =
    fun len, f ->
        let go: (Int, [Int]) -> [Int] =
        fun idx, xs ->
            if idx < len 
            then go(idx + 1, xs @ [f(idx)])   
            else xs
        in
        go(0, [])
in

# Reduce a list from the left. #
let fold_left: ((Int, Int) -> Int, Int, [Int]) -> Int =
  fun f, acc, xs ->
    case xs 
    | [] => acc
    | hd::tl => fold_left(f, f(acc, hd), tl) end in

# Reduce a list from the right. #
let fold_right: ((Int, Int) -> Int, [Int], Int) -> Int =
  fun f, xs, acc ->
    case xs
    | [] => acc
    | hd::tl => f(hd, fold_right(f, tl, acc)) end in


666
LSP: Prelude: String parsed successfully
LSP: Prelude: Info map generated successfully
Debug: true, Constrain: Types
LSP: Init: Recieved string: # Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)































































































































































































































































































LSP: Init: String parsed successfully
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: >( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {go: ((?, ?) -> [?]), filter: (((Int -> Bool), [Int]) -> [Int]), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: 
  LSP: Info: ALL errors:Error in term:
  p
Nature of error: type ((Int -> Bool), [Int]) is not consistent with arrow type    
Error in term:
  p
Nature of error: Variable p is not bound    
Error in term:
  p
Nature of error: Variable p is not bound
  LSP: Info: BidiCtx: Cls: Let expression
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent: Root
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: [?]
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: :: @
  LSP: Concave: Backpack: 
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new_tokens ::= whitespace | "," | "::" | "@"
root ::= new_tokens

Top 20 Logits:

:20.4305
#:15.1146
let:14.5342
##:14.2651
 :13.1819
    :12.5018
################:12.4621
  :12.4326
in:12.2271
   :12.1925
####:12.0037
/*:11.887
```:11.605
[:11.4842
//:11.469
                :11.269
{:11.2162
(:11.1582
        :11.032
end:10.9875
########:10.9244

================
# Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)

































































































































































































































































































LSP: Prelude: Recieved string: ### List ###

# Add an element to the front of a list. #
let cons: (Int, [Int]) -> [Int] = fun x, xs -> x::xs in

# Determine the length of a list. #
let length: [Int] -> Int =
  fun xs ->
    case xs
    | [] => 0
    | _::xs => 1 + length(xs) end in

# Extract the first element of a list. #
let hd: [Int] -> Option =
  fun l ->
    case l
    | [] => None
    | x::xs => Some(x) end in

# Extract the rest of the list. #
let tl: [Int] -> [Int] =
  fun l ->
    case l
    | [] => []
    | x::xs => xs end in

# Determine if a list is empty. #
let is_empty: [Int] -> Bool =
  fun xs ->
    case xs
    | [] => true
    | _::_ => false end in

# Return the element at the index. #
let nth: ([Int], Int) -> Option =
  fun xs, n ->
    case xs, n
    | x::_, 0 => Some(x)
    | _::xs, n => nth(xs, n - 1)
    | [], _ => None end in

# Reverse a List. #
let rev: [Int] -> [Int] =
fun l -> 
let go: ([Int], [Int]) -> [Int] =
  fun xs, acc -> 
    case xs 
    | [] => acc 
    | x::xs => go(xs, x::acc) end in
go(l, []) in

# Check if two lists are equal #
let equal: ([Int], [Int]) -> Bool =
    fun p, xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => x == y && equal(xs, ys)
    | _ => false end
in

# Initialize a list with a given length using an initializer function #
let init: (Int, Int -> Int) -> [Int] =
    fun len, f ->
        let go: (Int, [Int]) -> [Int] =
        fun idx, xs ->
            if idx < len 
            then go(idx + 1, xs @ [f(idx)])   
            else xs
        in
        go(0, [])
in

# Reduce a list from the left. #
let fold_left: ((Int, Int) -> Int, Int, [Int]) -> Int =
  fun f, acc, xs ->
    case xs 
    | [] => acc
    | hd::tl => fold_left(f, f(acc, hd), tl) end in

# Reduce a list from the right. #
let fold_right: ((Int, Int) -> Int, [Int], Int) -> Int =
  fun f, xs, acc ->
    case xs
    | [] => acc
    | hd::tl => f(hd, fold_right(f, tl, acc)) end in


666
LSP: Prelude: String parsed successfully
LSP: Prelude: Info map generated successfully
Debug: true, Constrain: Types
LSP: Init: Recieved string: # Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)
































































































































































































































































































LSP: Init: String parsed successfully
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: >( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {go: ((?, ?) -> [?]), filter: (((Int -> Bool), [Int]) -> [Int]), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: 
  LSP: Info: ALL errors:Error in term:
  p
Nature of error: Variable p is not bound    
Error in term:
  p
Nature of error: type ((Int -> Bool), [Int]) is not consistent with arrow type    
Error in term:
  p
Nature of error: Variable p is not bound
  LSP: Info: BidiCtx: Cls: Let expression
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent: Root
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: [?]
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: :: @
  LSP: Concave: Backpack: 
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new_tokens ::= whitespace | "," | "::" | "@"
root ::= new_tokens

Top 20 Logits:

:20.4427
#:15.1059
let:14.5344
##:14.2882
 :13.1782
    :12.493
################:12.4762
  :12.4287
   :12.1866
in:12.1533
####:12.0183
/*:11.8871
```:11.6129
[:11.493
//:11.4709
                :11.2637
{:11.2121
(:11.15
        :11.0242
end:10.95
########:10.9406

================
# Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)


































































































































































































































































































LSP: Prelude: Recieved string: ### List ###

# Add an element to the front of a list. #
let cons: (Int, [Int]) -> [Int] = fun x, xs -> x::xs in

# Determine the length of a list. #
let length: [Int] -> Int =
  fun xs ->
    case xs
    | [] => 0
    | _::xs => 1 + length(xs) end in

# Extract the first element of a list. #
let hd: [Int] -> Option =
  fun l ->
    case l
    | [] => None
    | x::xs => Some(x) end in

# Extract the rest of the list. #
let tl: [Int] -> [Int] =
  fun l ->
    case l
    | [] => []
    | x::xs => xs end in

# Determine if a list is empty. #
let is_empty: [Int] -> Bool =
  fun xs ->
    case xs
    | [] => true
    | _::_ => false end in

# Return the element at the index. #
let nth: ([Int], Int) -> Option =
  fun xs, n ->
    case xs, n
    | x::_, 0 => Some(x)
    | _::xs, n => nth(xs, n - 1)
    | [], _ => None end in

# Reverse a List. #
let rev: [Int] -> [Int] =
fun l -> 
let go: ([Int], [Int]) -> [Int] =
  fun xs, acc -> 
    case xs 
    | [] => acc 
    | x::xs => go(xs, x::acc) end in
go(l, []) in

# Check if two lists are equal #
let equal: ([Int], [Int]) -> Bool =
    fun p, xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => x == y && equal(xs, ys)
    | _ => false end
in

# Initialize a list with a given length using an initializer function #
let init: (Int, Int -> Int) -> [Int] =
    fun len, f ->
        let go: (Int, [Int]) -> [Int] =
        fun idx, xs ->
            if idx < len 
            then go(idx + 1, xs @ [f(idx)])   
            else xs
        in
        go(0, [])
in

# Reduce a list from the left. #
let fold_left: ((Int, Int) -> Int, Int, [Int]) -> Int =
  fun f, acc, xs ->
    case xs 
    | [] => acc
    | hd::tl => fold_left(f, f(acc, hd), tl) end in

# Reduce a list from the right. #
let fold_right: ((Int, Int) -> Int, [Int], Int) -> Int =
  fun f, xs, acc ->
    case xs
    | [] => acc
    | hd::tl => f(hd, fold_right(f, tl, acc)) end in


666
LSP: Prelude: String parsed successfully
LSP: Prelude: Info map generated successfully
Debug: true, Constrain: Types
LSP: Init: Recieved string: # Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)

































































































































































































































































































LSP: Init: String parsed successfully
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: >( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {go: ((?, ?) -> [?]), filter: (((Int -> Bool), [Int]) -> [Int]), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: 
  LSP: Info: ALL errors:Error in term:
  p
Nature of error: Variable p is not bound    
Error in term:
  p
Nature of error: type ((Int -> Bool), [Int]) is not consistent with arrow type    
Error in term:
  p
Nature of error: Variable p is not bound
  LSP: Info: BidiCtx: Cls: Let expression
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent: Root
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: [?]
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: :: @
  LSP: Concave: Backpack: 
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new_tokens ::= whitespace | "," | "::" | "@"
root ::= new_tokens

Top 20 Logits:

:20.4543
#:15.0901
let:14.527
##:14.3022
 :13.1744
    :12.4892
################:12.4855
  :12.4281
   :12.1774
in:12.1259
####:12.0215
/*:11.8868
```:11.6135
[:11.4916
//:11.4699
                :11.2625
{:11.2002
(:11.1351
        :11.0209
########:10.95
end:10.9463

================
# Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)



































































































































































































































































































LSP: Prelude: Recieved string: ### List ###

# Add an element to the front of a list. #
let cons: (Int, [Int]) -> [Int] = fun x, xs -> x::xs in

# Determine the length of a list. #
let length: [Int] -> Int =
  fun xs ->
    case xs
    | [] => 0
    | _::xs => 1 + length(xs) end in

# Extract the first element of a list. #
let hd: [Int] -> Option =
  fun l ->
    case l
    | [] => None
    | x::xs => Some(x) end in

# Extract the rest of the list. #
let tl: [Int] -> [Int] =
  fun l ->
    case l
    | [] => []
    | x::xs => xs end in

# Determine if a list is empty. #
let is_empty: [Int] -> Bool =
  fun xs ->
    case xs
    | [] => true
    | _::_ => false end in

# Return the element at the index. #
let nth: ([Int], Int) -> Option =
  fun xs, n ->
    case xs, n
    | x::_, 0 => Some(x)
    | _::xs, n => nth(xs, n - 1)
    | [], _ => None end in

# Reverse a List. #
let rev: [Int] -> [Int] =
fun l -> 
let go: ([Int], [Int]) -> [Int] =
  fun xs, acc -> 
    case xs 
    | [] => acc 
    | x::xs => go(xs, x::acc) end in
go(l, []) in

# Check if two lists are equal #
let equal: ([Int], [Int]) -> Bool =
    fun p, xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => x == y && equal(xs, ys)
    | _ => false end
in

# Initialize a list with a given length using an initializer function #
let init: (Int, Int -> Int) -> [Int] =
    fun len, f ->
        let go: (Int, [Int]) -> [Int] =
        fun idx, xs ->
            if idx < len 
            then go(idx + 1, xs @ [f(idx)])   
            else xs
        in
        go(0, [])
in

# Reduce a list from the left. #
let fold_left: ((Int, Int) -> Int, Int, [Int]) -> Int =
  fun f, acc, xs ->
    case xs 
    | [] => acc
    | hd::tl => fold_left(f, f(acc, hd), tl) end in

# Reduce a list from the right. #
let fold_right: ((Int, Int) -> Int, [Int], Int) -> Int =
  fun f, xs, acc ->
    case xs
    | [] => acc
    | hd::tl => f(hd, fold_right(f, tl, acc)) end in


666
LSP: Prelude: String parsed successfully
LSP: Prelude: Info map generated successfully
Debug: true, Constrain: Types
LSP: Init: Recieved string: # Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)


































































































































































































































































































LSP: Init: String parsed successfully
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: >( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {go: ((?, ?) -> [?]), filter: (((Int -> Bool), [Int]) -> [Int]), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: 
  LSP: Info: ALL errors:Error in term:
  p
Nature of error: type ((Int -> Bool), [Int]) is not consistent with arrow type    
Error in term:
  p
Nature of error: Variable p is not bound    
Error in term:
  p
Nature of error: Variable p is not bound
  LSP: Info: BidiCtx: Cls: Let expression
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent: Root
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: [?]
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: :: @
  LSP: Concave: Backpack: 
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new_tokens ::= whitespace | "," | "::" | "@"
root ::= new_tokens

Top 20 Logits:

:20.4617
#:15.0754
let:14.5156
##:14.3002
 :13.1716
    :12.4902
################:12.4863
  :12.4299
   :12.1684
in:12.143
####:12.0134
/*:11.8885
```:11.6051
[:11.4829
//:11.4705
                :11.2628
{:11.1881
(:11.1228
        :11.021
end:10.9677
########:10.9475

================
# Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)




































































































































































































































































































LSP: Prelude: Recieved string: ### List ###

# Add an element to the front of a list. #
let cons: (Int, [Int]) -> [Int] = fun x, xs -> x::xs in

# Determine the length of a list. #
let length: [Int] -> Int =
  fun xs ->
    case xs
    | [] => 0
    | _::xs => 1 + length(xs) end in

# Extract the first element of a list. #
let hd: [Int] -> Option =
  fun l ->
    case l
    | [] => None
    | x::xs => Some(x) end in

# Extract the rest of the list. #
let tl: [Int] -> [Int] =
  fun l ->
    case l
    | [] => []
    | x::xs => xs end in

# Determine if a list is empty. #
let is_empty: [Int] -> Bool =
  fun xs ->
    case xs
    | [] => true
    | _::_ => false end in

# Return the element at the index. #
let nth: ([Int], Int) -> Option =
  fun xs, n ->
    case xs, n
    | x::_, 0 => Some(x)
    | _::xs, n => nth(xs, n - 1)
    | [], _ => None end in

# Reverse a List. #
let rev: [Int] -> [Int] =
fun l -> 
let go: ([Int], [Int]) -> [Int] =
  fun xs, acc -> 
    case xs 
    | [] => acc 
    | x::xs => go(xs, x::acc) end in
go(l, []) in

# Check if two lists are equal #
let equal: ([Int], [Int]) -> Bool =
    fun p, xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => x == y && equal(xs, ys)
    | _ => false end
in

# Initialize a list with a given length using an initializer function #
let init: (Int, Int -> Int) -> [Int] =
    fun len, f ->
        let go: (Int, [Int]) -> [Int] =
        fun idx, xs ->
            if idx < len 
            then go(idx + 1, xs @ [f(idx)])   
            else xs
        in
        go(0, [])
in

# Reduce a list from the left. #
let fold_left: ((Int, Int) -> Int, Int, [Int]) -> Int =
  fun f, acc, xs ->
    case xs 
    | [] => acc
    | hd::tl => fold_left(f, f(acc, hd), tl) end in

# Reduce a list from the right. #
let fold_right: ((Int, Int) -> Int, [Int], Int) -> Int =
  fun f, xs, acc ->
    case xs
    | [] => acc
    | hd::tl => f(hd, fold_right(f, tl, acc)) end in


666
LSP: Prelude: String parsed successfully
LSP: Prelude: Info map generated successfully
Debug: true, Constrain: Types
LSP: Init: Recieved string: # Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)



































































































































































































































































































LSP: Init: String parsed successfully
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: >( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {go: ((?, ?) -> [?]), filter: (((Int -> Bool), [Int]) -> [Int]), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: 
  LSP: Info: ALL errors:Error in term:
  p
Nature of error: type ((Int -> Bool), [Int]) is not consistent with arrow type    
Error in term:
  p
Nature of error: Variable p is not bound    
Error in term:
  p
Nature of error: Variable p is not bound
  LSP: Info: BidiCtx: Cls: Let expression
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent: Root
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: [?]
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: :: @
  LSP: Concave: Backpack: 
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new_tokens ::= whitespace | "," | "::" | "@"
root ::= new_tokens

Top 20 Logits:

:20.4654
#:15.0709
let:14.5082
##:14.2833
 :13.1696
    :12.4933
################:12.4806
  :12.4309
in:12.1776
   :12.1611
####:11.9982
/*:11.8907
```:11.593
[:11.4739
//:11.4722
                :11.2629
{:11.1808
(:11.123
        :11.0215
end:10.9908
########:10.9352

================
# Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)





































































































































































































































































































LSP: Prelude: Recieved string: ### List ###

# Add an element to the front of a list. #
let cons: (Int, [Int]) -> [Int] = fun x, xs -> x::xs in

# Determine the length of a list. #
let length: [Int] -> Int =
  fun xs ->
    case xs
    | [] => 0
    | _::xs => 1 + length(xs) end in

# Extract the first element of a list. #
let hd: [Int] -> Option =
  fun l ->
    case l
    | [] => None
    | x::xs => Some(x) end in

# Extract the rest of the list. #
let tl: [Int] -> [Int] =
  fun l ->
    case l
    | [] => []
    | x::xs => xs end in

# Determine if a list is empty. #
let is_empty: [Int] -> Bool =
  fun xs ->
    case xs
    | [] => true
    | _::_ => false end in

# Return the element at the index. #
let nth: ([Int], Int) -> Option =
  fun xs, n ->
    case xs, n
    | x::_, 0 => Some(x)
    | _::xs, n => nth(xs, n - 1)
    | [], _ => None end in

# Reverse a List. #
let rev: [Int] -> [Int] =
fun l -> 
let go: ([Int], [Int]) -> [Int] =
  fun xs, acc -> 
    case xs 
    | [] => acc 
    | x::xs => go(xs, x::acc) end in
go(l, []) in

# Check if two lists are equal #
let equal: ([Int], [Int]) -> Bool =
    fun p, xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => x == y && equal(xs, ys)
    | _ => false end
in

# Initialize a list with a given length using an initializer function #
let init: (Int, Int -> Int) -> [Int] =
    fun len, f ->
        let go: (Int, [Int]) -> [Int] =
        fun idx, xs ->
            if idx < len 
            then go(idx + 1, xs @ [f(idx)])   
            else xs
        in
        go(0, [])
in

# Reduce a list from the left. #
let fold_left: ((Int, Int) -> Int, Int, [Int]) -> Int =
  fun f, acc, xs ->
    case xs 
    | [] => acc
    | hd::tl => fold_left(f, f(acc, hd), tl) end in

# Reduce a list from the right. #
let fold_right: ((Int, Int) -> Int, [Int], Int) -> Int =
  fun f, xs, acc ->
    case xs
    | [] => acc
    | hd::tl => f(hd, fold_right(f, tl, acc)) end in


666
LSP: Prelude: String parsed successfully
LSP: Prelude: Info map generated successfully
Debug: true, Constrain: Types
LSP: Init: Recieved string: # Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)




































































































































































































































































































LSP: Init: String parsed successfully
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: >( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {go: ((?, ?) -> [?]), filter: (((Int -> Bool), [Int]) -> [Int]), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: 
  LSP: Info: ALL errors:Error in term:
  p
Nature of error: Variable p is not bound    
Error in term:
  p
Nature of error: Variable p is not bound    
Error in term:
  p
Nature of error: type ((Int -> Bool), [Int]) is not consistent with arrow type
  LSP: Info: BidiCtx: Cls: Let expression
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent: Root
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: [?]
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: :: @
  LSP: Concave: Backpack: 
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new_tokens ::= whitespace | "," | "::" | "@"
root ::= new_tokens

Top 20 Logits:

:20.4693
#:15.0805
let:14.5101
##:14.2623
 :13.1686
    :12.4945
################:12.4732
  :12.4283
in:12.1988
   :12.1567
####:11.9836
/*:11.8933
```:11.5868
//:11.4755
[:11.4732
                :11.2615
{:11.1806
(:11.1373
        :11.0199
end:10.9989
########:10.9205

================
# Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)






































































































































































































































































































LSP: Prelude: Recieved string: ### List ###

# Add an element to the front of a list. #
let cons: (Int, [Int]) -> [Int] = fun x, xs -> x::xs in

# Determine the length of a list. #
let length: [Int] -> Int =
  fun xs ->
    case xs
    | [] => 0
    | _::xs => 1 + length(xs) end in

# Extract the first element of a list. #
let hd: [Int] -> Option =
  fun l ->
    case l
    | [] => None
    | x::xs => Some(x) end in

# Extract the rest of the list. #
let tl: [Int] -> [Int] =
  fun l ->
    case l
    | [] => []
    | x::xs => xs end in

# Determine if a list is empty. #
let is_empty: [Int] -> Bool =
  fun xs ->
    case xs
    | [] => true
    | _::_ => false end in

# Return the element at the index. #
let nth: ([Int], Int) -> Option =
  fun xs, n ->
    case xs, n
    | x::_, 0 => Some(x)
    | _::xs, n => nth(xs, n - 1)
    | [], _ => None end in

# Reverse a List. #
let rev: [Int] -> [Int] =
fun l -> 
let go: ([Int], [Int]) -> [Int] =
  fun xs, acc -> 
    case xs 
    | [] => acc 
    | x::xs => go(xs, x::acc) end in
go(l, []) in

# Check if two lists are equal #
let equal: ([Int], [Int]) -> Bool =
    fun p, xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => x == y && equal(xs, ys)
    | _ => false end
in

# Initialize a list with a given length using an initializer function #
let init: (Int, Int -> Int) -> [Int] =
    fun len, f ->
        let go: (Int, [Int]) -> [Int] =
        fun idx, xs ->
            if idx < len 
            then go(idx + 1, xs @ [f(idx)])   
            else xs
        in
        go(0, [])
in

# Reduce a list from the left. #
let fold_left: ((Int, Int) -> Int, Int, [Int]) -> Int =
  fun f, acc, xs ->
    case xs 
    | [] => acc
    | hd::tl => fold_left(f, f(acc, hd), tl) end in

# Reduce a list from the right. #
let fold_right: ((Int, Int) -> Int, [Int], Int) -> Int =
  fun f, xs, acc ->
    case xs
    | [] => acc
    | hd::tl => f(hd, fold_right(f, tl, acc)) end in


666
LSP: Prelude: String parsed successfully
LSP: Prelude: Info map generated successfully
Debug: true, Constrain: Types
LSP: Init: Recieved string: # Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)





































































































































































































































































































LSP: Init: String parsed successfully
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: >( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {go: ((?, ?) -> [?]), filter: (((Int -> Bool), [Int]) -> [Int]), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: 
  LSP: Info: ALL errors:Error in term:
  p
Nature of error: Variable p is not bound    
Error in term:
  p
Nature of error: type ((Int -> Bool), [Int]) is not consistent with arrow type    
Error in term:
  p
Nature of error: Variable p is not bound
  LSP: Info: BidiCtx: Cls: Let expression
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent: Root
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: [?]
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: :: @
  LSP: Concave: Backpack: 
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new_tokens ::= whitespace | "," | "::" | "@"
root ::= new_tokens

Top 20 Logits:

:20.4764
#:15.0992
let:14.5213
##:14.2489
 :13.1672
    :12.4905
################:12.4696
  :12.4215
in:12.1878
   :12.1536
####:11.975
/*:11.8949
```:11.5915
[:11.4844
//:11.478
                :11.2583
{:11.1841
(:11.1578
        :11.0137
end:10.9859
########:10.9102

================
# Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)







































































































































































































































































































LSP: Prelude: Recieved string: ### List ###

# Add an element to the front of a list. #
let cons: (Int, [Int]) -> [Int] = fun x, xs -> x::xs in

# Determine the length of a list. #
let length: [Int] -> Int =
  fun xs ->
    case xs
    | [] => 0
    | _::xs => 1 + length(xs) end in

# Extract the first element of a list. #
let hd: [Int] -> Option =
  fun l ->
    case l
    | [] => None
    | x::xs => Some(x) end in

# Extract the rest of the list. #
let tl: [Int] -> [Int] =
  fun l ->
    case l
    | [] => []
    | x::xs => xs end in

# Determine if a list is empty. #
let is_empty: [Int] -> Bool =
  fun xs ->
    case xs
    | [] => true
    | _::_ => false end in

# Return the element at the index. #
let nth: ([Int], Int) -> Option =
  fun xs, n ->
    case xs, n
    | x::_, 0 => Some(x)
    | _::xs, n => nth(xs, n - 1)
    | [], _ => None end in

# Reverse a List. #
let rev: [Int] -> [Int] =
fun l -> 
let go: ([Int], [Int]) -> [Int] =
  fun xs, acc -> 
    case xs 
    | [] => acc 
    | x::xs => go(xs, x::acc) end in
go(l, []) in

# Check if two lists are equal #
let equal: ([Int], [Int]) -> Bool =
    fun p, xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => x == y && equal(xs, ys)
    | _ => false end
in

# Initialize a list with a given length using an initializer function #
let init: (Int, Int -> Int) -> [Int] =
    fun len, f ->
        let go: (Int, [Int]) -> [Int] =
        fun idx, xs ->
            if idx < len 
            then go(idx + 1, xs @ [f(idx)])   
            else xs
        in
        go(0, [])
in

# Reduce a list from the left. #
let fold_left: ((Int, Int) -> Int, Int, [Int]) -> Int =
  fun f, acc, xs ->
    case xs 
    | [] => acc
    | hd::tl => fold_left(f, f(acc, hd), tl) end in

# Reduce a list from the right. #
let fold_right: ((Int, Int) -> Int, [Int], Int) -> Int =
  fun f, xs, acc ->
    case xs
    | [] => acc
    | hd::tl => f(hd, fold_right(f, tl, acc)) end in


666
LSP: Prelude: String parsed successfully
LSP: Prelude: Info map generated successfully
Debug: true, Constrain: Types
LSP: Init: Recieved string: # Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)






































































































































































































































































































LSP: Init: String parsed successfully
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: >( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {go: ((?, ?) -> [?]), filter: (((Int -> Bool), [Int]) -> [Int]), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: 
  LSP: Info: ALL errors:Error in term:
  p
Nature of error: Variable p is not bound    
Error in term:
  p
Nature of error: type ((Int -> Bool), [Int]) is not consistent with arrow type    
Error in term:
  p
Nature of error: Variable p is not bound
  LSP: Info: BidiCtx: Cls: Let expression
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent: Root
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: [?]
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: :: @
  LSP: Concave: Backpack: 
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new_tokens ::= whitespace | "," | "::" | "@"
root ::= new_tokens

Top 20 Logits:

:20.4855
#:15.1175
let:14.5368
##:14.2466
 :13.1645
    :12.4804
################:12.4713
  :12.4125
in:12.1505
   :12.1489
####:11.9712
/*:11.8935
```:11.6018
[:11.5003
//:11.4768
                :11.2561
{:11.1845
(:11.1729
        :11.0036
end:10.9601
########:10.9058

================
# Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)








































































































































































































































































































LSP: Prelude: Recieved string: ### List ###

# Add an element to the front of a list. #
let cons: (Int, [Int]) -> [Int] = fun x, xs -> x::xs in

# Determine the length of a list. #
let length: [Int] -> Int =
  fun xs ->
    case xs
    | [] => 0
    | _::xs => 1 + length(xs) end in

# Extract the first element of a list. #
let hd: [Int] -> Option =
  fun l ->
    case l
    | [] => None
    | x::xs => Some(x) end in

# Extract the rest of the list. #
let tl: [Int] -> [Int] =
  fun l ->
    case l
    | [] => []
    | x::xs => xs end in

# Determine if a list is empty. #
let is_empty: [Int] -> Bool =
  fun xs ->
    case xs
    | [] => true
    | _::_ => false end in

# Return the element at the index. #
let nth: ([Int], Int) -> Option =
  fun xs, n ->
    case xs, n
    | x::_, 0 => Some(x)
    | _::xs, n => nth(xs, n - 1)
    | [], _ => None end in

# Reverse a List. #
let rev: [Int] -> [Int] =
fun l -> 
let go: ([Int], [Int]) -> [Int] =
  fun xs, acc -> 
    case xs 
    | [] => acc 
    | x::xs => go(xs, x::acc) end in
go(l, []) in

# Check if two lists are equal #
let equal: ([Int], [Int]) -> Bool =
    fun p, xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => x == y && equal(xs, ys)
    | _ => false end
in

# Initialize a list with a given length using an initializer function #
let init: (Int, Int -> Int) -> [Int] =
    fun len, f ->
        let go: (Int, [Int]) -> [Int] =
        fun idx, xs ->
            if idx < len 
            then go(idx + 1, xs @ [f(idx)])   
            else xs
        in
        go(0, [])
in

# Reduce a list from the left. #
let fold_left: ((Int, Int) -> Int, Int, [Int]) -> Int =
  fun f, acc, xs ->
    case xs 
    | [] => acc
    | hd::tl => fold_left(f, f(acc, hd), tl) end in

# Reduce a list from the right. #
let fold_right: ((Int, Int) -> Int, [Int], Int) -> Int =
  fun f, xs, acc ->
    case xs
    | [] => acc
    | hd::tl => f(hd, fold_right(f, tl, acc)) end in


666
LSP: Prelude: String parsed successfully
LSP: Prelude: Info map generated successfully
Debug: true, Constrain: Types
LSP: Init: Recieved string: # Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)







































































































































































































































































































LSP: Init: String parsed successfully
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: >( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {go: ((?, ?) -> [?]), filter: (((Int -> Bool), [Int]) -> [Int]), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: 
  LSP: Info: ALL errors:Error in term:
  p
Nature of error: Variable p is not bound    
Error in term:
  p
Nature of error: Variable p is not bound    
Error in term:
  p
Nature of error: type ((Int -> Bool), [Int]) is not consistent with arrow type
  LSP: Info: BidiCtx: Cls: Let expression
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent: Root
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: [?]
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: :: @
  LSP: Concave: Backpack: 
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new_tokens ::= whitespace | "," | "::" | "@"
root ::= new_tokens

Top 20 Logits:

:20.493
#:15.127
let:14.5498
##:14.2518
 :13.161
################:12.4771
    :12.468
  :12.4051
   :12.1429
in:12.1091
####:11.9676
/*:11.8908
```:11.6083
[:11.5093
//:11.4729
                :11.2572
{:11.1773
(:11.1746
        :10.9937
end:10.9401
########:10.9053

================
# Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)









































































































































































































































































































LSP: Prelude: Recieved string: ### List ###

# Add an element to the front of a list. #
let cons: (Int, [Int]) -> [Int] = fun x, xs -> x::xs in

# Determine the length of a list. #
let length: [Int] -> Int =
  fun xs ->
    case xs
    | [] => 0
    | _::xs => 1 + length(xs) end in

# Extract the first element of a list. #
let hd: [Int] -> Option =
  fun l ->
    case l
    | [] => None
    | x::xs => Some(x) end in

# Extract the rest of the list. #
let tl: [Int] -> [Int] =
  fun l ->
    case l
    | [] => []
    | x::xs => xs end in

# Determine if a list is empty. #
let is_empty: [Int] -> Bool =
  fun xs ->
    case xs
    | [] => true
    | _::_ => false end in

# Return the element at the index. #
let nth: ([Int], Int) -> Option =
  fun xs, n ->
    case xs, n
    | x::_, 0 => Some(x)
    | _::xs, n => nth(xs, n - 1)
    | [], _ => None end in

# Reverse a List. #
let rev: [Int] -> [Int] =
fun l -> 
let go: ([Int], [Int]) -> [Int] =
  fun xs, acc -> 
    case xs 
    | [] => acc 
    | x::xs => go(xs, x::acc) end in
go(l, []) in

# Check if two lists are equal #
let equal: ([Int], [Int]) -> Bool =
    fun p, xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => x == y && equal(xs, ys)
    | _ => false end
in

# Initialize a list with a given length using an initializer function #
let init: (Int, Int -> Int) -> [Int] =
    fun len, f ->
        let go: (Int, [Int]) -> [Int] =
        fun idx, xs ->
            if idx < len 
            then go(idx + 1, xs @ [f(idx)])   
            else xs
        in
        go(0, [])
in

# Reduce a list from the left. #
let fold_left: ((Int, Int) -> Int, Int, [Int]) -> Int =
  fun f, acc, xs ->
    case xs 
    | [] => acc
    | hd::tl => fold_left(f, f(acc, hd), tl) end in

# Reduce a list from the right. #
let fold_right: ((Int, Int) -> Int, [Int], Int) -> Int =
  fun f, xs, acc ->
    case xs
    | [] => acc
    | hd::tl => f(hd, fold_right(f, tl, acc)) end in


666
LSP: Prelude: String parsed successfully
LSP: Prelude: Info map generated successfully
Debug: true, Constrain: Types
LSP: Init: Recieved string: # Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)








































































































































































































































































































LSP: Init: String parsed successfully
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: >( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {go: ((?, ?) -> [?]), filter: (((Int -> Bool), [Int]) -> [Int]), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: 
  LSP: Info: ALL errors:Error in term:
  p
Nature of error: Variable p is not bound    
Error in term:
  p
Nature of error: type ((Int -> Bool), [Int]) is not consistent with arrow type    
Error in term:
  p
Nature of error: Variable p is not bound
  LSP: Info: BidiCtx: Cls: Let expression
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent: Root
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: [?]
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: :: @
  LSP: Concave: Backpack: 
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new_tokens ::= whitespace | "," | "::" | "@"
root ::= new_tokens

Top 20 Logits:

:20.4974
#:15.1273
let:14.5554
##:14.262
 :13.1591
################:12.4849
    :12.4601
  :12.4025
   :12.1397
in:12.0787
####:11.9645
/*:11.8915
```:11.6065
[:11.5077
//:11.4707
                :11.2611
(:11.1672
{:11.1671
        :10.9884
end:10.9362
########:10.9081

================
# Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)










































































































































































































































































































LSP: Prelude: Recieved string: ### List ###

# Add an element to the front of a list. #
let cons: (Int, [Int]) -> [Int] = fun x, xs -> x::xs in

# Determine the length of a list. #
let length: [Int] -> Int =
  fun xs ->
    case xs
    | [] => 0
    | _::xs => 1 + length(xs) end in

# Extract the first element of a list. #
let hd: [Int] -> Option =
  fun l ->
    case l
    | [] => None
    | x::xs => Some(x) end in

# Extract the rest of the list. #
let tl: [Int] -> [Int] =
  fun l ->
    case l
    | [] => []
    | x::xs => xs end in

# Determine if a list is empty. #
let is_empty: [Int] -> Bool =
  fun xs ->
    case xs
    | [] => true
    | _::_ => false end in

# Return the element at the index. #
let nth: ([Int], Int) -> Option =
  fun xs, n ->
    case xs, n
    | x::_, 0 => Some(x)
    | _::xs, n => nth(xs, n - 1)
    | [], _ => None end in

# Reverse a List. #
let rev: [Int] -> [Int] =
fun l -> 
let go: ([Int], [Int]) -> [Int] =
  fun xs, acc -> 
    case xs 
    | [] => acc 
    | x::xs => go(xs, x::acc) end in
go(l, []) in

# Check if two lists are equal #
let equal: ([Int], [Int]) -> Bool =
    fun p, xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => x == y && equal(xs, ys)
    | _ => false end
in

# Initialize a list with a given length using an initializer function #
let init: (Int, Int -> Int) -> [Int] =
    fun len, f ->
        let go: (Int, [Int]) -> [Int] =
        fun idx, xs ->
            if idx < len 
            then go(idx + 1, xs @ [f(idx)])   
            else xs
        in
        go(0, [])
in

# Reduce a list from the left. #
let fold_left: ((Int, Int) -> Int, Int, [Int]) -> Int =
  fun f, acc, xs ->
    case xs 
    | [] => acc
    | hd::tl => fold_left(f, f(acc, hd), tl) end in

# Reduce a list from the right. #
let fold_right: ((Int, Int) -> Int, [Int], Int) -> Int =
  fun f, xs, acc ->
    case xs
    | [] => acc
    | hd::tl => f(hd, fold_right(f, tl, acc)) end in


666
LSP: Prelude: String parsed successfully
LSP: Prelude: Info map generated successfully
Debug: true, Constrain: Types
LSP: Init: Recieved string: # Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)









































































































































































































































































































LSP: Init: String parsed successfully
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: >( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {go: ((?, ?) -> [?]), filter: (((Int -> Bool), [Int]) -> [Int]), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: 
  LSP: Info: ALL errors:Error in term:
  p
Nature of error: type ((Int -> Bool), [Int]) is not consistent with arrow type    
Error in term:
  p
Nature of error: Variable p is not bound    
Error in term:
  p
Nature of error: Variable p is not bound
  LSP: Info: BidiCtx: Cls: Let expression
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent: Root
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: [?]
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: :: @
  LSP: Concave: Backpack: 
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new_tokens ::= whitespace | "," | "::" | "@"
root ::= new_tokens

Top 20 Logits:

:20.5
#:15.1245
let:14.5531
##:14.2738
 :13.1612
################:12.493
    :12.4615
  :12.4054
   :12.142
in:12.062
####:11.9646
/*:11.8958
```:11.6006
[:11.499
//:11.4721
                :11.2669
(:11.1622
{:11.1603
        :10.9905
end:10.9432
########:10.9144

================
# Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)











































































































































































































































































































LSP: Prelude: Recieved string: ### List ###

# Add an element to the front of a list. #
let cons: (Int, [Int]) -> [Int] = fun x, xs -> x::xs in

# Determine the length of a list. #
let length: [Int] -> Int =
  fun xs ->
    case xs
    | [] => 0
    | _::xs => 1 + length(xs) end in

# Extract the first element of a list. #
let hd: [Int] -> Option =
  fun l ->
    case l
    | [] => None
    | x::xs => Some(x) end in

# Extract the rest of the list. #
let tl: [Int] -> [Int] =
  fun l ->
    case l
    | [] => []
    | x::xs => xs end in

# Determine if a list is empty. #
let is_empty: [Int] -> Bool =
  fun xs ->
    case xs
    | [] => true
    | _::_ => false end in

# Return the element at the index. #
let nth: ([Int], Int) -> Option =
  fun xs, n ->
    case xs, n
    | x::_, 0 => Some(x)
    | _::xs, n => nth(xs, n - 1)
    | [], _ => None end in

# Reverse a List. #
let rev: [Int] -> [Int] =
fun l -> 
let go: ([Int], [Int]) -> [Int] =
  fun xs, acc -> 
    case xs 
    | [] => acc 
    | x::xs => go(xs, x::acc) end in
go(l, []) in

# Check if two lists are equal #
let equal: ([Int], [Int]) -> Bool =
    fun p, xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => x == y && equal(xs, ys)
    | _ => false end
in

# Initialize a list with a given length using an initializer function #
let init: (Int, Int -> Int) -> [Int] =
    fun len, f ->
        let go: (Int, [Int]) -> [Int] =
        fun idx, xs ->
            if idx < len 
            then go(idx + 1, xs @ [f(idx)])   
            else xs
        in
        go(0, [])
in

# Reduce a list from the left. #
let fold_left: ((Int, Int) -> Int, Int, [Int]) -> Int =
  fun f, acc, xs ->
    case xs 
    | [] => acc
    | hd::tl => fold_left(f, f(acc, hd), tl) end in

# Reduce a list from the right. #
let fold_right: ((Int, Int) -> Int, [Int], Int) -> Int =
  fun f, xs, acc ->
    case xs
    | [] => acc
    | hd::tl => f(hd, fold_right(f, tl, acc)) end in


666
LSP: Prelude: String parsed successfully
LSP: Prelude: Info map generated successfully
Debug: true, Constrain: Types
LSP: Init: Recieved string: # Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)










































































































































































































































































































LSP: Init: String parsed successfully
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: >( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {go: ((?, ?) -> [?]), filter: (((Int -> Bool), [Int]) -> [Int]), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: 
  LSP: Info: ALL errors:Error in term:
  p
Nature of error: Variable p is not bound    
Error in term:
  p
Nature of error: Variable p is not bound    
Error in term:
  p
Nature of error: type ((Int -> Bool), [Int]) is not consistent with arrow type
  LSP: Info: BidiCtx: Cls: Let expression
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent: Root
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: [?]
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: :: @
  LSP: Concave: Backpack: 
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new_tokens ::= whitespace | "," | "::" | "@"
root ::= new_tokens

Top 20 Logits:

:20.5038
#:15.123
let:14.5451
##:14.2839
 :13.1673
################:12.499
    :12.4701
  :12.412
   :12.1486
in:12.0594
####:11.9682
/*:11.9007
```:11.5973
[:11.4903
//:11.4762
                :11.2723
(:11.1658
{:11.1582
        :10.9979
end:10.9568
########:10.922

================
# Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)












































































































































































































































































































LSP: Prelude: Recieved string: ### List ###

# Add an element to the front of a list. #
let cons: (Int, [Int]) -> [Int] = fun x, xs -> x::xs in

# Determine the length of a list. #
let length: [Int] -> Int =
  fun xs ->
    case xs
    | [] => 0
    | _::xs => 1 + length(xs) end in

# Extract the first element of a list. #
let hd: [Int] -> Option =
  fun l ->
    case l
    | [] => None
    | x::xs => Some(x) end in

# Extract the rest of the list. #
let tl: [Int] -> [Int] =
  fun l ->
    case l
    | [] => []
    | x::xs => xs end in

# Determine if a list is empty. #
let is_empty: [Int] -> Bool =
  fun xs ->
    case xs
    | [] => true
    | _::_ => false end in

# Return the element at the index. #
let nth: ([Int], Int) -> Option =
  fun xs, n ->
    case xs, n
    | x::_, 0 => Some(x)
    | _::xs, n => nth(xs, n - 1)
    | [], _ => None end in

# Reverse a List. #
let rev: [Int] -> [Int] =
fun l -> 
let go: ([Int], [Int]) -> [Int] =
  fun xs, acc -> 
    case xs 
    | [] => acc 
    | x::xs => go(xs, x::acc) end in
go(l, []) in

# Check if two lists are equal #
let equal: ([Int], [Int]) -> Bool =
    fun p, xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => x == y && equal(xs, ys)
    | _ => false end
in

# Initialize a list with a given length using an initializer function #
let init: (Int, Int -> Int) -> [Int] =
    fun len, f ->
        let go: (Int, [Int]) -> [Int] =
        fun idx, xs ->
            if idx < len 
            then go(idx + 1, xs @ [f(idx)])   
            else xs
        in
        go(0, [])
in

# Reduce a list from the left. #
let fold_left: ((Int, Int) -> Int, Int, [Int]) -> Int =
  fun f, acc, xs ->
    case xs 
    | [] => acc
    | hd::tl => fold_left(f, f(acc, hd), tl) end in

# Reduce a list from the right. #
let fold_right: ((Int, Int) -> Int, [Int], Int) -> Int =
  fun f, xs, acc ->
    case xs
    | [] => acc
    | hd::tl => f(hd, fold_right(f, tl, acc)) end in


666
LSP: Prelude: String parsed successfully
LSP: Prelude: Info map generated successfully
Debug: true, Constrain: Types
LSP: Init: Recieved string: # Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)











































































































































































































































































































LSP: Init: String parsed successfully
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: >( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {go: ((?, ?) -> [?]), filter: (((Int -> Bool), [Int]) -> [Int]), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: 
  LSP: Info: ALL errors:Error in term:
  p
Nature of error: type ((Int -> Bool), [Int]) is not consistent with arrow type    
Error in term:
  p
Nature of error: Variable p is not bound    
Error in term:
  p
Nature of error: Variable p is not bound
  LSP: Info: BidiCtx: Cls: Let expression
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent: Root
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: [?]
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: :: @
  LSP: Concave: Backpack: 
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new_tokens ::= whitespace | "," | "::" | "@"
root ::= new_tokens

Top 20 Logits:

:20.5103
#:15.1223
let:14.5363
##:14.2883
 :13.1743
################:12.5004
    :12.4792
  :12.4187
   :12.1544
in:12.0644
####:11.9713
/*:11.9035
```:11.5984
[:11.4864
//:11.4805
                :11.275
(:11.1742
{:11.156
        :11.0048
end:10.9739
########:10.9258

================
# Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)













































































































































































































































































































LSP: Prelude: Recieved string: ### List ###

# Add an element to the front of a list. #
let cons: (Int, [Int]) -> [Int] = fun x, xs -> x::xs in

# Determine the length of a list. #
let length: [Int] -> Int =
  fun xs ->
    case xs
    | [] => 0
    | _::xs => 1 + length(xs) end in

# Extract the first element of a list. #
let hd: [Int] -> Option =
  fun l ->
    case l
    | [] => None
    | x::xs => Some(x) end in

# Extract the rest of the list. #
let tl: [Int] -> [Int] =
  fun l ->
    case l
    | [] => []
    | x::xs => xs end in

# Determine if a list is empty. #
let is_empty: [Int] -> Bool =
  fun xs ->
    case xs
    | [] => true
    | _::_ => false end in

# Return the element at the index. #
let nth: ([Int], Int) -> Option =
  fun xs, n ->
    case xs, n
    | x::_, 0 => Some(x)
    | _::xs, n => nth(xs, n - 1)
    | [], _ => None end in

# Reverse a List. #
let rev: [Int] -> [Int] =
fun l -> 
let go: ([Int], [Int]) -> [Int] =
  fun xs, acc -> 
    case xs 
    | [] => acc 
    | x::xs => go(xs, x::acc) end in
go(l, []) in

# Check if two lists are equal #
let equal: ([Int], [Int]) -> Bool =
    fun p, xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => x == y && equal(xs, ys)
    | _ => false end
in

# Initialize a list with a given length using an initializer function #
let init: (Int, Int -> Int) -> [Int] =
    fun len, f ->
        let go: (Int, [Int]) -> [Int] =
        fun idx, xs ->
            if idx < len 
            then go(idx + 1, xs @ [f(idx)])   
            else xs
        in
        go(0, [])
in

# Reduce a list from the left. #
let fold_left: ((Int, Int) -> Int, Int, [Int]) -> Int =
  fun f, acc, xs ->
    case xs 
    | [] => acc
    | hd::tl => fold_left(f, f(acc, hd), tl) end in

# Reduce a list from the right. #
let fold_right: ((Int, Int) -> Int, [Int], Int) -> Int =
  fun f, xs, acc ->
    case xs
    | [] => acc
    | hd::tl => f(hd, fold_right(f, tl, acc)) end in


666
LSP: Prelude: String parsed successfully
LSP: Prelude: Info map generated successfully
Debug: true, Constrain: Types
LSP: Init: Recieved string: # Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)












































































































































































































































































































LSP: Init: String parsed successfully
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: >( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {go: ((?, ?) -> [?]), filter: (((Int -> Bool), [Int]) -> [Int]), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: 
  LSP: Info: ALL errors:Error in term:
  p
Nature of error: Variable p is not bound    
Error in term:
  p
Nature of error: Variable p is not bound    
Error in term:
  p
Nature of error: type ((Int -> Bool), [Int]) is not consistent with arrow type
  LSP: Info: BidiCtx: Cls: Let expression
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent: Root
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: [?]
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: :: @
  LSP: Concave: Backpack: 
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new_tokens ::= whitespace | "," | "::" | "@"
root ::= new_tokens

Top 20 Logits:

:20.5199
#:15.1223
let:14.532
##:14.2856
 :13.1803
################:12.4982
    :12.4851
  :12.4248
   :12.1565
in:12.0726
####:11.9702
/*:11.9035
```:11.6025
[:11.4872
//:11.4834
                :11.278
(:11.1797
{:11.151
        :11.009
end:10.9929
########:10.9246

================
# Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)














































































































































































































































































































LSP: Prelude: Recieved string: ### List ###

# Add an element to the front of a list. #
let cons: (Int, [Int]) -> [Int] = fun x, xs -> x::xs in

# Determine the length of a list. #
let length: [Int] -> Int =
  fun xs ->
    case xs
    | [] => 0
    | _::xs => 1 + length(xs) end in

# Extract the first element of a list. #
let hd: [Int] -> Option =
  fun l ->
    case l
    | [] => None
    | x::xs => Some(x) end in

# Extract the rest of the list. #
let tl: [Int] -> [Int] =
  fun l ->
    case l
    | [] => []
    | x::xs => xs end in

# Determine if a list is empty. #
let is_empty: [Int] -> Bool =
  fun xs ->
    case xs
    | [] => true
    | _::_ => false end in

# Return the element at the index. #
let nth: ([Int], Int) -> Option =
  fun xs, n ->
    case xs, n
    | x::_, 0 => Some(x)
    | _::xs, n => nth(xs, n - 1)
    | [], _ => None end in

# Reverse a List. #
let rev: [Int] -> [Int] =
fun l -> 
let go: ([Int], [Int]) -> [Int] =
  fun xs, acc -> 
    case xs 
    | [] => acc 
    | x::xs => go(xs, x::acc) end in
go(l, []) in

# Check if two lists are equal #
let equal: ([Int], [Int]) -> Bool =
    fun p, xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => x == y && equal(xs, ys)
    | _ => false end
in

# Initialize a list with a given length using an initializer function #
let init: (Int, Int -> Int) -> [Int] =
    fun len, f ->
        let go: (Int, [Int]) -> [Int] =
        fun idx, xs ->
            if idx < len 
            then go(idx + 1, xs @ [f(idx)])   
            else xs
        in
        go(0, [])
in

# Reduce a list from the left. #
let fold_left: ((Int, Int) -> Int, Int, [Int]) -> Int =
  fun f, acc, xs ->
    case xs 
    | [] => acc
    | hd::tl => fold_left(f, f(acc, hd), tl) end in

# Reduce a list from the right. #
let fold_right: ((Int, Int) -> Int, [Int], Int) -> Int =
  fun f, xs, acc ->
    case xs
    | [] => acc
    | hd::tl => f(hd, fold_right(f, tl, acc)) end in


666
LSP: Prelude: String parsed successfully
LSP: Prelude: Info map generated successfully
Debug: true, Constrain: Types
LSP: Init: Recieved string: # Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)













































































































































































































































































































LSP: Init: String parsed successfully
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: >( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {go: ((?, ?) -> [?]), filter: (((Int -> Bool), [Int]) -> [Int]), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: 
  LSP: Info: ALL errors:Error in term:
  p
Nature of error: type ((Int -> Bool), [Int]) is not consistent with arrow type    
Error in term:
  p
Nature of error: Variable p is not bound    
Error in term:
  p
Nature of error: Variable p is not bound
  LSP: Info: BidiCtx: Cls: Let expression
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent: Root
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: [?]
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: :: @
  LSP: Concave: Backpack: 
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new_tokens ::= whitespace | "," | "::" | "@"
root ::= new_tokens

Top 20 Logits:

:20.5293
#:15.123
let:14.533
##:14.2748
 :13.1841
################:12.4942
    :12.486
  :12.4298
   :12.1536
in:12.0824
####:11.9621
/*:11.903
```:11.604
[:11.4866
//:11.4858
                :11.2825
(:11.1788
{:11.1437
end:11.011
        :11.0097
########:10.9196

================
# Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)















































































































































































































































































































LSP: Prelude: Recieved string: ### List ###

# Add an element to the front of a list. #
let cons: (Int, [Int]) -> [Int] = fun x, xs -> x::xs in

# Determine the length of a list. #
let length: [Int] -> Int =
  fun xs ->
    case xs
    | [] => 0
    | _::xs => 1 + length(xs) end in

# Extract the first element of a list. #
let hd: [Int] -> Option =
  fun l ->
    case l
    | [] => None
    | x::xs => Some(x) end in

# Extract the rest of the list. #
let tl: [Int] -> [Int] =
  fun l ->
    case l
    | [] => []
    | x::xs => xs end in

# Determine if a list is empty. #
let is_empty: [Int] -> Bool =
  fun xs ->
    case xs
    | [] => true
    | _::_ => false end in

# Return the element at the index. #
let nth: ([Int], Int) -> Option =
  fun xs, n ->
    case xs, n
    | x::_, 0 => Some(x)
    | _::xs, n => nth(xs, n - 1)
    | [], _ => None end in

# Reverse a List. #
let rev: [Int] -> [Int] =
fun l -> 
let go: ([Int], [Int]) -> [Int] =
  fun xs, acc -> 
    case xs 
    | [] => acc 
    | x::xs => go(xs, x::acc) end in
go(l, []) in

# Check if two lists are equal #
let equal: ([Int], [Int]) -> Bool =
    fun p, xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => x == y && equal(xs, ys)
    | _ => false end
in

# Initialize a list with a given length using an initializer function #
let init: (Int, Int -> Int) -> [Int] =
    fun len, f ->
        let go: (Int, [Int]) -> [Int] =
        fun idx, xs ->
            if idx < len 
            then go(idx + 1, xs @ [f(idx)])   
            else xs
        in
        go(0, [])
in

# Reduce a list from the left. #
let fold_left: ((Int, Int) -> Int, Int, [Int]) -> Int =
  fun f, acc, xs ->
    case xs 
    | [] => acc
    | hd::tl => fold_left(f, f(acc, hd), tl) end in

# Reduce a list from the right. #
let fold_right: ((Int, Int) -> Int, [Int], Int) -> Int =
  fun f, xs, acc ->
    case xs
    | [] => acc
    | hd::tl => f(hd, fold_right(f, tl, acc)) end in


666
LSP: Prelude: String parsed successfully
LSP: Prelude: Info map generated successfully
Debug: true, Constrain: Types
LSP: Init: Recieved string: # Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)














































































































































































































































































































LSP: Init: String parsed successfully
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: >( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {go: ((?, ?) -> [?]), filter: (((Int -> Bool), [Int]) -> [Int]), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: 
  LSP: Info: ALL errors:Error in term:
  p
Nature of error: type ((Int -> Bool), [Int]) is not consistent with arrow type    
Error in term:
  p
Nature of error: Variable p is not bound    
Error in term:
  p
Nature of error: Variable p is not bound
  LSP: Info: BidiCtx: Cls: Let expression
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent: Root
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: [?]
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: :: @
  LSP: Concave: Backpack: 
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new_tokens ::= whitespace | "," | "::" | "@"
root ::= new_tokens

Top 20 Logits:

:20.5345
#:15.1244
let:14.5364
##:14.2604
 :13.1858
################:12.4892
    :12.4831
  :12.433
   :12.148
in:12.0917
####:11.9495
/*:11.9061
```:11.5979
//:11.4902
[:11.4841
                :11.2857
(:11.174
{:11.1394
end:11.0257
        :11.007
########:10.9133

================
# Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)
















































































































































































































































































































LSP: Prelude: Recieved string: ### List ###

# Add an element to the front of a list. #
let cons: (Int, [Int]) -> [Int] = fun x, xs -> x::xs in

# Determine the length of a list. #
let length: [Int] -> Int =
  fun xs ->
    case xs
    | [] => 0
    | _::xs => 1 + length(xs) end in

# Extract the first element of a list. #
let hd: [Int] -> Option =
  fun l ->
    case l
    | [] => None
    | x::xs => Some(x) end in

# Extract the rest of the list. #
let tl: [Int] -> [Int] =
  fun l ->
    case l
    | [] => []
    | x::xs => xs end in

# Determine if a list is empty. #
let is_empty: [Int] -> Bool =
  fun xs ->
    case xs
    | [] => true
    | _::_ => false end in

# Return the element at the index. #
let nth: ([Int], Int) -> Option =
  fun xs, n ->
    case xs, n
    | x::_, 0 => Some(x)
    | _::xs, n => nth(xs, n - 1)
    | [], _ => None end in

# Reverse a List. #
let rev: [Int] -> [Int] =
fun l -> 
let go: ([Int], [Int]) -> [Int] =
  fun xs, acc -> 
    case xs 
    | [] => acc 
    | x::xs => go(xs, x::acc) end in
go(l, []) in

# Check if two lists are equal #
let equal: ([Int], [Int]) -> Bool =
    fun p, xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => x == y && equal(xs, ys)
    | _ => false end
in

# Initialize a list with a given length using an initializer function #
let init: (Int, Int -> Int) -> [Int] =
    fun len, f ->
        let go: (Int, [Int]) -> [Int] =
        fun idx, xs ->
            if idx < len 
            then go(idx + 1, xs @ [f(idx)])   
            else xs
        in
        go(0, [])
in

# Reduce a list from the left. #
let fold_left: ((Int, Int) -> Int, Int, [Int]) -> Int =
  fun f, acc, xs ->
    case xs 
    | [] => acc
    | hd::tl => fold_left(f, f(acc, hd), tl) end in

# Reduce a list from the right. #
let fold_right: ((Int, Int) -> Int, [Int], Int) -> Int =
  fun f, xs, acc ->
    case xs
    | [] => acc
    | hd::tl => f(hd, fold_right(f, tl, acc)) end in


666
LSP: Prelude: String parsed successfully
LSP: Prelude: Info map generated successfully
Debug: true, Constrain: Types
LSP: Init: Recieved string: # Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)















































































































































































































































































































LSP: Init: String parsed successfully
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: >( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {go: ((?, ?) -> [?]), filter: (((Int -> Bool), [Int]) -> [Int]), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: 
  LSP: Info: ALL errors:Error in term:
  p
Nature of error: type ((Int -> Bool), [Int]) is not consistent with arrow type    
Error in term:
  p
Nature of error: Variable p is not bound    
Error in term:
  p
Nature of error: Variable p is not bound
  LSP: Info: BidiCtx: Cls: Let expression
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent: Root
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: [?]
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: :: @
  LSP: Concave: Backpack: 
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new_tokens ::= whitespace | "," | "::" | "@"
root ::= new_tokens

Top 20 Logits:

:20.5358
#:15.1281
let:14.5405
##:14.2508
 :13.1868
################:12.4861
    :12.4806
  :12.4339
   :12.1445
in:12.0944
####:11.941
/*:11.9126
```:11.5878
//:11.4964
[:11.485
                :11.2853
(:11.1731
{:11.1435
end:11.0309
        :11.0038
########:10.9119

================
# Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)

















































































































































































































































































































LSP: Prelude: Recieved string: ### List ###

# Add an element to the front of a list. #
let cons: (Int, [Int]) -> [Int] = fun x, xs -> x::xs in

# Determine the length of a list. #
let length: [Int] -> Int =
  fun xs ->
    case xs
    | [] => 0
    | _::xs => 1 + length(xs) end in

# Extract the first element of a list. #
let hd: [Int] -> Option =
  fun l ->
    case l
    | [] => None
    | x::xs => Some(x) end in

# Extract the rest of the list. #
let tl: [Int] -> [Int] =
  fun l ->
    case l
    | [] => []
    | x::xs => xs end in

# Determine if a list is empty. #
let is_empty: [Int] -> Bool =
  fun xs ->
    case xs
    | [] => true
    | _::_ => false end in

# Return the element at the index. #
let nth: ([Int], Int) -> Option =
  fun xs, n ->
    case xs, n
    | x::_, 0 => Some(x)
    | _::xs, n => nth(xs, n - 1)
    | [], _ => None end in

# Reverse a List. #
let rev: [Int] -> [Int] =
fun l -> 
let go: ([Int], [Int]) -> [Int] =
  fun xs, acc -> 
    case xs 
    | [] => acc 
    | x::xs => go(xs, x::acc) end in
go(l, []) in

# Check if two lists are equal #
let equal: ([Int], [Int]) -> Bool =
    fun p, xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => x == y && equal(xs, ys)
    | _ => false end
in

# Initialize a list with a given length using an initializer function #
let init: (Int, Int -> Int) -> [Int] =
    fun len, f ->
        let go: (Int, [Int]) -> [Int] =
        fun idx, xs ->
            if idx < len 
            then go(idx + 1, xs @ [f(idx)])   
            else xs
        in
        go(0, [])
in

# Reduce a list from the left. #
let fold_left: ((Int, Int) -> Int, Int, [Int]) -> Int =
  fun f, acc, xs ->
    case xs 
    | [] => acc
    | hd::tl => fold_left(f, f(acc, hd), tl) end in

# Reduce a list from the right. #
let fold_right: ((Int, Int) -> Int, [Int], Int) -> Int =
  fun f, xs, acc ->
    case xs
    | [] => acc
    | hd::tl => f(hd, fold_right(f, tl, acc)) end in


666
LSP: Prelude: String parsed successfully
LSP: Prelude: Info map generated successfully
Debug: true, Constrain: Types
LSP: Init: Recieved string: # Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)
















































































































































































































































































































LSP: Init: String parsed successfully
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: >( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {go: ((?, ?) -> [?]), filter: (((Int -> Bool), [Int]) -> [Int]), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: 
  LSP: Info: ALL errors:Error in term:
  p
Nature of error: Variable p is not bound    
Error in term:
  p
Nature of error: type ((Int -> Bool), [Int]) is not consistent with arrow type    
Error in term:
  p
Nature of error: Variable p is not bound
  LSP: Info: BidiCtx: Cls: Let expression
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent: Root
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: [?]
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: :: @
  LSP: Concave: Backpack: 
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new_tokens ::= whitespace | "," | "::" | "@"
root ::= new_tokens

Top 20 Logits:

:20.5368
#:15.134
let:14.5423
##:14.2515
 :13.1889
################:12.4877
    :12.4809
  :12.4322
   :12.1463
in:12.0827
####:11.9424
/*:11.9171
```:11.5827
//:11.501
[:11.4925
                :11.2812
(:11.1814
{:11.1558
end:11.0195
        :11.0027
########:10.9196

================
# Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)


















































































































































































































































































































LSP: Prelude: Recieved string: ### List ###

# Add an element to the front of a list. #
let cons: (Int, [Int]) -> [Int] = fun x, xs -> x::xs in

# Determine the length of a list. #
let length: [Int] -> Int =
  fun xs ->
    case xs
    | [] => 0
    | _::xs => 1 + length(xs) end in

# Extract the first element of a list. #
let hd: [Int] -> Option =
  fun l ->
    case l
    | [] => None
    | x::xs => Some(x) end in

# Extract the rest of the list. #
let tl: [Int] -> [Int] =
  fun l ->
    case l
    | [] => []
    | x::xs => xs end in

# Determine if a list is empty. #
let is_empty: [Int] -> Bool =
  fun xs ->
    case xs
    | [] => true
    | _::_ => false end in

# Return the element at the index. #
let nth: ([Int], Int) -> Option =
  fun xs, n ->
    case xs, n
    | x::_, 0 => Some(x)
    | _::xs, n => nth(xs, n - 1)
    | [], _ => None end in

# Reverse a List. #
let rev: [Int] -> [Int] =
fun l -> 
let go: ([Int], [Int]) -> [Int] =
  fun xs, acc -> 
    case xs 
    | [] => acc 
    | x::xs => go(xs, x::acc) end in
go(l, []) in

# Check if two lists are equal #
let equal: ([Int], [Int]) -> Bool =
    fun p, xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => x == y && equal(xs, ys)
    | _ => false end
in

# Initialize a list with a given length using an initializer function #
let init: (Int, Int -> Int) -> [Int] =
    fun len, f ->
        let go: (Int, [Int]) -> [Int] =
        fun idx, xs ->
            if idx < len 
            then go(idx + 1, xs @ [f(idx)])   
            else xs
        in
        go(0, [])
in

# Reduce a list from the left. #
let fold_left: ((Int, Int) -> Int, Int, [Int]) -> Int =
  fun f, acc, xs ->
    case xs 
    | [] => acc
    | hd::tl => fold_left(f, f(acc, hd), tl) end in

# Reduce a list from the right. #
let fold_right: ((Int, Int) -> Int, [Int], Int) -> Int =
  fun f, xs, acc ->
    case xs
    | [] => acc
    | hd::tl => f(hd, fold_right(f, tl, acc)) end in


666
LSP: Prelude: String parsed successfully
LSP: Prelude: Info map generated successfully
Debug: true, Constrain: Types
LSP: Init: Recieved string: # Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)

















































































































































































































































































































LSP: Init: String parsed successfully
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: >( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {go: ((?, ?) -> [?]), filter: (((Int -> Bool), [Int]) -> [Int]), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: 
  LSP: Info: ALL errors:Error in term:
  p
Nature of error: Variable p is not bound    
Error in term:
  p
Nature of error: Variable p is not bound    
Error in term:
  p
Nature of error: type ((Int -> Bool), [Int]) is not consistent with arrow type
  LSP: Info: BidiCtx: Cls: Let expression
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent: Root
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: [?]
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: :: @
  LSP: Concave: Backpack: 
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new_tokens ::= whitespace | "," | "::" | "@"
root ::= new_tokens

Top 20 Logits:

:20.5414
#:15.1391
let:14.5413
##:14.2637
 :13.1917
################:12.4936
    :12.4829
  :12.4298
   :12.1522
in:12.0536
####:11.9532
/*:11.9143
```:11.5867
[:11.5065
//:11.5002
                :11.275
(:11.1966
{:11.1693
        :11.004
end:10.994
########:10.9339

================
# Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)



















































































































































































































































































































LSP: Prelude: Recieved string: ### List ###

# Add an element to the front of a list. #
let cons: (Int, [Int]) -> [Int] = fun x, xs -> x::xs in

# Determine the length of a list. #
let length: [Int] -> Int =
  fun xs ->
    case xs
    | [] => 0
    | _::xs => 1 + length(xs) end in

# Extract the first element of a list. #
let hd: [Int] -> Option =
  fun l ->
    case l
    | [] => None
    | x::xs => Some(x) end in

# Extract the rest of the list. #
let tl: [Int] -> [Int] =
  fun l ->
    case l
    | [] => []
    | x::xs => xs end in

# Determine if a list is empty. #
let is_empty: [Int] -> Bool =
  fun xs ->
    case xs
    | [] => true
    | _::_ => false end in

# Return the element at the index. #
let nth: ([Int], Int) -> Option =
  fun xs, n ->
    case xs, n
    | x::_, 0 => Some(x)
    | _::xs, n => nth(xs, n - 1)
    | [], _ => None end in

# Reverse a List. #
let rev: [Int] -> [Int] =
fun l -> 
let go: ([Int], [Int]) -> [Int] =
  fun xs, acc -> 
    case xs 
    | [] => acc 
    | x::xs => go(xs, x::acc) end in
go(l, []) in

# Check if two lists are equal #
let equal: ([Int], [Int]) -> Bool =
    fun p, xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => x == y && equal(xs, ys)
    | _ => false end
in

# Initialize a list with a given length using an initializer function #
let init: (Int, Int -> Int) -> [Int] =
    fun len, f ->
        let go: (Int, [Int]) -> [Int] =
        fun idx, xs ->
            if idx < len 
            then go(idx + 1, xs @ [f(idx)])   
            else xs
        in
        go(0, [])
in

# Reduce a list from the left. #
let fold_left: ((Int, Int) -> Int, Int, [Int]) -> Int =
  fun f, acc, xs ->
    case xs 
    | [] => acc
    | hd::tl => fold_left(f, f(acc, hd), tl) end in

# Reduce a list from the right. #
let fold_right: ((Int, Int) -> Int, [Int], Int) -> Int =
  fun f, xs, acc ->
    case xs
    | [] => acc
    | hd::tl => f(hd, fold_right(f, tl, acc)) end in


666
LSP: Prelude: String parsed successfully
LSP: Prelude: Info map generated successfully
Debug: true, Constrain: Types
LSP: Init: Recieved string: # Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)


















































































































































































































































































































LSP: Init: String parsed successfully
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: >( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {go: ((?, ?) -> [?]), filter: (((Int -> Bool), [Int]) -> [Int]), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: 
  LSP: Info: ALL errors:Error in term:
  p
Nature of error: Variable p is not bound    
Error in term:
  p
Nature of error: type ((Int -> Bool), [Int]) is not consistent with arrow type    
Error in term:
  p
Nature of error: Variable p is not bound
  LSP: Info: BidiCtx: Cls: Let expression
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent: Root
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: [?]
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: :: @
  LSP: Concave: Backpack: 
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new_tokens ::= whitespace | "," | "::" | "@"
root ::= new_tokens

Top 20 Logits:

:20.5509
#:15.1407
let:14.5425
##:14.2834
 :13.1957
################:12.5036
    :12.4848
  :12.4311
   :12.1581
in:12.0197
####:11.9693
/*:11.9043
```:11.5988
[:11.5237
//:11.4932
                :11.2715
(:11.2121
{:11.1782
        :11.0079
end:10.9677
########:10.9508

================
# Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)




















































































































































































































































































































LSP: Prelude: Recieved string: ### List ###

# Add an element to the front of a list. #
let cons: (Int, [Int]) -> [Int] = fun x, xs -> x::xs in

# Determine the length of a list. #
let length: [Int] -> Int =
  fun xs ->
    case xs
    | [] => 0
    | _::xs => 1 + length(xs) end in

# Extract the first element of a list. #
let hd: [Int] -> Option =
  fun l ->
    case l
    | [] => None
    | x::xs => Some(x) end in

# Extract the rest of the list. #
let tl: [Int] -> [Int] =
  fun l ->
    case l
    | [] => []
    | x::xs => xs end in

# Determine if a list is empty. #
let is_empty: [Int] -> Bool =
  fun xs ->
    case xs
    | [] => true
    | _::_ => false end in

# Return the element at the index. #
let nth: ([Int], Int) -> Option =
  fun xs, n ->
    case xs, n
    | x::_, 0 => Some(x)
    | _::xs, n => nth(xs, n - 1)
    | [], _ => None end in

# Reverse a List. #
let rev: [Int] -> [Int] =
fun l -> 
let go: ([Int], [Int]) -> [Int] =
  fun xs, acc -> 
    case xs 
    | [] => acc 
    | x::xs => go(xs, x::acc) end in
go(l, []) in

# Check if two lists are equal #
let equal: ([Int], [Int]) -> Bool =
    fun p, xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => x == y && equal(xs, ys)
    | _ => false end
in

# Initialize a list with a given length using an initializer function #
let init: (Int, Int -> Int) -> [Int] =
    fun len, f ->
        let go: (Int, [Int]) -> [Int] =
        fun idx, xs ->
            if idx < len 
            then go(idx + 1, xs @ [f(idx)])   
            else xs
        in
        go(0, [])
in

# Reduce a list from the left. #
let fold_left: ((Int, Int) -> Int, Int, [Int]) -> Int =
  fun f, acc, xs ->
    case xs 
    | [] => acc
    | hd::tl => fold_left(f, f(acc, hd), tl) end in

# Reduce a list from the right. #
let fold_right: ((Int, Int) -> Int, [Int], Int) -> Int =
  fun f, xs, acc ->
    case xs
    | [] => acc
    | hd::tl => f(hd, fold_right(f, tl, acc)) end in


666
LSP: Prelude: String parsed successfully
LSP: Prelude: Info map generated successfully
Debug: true, Constrain: Types
LSP: Init: Recieved string: # Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)



















































































































































































































































































































LSP: Init: String parsed successfully
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: >( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {go: ((?, ?) -> [?]), filter: (((Int -> Bool), [Int]) -> [Int]), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: 
  LSP: Info: ALL errors:Error in term:
  p
Nature of error: type ((Int -> Bool), [Int]) is not consistent with arrow type    
Error in term:
  p
Nature of error: Variable p is not bound    
Error in term:
  p
Nature of error: Variable p is not bound
  LSP: Info: BidiCtx: Cls: Let expression
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent: Root
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: [?]
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: :: @
  LSP: Concave: Backpack: 
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new_tokens ::= whitespace | "," | "::" | "@"
root ::= new_tokens

Top 20 Logits:

:20.5611
#:15.1367
let:14.5478
##:14.3004
 :13.1994
################:12.5137
    :12.4856
  :12.437
   :12.1595
in:11.9947
####:11.9817
/*:11.8929
```:11.6114
[:11.5354
//:11.4827
                :11.2727
(:11.2213
{:11.1803
        :11.0125
########:10.9653
end:10.9507

================
# Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)





















































































































































































































































































































LSP: Prelude: Recieved string: ### List ###

# Add an element to the front of a list. #
let cons: (Int, [Int]) -> [Int] = fun x, xs -> x::xs in

# Determine the length of a list. #
let length: [Int] -> Int =
  fun xs ->
    case xs
    | [] => 0
    | _::xs => 1 + length(xs) end in

# Extract the first element of a list. #
let hd: [Int] -> Option =
  fun l ->
    case l
    | [] => None
    | x::xs => Some(x) end in

# Extract the rest of the list. #
let tl: [Int] -> [Int] =
  fun l ->
    case l
    | [] => []
    | x::xs => xs end in

# Determine if a list is empty. #
let is_empty: [Int] -> Bool =
  fun xs ->
    case xs
    | [] => true
    | _::_ => false end in

# Return the element at the index. #
let nth: ([Int], Int) -> Option =
  fun xs, n ->
    case xs, n
    | x::_, 0 => Some(x)
    | _::xs, n => nth(xs, n - 1)
    | [], _ => None end in

# Reverse a List. #
let rev: [Int] -> [Int] =
fun l -> 
let go: ([Int], [Int]) -> [Int] =
  fun xs, acc -> 
    case xs 
    | [] => acc 
    | x::xs => go(xs, x::acc) end in
go(l, []) in

# Check if two lists are equal #
let equal: ([Int], [Int]) -> Bool =
    fun p, xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => x == y && equal(xs, ys)
    | _ => false end
in

# Initialize a list with a given length using an initializer function #
let init: (Int, Int -> Int) -> [Int] =
    fun len, f ->
        let go: (Int, [Int]) -> [Int] =
        fun idx, xs ->
            if idx < len 
            then go(idx + 1, xs @ [f(idx)])   
            else xs
        in
        go(0, [])
in

# Reduce a list from the left. #
let fold_left: ((Int, Int) -> Int, Int, [Int]) -> Int =
  fun f, acc, xs ->
    case xs 
    | [] => acc
    | hd::tl => fold_left(f, f(acc, hd), tl) end in

# Reduce a list from the right. #
let fold_right: ((Int, Int) -> Int, [Int], Int) -> Int =
  fun f, xs, acc ->
    case xs
    | [] => acc
    | hd::tl => f(hd, fold_right(f, tl, acc)) end in


666
LSP: Prelude: String parsed successfully
LSP: Prelude: Info map generated successfully
Debug: true, Constrain: Types
LSP: Init: Recieved string: # Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)




















































































































































































































































































































LSP: Init: String parsed successfully
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: >( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {go: ((?, ?) -> [?]), filter: (((Int -> Bool), [Int]) -> [Int]), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: 
  LSP: Info: ALL errors:Error in term:
  p
Nature of error: Variable p is not bound    
Error in term:
  p
Nature of error: Variable p is not bound    
Error in term:
  p
Nature of error: type ((Int -> Bool), [Int]) is not consistent with arrow type
  LSP: Info: BidiCtx: Cls: Let expression
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent: Root
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: [?]
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: :: @
  LSP: Concave: Backpack: 
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new_tokens ::= whitespace | "," | "::" | "@"
root ::= new_tokens

Top 20 Logits:

:20.5663
#:15.1296
let:14.5548
##:14.3083
 :13.2019
################:12.5192
    :12.4851
  :12.4447
   :12.1559
####:11.9858
in:11.9826
/*:11.8871
```:11.6172
[:11.5362
//:11.4741
                :11.2764
(:11.2233
{:11.179
        :11.0153
########:10.9744
end:10.9413

================
# Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)






















































































































































































































































































































LSP: Prelude: Recieved string: ### List ###

# Add an element to the front of a list. #
let cons: (Int, [Int]) -> [Int] = fun x, xs -> x::xs in

# Determine the length of a list. #
let length: [Int] -> Int =
  fun xs ->
    case xs
    | [] => 0
    | _::xs => 1 + length(xs) end in

# Extract the first element of a list. #
let hd: [Int] -> Option =
  fun l ->
    case l
    | [] => None
    | x::xs => Some(x) end in

# Extract the rest of the list. #
let tl: [Int] -> [Int] =
  fun l ->
    case l
    | [] => []
    | x::xs => xs end in

# Determine if a list is empty. #
let is_empty: [Int] -> Bool =
  fun xs ->
    case xs
    | [] => true
    | _::_ => false end in

# Return the element at the index. #
let nth: ([Int], Int) -> Option =
  fun xs, n ->
    case xs, n
    | x::_, 0 => Some(x)
    | _::xs, n => nth(xs, n - 1)
    | [], _ => None end in

# Reverse a List. #
let rev: [Int] -> [Int] =
fun l -> 
let go: ([Int], [Int]) -> [Int] =
  fun xs, acc -> 
    case xs 
    | [] => acc 
    | x::xs => go(xs, x::acc) end in
go(l, []) in

# Check if two lists are equal #
let equal: ([Int], [Int]) -> Bool =
    fun p, xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => x == y && equal(xs, ys)
    | _ => false end
in

# Initialize a list with a given length using an initializer function #
let init: (Int, Int -> Int) -> [Int] =
    fun len, f ->
        let go: (Int, [Int]) -> [Int] =
        fun idx, xs ->
            if idx < len 
            then go(idx + 1, xs @ [f(idx)])   
            else xs
        in
        go(0, [])
in

# Reduce a list from the left. #
let fold_left: ((Int, Int) -> Int, Int, [Int]) -> Int =
  fun f, acc, xs ->
    case xs 
    | [] => acc
    | hd::tl => fold_left(f, f(acc, hd), tl) end in

# Reduce a list from the right. #
let fold_right: ((Int, Int) -> Int, [Int], Int) -> Int =
  fun f, xs, acc ->
    case xs
    | [] => acc
    | hd::tl => f(hd, fold_right(f, tl, acc)) end in


666
LSP: Prelude: String parsed successfully
LSP: Prelude: Info map generated successfully
Debug: true, Constrain: Types
LSP: Init: Recieved string: # Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)





















































































































































































































































































































LSP: Init: String parsed successfully
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: >( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {go: ((?, ?) -> [?]), filter: (((Int -> Bool), [Int]) -> [Int]), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: 
  LSP: Info: ALL errors:Error in term:
  p
Nature of error: type ((Int -> Bool), [Int]) is not consistent with arrow type    
Error in term:
  p
Nature of error: Variable p is not bound    
Error in term:
  p
Nature of error: Variable p is not bound
  LSP: Info: BidiCtx: Cls: Let expression
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent: Root
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: [?]
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: :: @
  LSP: Concave: Backpack: 
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new_tokens ::= whitespace | "," | "::" | "@"
root ::= new_tokens

Top 20 Logits:

:20.5649
#:15.1247
let:14.562
##:14.3084
 :13.2024
################:12.5194
    :12.485
  :12.4495
   :12.1501
####:11.9841
in:11.9782
/*:11.8885
```:11.6139
[:11.5318
//:11.4696
                :11.2792
(:11.2222
{:11.1808
        :11.0151
########:10.9785
end:10.9321

================
# Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)























































































































































































































































































































LSP: Prelude: Recieved string: ### List ###

# Add an element to the front of a list. #
let cons: (Int, [Int]) -> [Int] = fun x, xs -> x::xs in

# Determine the length of a list. #
let length: [Int] -> Int =
  fun xs ->
    case xs
    | [] => 0
    | _::xs => 1 + length(xs) end in

# Extract the first element of a list. #
let hd: [Int] -> Option =
  fun l ->
    case l
    | [] => None
    | x::xs => Some(x) end in

# Extract the rest of the list. #
let tl: [Int] -> [Int] =
  fun l ->
    case l
    | [] => []
    | x::xs => xs end in

# Determine if a list is empty. #
let is_empty: [Int] -> Bool =
  fun xs ->
    case xs
    | [] => true
    | _::_ => false end in

# Return the element at the index. #
let nth: ([Int], Int) -> Option =
  fun xs, n ->
    case xs, n
    | x::_, 0 => Some(x)
    | _::xs, n => nth(xs, n - 1)
    | [], _ => None end in

# Reverse a List. #
let rev: [Int] -> [Int] =
fun l -> 
let go: ([Int], [Int]) -> [Int] =
  fun xs, acc -> 
    case xs 
    | [] => acc 
    | x::xs => go(xs, x::acc) end in
go(l, []) in

# Check if two lists are equal #
let equal: ([Int], [Int]) -> Bool =
    fun p, xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => x == y && equal(xs, ys)
    | _ => false end
in

# Initialize a list with a given length using an initializer function #
let init: (Int, Int -> Int) -> [Int] =
    fun len, f ->
        let go: (Int, [Int]) -> [Int] =
        fun idx, xs ->
            if idx < len 
            then go(idx + 1, xs @ [f(idx)])   
            else xs
        in
        go(0, [])
in

# Reduce a list from the left. #
let fold_left: ((Int, Int) -> Int, Int, [Int]) -> Int =
  fun f, acc, xs ->
    case xs 
    | [] => acc
    | hd::tl => fold_left(f, f(acc, hd), tl) end in

# Reduce a list from the right. #
let fold_right: ((Int, Int) -> Int, [Int], Int) -> Int =
  fun f, xs, acc ->
    case xs
    | [] => acc
    | hd::tl => f(hd, fold_right(f, tl, acc)) end in


666
LSP: Prelude: String parsed successfully
LSP: Prelude: Info map generated successfully
Debug: true, Constrain: Types
LSP: Init: Recieved string: # Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)






















































































































































































































































































































LSP: Init: String parsed successfully
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: >( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {go: ((?, ?) -> [?]), filter: (((Int -> Bool), [Int]) -> [Int]), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: 
  LSP: Info: ALL errors:Error in term:
  p
Nature of error: Variable p is not bound    
Error in term:
  p
Nature of error: type ((Int -> Bool), [Int]) is not consistent with arrow type    
Error in term:
  p
Nature of error: Variable p is not bound
  LSP: Info: BidiCtx: Cls: Let expression
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent: Root
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: [?]
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: :: @
  LSP: Concave: Backpack: 
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new_tokens ::= whitespace | "," | "::" | "@"
root ::= new_tokens

Top 20 Logits:

:20.5616
#:15.125
let:14.5672
##:14.3074
 :13.2016
################:12.5178
    :12.4876
  :12.4486
   :12.147
####:11.9829
in:11.9779
/*:11.8921
```:11.6076
[:11.5316
//:11.4692
                :11.279
(:11.2229
{:11.1894
        :11.0134
########:10.9815
end:10.9238

================
# Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)
























































































































































































































































































































LSP: Prelude: Recieved string: ### List ###

# Add an element to the front of a list. #
let cons: (Int, [Int]) -> [Int] = fun x, xs -> x::xs in

# Determine the length of a list. #
let length: [Int] -> Int =
  fun xs ->
    case xs
    | [] => 0
    | _::xs => 1 + length(xs) end in

# Extract the first element of a list. #
let hd: [Int] -> Option =
  fun l ->
    case l
    | [] => None
    | x::xs => Some(x) end in

# Extract the rest of the list. #
let tl: [Int] -> [Int] =
  fun l ->
    case l
    | [] => []
    | x::xs => xs end in

# Determine if a list is empty. #
let is_empty: [Int] -> Bool =
  fun xs ->
    case xs
    | [] => true
    | _::_ => false end in

# Return the element at the index. #
let nth: ([Int], Int) -> Option =
  fun xs, n ->
    case xs, n
    | x::_, 0 => Some(x)
    | _::xs, n => nth(xs, n - 1)
    | [], _ => None end in

# Reverse a List. #
let rev: [Int] -> [Int] =
fun l -> 
let go: ([Int], [Int]) -> [Int] =
  fun xs, acc -> 
    case xs 
    | [] => acc 
    | x::xs => go(xs, x::acc) end in
go(l, []) in

# Check if two lists are equal #
let equal: ([Int], [Int]) -> Bool =
    fun p, xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => x == y && equal(xs, ys)
    | _ => false end
in

# Initialize a list with a given length using an initializer function #
let init: (Int, Int -> Int) -> [Int] =
    fun len, f ->
        let go: (Int, [Int]) -> [Int] =
        fun idx, xs ->
            if idx < len 
            then go(idx + 1, xs @ [f(idx)])   
            else xs
        in
        go(0, [])
in

# Reduce a list from the left. #
let fold_left: ((Int, Int) -> Int, Int, [Int]) -> Int =
  fun f, acc, xs ->
    case xs 
    | [] => acc
    | hd::tl => fold_left(f, f(acc, hd), tl) end in

# Reduce a list from the right. #
let fold_right: ((Int, Int) -> Int, [Int], Int) -> Int =
  fun f, xs, acc ->
    case xs
    | [] => acc
    | hd::tl => f(hd, fold_right(f, tl, acc)) end in


666
LSP: Prelude: String parsed successfully
LSP: Prelude: Info map generated successfully
Debug: true, Constrain: Types
LSP: Init: Recieved string: # Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)























































































































































































































































































































LSP: Init: String parsed successfully
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: >( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {go: ((?, ?) -> [?]), filter: (((Int -> Bool), [Int]) -> [Int]), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: 
  LSP: Info: ALL errors:Error in term:
  p
Nature of error: Variable p is not bound    
Error in term:
  p
Nature of error: Variable p is not bound    
Error in term:
  p
Nature of error: type ((Int -> Bool), [Int]) is not consistent with arrow type
  LSP: Info: BidiCtx: Cls: Let expression
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent: Root
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: [?]
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: :: @
  LSP: Concave: Backpack: 
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new_tokens ::= whitespace | "," | "::" | "@"
root ::= new_tokens

Top 20 Logits:

:20.5623
#:15.13
let:14.5677
##:14.3107
 :13.1999
################:12.5177
    :12.4924
  :12.4419
   :12.149
####:11.985
in:11.9779
/*:11.8923
```:11.6054
[:11.54
//:11.4707
                :11.2755
(:11.2273
{:11.2011
        :11.0118
########:10.9856
end:10.9225

================
# Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)

























































































































































































































































































































LSP: Prelude: Recieved string: ### List ###

# Add an element to the front of a list. #
let cons: (Int, [Int]) -> [Int] = fun x, xs -> x::xs in

# Determine the length of a list. #
let length: [Int] -> Int =
  fun xs ->
    case xs
    | [] => 0
    | _::xs => 1 + length(xs) end in

# Extract the first element of a list. #
let hd: [Int] -> Option =
  fun l ->
    case l
    | [] => None
    | x::xs => Some(x) end in

# Extract the rest of the list. #
let tl: [Int] -> [Int] =
  fun l ->
    case l
    | [] => []
    | x::xs => xs end in

# Determine if a list is empty. #
let is_empty: [Int] -> Bool =
  fun xs ->
    case xs
    | [] => true
    | _::_ => false end in

# Return the element at the index. #
let nth: ([Int], Int) -> Option =
  fun xs, n ->
    case xs, n
    | x::_, 0 => Some(x)
    | _::xs, n => nth(xs, n - 1)
    | [], _ => None end in

# Reverse a List. #
let rev: [Int] -> [Int] =
fun l -> 
let go: ([Int], [Int]) -> [Int] =
  fun xs, acc -> 
    case xs 
    | [] => acc 
    | x::xs => go(xs, x::acc) end in
go(l, []) in

# Check if two lists are equal #
let equal: ([Int], [Int]) -> Bool =
    fun p, xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => x == y && equal(xs, ys)
    | _ => false end
in

# Initialize a list with a given length using an initializer function #
let init: (Int, Int -> Int) -> [Int] =
    fun len, f ->
        let go: (Int, [Int]) -> [Int] =
        fun idx, xs ->
            if idx < len 
            then go(idx + 1, xs @ [f(idx)])   
            else xs
        in
        go(0, [])
in

# Reduce a list from the left. #
let fold_left: ((Int, Int) -> Int, Int, [Int]) -> Int =
  fun f, acc, xs ->
    case xs 
    | [] => acc
    | hd::tl => fold_left(f, f(acc, hd), tl) end in

# Reduce a list from the right. #
let fold_right: ((Int, Int) -> Int, [Int], Int) -> Int =
  fun f, xs, acc ->
    case xs
    | [] => acc
    | hd::tl => f(hd, fold_right(f, tl, acc)) end in


666
LSP: Prelude: String parsed successfully
LSP: Prelude: Info map generated successfully
Debug: true, Constrain: Types
LSP: Init: Recieved string: # Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)
























































































































































































































































































































LSP: Init: String parsed successfully
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: >( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {go: ((?, ?) -> [?]), filter: (((Int -> Bool), [Int]) -> [Int]), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: 
  LSP: Info: ALL errors:Error in term:
  p
Nature of error: Variable p is not bound    
Error in term:
  p
Nature of error: type ((Int -> Bool), [Int]) is not consistent with arrow type    
Error in term:
  p
Nature of error: Variable p is not bound
  LSP: Info: BidiCtx: Cls: Let expression
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent: Root
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: [?]
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: :: @
  LSP: Concave: Backpack: 
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new_tokens ::= whitespace | "," | "::" | "@"
root ::= new_tokens

Top 20 Logits:

:20.5689
#:15.1383
let:14.5654
##:14.3171
 :13.1984
################:12.5202
    :12.4963
  :12.4333
   :12.1536
####:11.9892
in:11.975
/*:11.8874
```:11.6102
[:11.5565
//:11.471
                :11.272
(:11.2318
{:11.2112
        :11.0108
########:10.9896
end:10.9338

================
# Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)


























































































































































































































































































































LSP: Prelude: Recieved string: ### List ###

# Add an element to the front of a list. #
let cons: (Int, [Int]) -> [Int] = fun x, xs -> x::xs in

# Determine the length of a list. #
let length: [Int] -> Int =
  fun xs ->
    case xs
    | [] => 0
    | _::xs => 1 + length(xs) end in

# Extract the first element of a list. #
let hd: [Int] -> Option =
  fun l ->
    case l
    | [] => None
    | x::xs => Some(x) end in

# Extract the rest of the list. #
let tl: [Int] -> [Int] =
  fun l ->
    case l
    | [] => []
    | x::xs => xs end in

# Determine if a list is empty. #
let is_empty: [Int] -> Bool =
  fun xs ->
    case xs
    | [] => true
    | _::_ => false end in

# Return the element at the index. #
let nth: ([Int], Int) -> Option =
  fun xs, n ->
    case xs, n
    | x::_, 0 => Some(x)
    | _::xs, n => nth(xs, n - 1)
    | [], _ => None end in

# Reverse a List. #
let rev: [Int] -> [Int] =
fun l -> 
let go: ([Int], [Int]) -> [Int] =
  fun xs, acc -> 
    case xs 
    | [] => acc 
    | x::xs => go(xs, x::acc) end in
go(l, []) in

# Check if two lists are equal #
let equal: ([Int], [Int]) -> Bool =
    fun p, xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => x == y && equal(xs, ys)
    | _ => false end
in

# Initialize a list with a given length using an initializer function #
let init: (Int, Int -> Int) -> [Int] =
    fun len, f ->
        let go: (Int, [Int]) -> [Int] =
        fun idx, xs ->
            if idx < len 
            then go(idx + 1, xs @ [f(idx)])   
            else xs
        in
        go(0, [])
in

# Reduce a list from the left. #
let fold_left: ((Int, Int) -> Int, Int, [Int]) -> Int =
  fun f, acc, xs ->
    case xs 
    | [] => acc
    | hd::tl => fold_left(f, f(acc, hd), tl) end in

# Reduce a list from the right. #
let fold_right: ((Int, Int) -> Int, [Int], Int) -> Int =
  fun f, xs, acc ->
    case xs
    | [] => acc
    | hd::tl => f(hd, fold_right(f, tl, acc)) end in


666
LSP: Prelude: String parsed successfully
LSP: Prelude: Info map generated successfully
Debug: true, Constrain: Types
LSP: Init: Recieved string: # Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)

























































































































































































































































































































LSP: Init: String parsed successfully
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: >( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {go: ((?, ?) -> [?]), filter: (((Int -> Bool), [Int]) -> [Int]), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: 
  LSP: Info: ALL errors:Error in term:
  p
Nature of error: Variable p is not bound    
Error in term:
  p
Nature of error: Variable p is not bound    
Error in term:
  p
Nature of error: type ((Int -> Bool), [Int]) is not consistent with arrow type
  LSP: Info: BidiCtx: Cls: Let expression
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent: Root
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: [?]
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: :: @
  LSP: Concave: Backpack: 
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new_tokens ::= whitespace | "," | "::" | "@"
root ::= new_tokens

Top 20 Logits:

:20.5796
#:15.1484
let:14.565
##:14.3184
 :13.1996
################:12.5241
    :12.4984
  :12.4284
   :12.1585
####:11.9899
in:11.9764
/*:11.8802
```:11.6174
[:11.5721
//:11.4687
                :11.2734
(:11.2323
{:11.2144
        :11.0112
########:10.9898
end:10.957

================
# Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)



























































































































































































































































































































LSP: Prelude: Recieved string: ### List ###

# Add an element to the front of a list. #
let cons: (Int, [Int]) -> [Int] = fun x, xs -> x::xs in

# Determine the length of a list. #
let length: [Int] -> Int =
  fun xs ->
    case xs
    | [] => 0
    | _::xs => 1 + length(xs) end in

# Extract the first element of a list. #
let hd: [Int] -> Option =
  fun l ->
    case l
    | [] => None
    | x::xs => Some(x) end in

# Extract the rest of the list. #
let tl: [Int] -> [Int] =
  fun l ->
    case l
    | [] => []
    | x::xs => xs end in

# Determine if a list is empty. #
let is_empty: [Int] -> Bool =
  fun xs ->
    case xs
    | [] => true
    | _::_ => false end in

# Return the element at the index. #
let nth: ([Int], Int) -> Option =
  fun xs, n ->
    case xs, n
    | x::_, 0 => Some(x)
    | _::xs, n => nth(xs, n - 1)
    | [], _ => None end in

# Reverse a List. #
let rev: [Int] -> [Int] =
fun l -> 
let go: ([Int], [Int]) -> [Int] =
  fun xs, acc -> 
    case xs 
    | [] => acc 
    | x::xs => go(xs, x::acc) end in
go(l, []) in

# Check if two lists are equal #
let equal: ([Int], [Int]) -> Bool =
    fun p, xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => x == y && equal(xs, ys)
    | _ => false end
in

# Initialize a list with a given length using an initializer function #
let init: (Int, Int -> Int) -> [Int] =
    fun len, f ->
        let go: (Int, [Int]) -> [Int] =
        fun idx, xs ->
            if idx < len 
            then go(idx + 1, xs @ [f(idx)])   
            else xs
        in
        go(0, [])
in

# Reduce a list from the left. #
let fold_left: ((Int, Int) -> Int, Int, [Int]) -> Int =
  fun f, acc, xs ->
    case xs 
    | [] => acc
    | hd::tl => fold_left(f, f(acc, hd), tl) end in

# Reduce a list from the right. #
let fold_right: ((Int, Int) -> Int, [Int], Int) -> Int =
  fun f, xs, acc ->
    case xs
    | [] => acc
    | hd::tl => f(hd, fold_right(f, tl, acc)) end in


666
LSP: Prelude: String parsed successfully
LSP: Prelude: Info map generated successfully
Debug: true, Constrain: Types
LSP: Init: Recieved string: # Keep elements that satisfy the test. #
let filter: (Int -> Bool, [Int]) -> [Int] =
  fun (p) ->
    let (go) = fun (xs, acc) ->
      case (xs)
      | [] => acc
      | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
    go(p) in

let (go) = fun (xs, acc) ->
  case (xs)
  | [] => acc
  | hd::tl => if (p) (hd) then (acc @ [hd] @ tl) else (acc @ tl) end in
go(p)


























































































































































































































































































































LSP: Init: String parsed successfully
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: >( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {go: ((?, ?) -> [?]), filter: (((Int -> Bool), [Int]) -> [Int]), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: 
  LSP: Info: ALL errors:Error in term:
  p
Nature of error: type ((Int -> Bool), [Int]) is not consistent with arrow type    
Error in term:
  p
Nature of error: Variable p is not bound    
Error in term:
  p
Nature of error: Variable p is not bound
  LSP: Info: BidiCtx: Cls: Let expression
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent: Root
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: [?]
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: :: @
  LSP: Concave: Backpack: 
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new_tokens ::= whitespace | "," | "::" | "@"
root ::= new_tokens

Top 20 Logits:

:20.5888
#:15.1579
let:14.5688
##:14.3081
 :13.2044
################:12.5266
    :12.5016
  :12.4308
   :12.1638
in:11.9963
####:11.9817
/*:11.876
```:11.6215
[:11.5767
//:11.4673
                :11.2807
(:11.2284
{:11.2089
        :11.0138
end:10.9857
########:10.983
